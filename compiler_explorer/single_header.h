#include <immintrin.h>
#include <cstddef>
#include <cstdint>
#include <algorithm>
#include <complex>
#include <type_traits>
#include <string>
#include <tuple>
#include <limits>
#include <cstring>
#include <chrono>
#include <memory>
#include <thread>
#include <vector>
#include <exception>
#include <iterator>
#include <optional>
#include <cassert>
#include <array>
#include <initializer_list>
#include <numeric>
#include <variant>
#include <cmath>
#include <functional>
#include <stdexcept>
#include <climits>
#include <cwchar>
#include <locale>
#include <cstdio>
#include <cstdlib>
#include <utility>
#include <bitset>
#include <random>
#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
#  if _MSC_VER < 1920
#    pragma message (": error cxx::compilerver")
#  endif
#  define WL_INLINE __forceinline
#  define WL_IGNORE_DEPENDENCIES __pragma(loop(ivdep))
#  define WL_RESTRICT __restrict
#  ifdef __AVX2__
#    define __AVX__ 1
#    define __BMI__ 1
#    define __BMI2__ 1
#  endif
#  ifdef __AVX__
#    define __POPCNT__ 1
#    define __LZCNT__ 1
#    define __SSE4_2__ 1
#    define __SSE4_1__ 1
#    define __SSE3__ 1
#    define __SSE2__ 1
#    define __SSE__ 1
#  endif
#  define _wl_popcnt64 __popcnt64
#  define NOMINMAX // disable min, max macros
#  define WL_FUNCSIG __FUNCSIG__
#  define WL_LIKELY(x) x
#  define WL_UNLIKELY(x) x
#elif defined(__INTEL_COMPILER)
#  if __INTEL_COMPILER < 1900
#    pragma message ("error: cxx::compilerver")
#  endif
#  define WL_INLINE __forceinline
#  define WL_IGNORE_DEPENDENCIES __pragma(ivdep)
#  define WL_RESTRICT __restrict
#  define WL_FUNCSIG __PRETTY_FUNCTION__
#  define WL_LIKELY(x) __builtin_expect(!!(x), 1)
#  define WL_UNLIKELY(x) __builtin_expect(!!(x), 0)
#  pragma warning (disable:1011)
#  pragma warning (disable:650)
#elif defined(__clang__)
#  if __clang_major__ < 5
#    pragma message ("error: cxx::compilerver")
#  endif
#  define WL_INLINE __attribute__((always_inline)) inline
#  define WL_IGNORE_DEPENDENCIES _Pragma("ivdep")
#  define WL_RESTRICT __restrict__
#  define WL_FUNCSIG __PRETTY_FUNCTION__
#  define WL_LIKELY(x) __builtin_expect(!!(x), 1)
#  define WL_UNLIKELY(x) __builtin_expect(!!(x), 0)
#elif defined(__GNUC__)
#  if __GNUC__ < 7
#    pragma message ("error: cxx::compilerver")
#  endif
#  define WL_INLINE __attribute__((always_inline)) inline
#  define WL_IGNORE_DEPENDENCIES _Pragma("ivdep")
#  define WL_RESTRICT __restrict__
#  define WL_FUNCSIG __PRETTY_FUNCTION__
#  define WL_LIKELY(x) __builtin_expect(!!(x), 1)
#  define WL_UNLIKELY(x) __builtin_expect(!!(x), 0)
#  pragma GCC diagnostic ignored "-Wignored-attributes"
#endif
#if defined(__MINGW64__)
#  define WL_NO_RANDOM_DEVICE 1
#endif
namespace wl
{
#define WL_FUNCTION(fn) wl::variadic( \
    [](auto&&... args) { return fn(std::forward<decltype(args)>(args)...); }, \
    [](auto&& arg) { return fn(std::forward<decltype(arg)>(arg)); })
#define WL_PASS(var) std::forward<decltype(var)>(var)
#define WL_BASE_RANDOM_ENGINE std::mt19937_64
#define WL_CHECK_ABORT_PERIOD 100 // milliseconds
#define WL_CHECK_ABORT_LENGTH 1024
#define WL_ERROR_INTERNAL \
"An internal error is encountered."
#define WL_ERROR_SIZEOF_CHAR \
"The size of char should be 1 byte."
#define WL_ERROR_MUTABLE_TYPE \
"The type of the result cannot be converted to that of the target."
#define WL_ERROR_MUTABLE_RANK \
"The array rank of the result is different from that of the target."
#define WL_ERROR_ASSIGN_TYPE \
"The type of the source cannot be converted to that of the target."
#define WL_ERROR_ASSIGN_RANK \
"The array rank of the source is different from that of the target."
#define WL_ERROR_LIST_ELEM_TYPE \
"The elements of the list do not have a consistent type."
#define WL_ERROR_LIST_ELEM_RANK \
"The elements of the list do not have a consistent array rank."
#define WL_ERROR_MODIFY_TARGET \
"The target is not a variable, so it cannot be modified."
#define WL_ERROR_OPERAND_RANK \
"The operands should be scalars or arrays of the same rank."
#define WL_ERROR_OPERAND_TYPE \
"The operands should contain values of the same type."
#define WL_ERROR_FUNCTION_TYPE \
"The argument is not a function gives an appropriate type."
#define WL_ERROR_PRED_TYPE \
"The function is not called with a valid predicate."
#define WL_ERROR_ORDER_PRED_TYPE \
"The function is not called with a valid ordering function."
#define WL_ERROR_NUMERIC_ONLY \
"The function can only take numerical values as its argument(s)."
#define WL_ERROR_STRING_ONLY \
"The function can only take strings as its arguments."
#define WL_ERROR_STRING_TYPE_ONLY \
"The function can only take a string or a list of strings."
#define WL_ERROR_PART_DEPTH \
"The number of part specifications is larger than the array rank."
#define WL_ERROR_PART_SPEC_INTEGRAL \
"Part specifications should have integral types."
#define WL_ERROR_REQUIRE_ARRAY \
"The function requires its argument to be an array."
#define WL_ERROR_REQUIRE_ARRAY_RANK \
"The function requires its argument to be an array with rank "
#define WL_ERROR_REQUIRE_VARIADIC \
"The function requires the argument to be a variadic function."
#define WL_ERROR_BAD_LEVEL \
"The function is not called with appropriate level specifications."
#define WL_ERROR_LARGE_RANK \
"The rank of the array produced is too large; the maximum rank is 16."
#define WL_ERROR_ZERO_RANK \
"The rank of the array produced is 0; the minimum rank is 1."
#define WL_ERROR_LARGE_ARGC \
"The number of arguments is too large; the maximum count is 16."
#define WL_ERROR_ARRAY_VALUE_TYPE \
"Only numerical values and strings can be stored in an array."
#define WL_ERROR_APPEND_RANK \
"The argument to be appended or prepended does not have an appropriate rank."
#define WL_ERROR_JOIN_RANK \
"The arrays to be joined should have the same rank."
#define WL_ERROR_JOIN_VALUE_TYPE \
"The values to be concatenated should have consistent types."
#define WL_ERROR_ITERATOR_TYPE \
"The bounds of an iterator can only be integers and real numbers."
#define WL_ERROR_BAD_RETURN \
"The specified return type of the values is invalid."
#define WL_ERROR_DIMENSIONS_SPEC \
"The specified dimensions should all be integers and non-empty."
#define WL_ERROR_ARRAY_RESHAPE_PAD_TYPE \
"The type of padding value is not consistent with the type of array."
#define WL_ERROR_POSITION_RANK \
"The pattern should have a smaller rank than the array."
#define WL_ERROR_RANDOM_BOUNDS \
"The bounds of the random numbers do not have appropriate types."
#define WL_ERROR_BRANCH_RETURN \
"All branches should have the same return type."
#define WL_ERROR_SUM_ELEMENT \
"The elements of accumulation should be of numerical types."
#define WL_ERROR_MAP_THREAD_LEVEL \
"The level specified should be less than the rank of all arrays."
#define WL_ERROR_NEST_TYPE \
"The type should be consistent when the function is applied repeatedly."
#define WL_ERROR_COUNTING_ARG \
"The argument indicating a count should be an integer."
#define WL_ERROR_INDEXER_LIST \
"The specification should be a list of integers."
#define WL_ERROR_INDEXER_SCALAR \
"The specification should be All or an integer."
#define WL_ERROR_REAL_TYPE_ARG \
"The arguments should be integers or real numbers."
#define WL_ERROR_INTEGRAL_TYPE_ARG \
"The arguments should be integers."
#define WL_ERROR_BOOLEAN_ARG \
"The arguments should be logical values."
#define WL_ERROR_BAD_COMPARE \
"The values cannot be compared with each other."
#define WL_ERROR_BAD_CAST \
"The requested type conversion is not valid."
#define WL_ERROR_LOOP_TEST \
"The test statement should evaluates to a logical value."
#define WL_ERROR_INSERT_RANK \
"The element to be inserted should have a rank less than the array by one."
#define WL_ERROR_INSERT_POS_FORM \
"The position should be an integer or a rank-2 array of integers."
#define WL_ERROR_DELETE_CASES_LEVEL \
"DeleteCases can only operate on the first level."
#define WL_ERROR_RANDOM_WEIGHTS_TYPE \
"The weights should form a list of integers or real numbers."
#define WL_ERROR_UNIFORM_BOUNDS_SPEC \
"The arguments should be an integer, a pair of number, or a list of pairs."
#define WL_ERROR_DIST_PARAMETER_COUNT \
"The distribution is not specified with a correct number of parameters."
#define WL_ERROR_TAKE_SPEC_TYPE \
"The specification should be All, an integer, or a list of integers."
#define WL_ERROR_PARTITION_LEVEL \
"The level of partition should be between one and the rank of the array."
#define WL_ERROR_PARTITION_SPEC \
"The lengths and offsets of partition should be integers or lists of integers."
#define WL_ERROR_CALLBACK \
"Callback failed."
#define WL_ERROR_NEGATIVE_DIMS \
"The dimension specifications should be non-negative integers."
#define WL_ERROR_LIST_ELEM_DIMS \
"All elements of a list should have the same dimensions."
#define WL_ERROR_ARITHMETIC_DIMS \
"Both arguments of the arithmetic operation should have the same dimensions."
#define WL_ERROR_OPERAND_DIMS \
"All of the arguments of the function should have the same dimensions."
#define WL_ERROR_REQUIRE_NON_EMPTY \
"The argument should be a non-empty list."
#define WL_ERROR_ITERATOR_ZERO_STEP \
"The size of the step should not be zero."
#define WL_ERROR_OUT_OF_RANGE \
"The index is out of range."
#define WL_ERROR_SPAN_OUT_OF_RANGE \
"Some of the indices are out of range."
#define WL_ERROR_INTEGER_DIGITS_NEGATIVE \
"The argument should be non-negative."
#define WL_ERROR_CLIP_LIMIT_SIZE \
"The upper and lower limits should be specified as a list of two elements."
#define WL_ERROR_SUM_ZERO_SIZE \
"The sum of zero elements is undefined for non-arithmetic scalars."
#define WL_ERROR_PRODUCT_ZERO_SIZE \
"The product of zero elements is undefined for non-arithmetic scalars."
#define WL_ERROR_TRANSPOSE_COLLAPSE \
"Collapsing dimensions should have equal lengths."
#define WL_ERROR_ORDERING_OUT_OF_RANGE \
"The requested number of indices is larger than the size of the list."
#define WL_ERROR_INSERT_ELEM_DIMS \
"The element to be inserted should have the same dimensions as the others."
#define WL_ERROR_ARGPACK_OUT_OF_RANGE \
"The slot index is larger than the number of arguments."
#define WL_ERROR_EMPTY_PACK \
"The function cannot be called with zero arguments."
#define WL_ERROR_ITERATION_NEGATIVE \
"The number of iterations should be non-negative integer."
#define WL_ERROR_INSERT_POS_DIMS \
"The each position specification should be a list of one integer."
#define WL_ERROR_RANDOM_WEIGHTS_LENGTH \
"The number of weights should match that of elements and more than zero."
#define WL_ERROR_RANDOM_ELEM_LENGTH \
"The number of elements should be more than zero."
#define WL_ERROR_NEGATIVE_WEIGHT \
"The weights should be non-negative."
#define WL_ERROR_DIST_PARAMETER_DOMAIN \
"The distribution is not specified with appropriate parameter values."
#define WL_ERROR_RANDOM_SAMPLE_NO_ELEM \
"There are not enough elements in the list to sample from."
#define WL_ERROR_RANDOM_SAMPLE_ZERO_WEIGHTS \
"The total weights of the elements are effectively zero."
#define WL_ERROR_TAKE_SPEC_LIST_LENGTH \
"The list as a specification should have between one and three integers."
#define WL_ERROR_STRING_TAKE_SPEC_LIST_LENGTH \
"Only lists with 1 or 2 integers are supported as StringTake specifications."
#define WL_ERROR_STRING_DROP_SPEC_LIST_LENGTH \
"Only lists with 1 or 2 integers are supported as StringDrop specifications."
#define WL_ERROR_PAUSE_NEGATIVE \
"The duration should be non-negative."
#define WL_ERROR_PARTITION_SPEC_LENGTH \
"The lengths and offsets of partition should match the level specification."
#define WL_ERROR_PARTITION_NEGATIVE_SPEC \
"The lengths and offsets of partition should be positive."
#define WL_ERROR_PARTITION_DEFAULT_LEVEL \
"Lengths and offsets should match array rank when the level is not specified."
#define WL_ERROR_NEST_WHILE_OFFSET \
"There are not sufficient results from NestWhile for the specified offset."
#define WL_ERROR_NEST_WHILE_LIST_OFFSET \
"There are not sufficient results from NestWhileList for the specified offset."
#define WL_ERROR_FACTORIAL_NEGATIVE \
"Factorial of a negative integer equals infinity."
#define WL_ERROR_FACTORIAL2_DOMAIN \
"Factorial2 of the argument cannot be represented by an integer."
#define WL_ERROR_BAD_UTF8_CODEPOINT \
"The string contains an invalid UTF-8 codepoint."
#define WL_ERROR_BAD_UTF8_NULL_TERMINATED \
"The string is not terminated by a null character."
}
namespace wl
{
template<typename T, size_t R>
struct ndarray;
union u8string;
template<typename T, size_t ArrayRank, size_t ViewRank, bool Const>
struct simple_view;
template<typename T, size_t ArrayRank, size_t ViewRank, size_t StrideRank, bool Const>
struct regular_view;
template<typename T, size_t ArrayRank, size_t ViewRank, size_t StrideRank, typename IndexersTuple, bool Const>
struct general_view;
template<typename T>
using complex = std::complex<T>;
using string = u8string;
struct void_type;
struct all_type;
struct boolean;
template<typename F>
struct function;
template<typename ArgIter, bool HasStride = false>
struct argument_pack;
template<typename Normal, typename Variadic>
struct variadic;
template<typename...>
constexpr auto always_false_v = false;
template<typename...>
struct undefined_type;
template<size_t...>
struct undefined_integral;
template<typename T, size_t...>
struct identity_type
{
    using type = T;
};
template<typename T>
constexpr auto is_integral_v = std::is_integral_v<T>;
template<typename T>
constexpr auto is_float_v = std::is_floating_point_v<T>;
template<typename T>
constexpr auto is_string_v = std::is_same_v<T, string>;
template<typename T>
constexpr auto is_boolean_v = std::is_same_v<T, boolean>;
template<typename T>
struct is_complex : std::false_type {};
template<typename T>
struct is_complex<complex<T>> : std::true_type {};
template<typename T>
constexpr auto is_complex_v = is_complex<T>::value;
template<typename T>
constexpr auto is_real_v = is_integral_v<T> || is_float_v<T>;
template<typename T>
constexpr auto is_arithmetic_v = is_real_v<T> || is_complex_v<T>;
template<typename T>
struct promote_integral
{
    using type = std::conditional_t<is_integral_v<T>, double, T>;
};
template<typename T>
using promote_integral_t = typename promote_integral<T>::type;
template<typename T, typename U>
struct _common_type_impl
{
    using type = std::conditional_t<is_float_v<T>, T, U>;
};
template<> struct _common_type_impl<double, double> { using type = double; };
template<> struct _common_type_impl<float, double> { using type = double; };
template<> struct _common_type_impl<double, float> { using type = double; };
template<> struct _common_type_impl<float, float> { using type = float; };
template<typename... Ts>
struct common_type;
template<typename T, typename U>
struct common_type<T, U>
{
    using type = std::conditional_t<
        is_float_v<T> || is_float_v<U>,
        typename _common_type_impl<T, U>::type,
        std::conditional_t<(sizeof(T) > sizeof(U)), T,
        std::conditional_t<(sizeof(U) > sizeof(T)), U,
        std::conditional_t<std::is_unsigned_v<T>, T, U
        >>>>;
};
template<typename T, typename U>
struct common_type<T, complex<U>> : common_type<complex<U>, T> {};
template<typename T, typename U>
struct common_type<complex<T>, U>
{
    using type = std::conditional_t<is_integral_v<U>,
        complex<T>, complex<typename common_type<T, U>::type>>;
};
template<typename T, typename U>
struct common_type<complex<T>, complex<U>>
{
    using type = complex<typename common_type<T, U>::type>;
};
template<typename T1, typename T2, typename T3, typename... Ts>
struct common_type<T1, T2, T3, Ts...>
{
    using type = typename common_type<
        typename common_type<T1, T2>::type, T3, Ts...>::type;
};
template<typename... Ts>
using common_type_t = typename common_type<Ts...>::type;
template<typename T> struct make_signed { using type = T; };
template<> struct make_signed<uint8_t> { using type = int8_t; };
template<> struct make_signed<uint16_t> { using type = int16_t; };
template<> struct make_signed<uint32_t> { using type = int32_t; };
template<> struct make_signed<uint64_t> { using type = int64_t; };
template<typename T>
using make_signed_t = typename make_signed<T>::type;
template<typename T>
using remove_cvref_t = std::remove_cv_t<std::remove_reference_t<T>>;
template<typename T>
struct is_array : std::false_type {};
template<typename T, size_t R>
struct is_array<ndarray<T, R>> : std::true_type {};
template<typename T>
constexpr auto is_array_v = is_array<T>::value;
template<typename T>
struct is_array_view : std::false_type {};
template<typename T, size_t A, size_t V, bool C>
struct is_array_view<simple_view<T, A, V, C>> : std::true_type {};
template<typename T, size_t A, size_t V, size_t S, bool C>
struct is_array_view<regular_view<T, A, V, S, C>> : std::true_type {};
template<typename T, size_t A, size_t V, size_t S, typename IT, bool C>
struct is_array_view<general_view<T, A, V, S, IT, C>> : std::true_type {};
template<typename T>
constexpr auto is_array_view_v = is_array_view<T>::value;
template<typename T, typename = void>
struct value_type { using type = T; };
template<typename T>
struct value_type<T, std::void_t<typename T::value_type>>
{
    using type = typename T::value_type;
};
template<typename T>
using value_type_t = typename value_type<T>::type;
template<typename T>
struct array_rank : std::integral_constant<size_t, 0u> {};
template<typename T, size_t R>
struct array_rank<ndarray<T, R>> :
    std::integral_constant<size_t, R> {};
template<typename T, size_t A, size_t V, bool C>
struct array_rank<simple_view<T, A, V, C>> :
    std::integral_constant<size_t, V> {};
template<typename T, size_t A, size_t V, size_t S, bool C>
struct array_rank<regular_view<T, A, V, S, C>> :
    std::integral_constant<size_t, V> {};
template<typename T, size_t A, size_t V, size_t S, typename IT, bool C>
struct array_rank<general_view<T, A, V, S, IT, C>> :
    std::integral_constant<size_t, V> {};
template<typename T>
constexpr auto array_rank_v = array_rank<T>::value;
template<typename T>
constexpr auto is_numerical_type_v = (array_rank_v<T> == 0u ?
    is_arithmetic_v<T> : is_arithmetic_v<value_type_t<T>>);
template<typename T>
constexpr auto is_boolean_type_v = is_boolean_v<value_type_t<T>>;
template<typename T>
constexpr auto is_string_type_v = is_string_v<value_type_t<T>>;
template<typename T>
constexpr auto is_value_type_v = is_arithmetic_v<T> || is_array_v<T> ||
is_array_view_v<T> || is_boolean_v<T> || is_string_v<T> ||
std::is_same_v<T, void_type> || std::is_same_v<T, all_type>;
template<typename T>
struct is_movable : std::false_type {};
template<typename T, size_t R>
struct is_movable<ndarray<T, R>&&> : std::true_type {};
template<typename T>
constexpr auto is_movable_v = is_movable<T>::value;
template<typename T>
constexpr auto array_is_const_v = std::is_const_v<
    std::remove_pointer_t<decltype(std::declval<T>().data())>>;
template<typename T, typename U>
struct _is_convertible_impl
{
    static constexpr bool value =
        (is_arithmetic_v<T> && is_complex_v<U>) ||
        (is_integral_v<T> && is_arithmetic_v<U>) ||
        (is_float_v<T> && is_float_v<U>);
};
template<typename T, typename U>
struct is_convertible
{
    static constexpr bool value =
        _is_convertible_impl<T, U>::value ||
        (is_array_v<T> && is_array_v<U> &&
            array_rank_v<T> == array_rank_v<U> &&
            _is_convertible_impl<value_type_t<T>, value_type_t<U>>::value);
};
template<typename T, typename Ret, typename... Args>
struct is_convertible<T, function<Ret(Args...)>> : std::true_type {};
template<typename T>
struct is_convertible<T, T> : std::true_type {};
template<typename T, typename U>
constexpr auto is_convertible_v = is_convertible<T, U>::value;
template<typename... Ts>
struct all_is_integral;
template<>
struct all_is_integral<> : std::true_type {};
template<typename T1, typename... Ts>
struct all_is_integral<T1, Ts...> :
    std::bool_constant<is_integral_v<T1> && all_is_integral<Ts...>::value> {};
template<typename... Ts>
constexpr auto all_is_integral_v = all_is_integral<Ts...>::value;
template<typename... Ts>
struct all_is_real;
template<>
struct all_is_real<> : std::true_type {};
template<typename T1, typename... Ts>
struct all_is_real<T1, Ts...> :
    std::bool_constant<is_real_v<T1> && all_is_real<Ts...>::value> {};
template<typename... Ts>
constexpr auto all_is_real_v = all_is_real<Ts...>::value;
template<typename F>
struct is_variadic_function : std::false_type {};
template<typename Normal, typename Variadic>
struct is_variadic_function<variadic<Normal, Variadic>> : std::true_type {};
template<typename Fn>
constexpr auto is_variadic_function_v = is_variadic_function<Fn>::value;
template<typename T>
struct is_argument_pack : std::false_type {};
template<typename Iter, bool HasStride>
struct is_argument_pack<argument_pack<Iter, HasStride>> : std::true_type {};
template<typename Iter>
constexpr auto is_argument_pack_v = is_argument_pack<Iter>::value;
}
namespace wl
{
struct void_type
{
};
struct all_type
{
};
struct none_type
{
};
struct varg_tag
{
};
template<int64_t>
struct level_tag
{
};
struct loop_break
{
};
struct dim_checked
{
};
struct complement_span_tag
{
};
struct no_check_abort_tag
{
};
struct boolean
{
    bool val_ = false;
    constexpr explicit boolean(bool val) : val_{val}
    {
    }
    constexpr boolean() = default;
    constexpr boolean operator&&(boolean other) const
    {
        return boolean(this->val_ && other.val_);
    }
    constexpr boolean operator||(boolean other) const
    {
        return boolean(this->val_ || other.val_);
    }
    constexpr boolean operator^ (boolean other) const
    {
        return boolean(this->val_ ^ other.val_);
    }
    constexpr boolean operator!() const
    {
        return boolean(!this->val_);
    }
    constexpr operator bool() const
    {
        return this->val_;
    }
};
template<int64_t I>
struct const_int
{
    static constexpr auto value = I;
};
template<int64_t... Is>
struct const_ints
{
    template<size_t N>
    static constexpr auto value = 
        std::tuple_element_t<N, 
        std::tuple<std::integral_constant<int64_t, Is>...>>::value;
};
}
namespace wl
{
constexpr auto const_null  = void_type{};
constexpr auto const_all   = all_type{};
constexpr auto const_none  = none_type{};
constexpr auto const_i     = complex<double>(0.f, 1.f);
constexpr auto const_true  = boolean(true);
constexpr auto const_false = boolean(false);
constexpr auto const_pi           = double(3.1415926535897932385e+0);
constexpr auto const_e            = double(2.7182818284590452354e+0);
constexpr auto const_degree       = double(1.7453292519943295769e-2);
constexpr auto const_golden_ratio = double(1.6180339887498948482e+0);
constexpr auto const_golden_angle = double(2.3999632297286533222e+0);
constexpr auto const_euler_gamma  = double(5.7721566490153286061e-1);
constexpr auto const_catalan      = double(9.1596559417721901505e-1);
constexpr auto const_glaisher     = double(1.2824271291006226369e+0);
constexpr auto const_khinchin     = double(2.6854520010653064453e+0);
constexpr auto MaximumArrayRank = 16;
constexpr auto MaximumArgCount  = 16;
constexpr auto const_int_infinity  = std::numeric_limits<int64_t>::max();
constexpr auto const_real_infinity = std::numeric_limits<double>::max();
}
namespace wl
{
namespace simd
{
#define WL_DEFINE_DEFULAT_SIMD_UNARY(name)                      \
WL_INLINE auto name(__m256i x) { return _mm256_##name(x); }     \
WL_INLINE auto name(__m128i x) { return _mm_##name(x); }
#define WL_DEFINE_DEFULAT_SIMD_BINARY(name)                                 \
WL_INLINE auto name(__m256i x, __m256i y) { return _mm256_##name(x, y); }   \
WL_INLINE auto name(__m128i x, __m128i y) { return _mm_##name(x, y); }
WL_DEFINE_DEFULAT_SIMD_BINARY(unpacklo_epi8)
WL_DEFINE_DEFULAT_SIMD_BINARY(unpackhi_epi8)
WL_DEFINE_DEFULAT_SIMD_BINARY(add_epi8)
WL_DEFINE_DEFULAT_SIMD_BINARY(add_epi16)
WL_DEFINE_DEFULAT_SIMD_BINARY(sub_epi8)
WL_DEFINE_DEFULAT_SIMD_BINARY(sub_epi16)
WL_DEFINE_DEFULAT_SIMD_BINARY(cmpeq_epi8)
WL_DEFINE_DEFULAT_SIMD_BINARY(cmpgt_epi8)
WL_DEFINE_DEFULAT_SIMD_UNARY(movemask_epi8)
WL_INLINE auto testc(__m128i x, __m128i y) { return _mm_testc_si128(x, y); }
WL_INLINE auto testc(__m256i x, __m256i y) { return _mm256_testc_si256(x, y); }
template<typename M>
WL_INLINE auto zero()
{
    if constexpr (std::is_same_v<M, __m256i>)
        return _mm256_setzero_si256();
    else if constexpr (std::is_same_v<M, __m128i>)
        return _mm_setzero_si128();
    else
        static_assert(always_false_v<M>, WL_ERROR_INTERNAL);
}
template<typename M, typename T>
WL_INLINE auto set1(T x)
{
    if constexpr (std::is_same_v<M, __m256i>)
    {
        if constexpr (sizeof(T) == 1u) return _mm256_set1_epi8(x);
        else if constexpr (sizeof(T) == 2u) return _mm256_set1_epi16(x);
        else if constexpr (sizeof(T) == 4u) return _mm256_set1_epi32(x);
        else if constexpr (sizeof(T) == 8u) return _mm256_set1_epi64(x);
        else static_assert(always_false_v<M>, WL_ERROR_INTERNAL);
    }
    else if constexpr (std::is_same_v<M, __m128i>)
    {
        if constexpr (sizeof(T) == 1u) return _mm_set1_epi8(x);
        else if constexpr (sizeof(T) == 2u) return _mm_set1_epi16(x);
        else if constexpr (sizeof(T) == 4u) return _mm_set1_epi32(x);
        else if constexpr (sizeof(T) == 8u) return _mm_set1_epi64(x);
        else static_assert(always_false_v<M>, WL_ERROR_INTERNAL);
    }
    else static_assert(always_false_v<M>, WL_ERROR_INTERNAL);
}
template<typename M, typename Ptr>
WL_INLINE auto loadu(const Ptr* ptr)
{
    if constexpr (std::is_same_v<M, __m256i>)
        return _mm256_loadu_si256((const __m256i*)ptr);
    else if constexpr (std::is_same_v<M, __m128i>)
        return _mm_loadu_si128((const __m128i*)ptr);
    else
        static_assert(always_false_v<M>, WL_ERROR_INTERNAL);
}
template<typename M, typename Ptr>
WL_INLINE auto storeu(Ptr* ptr, M x)
{
    if constexpr (std::is_same_v<M, __m256i>)
        return _mm256_storeu_si256((__m256i*)ptr, x);
    else if constexpr (std::is_same_v<M, __m128i>)
        return _mm_storeu_si128((__m128i*)ptr, x);
    else
        static_assert(always_false_v<M>, WL_ERROR_INTERNAL);
}
template<int I, typename M>
WL_INLINE auto extract_epi64(M x)
{
    if constexpr (std::is_same_v<M, __m256i>)
        return _mm256_extract_epi64(x, I);
    else if constexpr (std::is_same_v<M, __m128i>)
        return _mm_extract_epi64(x, I);
    else static_assert(always_false_v<M>, WL_ERROR_INTERNAL);
}
WL_INLINE int64_t hsum_epi8(__m256i v)
{
    v = add_epi16(unpacklo_epi8(v, zero<__m256i>()),
        unpackhi_epi8(v, zero<__m256i>()));
    auto total = uint64_t(extract_epi64<0>(v) + extract_epi64<1>(v) +
        extract_epi64<2>(v) + extract_epi64<3>(v));
    total += total >> 32;
    total += total >> 16;
    return int64_t(total & 0xffffu);
}
WL_INLINE int64_t hsum_epi8(__m128i v)
{
    v = add_epi16(unpacklo_epi8(v, zero<__m128i>()),
        unpackhi_epi8(v, zero<__m128i>()));
    auto total = uint64_t(extract_epi64<0>(v) + extract_epi64<1>(v));
    total += total >> 32;
    total += total >> 16;
    return int64_t(total & 0xffffu);
}
}
}
namespace wl
{
struct scalar_indexer; // I
struct all_indexer;    // A
struct unit_indexer;   // U
struct step_indexer;   // S
struct complement_step_indexer;
struct list_indexer;
enum class view_category
{
    Scalar, 
    Array, 
    Simple, 
    Regular, 
    General
};
namespace view_detail
{
template<typename Tuple, typename... Indexers>
struct indexers_tuple_impl;
template<typename... InTuple, typename First, typename... Rest>
struct indexers_tuple_impl<std::tuple<InTuple...>, First, Rest...>
{
    using type = std::conditional_t<
        std::is_same_v<First, scalar_indexer>,
        typename indexers_tuple_impl<std::tuple<InTuple...>, Rest...>::type,
        typename indexers_tuple_impl<std::tuple<InTuple..., First>, Rest...>::type>;
};
template<typename... InTuple>
struct indexers_tuple_impl<std::tuple<InTuple...>>
{
    using type = std::tuple<InTuple...>;
};
template<typename... Indexers>
using indexers_tuple_t = typename indexers_tuple_impl<std::tuple<>, Indexers...>::type;
template<size_t A, size_t V, size_t S>
struct _scalar_base
{
    static constexpr auto category = view_category::Scalar;
    template<typename T, bool Const, typename...>
    using return_type = std::conditional_t<Const, T, T&>;
};
template<size_t A, size_t V, size_t S>
struct _simple_base
{
    static constexpr auto category = view_category::Simple;
    template<typename T, bool Const, typename...>
    using return_type = simple_view<T, A, V, Const>;
};
template<size_t A, size_t V, size_t S>
struct _regular_base
{
    static constexpr auto category = view_category::Regular;
    template<typename T, bool Const, typename...>
    using return_type = regular_view<T, A, V, S, Const>;
};
template<size_t A, size_t V, size_t S>
struct _general_base
{
    static constexpr auto category = view_category::General;
    template<typename T, bool Const, typename... Indexers>
    using return_type = general_view<T, A, V, S, indexers_tuple_t<Indexers...>, Const>;
};
template<size_t A, size_t V, size_t S>
struct G_I_ : _general_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, G_I_<A + 1, V, S + 1>,
        G_I_<A + 1, V + 1, 0>
        >;
};
template<size_t A, size_t V, size_t S>
struct I_SI_ : _regular_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_SI_<A + 1, V, S + 1>,
        G_I_<A + 1, V + 1, 0>
        >;
};
template<size_t A, size_t V, size_t S>
struct I_S : _regular_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_SI_<A + 1, V, S + 1>,
        G_I_<A + 1, V + 1, 0>
        >;
};
template<size_t A, size_t V, size_t S>
struct I_A_I_ : _regular_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_A_I_<A + 1, V, S + 1>,
        G_I_<A + 1, V + 1, 0>
        >;
};
template<size_t A, size_t V, size_t S>
struct I_A_ : _simple_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_A_I_<A + 1, V, S + 1>,
        std::conditional_t<std::is_same_v<Idx, all_indexer>, I_A_<A + 1, V + 1, 0>,
        G_I_<A + 1, V + 1, 0>
        >>;
};
template<size_t A, size_t V, size_t S>
struct I_UI_ : _regular_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_UI_<A + 1, V, S + 1>,
        G_I_<A + 1, V + 1, 0>
        >;
};
template<size_t A, size_t V, size_t S>
struct I_UA_I_ : _regular_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_UA_I_<A + 1, V, S + 1>,
        G_I_<A + 1, V + 1, 0>
        >;
};
template<size_t A, size_t V, size_t S>
struct I_UA_ : _simple_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_UA_I_<A + 1, V, S + 1>,
        std::conditional_t<std::is_same_v<Idx, all_indexer>, I_UA_<A + 1, V + 1, S>,
        G_I_<A + 1, V + 1, 0>
        >>;
};
template<size_t A, size_t V, size_t S>
struct I_U : _simple_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_UI_<A + 1, V, S + 1>,
        std::conditional_t<std::is_same_v<Idx, all_indexer>, I_UA_<A + 1, V + 1, 0>,
        G_I_<A + 1, V + 1, 0>
        >>;
};
template<size_t A, size_t V, size_t S> 
struct I_ : _scalar_base<A, V, S>
{
    template<typename Idx>
    using collapse =
        std::conditional_t<std::is_same_v<Idx, scalar_indexer>, I_<A + 1, V, 0>,
        std::conditional_t<std::is_same_v<Idx, all_indexer>, I_A_<A + 1, V + 1, 0>,
        std::conditional_t<std::is_same_v<Idx, unit_indexer>, I_U<A + 1, V + 1, 0>,
        std::conditional_t<std::is_same_v<Idx, step_indexer>, I_S<A + 1, V + 1, 0>,
        G_I_<A + 1, V + 1, 0>
        >>>>;
};
template<typename State, typename... Indexers>
struct view_derive_impl;
template<typename State, typename Idx1, typename... Idxs>
struct view_derive_impl<State, Idx1, Idxs...>
{
    using type = typename view_derive_impl<typename State::template collapse<Idx1>, Idxs...>::type;
};
template<typename State>
struct view_derive_impl<State>
{
    using type = State;
};
template<typename... Indexers>
using view_type = typename view_derive_impl<I_<0u, 0u, 0u>, Indexers...>::type;
}
}
namespace wl
{
template<typename Y, typename XV, size_t XR>
auto cast(ndarray<XV, XR>&& x) -> decltype(auto)
{
    static_assert(is_convertible_v<ndarray<XV, XR>, Y>, WL_ERROR_BAD_CAST);
    using YV = value_type_t<Y>;
    if constexpr (std::is_same_v<XV, YV>)
        return std::move(x);
    else
    {
        ndarray<YV, XR> ret(x.dims());
        x.copy_to(ret.begin());
        return ret;
    }
}
template<typename Y, typename XV, size_t XR>
auto cast(const ndarray<XV, XR>& x) -> decltype(auto)
{
    static_assert(is_convertible_v<ndarray<XV, XR>, Y>, WL_ERROR_BAD_CAST);
    using YV = value_type_t<Y>;
    if constexpr (std::is_same_v<XV, YV>)
        return x;
    else
    {
        ndarray<YV, XR> ret(x.dims());
        x.copy_to(ret.begin());
        return ret;
    }
}
template<typename Y, typename X>
auto cast(const X& x)
{
    if constexpr (is_array_view_v<X>)
    {
        constexpr auto XR = array_rank_v<X>;
        using XV = value_type_t<X>;
        using YV = value_type_t<Y>;
        static_assert(is_convertible_v<ndarray<XV, XR>, Y>, WL_ERROR_BAD_CAST);
        if constexpr (std::is_same_v<XV, YV>)
            return x.to_array();
        else
        {
            ndarray<YV, XR> ret(x.dims());
            x.copy_to(ret.begin());
            return ret;
        }
    }
    else if constexpr (is_real_v<X>)
    {
        static_assert(is_convertible_v<X, Y>, WL_ERROR_BAD_CAST);
        return Y(x);
    }
    else
    {
        static_assert(std::is_same_v<Y, X>, WL_ERROR_BAD_CAST);
        return x;
    }
}
template<typename Y, typename X>
auto cast(const complex<X>& x)
{
    static_assert(is_complex_v<Y>, WL_ERROR_BAD_CAST);
    return std::complex<value_type_t<Y>>(x);
}
template<typename Y>
auto cast(const boolean& x)
{
    static_assert(is_boolean_v<Y>, WL_ERROR_BAD_CAST);
    return x;
}
template<typename Y>
auto cast(const std::string& x)
{
    static_assert(is_string_v<Y>, WL_ERROR_BAD_CAST);
    return x;
}
template<typename Y>
auto cast(std::string&& x)
{
    static_assert(is_string_v<Y>, WL_ERROR_BAD_CAST);
    return std::move(x);
}
namespace utils
{
inline auto _get_time()
{
    auto now = std::chrono::high_resolution_clock::now();
    return now.time_since_epoch().count();
}
template<bool AllowEmpty = false, typename... Dims>
auto get_dims_array(const Dims&... dims)
{
    static_assert(all_is_integral_v<Dims...> && (sizeof...(Dims) >= 1u),
        WL_ERROR_DIMENSIONS_SPEC);
    if (!((dims >= Dims(0)) && ...))
        throw std::logic_error(WL_ERROR_NEGATIVE_DIMS);
    return std::array<size_t, sizeof...(Dims)>{size_t(dims)...};
}
template<size_t R1, size_t R2, size_t... Is1, size_t... Is2>
auto _dims_join_impl(
    const std::array<size_t, R1>& dims1, std::index_sequence<Is1...>,
    const std::array<size_t, R2>& dims2, std::index_sequence<Is2...>)
{
    return std::array<size_t, R1 + R2>{dims1[Is1]..., dims2[Is2]...};
}
template<size_t R1, size_t R2>
auto dims_join(const std::array<size_t, R1>& dims1,
    const std::array<size_t, R2>& dims2)
{
    return _dims_join_impl(dims1, std::make_index_sequence<R1>{},
        dims2, std::make_index_sequence<R2>{});
}
template<size_t... Is>
auto _dims_take_impl(const size_t* dims, std::index_sequence<Is...>)
{
    return std::array<size_t, sizeof...(Is)>{dims[Is]...};
}
template<size_t I1, size_t I2>
auto dims_take(const size_t* dims)
{
    static_assert(1u <= I1 && 1u <= I2, WL_ERROR_INTERNAL);
    if constexpr (I1 <= I2)
        return _dims_take_impl(dims + I1 - 1,
            std::make_index_sequence<I2 - I1 + 1>{});
    else
        return std::array<size_t, 0u>{};
}
template<size_t I1, size_t I2, size_t R>
auto dims_take(const std::array<size_t, R>& dims)
{
    if constexpr (I1 > I2)
        return std::array<size_t, 0u>{};
    else
    {
        static_assert(1u <= I1 && I1 <= R && 1u <= I2 && I2 <= R,
            WL_ERROR_INTERNAL);
        return dims_take<I1, I2>(dims.data());
    }
}
template<typename Dims, size_t... Is>
auto _size_of_dims_impl(const Dims* dims, std::index_sequence<Is...>)
{
    if constexpr (std::is_unsigned_v<Dims>)
        return (size_t(dims[Is]) * ...);
    else
    {
#if !defined(NDEBUG)
        if (!((dims[Is] >= 0) && ...))
            throw std::logic_error(WL_ERROR_INTERNAL);
#endif
        return (size_t(dims[Is]) * ...);
    }
}
template<size_t R, typename Dims>
auto size_of_dims(const Dims* dims)
{
    static_assert(is_integral_v<Dims>, WL_ERROR_INTERNAL);
    if constexpr (R == 0u)
        return size_t(1);
    else
        return _size_of_dims_impl(dims, std::make_index_sequence<R>{});
}
template<size_t R, typename Dims>
auto size_of_dims(const std::array<Dims, R>& dims)
{
    static_assert(is_integral_v<Dims>, WL_ERROR_INTERNAL);
    if constexpr (R == 0u)
        return size_t(1);
    else
        return _size_of_dims_impl(dims.data(), std::make_index_sequence<R>{});
}
template<size_t... Is>
bool check_dims_impl(const size_t* dims1, const size_t* dims2,
    std::index_sequence<Is...>)
{
    return ((dims1[Is] == dims2[Is]) && ...);
}
template<size_t R>
auto check_dims(const size_t* dims1, const size_t* dims2)
{
    if constexpr (R == 0u)
        return true;
    else
        return check_dims_impl(dims1, dims2, std::make_index_sequence<R>{});
}
template<size_t R>
auto check_dims(const std::array<size_t, R>& dims1,
    const std::array<size_t, R>& dims2)
{
    static_assert(R >= 1u, WL_ERROR_INTERNAL);
    return check_dims_impl(dims1.data(), dims2.data(),
        std::make_index_sequence<R>{});
}
template<size_t Level, size_t R, typename... Is>
void _linear_position_impl(const std::array<size_t, R>& dims, size_t& pos,
    const size_t& i1, const Is&... is)
{
    pos += i1;
    if constexpr (Level < R - 1)
    {
        pos *= dims[Level + 1u];
        _linear_position_impl<Level + 1u>(dims, pos, is...);
    }
}
template<size_t R, typename... Is>
size_t linear_position(const std::array<size_t, R>& dims, const Is&... is)
{
    static_assert(R == sizeof...(Is), WL_ERROR_INTERNAL);
    size_t pos = 0u;
    _linear_position_impl<0u>(dims, pos, is...);
    return pos;
}
template<typename X>
size_t lzcnt_u64(X x)
{
#if defined(__LZCNT__)
    return _lzcnt_u64(uint64_t(x));
#else
    int64_t n = 64;
    uint64_t y = x;
    if constexpr (sizeof(X) >= 8) if (y >> 32) { n -= 32; y >>= 32; }
    if constexpr (sizeof(X) >= 4) if (y >> 16) { n -= 16; y >>= 16; }
    if constexpr (sizeof(X) >= 2) if (y >> 8) { n -= 8; y >>= 8; }
    if (y >> 4) { n -= 4; y >>= 4; }
    if (y >> 2) { n -= 2; y >>= 2; }
    return n - ((y >> 1) ? int64_t(2) : int64_t(y));
#endif
}
template<typename X>
size_t tzcnt_u64(X x)
{
#if defined(__BMI__)
    return _tzcnt_u64(uint64_t(x));
#else
    int64_t n = 64;
    uint64_t y = x;
    if constexpr (sizeof(X) >= 8) if (y << 32) { n -= 32; y <<= 32; }
    if constexpr (sizeof(X) >= 4) if (y << 16) { n -= 16; y <<= 16; }
    if constexpr (sizeof(X) >= 2) if (y << 8) { n -= 8; y <<= 8; }
    if (y << 4) { n -= 4; y <<= 4; }
    if (y << 2) { n -= 2; y <<= 2; }
    return n - ((y << 1) ? int64_t(2) : int64_t(y >> 63));
#endif
}
template<typename X>
size_t _popcnt(X x)
{
    static_assert(std::is_unsigned_v<X>, WL_ERROR_INTERNAL);
#if defined(__POPCNT__)
    return _mm_popcnt_u64(uint64_t(x));
#else
    constexpr uint64_t m1  = 0x5555555555555555u;
    constexpr uint64_t m2  = 0x3333333333333333u;
    constexpr uint64_t m4  = 0x0f0f0f0f0f0f0f0fu;
    constexpr uint64_t h01 = 0x0101010101010101u;
    x -= (x >> 1) & m1;
    x = (x & m2) + ((x >> 2) & m2);
    x = (x + (x >> 4)) & m4;
    return size_t((x * h01) >> 56);
#endif
}
}
#if defined(WL_USE_MATHLINK)
namespace librarylink
{
template<typename String>
void send_error(const String& what) noexcept;
inline std::string get_stack_message(const std::string& err)
{
    std::string message = "error: " + err;
    return message;
}
inline std::string extract_filename(const char* file)
{
#if defined (_MSC_VER)
    const char separator = '\\';
#else
    const char separator = '/';
#endif
    const char* output = std::strrchr(file, separator);
    return output ? std::string(output + 1) : std::string(file);
}
extern volatile bool global_abort_in_progress;
extern volatile bool global_stop_check_abort;
template<typename AbortQ>
void start_check_abort(std::unique_ptr<std::thread>& thread, AbortQ* abort_q)
{
#if defined(WL_USE_MATHLINK) && defined(WL_CHECK_ABORT)
    global_stop_check_abort = false;
    global_abort_in_progress = false;
    if (thread)
        return;
    thread = std::make_unique<std::thread>([=]
        {
            for (;;)
            {
                global_abort_in_progress = bool(abort_q());
                std::this_thread::sleep_for(
                    std::chrono::milliseconds(WL_CHECK_ABORT_PERIOD));
                if (global_stop_check_abort || global_abort_in_progress)
                    return;
            }
        });
#endif
}
inline void stop_check_abort(std::unique_ptr<std::thread>& thread)
{
#if defined(WL_USE_MATHLINK) && defined(WL_CHECK_ABORT)
    global_stop_check_abort = true;
    global_abort_in_progress = false;
    if (thread)
        thread.release()->join();
#endif
}
}
#endif
#if defined(WL_USE_MATHLINK) && !defined(NDEBUG)
#  define WL_TRY_BEGIN()                                        \
    try                                                         \
    {
#  define WL_TRY_END(func, file, line)                          \
    } catch (std::logic_error& err)                             \
    {                                                           \
        throw std::logic_error(err.what() +                     \
            (std::string("\n>> from function \"") + func +      \
            "\" in \"" + librarylink::extract_filename(file) +  \
            "\" line " + std::to_string(line)));                \
    }
#else
#  define WL_TRY_BEGIN() ((void)0);
#  define WL_TRY_END(...) ((void)0);
#endif
#if defined(WL_USE_MATHLINK) && (defined(WL_CHECK_ABORT) || defined(WL_CHECK_ABORT_TEST))
#  define WL_THROW_IF_ABORT()                                           \
    {                                                                   \
        if (WL_UNLIKELY(librarylink::global_abort_in_progress))         \
            throw std::logic_error("AbortQ is called.");                \
    }
#  define WL_CHECK_ABORT_LOOP_BEGIN(n)                                  \
    const int64_t _loop_total_size = int64_t(n);                        \
    for (int64_t _loop_begin = 0;                                       \
        _loop_begin < _loop_total_size;                                 \
        _loop_begin += WL_CHECK_ABORT_LENGTH)                           \
    {                                                                   \
        constexpr int64_t _loop_zero = int64_t(0);                      \
        const int64_t _loop_size =                                      \
            _loop_begin + WL_CHECK_ABORT_LENGTH > _loop_total_size ?    \
            _loop_total_size - _loop_begin : WL_CHECK_ABORT_LENGTH;     \
        const int64_t _loop_end = _loop_begin + _loop_size;
#  define WL_CHECK_ABORT_LOOP_END()                                     \
        WL_THROW_IF_ABORT()                                             \
    }
#else
#  define WL_THROW_IF_ABORT() ((void)0);
#  define WL_CHECK_ABORT_LOOP_BEGIN(n)                                  \
    {                                                                   \
        constexpr int64_t _loop_zero = int64_t(0);                      \
        const int64_t _loop_size = int64_t(n);                          \
        const int64_t _loop_begin = 0;                                  \
        const int64_t _loop_end = _loop_size;
#  define WL_CHECK_ABORT_LOOP_END()                                     \
    }
#endif
namespace utils
{
template<typename XIter, typename YIter>
WL_INLINE void restrict_copy_n(XIter x_iter, const size_t n, YIter y_iter)
{
    using XV = remove_cvref_t<decltype(*x_iter)>;
    using YV = remove_cvref_t<decltype(*y_iter)>;
    constexpr bool use_memcpy =
        std::is_same_v<XV, YV> && std::is_trivially_copyable_v<XV> &&
        std::is_pointer_v<XIter> && std::is_pointer_v<YIter>;
    if constexpr (use_memcpy)
    {
        std::memcpy((void*)y_iter, (void*)x_iter, n * sizeof(XV));
        WL_THROW_IF_ABORT()
    }
    else
    {
        WL_CHECK_ABORT_LOOP_BEGIN(n)
            WL_IGNORE_DEPENDENCIES
            for (auto i = _loop_zero; i < _loop_size; ++i, ++x_iter, ++y_iter)
                *y_iter = *x_iter;
        WL_CHECK_ABORT_LOOP_END()
    }
}
template<typename XIter, typename YIter>
WL_INLINE void restrict_copy_n(XIter x_iter, const size_t n, YIter y_iter,
    no_check_abort_tag)
{
    using XV = remove_cvref_t<decltype(*x_iter)>;
    using YV = remove_cvref_t<decltype(*y_iter)>;
    constexpr bool use_memcpy =
        std::is_same_v<XV, YV> && std::is_trivially_copyable_v<XV> &&
        std::is_pointer_v<XIter> && std::is_pointer_v<YIter>;
    if constexpr (use_memcpy)
    {
        std::memcpy((void*)y_iter, (void*)x_iter, n * sizeof(XV));
    }
    else
    {
        const auto size = int64_t(n);
        for (int64_t i = 0; i < size; ++i, ++x_iter, ++y_iter)
            *y_iter = *x_iter;
    }
}
}
template<typename X>
auto pause(const X& x)
{
    constexpr uint64_t giga = 1'000'000'000;
    constexpr uint64_t max_sec = std::numeric_limits<uint64_t>::max() / giga;
    static_assert(is_real_v<X>, WL_ERROR_REAL_TYPE_ARG);
    if (x == X(0))
        return const_null;
    else if (x < X(0))
        throw std::logic_error(WL_ERROR_PAUSE_NEGATIVE);
    uint64_t nanosec = 0;
    if constexpr (is_integral_v<X>)
        nanosec = giga * std::min(uint64_t(x), max_sec);
    else
        nanosec = uint64_t(std::min(double(x), double(giga * max_sec)));
    constexpr uint64_t check_abort_nanosec =
        (WL_CHECK_ABORT_PERIOD * (giga / 1000u));
    while (nanosec > check_abort_nanosec)
    {
        WL_THROW_IF_ABORT()
        std::this_thread::sleep_for(
            std::chrono::nanoseconds(check_abort_nanosec));
        nanosec -= check_abort_nanosec;
    }
    WL_THROW_IF_ABORT()
    std::this_thread::sleep_for(std::chrono::nanoseconds(nanosec));
    return const_null;
}
}
namespace wl
{
template<bool UnitStep>
struct indexer_iter;
template<>
struct indexer_iter<false>
{
    size_t index_;
    ptrdiff_t step_;
    indexer_iter(size_t index, ptrdiff_t step) :
        index_{index}, step_{step}
    {
    }
    auto& operator++()
    {
        index_ += step_;
        return *this;
    }
    bool operator==(const indexer_iter& other) const
    {
        return this->index_ == other.index_;
    }
};
template<>
struct indexer_iter<true>
{
    size_t index_;
    explicit indexer_iter(size_t index) :
        index_{index}
    {
    }
    auto& operator++()
    {
        ++index_;
        return *this;
    }
    bool operator==(const indexer_iter& other) const
    {
        return this->index_ == other.index_;
    }
};
struct cidx
{
    const size_t value_;
    constexpr explicit cidx(int64_t value) : value_{size_t(value)}
    {
    }
    constexpr size_t value() const
    {
        return value_;
    }
};
template<typename IndexType>
size_t convert_index(const IndexType& idx, const size_t& dim)
{
    WL_TRY_BEGIN()
    if constexpr (std::is_same_v<IndexType, cidx>)
    {
        if (idx.value() < dim)
            return idx.value();
        else
            throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
    }
    else if constexpr (std::is_unsigned_v<IndexType>)
    {
        if (1u <= idx && idx <= dim)
            return size_t(idx - 1u);
        else
            throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
    }
    else
    {
        static_assert(is_integral_v<IndexType>, WL_ERROR_PART_SPEC_INTEGRAL);
        ptrdiff_t pos_idx = idx >= 0 ?
            idx : idx + ptrdiff_t(dim) + 1;
        if (1 <= pos_idx && pos_idx <= ptrdiff_t(dim))
            return size_t(pos_idx - 1u);
        else
            throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
    }
    return 0u;
    WL_TRY_END(__func__, __FILE__, __LINE__)
};
struct scalar_indexer
{
    size_t index_;
    scalar_indexer() = default;
    template<typename IndexType, typename Dim>
    scalar_indexer(IndexType index, const Dim& dim) :
        index_{convert_index(index, dim)}
    {
    }
    size_t offset() const
    {
        return this->index_;
    }
    size_t size() = delete;
    ptrdiff_t stride() = delete;
};
struct all_indexer
{
    size_t size_;
    all_indexer() = default;
    explicit all_indexer(size_t dim) :
        size_{dim}
    {
    }
    size_t offset() const
    {
        return 0u;
    }
    size_t size() const
    {
        return this->size_;
    }
    ptrdiff_t stride() const
    {
        return 1;
    }
};
struct unit_indexer
{
    size_t begin_;
    size_t size_;
    unit_indexer() = default;
    unit_indexer(size_t begin, size_t size) :
        begin_{begin}, size_{size}
    {
    }
    size_t offset() const
    {
        return this->begin_;
    }
    size_t size() const
    {
        return this->size_;
    }
    ptrdiff_t stride() const
    {
        return 1;
    }
    auto begin() const
    {
        return indexer_iter<true>(begin_);
    }
    auto end() const
    {
        return indexer_iter<true>(begin_ + size_);
    }
};
struct step_indexer
{
    size_t begin_;
    size_t size_;
    ptrdiff_t step_;
    step_indexer() = default;
    step_indexer(size_t begin, size_t size, ptrdiff_t step) :
        begin_{begin}, size_{size}, step_{step}
    {
    }
    size_t offset() const
    {
        return this->begin_;
    }
    size_t size() const
    {
        return this->size_;
    }
    ptrdiff_t stride() const
    {
        return step_;
    }
    auto begin() const
    {
        return indexer_iter<false>(begin_, step_);
    }
    auto end() const
    {
        return indexer_iter<false>(begin_ + step_ * size_, step_);
    }
};
struct complement_step_indexer_iterator
{
    size_t next_;
    size_t step_;
    size_t remain_;
    size_t current_;
    complement_step_indexer_iterator(size_t begin, size_t size, size_t step) :
        next_{begin}, remain_{size}, step_{step}, current_{0}
    {
        seek_if_invalid();
    }
    auto operator*() const
    {
        return current_;
    }
    void seek_if_invalid()
    {
        if (current_ == next_)
        {
            if (step_ == 1u)
            {
                current_ += remain_;
                remain_ = 0u;
            }
            else
            {
                ++current_;
                --remain_;
                if (remain_ > 0u)
                    next_ += step_;
            }
        }
    }
    auto& operator++()
    {
        ++current_;
        seek_if_invalid();
        return *this;
    }    
};
struct complement_step_indexer
{
    size_t begin_;
    size_t size_;
    size_t step_;
    size_t dim_;
    complement_step_indexer() = default;
    complement_step_indexer(
        size_t begin, size_t size, size_t step, size_t dim) :
        begin_{begin}, size_{size}, step_{step}, dim_{dim}
    {
    }
    size_t offset() const
    {
        return 0u;
    }
    ptrdiff_t stride() = delete;
    size_t size() const
    {
        return dim_ - size_;
    }
    auto iterator() const
    {
        return complement_step_indexer_iterator(begin_, size_, step_);
    }
};
struct list_indexer
{
    std::vector<size_t> indices_;
    list_indexer() = default;
    template<typename Iter>
    list_indexer(Iter idx_begin, Iter idx_end, size_t level_dim)
    {
        indices_.resize(idx_end - idx_begin);
        std::transform(idx_begin, idx_end, indices_.begin(),
            [&](const auto& idx) { return convert_index(idx, level_dim); });
    }
    size_t offset() const
    {
        return 0u;
    }
    ptrdiff_t stride() = delete;
    size_t size() const
    {
        return indices_.size();
    }
    const auto& indices() const
    {
        return this->indices_;
    }
};
template<typename Begin, typename End, typename Step>
struct span
{
    static constexpr auto default_begin = std::is_same_v<Begin, all_type>;
    static constexpr auto default_end = std::is_same_v<End, all_type>;
    static constexpr auto default_step = std::is_same_v<Step, all_type>;
    static_assert((default_begin || is_integral_v<Begin>) &&
        (default_end || is_integral_v<End>) &&
        (default_step || is_integral_v<Step>), WL_ERROR_INTEGRAL_TYPE_ARG);
    Begin begin_;
    End end_;
    Step step_;
    span(Begin begin, End end, Step step) :
        begin_{begin}, end_{end}, step_{step}
    {
    }
    auto to_indexer(size_t dim) const
    {
        if constexpr (default_begin && default_end && default_step)
            return all_indexer(dim);
        else
        {
            // convert WL-style index to C-style index
            ptrdiff_t begin = 1;
            ptrdiff_t end = ptrdiff_t(dim);
            ptrdiff_t step = 1;
            if constexpr (!default_begin)
            {
                if constexpr (std::is_unsigned_v<Begin>)
                    begin = ptrdiff_t(this->begin_);
                else if (this->begin_ >= 0)
                    begin = ptrdiff_t(this->begin_);
                else // this->begin_ < 0
                    begin = ptrdiff_t(this->begin_) + ptrdiff_t(dim + 1u);
                //check out-of-range
                if (begin < 1 || begin > ptrdiff_t(dim))
                    throw std::logic_error(WL_ERROR_SPAN_OUT_OF_RANGE);
            }
            if constexpr (!default_end)
            {
                if constexpr (std::is_unsigned_v<End>)
                    end = ptrdiff_t(this->end_);
                else if (this->end_ >= 0)
                    end = ptrdiff_t(this->end_);
                else // this->end_ < 0
                    end = ptrdiff_t(this->end_) + ptrdiff_t(dim + 1u);
                //check out-of-range
                if (end < 1 || end > ptrdiff_t(dim))
                    throw std::logic_error(WL_ERROR_SPAN_OUT_OF_RANGE);
            }
            if constexpr (!default_step)
            {
                step = step_;
                if (step == 0)
                    throw std::logic_error(WL_ERROR_ITERATOR_ZERO_STEP);
                else if (step < 0)
                {
                    if constexpr (default_begin)
                        begin = ptrdiff_t(dim);
                    if constexpr (default_end)
                        end = 1;
                }
            }
            if constexpr (default_step)
            {
                if constexpr (default_begin || default_end)
                {
                    return unit_indexer(
                        size_t(begin - 1),
                        size_t(end - begin + 1));
                }
                else
                {
                    return unit_indexer(
                        size_t(begin - 1),
                        end >= begin ? size_t(end - begin + 1) : 0u);
                }
            }
            else if (step > 0)
            {
                return step_indexer(
                    size_t(begin - 1),
                    end >= begin ? size_t((end - begin) / step) + 1u : 0u,
                    step);
            }
            else // step < 0
            {
                return step_indexer(
                    size_t(begin - 1),
                    end <= begin ? size_t((begin - end) / -step) + 1u : 0u,
                    step);
            }
        }
    }
};
template<typename Begin, typename End, typename Step>
struct complement_span
{
    using normal_span = span<Begin, End, Step>;
    normal_span normal_span_;
    complement_span(Begin begin, End end, Step step) :
        normal_span_(begin, end, step)
    {
    }
    auto to_indexer(size_t dim) const
    {
        const auto normal_indexer = normal_span_.to_indexer(dim);
        const auto begin = normal_indexer.offset();
        const auto size = normal_indexer.size();
        const auto step = normal_indexer.stride();
        if (step > 0)
            return complement_step_indexer(begin, size, size_t(step), dim);
        else
            return complement_step_indexer(
                begin + step * (size - 1u), size, size_t(-step), dim);
    }
};
template<typename Begin, typename End, typename Step>
auto make_span(const Begin& begin, const End& end, const Step& step)
{
    return span<Begin, End, Step>(begin, end, step);
}
template<typename Begin, typename End>
auto make_span(const Begin& begin, const End& end)
{
    return make_span(begin, end, const_all);
}
template<typename Begin, typename End, typename Step>
auto make_span(complement_span_tag,
    const Begin& begin, const End& end, const Step& step)
{
    return complement_span<Begin, End, Step>(begin, end, step);
}
template<typename Begin, typename End>
auto make_span(complement_span_tag, const Begin& begin, const End& end)
{
    return make_span(complement_span_tag{}, begin, end, const_all);
}
template<typename Begin, typename End, typename Step>
auto make_indexer(const span<Begin, End, Step>& s, size_t dim)
{
    WL_TRY_BEGIN()
    return s.to_indexer(dim);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Begin, typename End, typename Step>
auto make_indexer(const complement_span<Begin, End, Step>& s, size_t dim)
{
    WL_TRY_BEGIN()
    return s.to_indexer(dim);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename IndexType, size_t Rank>
auto make_indexer(const ndarray<IndexType, Rank>& list, size_t dim)
{
    WL_TRY_BEGIN()
    static_assert(Rank == 1u && is_integral_v<IndexType>,
        WL_ERROR_INDEXER_LIST);
    return list_indexer(list.begin(), list.end(), dim);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename IndexType>
auto make_indexer(const IndexType& index, size_t dim)
{
    WL_TRY_BEGIN()
    if constexpr (std::is_same_v<IndexType, all_type>)
        return all_indexer(dim);
    else if constexpr (std::is_same_v<IndexType, cidx>)
        return scalar_indexer(index, dim);
    else
    {
        static_assert(is_integral_v<IndexType>, WL_ERROR_INDEXER_SCALAR);
        return scalar_indexer(index, dim);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename T, size_t ArrayRank, size_t ViewRank, bool Const>
struct simple_view
{
    static constexpr auto is_const = Const;
    static constexpr auto array_rank = ArrayRank;
    static constexpr auto view_rank = ViewRank;
    static constexpr auto rank = ViewRank;
    static constexpr auto category = view_category::Simple;
    using value_type = T;
    using array_ref_type = std::conditional_t<Const,
        const ndarray<T, ArrayRank>&, ndarray<T, ArrayRank>&>;
    using pointer_type = std::conditional_t<Const, const T*, T*>;
    using _base_dims_t = std::array<size_t, ArrayRank>;
    using _dims_t = std::array<size_t, ViewRank>;
    const void* const identifier_;
    pointer_type data_;
    _dims_t dims_;
    size_t size_;
    simple_view(const void* base_id, pointer_type view_data, const size_t* dims) :
        identifier_{base_id}, data_{view_data}
    {
        std::copy_n(dims, ViewRank, this->dims_.begin());
        this->size_ = utils::size_of_dims(this->dims_);
    }
    template<typename... Specs>
    simple_view(const void* base_id, pointer_type base_data, 
        const _base_dims_t& base_dims, const Specs&... specs) :
        identifier_{base_id}, size_{1u}
    {
        static_assert(sizeof...(Specs) == ArrayRank, WL_ERROR_INTERNAL);
        this->_initialize<0u>(specs...);
        this->data_ = base_data + 
            utils::linear_position(base_dims, specs.offset()...);
    }
    template<size_t Level, typename Spec1, typename... Specs>
    void _initialize(const Spec1& spec1, const Specs&... specs)
    {
        if constexpr (Level < ArrayRank - ViewRank)
        {
            static_assert(std::is_same_v<Spec1, scalar_indexer>,
                WL_ERROR_INTERNAL);
            this->_initialize<Level + 1u>(specs...);
        }
        else
        {
            static_assert(!std::is_same_v<Spec1, scalar_indexer>,
                WL_ERROR_INTERNAL);
            constexpr size_t ViewLevel = Level - (ArrayRank - ViewRank);
            this->dims_[ViewLevel] = spec1.size();
            this->size_ *= this->dims_[ViewLevel];
            if constexpr (Level < ArrayRank - 1u)
                _initialize<Level + 1u>(specs...);
        }
    }
    auto dims() const
    {
        return this->dims_;
    }
    const size_t* dims_ptr() const
    {
        return this->dims_.data();
    }
    auto identifier() const
    {
        return this->identifier_;
    }
    auto begin() const
    {
        return this->data_;
    }
    auto data() const
    {
        return this->data_;
    }
    auto size() const
    {
        return this->size_;
    }
    template<typename Function, typename... Iters>
    void for_each(Function f, Iters... iters) const
    {
        if constexpr (std::is_same_v<bool, decltype(f(*data_, *iters...))>)
        {
            bool continue_flag = true;
            for (size_t i = 0u; i < this->size_ && continue_flag; ++i)
                continue_flag = !f(this->data_[i], iters[i]...);
        }
        else
        {
            for (size_t i = 0u; i < this->size_; ++i)
                f(this->data_[i], iters[i]...);
        }
    }
    template<typename FwdIter>
    void copy_to(FwdIter iter) const
    {
        for (size_t i = 0u; i < this->size_; ++i)
            iter[i] = this->data_[i];
    }
    template<typename FwdIter>
    void copy_from(FwdIter iter) const
    {
        for (size_t i = 0u; i < this->size_; ++i)
            this->data_[i] = iter[i];
    }
    auto to_array() const
    {
        return ndarray<T, ViewRank>(this->dims_,
            this->begin(), this->begin() + this->size());
    }
    void apply_pointer_offset(ptrdiff_t diff)
    {
        this->data_ += diff;
    }
    simple_view& operator++()
    {
        this->apply_pointer_offset(ptrdiff_t(this->size_));
        return *this;
    }
    simple_view& operator--()
    {
        this->apply_pointer_offset(-ptrdiff_t(this->size_));
        return *this;
    }
    simple_view& operator+=(ptrdiff_t diff)
    {
        this->apply_pointer_offset(ptrdiff_t(this->size_) * diff);
        return *this;
    }
    simple_view& operator-=(ptrdiff_t diff)
    {
        return *this += (-diff);
    }
    simple_view operator+(ptrdiff_t diff) const
    {
        auto copy = *this;
        copy += diff;
        return copy;
    }
    simple_view operator-(ptrdiff_t diff) const
    {
        auto copy = *this;
        copy -= diff;
        return copy;
    }
    const simple_view& operator*() const
    {
        return *this;
    }
    bool operator==(const simple_view& other) const
    {
        return this->data_ == other.data_;
    }
    bool operator!=(const simple_view& other) const
    {
        return !(*this == other);
    }
};
template<typename T, bool Const>
struct regular_view_iterator
{
    using _my_type = regular_view_iterator;
    using iterator_category = std::forward_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = std::conditional_t<Const, const T*, T*>;
    using reference = std::conditional_t<Const, const T&, T&>;
    pointer pointer_;
    ptrdiff_t stride_;
    regular_view_iterator(pointer pointer, ptrdiff_t stride) :
        pointer_{pointer}, stride_{stride}
    {
    }
    reference operator*() const
    {
        return *this->pointer_;
    }
    auto operator++()
    {
        this->pointer_ += this->stride_;
        return *this;
    }
    auto operator++(int)
    {
        auto old_pointer = this->pointer_;
        this->pointer_ += this->stride_;
        return _my_type(old_pointer, this->stride_);
    }
    auto operator==(const _my_type& other) const
    {
        return this->pointer_ == other.pointer_;
    }
    auto operator!=(const _my_type& other) const
    {
        return !(*this == other);
    }
    auto operator+(ptrdiff_t diff) const
    {
        return _my_type(pointer_ + diff * stride_, stride_);
    }
    auto& operator[](ptrdiff_t diff) const
    {
        return pointer_ + diff * stride_;
    }
    auto operator-(const _my_type& other) const
    {
        return ptrdiff_t(this->pointer_ - other.pointer_) / this->stride_;
    }
};
template<typename T, size_t ArrayRank, size_t ViewRank, size_t StrideRank, bool Const>
struct regular_view
{
    static constexpr auto is_const = Const;
    static constexpr auto array_rank = ArrayRank;
    static constexpr auto view_rank = ViewRank;
    static constexpr auto stride_rank = StrideRank;
    static constexpr auto rank = ViewRank;
    static constexpr auto category = view_category::Regular;
    using value_type = T;
    using array_ref_type = std::conditional_t<Const,
        const ndarray<T, ArrayRank>&, ndarray<T, ArrayRank>&>;
    using pointer_type = std::conditional_t<Const, const T*, T*>;
    using _base_dims_t = std::array<size_t, ArrayRank>;
    using _dims_t = std::array<size_t, ViewRank>;
    const void* const identifier_;
    pointer_type data_;
    ptrdiff_t stride_;
    _dims_t dims_;
    size_t size_;
    template<typename... Specs>
    regular_view(const void* base_id, pointer_type base_data,
        const _base_dims_t& base_dims, const Specs&... specs) :
        identifier_{base_id}, size_{1u}
    {
        static_assert(sizeof...(Specs) == ArrayRank, WL_ERROR_INTERNAL);
        this->stride_ = 1;
        this->_initialize<0u>(base_dims, specs...);
        this->data_ = base_data +
            utils::linear_position(base_dims, specs.offset()...);
    }
    template<size_t Level, typename Spec1, typename... Specs>
    auto _initialize(const _base_dims_t& dims,
        const Spec1& spec1, const Specs&... specs)
    {
        if constexpr (Level < ArrayRank - ViewRank - StrideRank)
        {
            static_assert(std::is_same_v<Spec1, scalar_indexer>,
                WL_ERROR_INTERNAL);
            this->_initialize<Level + 1>(dims, specs...);
        }
        else if constexpr (Level < ArrayRank - StrideRank)
        {
            static_assert(!std::is_same_v<Spec1, scalar_indexer>,
                WL_ERROR_INTERNAL);
            constexpr size_t ViewLevel = Level -
                (ArrayRank - ViewRank - StrideRank);
            this->dims_[ViewLevel] = spec1.size();
            this->size_ *= this->dims_[ViewLevel];
            if constexpr (std::is_same_v<Spec1, step_indexer>)
                this->stride_ *= spec1.stride();
            if constexpr (Level < ArrayRank - 1u)
                _initialize<Level + 1u>(dims, specs...);
        }
        else
        {
            static_assert(std::is_same_v<Spec1, scalar_indexer>,
                WL_ERROR_INTERNAL);
            this->stride_ *= dims[Level];
            if constexpr (Level < ArrayRank - 1u)
                _initialize<Level + 1u>(dims, specs...);
        }
    }
    auto dims() const
    {
        return this->dims_;
    }
    const size_t* dims_ptr() const
    {
        return this->dims_.data();
    }
    auto identifier() const
    {
        return this->identifier_;
    }
    auto begin() const
    {
        return regular_view_iterator<T, Const>(this->data_, this->stride_);
    }
    auto data() const
    {
        return this->data_;
    }
    auto size() const
    {
        return this->size_;
    }
    auto stride() const
    {
        return this->stride_;
    }
    template<typename Function, typename... Iters>
    void for_each(Function f, Iters... iters) const
    {
        if constexpr (std::is_same_v<bool, decltype(f(*data_, *iters...))>)
        {
            bool continue_flag = true;
            for (size_t i = 0u; i < this->size_ && continue_flag; ++i)
                continue_flag = !f(this->data_[i * stride_], iters[i]...);
        }
        else
        {
            for (size_t i = 0u; i < this->size_; ++i)
                f(this->data_[i * stride_], iters[i]...);
        }
    }
    template<typename FwdIter>
    void copy_to(FwdIter iter) const
    {
        for (size_t i = 0u; i < this->size_; ++i)
            iter[i] = this->data_[i * stride_];
    }
    template<typename FwdIter>
    void copy_from(FwdIter iter) const
    {
        for (size_t i = 0u; i < this->size_; ++i)
            this->data_[i * stride_] = iter[i];
    }
    auto to_array() const
    {
        return ndarray<T, ViewRank>(this->dims_,
            this->begin(), this->begin() + this->size());
    }
};
template<typename T, size_t ArrayRank, size_t ViewRank, size_t StrideRank, typename IndexersTuple, bool Const>
struct general_view
{
    static_assert(ViewRank == std::tuple_size_v<IndexersTuple>,
        WL_ERROR_INTERNAL);
    static constexpr auto is_const = Const;
    static constexpr auto array_rank = ArrayRank;
    static constexpr auto view_rank = ViewRank;
    static constexpr auto stride_rank = StrideRank;
    static constexpr auto rank = ViewRank;
    static constexpr auto category = view_category::General;
    using value_type = T;
    using array_ref_type = std::conditional_t<Const,
        const ndarray<T, ArrayRank>&, ndarray<T, ArrayRank>&>;
    using pointer_type = std::conditional_t<Const, const T*, T*>;
    using _base_dims_t = std::array<size_t, ArrayRank>;
    using _dims_t = std::array<size_t, ViewRank>;
    using _strides_t = std::array<ptrdiff_t, ViewRank>;
    using _indexers_tuple = IndexersTuple;
    static constexpr auto _has_last_stride = (StrideRank != 0);
    const void* const identifier_;
    pointer_type data_;
    _strides_t strides_;
    _indexers_tuple indexers_;
    _dims_t dims_;
    size_t size_;
    template<typename... Specs>
    general_view(const void* base_id, pointer_type base_data,
        const _base_dims_t& base_dims, Specs&&... specs) :
        identifier_{base_id}, size_{1u}
    {
        static_assert(sizeof...(Specs) == ArrayRank,
            WL_ERROR_INTERNAL);
        this->_initialize<0u, 0u>(
            base_dims, std::forward<decltype(specs)>(specs)...);
        this->data_ = base_data +
            utils::linear_position(base_dims, specs.offset()...);
    }
    template<size_t Level, size_t ViewLevel, typename Spec1, typename... Specs>
    auto _initialize(const _base_dims_t& dims,
        Spec1&& spec1, Specs&&... specs)
    {
        if constexpr (std::is_same_v<remove_cvref_t<Spec1>, scalar_indexer>)
        {
            if constexpr (ViewLevel > 0u)
                this->strides_[ViewLevel - 1] *= dims[Level];
            if constexpr (Level < ArrayRank - 1u)
                _initialize<Level + 1u, ViewLevel>(
                    dims, std::forward<decltype(specs)>(specs)...);
        }
        else
        {
            if constexpr (ViewLevel > 0u)
                this->strides_[ViewLevel - 1] *= dims[Level];
            this->strides_[ViewLevel] = 1;
            this->dims_[ViewLevel] = spec1.size();
            this->size_ *= this->dims_[ViewLevel];
            std::get<ViewLevel>(this->indexers_) = 
                std::forward<decltype(spec1)>(spec1);
            if constexpr (Level < ArrayRank - 1u)
                _initialize<Level + 1u, ViewLevel + 1u>(
                    dims, std::forward<decltype(specs)>(specs)...);
        }
    }
    auto dims() const
    {
        return this->dims_;
    }
    const size_t* dims_ptr() const
    {
        return this->dims_.data();
    }
    auto identifier() const
    {
        return this->identifier_;
    }
    auto begin() const = delete;
    auto data() const = delete;
    auto size() const
    {
        return this->size_;
    }
    template<size_t ViewLevel, typename Function, typename... Iters>
    void _for_each_impl(size_t index, bool& break_flag, 
        Function& f, Iters&... iters) const
    {
        constexpr bool check_break =
            std::is_same_v<bool, decltype(f(*data_, *iters...))>;
        const auto& indexer = std::get<ViewLevel>(this->indexers_);
        using Indexer = remove_cvref_t<decltype(indexer)>;
        if constexpr (ViewLevel > 0u)
            index *= this->strides_[ViewLevel - 1];
        if constexpr (ViewLevel < ViewRank - 1u)
        {
            if constexpr (std::is_same_v<Indexer, list_indexer>)
            {
                for (const auto& i : indexer.indices())
                {
                    _for_each_impl<ViewLevel + 1u>(
                        index + i, break_flag, f, iters...);
                    if (check_break && break_flag)
                        break;
                }
            }
            else if constexpr (
                std::is_same_v<Indexer, complement_step_indexer>)
            {
                const auto dim_size = indexer.size();
                auto index_iter = indexer.iterator();
                for (size_t i = 0; i < dim_size; ++i, ++index_iter)
                {
                    _for_each_impl<ViewLevel + 1u>(
                        index + (*index_iter), break_flag, f, iters...);
                    if (check_break && break_flag)
                        break;
                }
            }
            else if constexpr (std::is_same_v<Indexer, step_indexer>)
            {
                const auto this_stride = indexer.stride();
                for (size_t i = 0; i < this->dims_[ViewLevel]; ++i)
                {
                    _for_each_impl<ViewLevel + 1u>(
                        index + i * this_stride, break_flag, f, iters...);
                    if (check_break && break_flag)
                        break;
                }
            }
            else
            {
                for (size_t i = 0; i < this->dims_[ViewLevel]; ++i)
                {
                    _for_each_impl<ViewLevel + 1u>(
                        index + i, break_flag, f, iters...);
                    if (check_break && break_flag)
                        break;
                }
            }
        }
        else
        {
            const auto last_stride = _has_last_stride ? 
                this->strides_[ViewLevel] : ptrdiff_t(1);
            if constexpr (std::is_same_v<Indexer, list_indexer>)
            {
                for (const auto& i : indexer.indices())
                {
                    if constexpr (check_break)
                    {
                        if (f(this->data_[(index + i) * last_stride],
                            (*iters++)...))
                            break;
                    }
                    else
                        f(this->data_[(index + i) * last_stride],
                        (*iters++)...);
                }
            }
            else if constexpr (
                std::is_same_v<Indexer, complement_step_indexer>)
            {
                const auto dim_size = indexer.size();
                auto index_iter = indexer.iterator();
                for (size_t i = 0; i < dim_size; ++i, ++index_iter)
                {
                    const auto this_index = *index_iter;
                    if constexpr (check_break)
                    {
                        if (f(this->data_[(index + this_index) * last_stride],
                            (*iters++)...))
                            break;
                    }
                    else
                        f(this->data_[(index + this_index) * last_stride],
                        (*iters++)...);
                }
            }
            else if constexpr (std::is_same_v<Indexer, step_indexer>)
            {
                const auto this_stride = indexer.stride();
                for (size_t i = 0; i < this->dims_[ViewLevel]; ++i)
                {
                    const auto this_i = i * this_stride;
                    if constexpr (check_break)
                    {
                        if (f(this->data_[(index + this_i) * last_stride],
                            (*iters++)...))
                            break;
                    }
                    else
                        f(this->data_[(index + this_i) * last_stride],
                        (*iters++)...);
                }
            }
            else
            {
                for (size_t i = 0; i < this->dims_[ViewLevel]; ++i)
                {
                    if constexpr (check_break)
                    {
                        if (f(this->data_[(index + i) * last_stride],
                            (*iters++)...))
                            break;
                    }
                    else
                        f(this->data_[(index + i) * last_stride],
                        (*iters++)...);
                }
            }
        }
    }
    template<typename Function, typename... Iters>
    void for_each(Function f, Iters... iters) const
    {
        bool break_flag = false;
        this->_for_each_impl<0u>(0u, break_flag, f, iters...);
    }
    template<typename FwdIter>
    void copy_to(FwdIter iter) const
    {
        this->for_each([](const auto& src, auto& dst) { dst = src; }, iter);
    }
    template<typename FwdIter>
    void copy_from(FwdIter iter) const
    {
        this->for_each([](auto& dst, const auto& src) { dst = src; }, iter);
    }
    auto to_array() const
    {
        auto ret = ndarray<T, ViewRank>(this->dims_);
        this->copy_to(ret.begin());
        return ret;
    }
};
template<typename Any>
auto val(Any&& any) -> decltype(auto)
{
    if constexpr (is_array_view_v<remove_cvref_t<Any>>)
        return std::forward<decltype(any)>(any).to_array();
    else
        return std::forward<decltype(any)>(any);
}
template<view_category Category, typename Any>
auto allows(Any&& any) -> decltype(auto)
{
    using AnyType = remove_cvref_t<Any>;
    if constexpr (array_rank_v<AnyType> == 0)
        return std::forward<decltype(any)>(any);
    else
    {
        constexpr auto array_filter =
            Category == view_category::Array && is_array_view_v<AnyType>;
        constexpr auto simple_filter =
            Category == view_category::Simple &&
            (AnyType::category == view_category::General ||
                AnyType::category == view_category::Regular);
        constexpr auto regular_filter =
            Category == view_category::Regular &&
            AnyType::category == view_category::General;
        if constexpr (array_filter || simple_filter || regular_filter)
            return std::forward<decltype(any)>(any).to_array();
        else
            return std::forward<decltype(any)>(any);
    }
}
template<typename T>
struct scalar_view_iterator
{
    using _my_type = scalar_view_iterator;
    using value_type = T;
    T val_;
    constexpr scalar_view_iterator(const T& val) : val_{val}
    {
    }
    constexpr auto operator++() const
    {
        return *this;
    }
    constexpr auto operator++(int) const
    {
        return *this;
    }
    auto operator==(const _my_type&) = delete;
    constexpr const T& operator[](ptrdiff_t) const
    {
        return val_;
    }
    constexpr const T& operator*() const
    {
        return val_;
    }
};
template<typename T>
constexpr auto make_scalar_view_iterator(const T& val)
{
    return scalar_view_iterator<T>(val);
}
template<typename View>
auto _data_coverage(const View& view)
{
    if constexpr (View::category == view_category::Simple)
        return std::make_pair(view.data(), view.data() + view.size() - 1u);
    else
    {
        static_assert(View::category == view_category::Regular,
            WL_ERROR_INTERNAL);
        return std::make_pair(view.data(),
            view.data() + (view.size() - 1u) * view.stride() +
            (view.stride() > 0 ? 1 : -1));
    }
}
template<typename Dst, typename Src>
auto has_aliasing(const Dst& dst, const Src& src)
{
    if constexpr (std::is_same_v<value_type_t<Dst>, value_type_t<Src>>)
    {
        if (dst.identifier() != src.identifier())
            return false;
        if constexpr (
            Dst::category == view_category::Array   ||
            Dst::category == view_category::General ||
            Src::category == view_category::Array   ||
            Src::category == view_category::General)
        {
            return true;
        }
        else
        {
            auto[src_min, src_max] = _data_coverage(src);
            auto[dst_min, dst_max] = _data_coverage(dst);
            return (src_max >= dst_min) && (src_min <= dst_max);
        }
    }
    else
        return false;
}
template<typename Dst, typename Src>
auto indirect_view_copy(Dst&& dst, const Src& src)
{
    using SrcValueType = typename Src::value_type;
    using DstValueType = typename remove_cvref_t<Dst>::value_type;
    using T = std::conditional_t<sizeof(SrcValueType) < sizeof(DstValueType),
        SrcValueType, DstValueType>;
    std::vector<T> buffer(src.size());
    src.copy_to(buffer.begin());
    dst.copy_from(buffer.begin());
}
}
namespace wl
{
#ifndef WL_SMALL_ARRAY_SIZE
#define WL_SMALL_ARRAY_SIZE 256
#endif
template<typename T, size_t N>
struct _small_vector
{
    using static_t = std::array<T, N>;
    using dynamic_t = std::vector<T>;
    union data_t
    {
        static_t static_;
        dynamic_t dynamic_;
        data_t() {}
        ~data_t() {}
        data_t(const data_t&) = delete;
        data_t(data_t&&) = delete;
        data_t& operator=(const data_t&) = delete;
        data_t& operator=(data_t&&) = delete;
    };
    bool is_static_ = true;
    size_t size_ = 0u;
    data_t data_;
    _small_vector()
    {
    }
    ~_small_vector()
    {
        this->destroy();
    }
    explicit _small_vector(size_t size) : size_{size}
    {
        bool is_static = (size_ <= N);
        if (is_static)
        {
            std::uninitialized_default_construct_n(static_begin(), size);
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(size);
        }
        this->is_static_ = is_static;
    }
    _small_vector(size_t size, const T& val) : size_{size}
    {
        bool is_static = (size_ <= N);
        if (is_static)
        {
            std::uninitialized_fill_n(static_begin(), size, val);
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(size, val);
        }
        this->is_static_ = is_static;
    }
    template<typename FwdIter>
    _small_vector(FwdIter begin, FwdIter end) : size_{size_t(end - begin)}
    {
        bool is_static = (size_ <= N);
        if (is_static)
        {
            std::uninitialized_copy_n(begin, size_, static_begin());
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(begin, end);
        }
        this->is_static_ = is_static;
    }
    explicit _small_vector(const dynamic_t& other) : size_{other.size()}
    {
        bool is_static = (size_ <= N);
        if (is_static)
        {
            std::uninitialized_copy_n(other.begin(), size_, static_begin());
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(other);
        }
        this->is_static_ = is_static;
    }
    explicit _small_vector(dynamic_t&& other) : size_{other.size()}
    {
        WL_THROW_IF_ABORT()
        new(&data_.dynamic_) dynamic_t(std::move(other));
        this->is_static_ = false;
    }
    _small_vector(const _small_vector& other) : size_{other.size_}
    {
        if (other.size_ <= N)
        {
            std::uninitialized_copy_n(other.begin(), size_, static_begin());
            this->is_static_ = true;
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(other.data_.dynamic_);
            this->is_static_ = false;
        }
    }
    _small_vector(_small_vector&& other) : size_{other.size_}
    {
        if (other.is_static_)
        {
            std::uninitialized_move_n(
                other.static_begin(), size_, static_begin());
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(std::move(other.data_.dynamic_));
        }
        this->is_static_ = other.is_static_;
    }
    _small_vector& operator=(const _small_vector& other)
    {
        this->destroy();
        if (other.size_ <= N)
        {
            std::uninitialized_copy_n(other.begin(), size_, static_begin());
            this->is_static_ = true;
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(other.data_.dynamic_);
            this->is_static_ = false;
        }
        this->size_ = other.size_;
        return *this;
    }
    _small_vector& operator=(_small_vector&& other)
    {
        this->destroy();
        if (other.is_static_)
        {
            std::uninitialized_move_n(
                other.static_begin(), other.size_, static_begin());
        }
        else
        {
            WL_THROW_IF_ABORT()
            new(&data_.dynamic_) dynamic_t(std::move(other.data_.dynamic_));
        }
        this->is_static_ = other.is_static_;
        this->size_ = other.size_;
        return *this;
    }
    WL_INLINE void destroy_static()
    {
        std::destroy(static_begin(), static_end());
    }
    WL_INLINE void destroy_dynamic()
    {
        WL_THROW_IF_ABORT()
        data_.dynamic_.~dynamic_t();
    }
    WL_INLINE void destroy()
    {
        if (is_static_)
        {
            destroy_static();
        }
        else
        {
            destroy_dynamic();
        }
    }
    size_t size() const
    {
        return size_;
    }
    bool is_static() const
    {
        return is_static_;
    }
    const T* data() const
    {
        return is_static_ ? static_begin() : dynamic_begin();
    }
    T* data()
    {
        return is_static_ ? static_begin() : dynamic_begin();
    }
    T* static_begin() { return data_.static_.data(); }
    T* static_end() { return static_begin() + size_; }
    const T* static_begin() const { return data_.static_.data(); }
    const T* static_end() const { return static_begin() + size_; }
    T* dynamic_begin() { return data_.dynamic_.data(); }
    T* dynamic_end() { return dynamic_begin() + size_; }
    const T* dynamic_begin() const { return data_.dynamic_.data(); }
    const T* dynamic_end() const { return dynamic_begin() + size_; }
    T* begin() { return data(); }
    T* end() { return data() + size_; }
    const T* begin() const { return data(); }
    const T* end() const { return data() + size_; }
    void resize(size_t new_size)
    {
        const auto prev_size = size_;
        if (!is_static_)
        {
            WL_THROW_IF_ABORT()
            data_.dynamic_.resize(new_size);
            if (new_size < prev_size)
                data_.dynamic_.shrink_to_fit();
        }
        else if (new_size > N)
        {
            WL_THROW_IF_ABORT()
            dynamic_t new_data(new_size);
            std::move(static_begin(), static_end(), new_data.data());
            std::destroy(static_begin(), static_end());
            new(&data_.dynamic_) dynamic_t(std::move(new_data));
            is_static_ = false;
        }
        else
        {
            const auto diff_size = ptrdiff_t(new_size - prev_size);
            if (diff_size > 0)
                std::uninitialized_default_construct_n(
                    static_begin() + prev_size, size_t(diff_size));
            else if (diff_size < 0)
                std::destroy_n(static_begin() + new_size, size_t(-diff_size));
        }
        size_ = new_size;
    }
    const void* identifier() const
    {
        return reinterpret_cast<const void*>(this);
    }
};
template<typename T, size_t R>
struct ndarray
{
    static_assert(1u <= R, WL_ERROR_ZERO_RANK);
    static_assert(R <= MaximumArrayRank, WL_ERROR_LARGE_RANK);
    static_assert(std::is_same_v<T, remove_cvref_t<T>>, WL_ERROR_INTERNAL);
    static_assert(is_arithmetic_v<T> || is_boolean_v<T> || is_string_v<T>,
        WL_ERROR_ARRAY_VALUE_TYPE);
    using value_type = T;
    static constexpr auto rank = R;
    using _dims_t = std::array<size_t, R>;
    static constexpr auto category = view_category::Array;
    static constexpr auto small_size = size_t(WL_SMALL_ARRAY_SIZE) / sizeof(T);
    using _data_t = _small_vector<T, small_size>;
    _dims_t dims_;
    _data_t data_;
    ndarray() : dims_{0u}, data_{}
    {
    }
    template<typename DimsT>
    ndarray(const std::array<DimsT, R>& dims, const T& val) :
        data_(utils::size_of_dims(dims), val)
    {
        std::copy(dims.begin(), dims.end(), this->dims_.data());
    }
    template<typename DimsT>
    ndarray(const std::array<DimsT, R>& dims) :
        data_(utils::size_of_dims(dims))
    {
        std::copy(dims.begin(), dims.end(), this->dims_.data());
    }
    template<typename FwdIter>
    ndarray(std::array<size_t, R> dims, FwdIter begin, FwdIter end) :
        dims_{dims}, data_(begin, end)
    {
    }
    ndarray(std::array<size_t, R> dims, std::initializer_list<T> data) :
        dims_{dims}, data_(data.begin(), data.end())
    {
    }
    ndarray(std::array<size_t, R> dims, _data_t&& movable) :
        dims_{dims}, data_(std::move(movable))
    {
    }
    ndarray(std::array<size_t, R> dims, std::vector<T>&& movable) :
        dims_{dims}, data_(std::move(movable))
    {
    }
    size_t size() const
    {
        return data_.size();
    }
    template<size_t Level>
    size_t partial_size() const
    {
        static_assert(Level <= R, WL_ERROR_INTERNAL);
        return utils::size_of_dims<R - Level>(this->dims_.data());
    }
    // uses one-based indexing
    template<size_t Level>
    size_t dimension() const
    {
        static_assert(1 <= Level && Level <= R, WL_ERROR_INTERNAL);
        return this->dims_[Level - 1];
    }
    const auto& dims() const
    {
        return this->dims_;
    }
    const size_t* dims_ptr() const
    {
        return this->dims_.data();
    }
    const T* data() const
    {
        return this->data_.data();
    }
    T* data()
    {
        return this->data_.data();
    }
    auto is_static() const
    {
        return this->data_.is_static();
    }
    auto data_vector() const & -> const auto&
    {
        return this->data_;
    }
    auto data_vector() & -> auto&
    {
        return this->data_;
    }
    auto data_vector() && -> auto&&
    {
        return std::move(this->data_);
    }
    const void* identifier() const
    {
        return this->data_.identifier();
    }
    auto begin() { return this->data_.begin(); }
    auto end() { return this->data_.end(); }
    auto begin() const { return this->data_.begin(); }
    auto end() const { return this->data_.end(); }
    template<size_t Level>
    auto view_begin()
    {
        static_assert(Level <= R, WL_ERROR_INTERNAL);
        if constexpr (Level == R)
            return this->begin();
        else
            return simple_view<T, R, R - Level, false>(
                this->identifier(), this->data(), this->dims_ptr() + Level);
    }
    template<size_t Level>
    auto view_end()
    {
        if constexpr (Level == R)
            return this->end();
        else
        {
            auto iter = this->template view_begin<Level>();
            iter.apply_pointer_offset(this->size());
            return iter;
        }
    }
    template<size_t Level>
    auto view_begin() const
    {
        static_assert(Level <= R, WL_ERROR_INTERNAL);
        if constexpr (Level == R)
            return this->begin();
        else
            return simple_view<T, R, R - Level, true>(
                this->identifier(), this->data(), this->dims_ptr() + Level);
    }
    template<size_t Level>
    auto view_end() const
    {
        if constexpr (Level == R)
            return this->end();
        else
        {
            auto iter = this->template view_begin<Level>();
            iter.apply_pointer_offset(this->size());
            return iter;
        }
    }
    void uninitialized_resize(const _dims_t& new_dims, size_t new_size)
    {
        assert(utils::size_of_dims(new_dims) == new_size);
        this->dims_ = new_dims;
        this->data_.resize(new_size);
    }
    void uninitialized_resize(const _dims_t& new_dims)
    {
        this->dims_ = new_dims;
        this->data_.resize(utils::size_of_dims(this->dims_));
    }
    template<typename X>
    void _append_scalar(X&& x)
    {
        size_t prev_size = this->size();
        this->data_.resize(prev_size + 1u);
        *(this->data_.data() + prev_size) = std::forward<decltype(x)>(x);
        ++this->dims_[0];
    }
    template<typename X>
    void _append_array(X&& x)
    {
        if (this->size() == 0u)
        {
            using XV = value_type_t<remove_cvref_t<X>>;
            this->dims_ = utils::dims_join(
                std::array<size_t, 1u>{1u}, x.dims());
            if constexpr (is_movable_v<X&&> && std::is_same_v<XV, T>)
                this->data_ = std::move(std::move(x).data_vector());
            else
            {
                this->data_.resize(x.size());
                x.copy_to(this->data_.data());
            }
        }
        else
        {
            size_t prev_size = this->size();
            this->data_.resize(prev_size + x.size());
            auto dst_ptr = this->data_.data() + prev_size;
            x.copy_to(dst_ptr);
            ++this->dims_[0];
        }
    }
    template<typename X>
    void append(X&& x, dim_checked)
    {
        if constexpr (R > 1u)
            _append_array(std::forward<decltype(x)>(x));
        else
            _append_scalar(std::forward<decltype(x)>(x));
    }
    template<typename X>
    void append(X&& x)
    {
        static_assert(array_rank_v<remove_cvref_t<X>> + 1u == R,
            WL_ERROR_APPEND_RANK);
        if constexpr (R > 1u)
        {
            if (this->size() > 0u && !utils::check_dims<R - 1u>(
                this->dims_ptr() + 1, x.dims().data()))
                throw std::logic_error(WL_ERROR_INTERNAL);
        }
        this->append(std::forward<decltype(x)>(x), dim_checked{});
    }
    template<typename... Is>
    size_t linear_position(const Is&... is) const
    {
        return utils::linear_position(this->dims_, is...);
    }
    template<typename Function, typename... Iters>
    void for_each(Function f, Iters... iters)
    {
        auto ptr = this->data();
        const auto size = this->size();
        if constexpr (std::is_same_v<bool, decltype(f(*ptr, *iters...))>)
        {
            bool continue_flag = true;
            for (size_t i = 0u; i < size && continue_flag; ++i)
                continue_flag = !f(ptr[i], iters[i]...);
        }
        else
        {
            for (size_t i = 0u; i < size; ++i)
                f(ptr[i], iters[i]...);
        }
    }
    template<typename Function, typename... Iters>
    void for_each(Function f, Iters... iters) const
    {
        auto ptr = this->data();
        const auto size = this->size();
        if constexpr (std::is_same_v<bool, decltype(f(*ptr, *iters...))>)
        {
            bool continue_flag = true;
            for (size_t i = 0u; i < size && continue_flag; ++i)
                continue_flag = !f(ptr[i], iters[i]...);
        }
        else
        {
            for (size_t i = 0u; i < size; ++i)
                f(ptr[i], iters[i]...);
        }
    }
    template<typename FwdIter>
    void copy_to(FwdIter iter) const
    {
        auto ptr = this->data();
        const auto size = this->size();
        for (size_t i = 0u; i < size; ++i)
            iter[i] = ptr[i];
    }
    template<typename FwdIter>
    void copy_from(FwdIter iter) &
    {
        auto ptr = this->data();
        const auto size = this->size();
        for (size_t i = 0u; i < size; ++i)
            ptr[i] = iter[i];
    }
    template<typename FwdIter>
    void copy_from(FwdIter) && = delete;
    auto to_array() const & -> decltype(auto)
    {
        return *this;
    }
    auto to_array() && -> decltype(auto)
    {
        return std::move(*this);
    }
};
}
namespace wl
{
namespace utils
{
template<typename Fn, typename X>
auto listable_function(Fn fn, X&& x)
{
    using XT = remove_cvref_t<X>;
    constexpr auto x_rank = array_rank_v<XT>;
    if constexpr (x_rank == 0)
    {
        return fn(x);
    }
    else
    {
        using XV = typename XT::value_type;
        using RV = decltype(fn(XV{}));
        if constexpr (is_movable_v<X&&> && std::is_same_v<RV, XV>)
        {
            x.for_each([=](auto& a) { a = fn(a); });
            return std::move(x);
        }
        else
        {
            ndarray<RV, x_rank> ret(x.dims());
            x.for_each([=](const auto& a, auto& r) { r = fn(a); },
                ret.begin());
            return ret;
        }
    }
}
template<typename Fn, typename X, typename Y>
auto listable_function(Fn fn, X&& x, Y&& y)
{
    using XT = remove_cvref_t<X>;
    using YT = remove_cvref_t<Y>;
    constexpr auto x_rank = array_rank_v<XT>;
    constexpr auto y_rank = array_rank_v<YT>;
    if constexpr (x_rank == 0 && y_rank == 0)
    {
        return fn(x, y);
    }
    else if constexpr (x_rank == 0 && y_rank >= 1)
    {
        using YV = typename YT::value_type;
        using RV = decltype(fn(x, YV{}));
        if constexpr (is_movable_v<Y&&> && std::is_same_v<RV, YV>)
        {
            y.for_each([=](auto& b) { b = fn(x, b); });
            return std::move(y);
        }
        else
        {
            ndarray<RV, y_rank> ret(y.dims());
            y.for_each([=](const auto& b, auto& r) { r = fn(x, b); },
                ret.begin());
            return ret;
        }
    }
    else if constexpr (x_rank >= 1 && y_rank == 0)
    {
        using XV = typename XT::value_type;
        using RV = decltype(fn(XV{}, y));
        if constexpr (is_movable_v<X&&> && std::is_same_v<RV, XV>)
        {
            x.for_each([=](auto& a) { a = fn(a, y); });
            return std::move(x);
        }
        else
        {
            ndarray<RV, x_rank> ret(x.dims());
            x.for_each([=](const auto& a, auto& r) { r = fn(a, y); },
                ret.begin());
            return ret;
        }
    }
    else
    {
        static_assert(x_rank == y_rank, WL_ERROR_OPERAND_RANK);
        if (!utils::check_dims(x.dims(), y.dims()))
            throw std::logic_error(WL_ERROR_OPERAND_DIMS);
        using XV = typename XT::value_type;
        using YV = typename YT::value_type;
        using RV = decltype(fn(XV{}, YV{}));
        if constexpr (is_movable_v<X&&> && std::is_same_v<XV, RV>)
        {
            y.for_each([=](const auto& b, auto& a) { a = fn(a, b); },
                x.begin());
            return std::move(x);
        }
        else if constexpr (XT::category == view_category::General)
        {
            if constexpr (is_movable_v<Y&&> && std::is_same_v<YV, RV>)
            {
                x.for_each([=](const auto& a, auto& b) { b = fn(a, b); },
                    y.begin());
                return std::move(y);
            }
            else if constexpr (YT::category == view_category::General)
            {
                if constexpr (std::is_same_v<XV, RV>)
                    return _listable_numerical_function(fn,
                        x.to_array(), std::forward<decltype(y)>(y));
                else
                    return _listable_numerical_function(fn,
                        std::forward<decltype(x)>(x), y.to_array());
            }
            else
            {
                ndarray<RV, x_rank> ret(x.dims());
                x.for_each([=](const auto& a, const auto& b, auto& r)
                    { r = fn(a, b); },
                    y.begin(), ret.begin());
                return ret;
            }
        }
        else
        {
            if constexpr (is_movable_v<Y&&>&& std::is_same_v<YV, RV>)
            {
                x.for_each([=](const auto& a, auto& b) { b = fn(a, b); },
                    y.begin());
                return std::move(y);
            }
            else
            {
                ndarray<RV, x_rank> ret(x.dims());
                y.for_each([=](const auto& b, const auto& a, auto& r)
                    { r = fn(a, b); },
                    x.begin(), ret.begin());
                return ret;
            }
        }
    }
}
#define WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_VARIADIC(name)          \
template<typename Iter, bool HasStride>                             \
auto _variadic_##name(const argument_pack<Iter, HasStride>& args)   \
{                                                                   \
    auto ret = val(args.get(0));                                    \
    WL_CHECK_ABORT_LOOP_BEGIN(args.size() - 1u)                     \
        for (auto i = _loop_begin; i < _loop_end; ++i)              \
            ret = name(std::move(ret),                              \
                args.get(i + 1, dim_checked{}));                    \
    WL_CHECK_ABORT_LOOP_END()                                       \
    return ret;                                                     \
}
#define WL_VARIADIC_FUNCTION_DEFAULT_IF_PARAMETER_PACK(name)        \
if constexpr (is_argument_pack_v<remove_cvref_t<Y>>)                \
{                                                                   \
    if (y.size() == 0u)                                             \
        return std::forward<decltype(x)>(x);                        \
    else                                                            \
        return name(std::forward<decltype(x)>(x),                   \
            _variadic_##name(y));                                   \
}                                                                   \
else if constexpr (is_argument_pack_v<remove_cvref_t<X>>)           \
{                                                                   \
    if (x.size() == 0u)                                             \
        return std::forward<decltype(y)>(y);                        \
    else                                                            \
        return name(_variadic_##name(x),                            \
            std::forward<decltype(y)>(y));                          \
}                                                                   \
else
#define WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(name, expr)     \
constexpr auto name()                                               \
{                                                                   \
    return expr;                                                    \
}
#define WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(name)             \
template<typename X>                                                \
auto name(X&& x)                                                    \
{                                                                   \
    if constexpr (is_argument_pack_v<remove_cvref_t<X>>)            \
    {                                                               \
        using ArgType = remove_cvref_t<decltype(x.get(0))>;         \
        if constexpr (is_convertible_v<                             \
            remove_cvref_t<decltype(name())>,                       \
            remove_cvref_t<decltype(_variadic_##name(x))>>)         \
        {                                                           \
            if (x.size() == 0u)                                     \
                return cast<remove_cvref_t<                         \
                    decltype(_variadic_##name(x))>>(name());        \
            else                                                    \
                return _variadic_##name(x);                         \
        }                                                           \
        else                                                        \
        {                                                           \
            if (x.size() == 0u)                                     \
                throw std::logic_error(WL_ERROR_EMPTY_PACK);        \
            else                                                    \
                return _variadic_##name(x);                         \
        }                                                           \
    }                                                               \
    else                                                            \
        return std::forward<decltype(x)>(x);                        \
}
#define WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(name)              \
template<typename X1, typename X2, typename X3, typename... Xs>     \
auto name(X1&& x1, X2&& x2, X3&& x3, Xs&&... xs)                    \
{                                                                   \
    return name(name(std::forward<decltype(x1)>(x1),                \
        std::forward<decltype(x2)>(x2)),                            \
        std::forward<decltype(x3)>(x3),                             \
        std::forward<decltype(xs)>(xs)...);                         \
}
}
}
namespace wl
{
template<typename X>
auto n(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    using XV = std::conditional_t<XR == 0u, XT, value_type_t<XT>>;
    if constexpr (!is_integral_v<XV>)
        return std::forward<decltype(x)>(x);
    else
        return utils::listable_function(
            [](const auto& a) { return double(a); },
            std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
#define WL_DEFINE_ROUNDING_FUNCTION(name, stdname)                      \
template<typename X>                                                    \
auto name(X&& x)                                                        \
{                                                                       \
    WL_TRY_BEGIN()                                                      \
    using XT = remove_cvref_t<X>;                                       \
    constexpr auto XR = array_rank_v<XT>;                               \
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);      \
    using XV = std::conditional_t<(XR == 0u), XT, value_type_t<XT>>;    \
    if constexpr (is_integral_v<XV>)                                    \
        return std::forward<decltype(x)>(x);                            \
    else                                                                \
    {                                                                   \
        auto pure = [](const auto& x)                                   \
        {                                                               \
            if constexpr (is_float_v<XV>)                               \
                return int64_t(std::stdname(x));                        \
            else                                                        \
                return complex<value_type_t<XV>>(                       \
                    std::stdname(std::real(x)),                         \
                    std::stdname(std::imag(x)));                        \
        };                                                              \
        return utils::listable_function(pure,                           \
            std::forward<decltype(x)>(x));                              \
    }                                                                   \
    WL_TRY_END(__func__, __FILE__, __LINE__)                            \
}
WL_DEFINE_ROUNDING_FUNCTION(round, round)
WL_DEFINE_ROUNDING_FUNCTION(ceiling, ceil)
WL_DEFINE_ROUNDING_FUNCTION(floor, floor)
WL_DEFINE_ROUNDING_FUNCTION(integer_part, trunc)
template<typename X>
auto fractional_part(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    using XV = std::conditional_t<XR == 0u, XT, value_type_t<XT>>;
    auto pure = [](const auto& x)
    {
        if constexpr (is_integral_v<XV>)
            return double(0);
        else if constexpr (is_float_v<XV>)
            return x - std::trunc(x);
        else
            return XV(std::real(x) - std::trunc(std::real(x)),
                std::imag(x) - std::trunc(std::imag(x)));
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto abs(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    using XV = std::conditional_t<XR == 0u, XT, value_type_t<XT>>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    if constexpr (std::is_unsigned_v<XV>)
        return std::forward<decltype(x)>(x);
    else
        return utils::listable_function([](auto x) { return std::abs(x); },
            std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto ramp(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    using XV = std::conditional_t<XR == 0u, XT, value_type_t<XT>>;
    if constexpr (std::is_unsigned_v<XV>)
        return std::forward<decltype(x)>(x);
    else
    {
        auto pure = [](const auto& x)
        {
            return x >= XV(0) ? x : XV(0);
        };
        return utils::listable_function(pure, std::forward<decltype(x)>(x));
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
boolean greater(const X& x, const Y& y)
{
    static_assert(is_real_v<X> && is_real_v<Y>, WL_ERROR_BAD_COMPARE);
    return boolean(x > y);
}
template<typename X, typename Y>
boolean less(const X& x, const Y& y)
{
    static_assert(is_real_v<X> && is_real_v<Y>, WL_ERROR_BAD_COMPARE);
    return boolean(x < y);
}
template<typename X, typename Y>
boolean greater_equal(const X& x, const Y& y)
{
    static_assert(is_real_v<X> && is_real_v<Y>, WL_ERROR_BAD_COMPARE);
    return boolean(x >= y);
}
template<typename X, typename Y>
boolean less_equal(const X& x, const Y& y)
{
    static_assert(is_real_v<X> && is_real_v<Y>, WL_ERROR_BAD_COMPARE);
    return boolean(x <= y);
}
template<bool DimChecked, typename X, typename Y>
boolean _equal_impl(const X& x, const Y& y)
{
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(XR == YR, WL_ERROR_OPERAND_RANK);
    if constexpr (XR == 0u)
    {
        static_assert((is_arithmetic_v<X> && is_arithmetic_v<X>) ||
            (is_value_type_v<X> && std::is_same_v<X, Y>),
            WL_ERROR_BAD_COMPARE);
        if constexpr (is_complex_v<X>)
            return boolean(x == cast<X>(y));
        else if constexpr (is_complex_v<Y>)
            return boolean(cast<Y>(x) == y);
        else
            return boolean(x == y);
    }
    else
    {
        if constexpr (!DimChecked)
            if (!utils::check_dims(x.dims(), y.dims()))
                return const_false;
        if constexpr (X::category != view_category::General)
        {
            auto equal_flag = true;
            y.for_each([&](const auto& a, const auto& b)
                {
                    equal_flag = _equal_impl<true>(a, b);
                    return !equal_flag;
                }, x.begin());
            return boolean(equal_flag);
        }
        else if constexpr (Y::category != view_category::General)
        {
            return _equal_impl<true>(y, x);
        }
        else
        {
            if constexpr (sizeof(value_type_t<X>) < sizeof(value_type_t<Y>))
                return _equal_impl<true>(x.to_array(), y);
            else
                return _equal_impl<true>(x, y.to_array());
        }
    }
}
template<typename X, typename Y>
boolean equal(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    return _equal_impl<false>(x, y);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
boolean equal(const X& x, const Y& y, dim_checked)
{
    WL_TRY_BEGIN()
    return _equal_impl<true>(x, y);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
boolean unequal(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    return !equal(x, y);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
boolean unequal(const X& x, const Y& y, dim_checked)
{
    WL_TRY_BEGIN()
    return !equal(x, y, dim_checked{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y, typename... DimChecked>
boolean same_q(const X& x, const Y& y, DimChecked...)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    constexpr auto same_type = (XR == 0u) ? std::is_same_v<X, Y> :
        std::is_same_v<value_type_t<X>, value_type_t<Y>>;
    if constexpr (XR == YR && same_type)
        return equal(x, y, DimChecked{}...);
    else
        return const_false;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y, typename... DimChecked>
boolean unsame_q(const X& x, const Y& y, DimChecked...)
{
    WL_TRY_BEGIN()
    return !same_q(x, y, DimChecked{}...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto mod(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>> &&
        is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x, const auto& y)
    {
        using XV = remove_cvref_t<decltype(x)>;
        using YV = remove_cvref_t<decltype(y)>;
        static_assert(is_real_v<XV> && is_real_v<YV>, WL_ERROR_REAL_TYPE_ARG);
        if constexpr (is_integral_v<XV> && is_integral_v<YV>)
        {
            using C = std::conditional_t<
                std::is_signed_v<XV> || std::is_signed_v<YV>,
                make_signed_t<common_type_t<XV, YV>>,
                common_type_t<XV, YV>>;
            if (y == 0)
                return C(0);
            else
            {
                auto xi = C(x);
                auto yi = C(y);
                auto rem = xi % yi;
                if constexpr (std::is_unsigned_v<C>)
                    return rem;
                else if (rem == C(0))
                    return rem;
                else
                    return rem + (yi & ((xi ^ yi) >> (8u * sizeof(C) - 1u)));
            }
        }
        else
        {
            using C = common_type_t<XV, YV>;
            auto cx = C(x);
            auto cy = C(y);
            return cx - std::floor(cx / cy) * cy;
        }
    };
    return utils::listable_function(pure,
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto quotient(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>> &&
        is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x, const auto& y)
    {
        using XV = remove_cvref_t<decltype(x)>;
        using YV = remove_cvref_t<decltype(y)>;
        static_assert(is_real_v<XV> && is_real_v<YV>, WL_ERROR_REAL_TYPE_ARG);
        if constexpr (is_integral_v<XV> && is_integral_v<YV>)
        {
            using C = std::conditional_t<
                std::is_signed_v<XV> || std::is_signed_v<YV>,
                make_signed_t<common_type_t<XV, YV>>,
                common_type_t<XV, YV>>;
            if (y == 0)
                return C(0);
            else
            {
                auto xi = C(x);
                auto yi = C(y);
                auto rem = xi % yi;
                auto quot = xi / yi;
                if constexpr (std::is_unsigned_v<C>)
                    return quot;
                else if (rem == C(0))
                    return quot;
                else
                    return quot + ((xi ^ yi) >> (8u * sizeof(C) - 1u));
            }
        }
        else
        {
            using C = common_type_t<XV, YV>;
            auto cx = C(x);
            auto cy = C(y);
            return std::floor(cx / cy);
        }
    };
    return utils::listable_function(pure,
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto sign(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    static_assert(is_arithmetic_v<Ret>, WL_ERROR_BAD_RETURN);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_complex_v<XV>)
            return x / std::abs(x);
        else if (x == XV(0))
            return Ret(0);
        else if (x > XV(0))
            return Ret(1);
        else
            return Ret(-1);
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X, typename Y, typename N>
auto integer_digits(const X& x, const Y& y, const N& n)
{
    WL_TRY_BEGIN()
    static_assert(is_integral_v<X> && is_integral_v<Y>,
        WL_ERROR_INTEGRAL_TYPE_ARG);
    static_assert(is_arithmetic_v<Ret>, WL_ERROR_BAD_RETURN);
    constexpr auto fixed_length = !std::is_same_v<N, void_type>;
    if (y < Y(0)) throw std::logic_error(WL_ERROR_INTEGER_DIGITS_NEGATIVE);
    auto ux = (x >= X(0)) ? uint64_t(x) : uint64_t(-x);
    auto uy = uint64_t(y);
    ndarray<Ret, 1u> ret;
    if constexpr (fixed_length)
    {
        static_assert(is_integral_v<N>, WL_ERROR_COUNTING_ARG);
        if (n < N(0)) throw std::logic_error(WL_ERROR_INTEGER_DIGITS_NEGATIVE);
        ret.uninitialized_resize(std::array<size_t, 1u>{size_t(n)}, size_t(n));
        auto ret_begin = ret.data();
        auto ret_end = ret_begin + size_t(n);
        auto ret_iter = ret_begin;
        for (;;)
        {
            uint64_t rem = ux % uy;
            ux = ux / uy;
            *ret_iter = Ret(rem);
            ++ret_iter;
            if (ux == 0u)
            {
                for (; ret_iter < ret_end; ++ret_iter)
                    *ret_iter = Ret(0);
                break;
            }
        }
        std::reverse(ret_begin, ret_end);
    }
    else if (ux == 0u)
        ret.append(Ret(0));
    else
    {
        for (;;)
        {
            uint64_t rem = ux % uy;
            ux = ux / uy;
            ret.append(Ret(rem));
            if (ux == 0u)
                break;
        }
        auto ret_begin = ret.data();
        auto ret_end = ret_begin + ret.size();
        std::reverse(ret_begin, ret_end);
    }
    return ret;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X, typename Y>
auto integer_digits(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    return integer_digits<Ret>(x, y, const_null);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto integer_digits(const X& x)
{
    WL_TRY_BEGIN()
    return integer_digits<Ret>(x, uint64_t(10), const_null);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto positive(const X& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<X>, WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        return boolean(x > XV(0));
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto negative(const X& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<X>, WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        return boolean(x < XV(0));
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto non_positive(const X& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<X>, WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        return boolean(x <= XV(0));
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto non_negative(const X& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<X>, WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        return boolean(x >= XV(0));
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename L>
auto clip(X&& x, const L& limit)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<L> == 1u, WL_ERROR_REQUIRE_ARRAY_RANK"one.");
    if (limit.size() != 2u) throw std::logic_error(WL_ERROR_CLIP_LIMIT_SIZE);
    std::array<value_type_t<L>, 2u> limit_pair;
    limit.copy_to(limit_pair.data());
    return clip(std::forward<decltype(x)>(x), varg_tag{},
        limit_pair[0], limit_pair[1]);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename L, typename VL>
auto clip(X&& x, const L& limit, const VL& vlimit)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<L> == 1u, WL_ERROR_REQUIRE_ARRAY_RANK"one.");
    static_assert(array_rank_v<VL> == 1u, WL_ERROR_REQUIRE_ARRAY_RANK"one.");
    if (limit.size() != 2u) throw std::logic_error(WL_ERROR_CLIP_LIMIT_SIZE);
    if (vlimit.size() != 2u) throw std::logic_error(WL_ERROR_CLIP_LIMIT_SIZE);
    std::array<value_type_t<L>, 2u> limit_pair;
    std::array<value_type_t<VL>, 2u> vlimit_pair;
    limit.copy_to(limit_pair.data());
    vlimit.copy_to(vlimit_pair.data());
    return clip(std::forward<decltype(x)>(x), varg_tag{},
        limit_pair[0], limit_pair[1], vlimit_pair[0], vlimit_pair[1]);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto clip(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        if (x < XV(0))
            return XV(0);
        else if (x > XV(1))
            return XV(1);
        else
            return x;
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Min, typename Max>
auto clip(X&& x, varg_tag, Min min, Max max)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    static_assert(is_real_v<Min> && is_real_v<Max>, WL_ERROR_REAL_TYPE_ARG);
    using C = common_type_t<value_type<XT>, Min, Max>;
    const auto cmin = cast<C>(min);
    const auto cmax = cast<C>(max);
    auto pure = [=](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        auto cx = cast<C>(x);
        if (cx < cmin)
            return cmin;
        else if (cx > cmax)
            return cmax;
        else
            return cx;
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Min, typename Max, typename VMin, typename VMax>
auto clip(X&& x, varg_tag, Min min, Max max, VMin vmin, VMax vmax)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    static_assert(is_real_v<Min> && is_real_v<Max>, WL_ERROR_REAL_TYPE_ARG);
    static_assert(is_real_v<VMin> && is_real_v<VMax>, WL_ERROR_REAL_TYPE_ARG);
    using C = common_type_t<value_type_t<XT>, Min, Max, VMin, VMax>;
    const auto cmin = cast<C>(min);
    const auto cmax = cast<C>(max);
    const auto cvmin = cast<C>(vmin);
    const auto cvmax = cast<C>(vmax);
    auto pure = [=](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        auto cx = cast<C>(x);
        if (cx < cmin)
            return cvmin;
        else if (cx > cmax)
            return cvmax;
        else
            return cx;
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto unitize(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    static_assert(is_arithmetic_v<Ret>, WL_ERROR_BAD_RETURN);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        return Ret(int8_t(x != XV(0)));
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto unit_step(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    static_assert(is_arithmetic_v<Ret>, WL_ERROR_BAD_RETURN);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        if (x >= XV(0))
            return Ret(1);
        else
            return Ret(0);
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
constexpr auto min()
{
    return const_real_infinity;
}
template<typename X>
auto min(const X& x)
{
    WL_TRY_BEGIN()
    if constexpr (is_argument_pack_v<X>)
    {
        using XV = value_type_t<value_type_t<X>>;
        const auto pack_size = x.size();
        auto ret = std::numeric_limits<XV>::max();
        WL_CHECK_ABORT_LOOP_BEGIN(x.size())
            for (auto i = _loop_begin; i < _loop_end; ++i)
                ret = std::min(ret, min(x.get(i, dim_checked{})));
        WL_CHECK_ABORT_LOOP_END()
        return ret;
    }
    else if constexpr (array_rank_v<X> == 0u)
    {
        static_assert(is_real_v<X>, WL_ERROR_REAL_TYPE_ARG);
        return x;
    }
    else
    {
        using XV = value_type_t<X>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        auto ret = std::numeric_limits<XV>::max();
        x.for_each([&](const auto& a) { ret = std::min(ret, a); });
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X1, typename X2, typename... Xs>
auto min(const X1& x1, const X2& x2, const Xs&... xs)
{
    WL_TRY_BEGIN()
    using MinType1 = decltype(min(x1));
    using MinType2 = decltype(min(x2));
    using LimitType = common_type_t<MinType1, MinType2, uint64_t>;
    constexpr auto signed1 =
        std::is_signed_v<MinType1> && std::is_unsigned_v<MinType2>;
    constexpr auto signed2 =
        std::is_signed_v<MinType2> && std::is_unsigned_v<MinType1>;
    constexpr auto high1 = LimitType(std::numeric_limits<MinType1>::max());
    constexpr auto high2 = LimitType(std::numeric_limits<MinType2>::max());
    using RT =
        std::conditional_t<signed1, MinType1,
        std::conditional_t<signed2, MinType2,
        std::conditional_t<(high1 > high2), MinType1, MinType2>>>;
    if constexpr (signed1)
    {
        auto min1 = min(x1);
        if (min1 <= MinType1(0))
            return min(RT(min1), xs...);
        else
        {
            auto min2 = min(x2);
            if (LimitType(min2) > LimitType(high1))
                return min(RT(min1), xs...);
            else
                return min((RT(min1) < RT(min2)) ? RT(min1) : RT(min2), xs...);
        }
    }
    else if constexpr (signed2)
        return min(x2, x1, xs...);
    else
    {
        auto min1 = min(x1);
        auto min2 = min(x2);
        return min((RT(min1) < RT(min2)) ? RT(min1) : RT(min2), xs...);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
constexpr auto max()
{
    return -const_real_infinity;
}
template<typename X>
auto max(const X& x)
{
    WL_TRY_BEGIN()
    if constexpr (is_argument_pack_v<X>)
    {
        using XV = value_type_t<value_type_t<X>>;
        auto ret = std::numeric_limits<XV>::min();
        WL_CHECK_ABORT_LOOP_BEGIN(x.size())
            for (auto i = _loop_begin; i < _loop_end; ++i)
                ret = std::max(ret, max(x.get(i, dim_checked{})));
        WL_CHECK_ABORT_LOOP_END()
        return ret;
    }
    else if constexpr (array_rank_v<X> == 0u)
    {
        static_assert(is_real_v<X>, WL_ERROR_REAL_TYPE_ARG);
        return x;
    }
    else
    {
        using XV = value_type_t<X>;
        static_assert(is_real_v<XV>, WL_ERROR_REAL_TYPE_ARG);
        auto ret = std::numeric_limits<XV>::min();
        x.for_each([&](const auto& a) { ret = std::max(ret, a); });
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X1, typename X2, typename... Xs>
auto max(const X1& x1, const X2& x2, const Xs&... xs)
{
    WL_TRY_BEGIN()
    using MaxType1 = decltype(max(x1));
    using MaxType2 = decltype(max(x2));
    using LimitType = common_type_t<MaxType1, MaxType2, uint64_t>;
    constexpr auto high1 = LimitType(std::numeric_limits<MaxType1>::max());
    constexpr auto high2 = LimitType(std::numeric_limits<MaxType2>::max());
    using RT = std::conditional_t<(high1 > high2), MaxType1, MaxType2>;
    if constexpr (high1 < high2)
    {
        auto max2 = max(x2);
        if (LimitType(max2) > LimitType(high1))
            return max(RT(max2), xs...);
        else
        {
            auto max1 = max(x1);
            if (std::is_signed_v<MaxType1> && max1 <= MaxType1(0))
                return max(RT(max2), xs...);
            else
                return max((RT(max1) > RT(max2)) ? RT(max1) : RT(max2), xs...);
        }
    }
    else if constexpr (high1 > high2)
        return max(x2, x1, xs...);
    else
    {
        auto max1 = max(x1);
        auto max2 = max(x2);
        return max((RT(max1) > RT(max2)) ? RT(max1) : RT(max2), xs...);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto chop(X&& x, const Y& y)
{
    WL_TRY_BEGIN()
    static_assert(is_real_v<Y>, WL_ERROR_REAL_TYPE_ARG);
    using XT = remove_cvref_t<X>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    constexpr auto XR = array_rank_v<XT>;
    using XV = std::conditional_t<XR == 0u, XT, value_type_t<XT>>;
    if constexpr (is_integral_v<XV>)
        return std::forward<decltype(x)>(x);
    else
    {
        auto pure = [lim = cast<value_type_t<XV>>(y)](const auto& x)
        {
            if constexpr (is_real_v<XV>)
                return std::abs(x) < lim ? XV(0) : x;
            else
            {
                using T = value_type_t<XV>;
                T re = std::real(x);
                T im = std::imag(x);
                re = std::abs(re) < lim ? T(0) : re;
                im = std::abs(im) < lim ? T(0) : im;
                return complex<T>(re, im);
            }
        };
        return utils::listable_function(pure, std::forward<decltype(x)>(x));
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
template<typename T, bool HasVariable>
struct step_iterator
{
    static constexpr bool has_variable = HasVariable;
    using value_type = T;
    T begin_;
    T step_;
    size_t length_;
    step_iterator(T begin, T step, size_t length) :
        begin_{begin}, step_{step}, length_{length}
    {
    }
    size_t length() const
    {
        return length_;
    }
    auto operator[](size_t i) const
    {
        return T(begin_ + step_ * i);
    }
};
template<typename Array>
struct list_iterator
{
    static constexpr bool has_variable = true;
    using Iter = remove_cvref_t<decltype(
        std::declval<Array>().template view_begin<1u>())>;
    using value_type = decltype(*std::declval<Iter>());
    Array values_;
    Iter iter_;
    list_iterator(Array&& values) :
        values_{std::move(values)}, iter_{values_.template view_begin<1u>()}
    {
    }
    list_iterator(const Array& values) :
        values_{values}, iter_{values_.template view_begin<1u>()}
    {
    }
    size_t length() const
    {
        return values_.dims()[0];
    }
    auto operator[](size_t i) const
    {
        return *(iter_ + i);
    }
};
template<bool HasVariable, typename Begin, typename End, typename Step>
auto make_step_iterator(Begin begin, End end, Step step)
{
    static_assert(is_real_v<Begin> && is_real_v<End> && is_real_v<Step>,
        WL_ERROR_ITERATOR_TYPE);
    using T = common_type_t<Begin, Step>;
    if (step == Step(0))
        throw std::logic_error(WL_ERROR_ITERATOR_ZERO_STEP);
    if constexpr (is_integral_v<T>)
    {
        auto diff = ptrdiff_t(wl::integer_part(end - begin));
        if ((step > Step(0) && diff < 0) || (step < Step(0) && diff > 0))
            return step_iterator<T, HasVariable>(begin, step, 0u);
        else
            return step_iterator<T, HasVariable>(begin, step,
                size_t(diff / ptrdiff_t(step)) + 1u);
    }
    else
    {
        auto diff = T(end - begin);
        if ((step > Step(0) && diff < 0) || (step < Step(0) && diff > 0))
            return step_iterator<T, HasVariable>(begin, step, 0u);
        else
        {
            size_t length = wl::integer_part(diff / step) + 1u;
            auto remain = T(begin + (length - 1u) * step) - T(end);
            if (step * remain > T(0))
                --length;
            return step_iterator<T, HasVariable>(begin, step, length);
        }
    }
}
template<typename Begin, typename End, typename Step>
auto var_iterator(Begin begin, End end, Step step)
{
    WL_TRY_BEGIN()
    return make_step_iterator<true>(begin, end, step);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Begin, typename End>
auto var_iterator(Begin begin, End end)
{
    WL_TRY_BEGIN()
    return make_step_iterator<true>(begin, end, int8_t(1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Begin, typename End>
auto var_iterator(End end)
{
    WL_TRY_BEGIN()
    return make_step_iterator<true>(int8_t(1), end, int8_t(1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Any>
auto var_iterator(Any&& any)
{
    WL_TRY_BEGIN()
    using Type = remove_cvref_t<Any>;
    if constexpr (array_rank_v<Type> == 0u)
    {
        if constexpr (is_integral_v<Type>)
            return make_step_iterator<true>(Type(1), any, Type(1));
        else
            return make_step_iterator<true>(int64_t(1), any, int64_t(1));
    }
    else
    {
        if constexpr (is_movable_v<Any&&>)
            return list_iterator<Type>(std::move(any));
        else
        {
            auto copy = allows<view_category::Array>(
                std::forward<decltype(any)>(any));
            return list_iterator<decltype(copy)>(std::move(copy));
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Any>
auto iterator(Any&& any)
{
    WL_TRY_BEGIN()
    return make_step_iterator<false>(int8_t(1), any, int8_t(1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
constexpr auto _scalar_plus = [](const auto& x, const auto& y)
{
    using XT = remove_cvref_t<decltype(x)>;
    using YT = remove_cvref_t<decltype(y)>;
    using XV = value_type_t<XT>;
    using YV = value_type_t<YT>;
    using C = common_type_t<XV, YV>;
    if constexpr (is_complex_v<XT>)
    {
        if constexpr (is_complex_v<YT>)
            return complex<C>(std::real(x) + std::real(y),
                std::imag(x) + std::imag(y));
        else
            return complex<C>(std::real(x) + cast<C>(y), std::imag(x));
    }
    else
    {
        if constexpr (is_complex_v<YT>)
            return complex<C>(cast<C>(x) + std::real(y), std::imag(y));
        else
            return cast<C>(cast<C>(x) + cast<C>(y));
    }
};
constexpr auto _scalar_subtract = [](const auto& x, const auto& y)
{
    using XT = remove_cvref_t<decltype(x)>;
    using YT = remove_cvref_t<decltype(y)>;
    using XV = value_type_t<XT>;
    using YV = value_type_t<YT>;
    using C = common_type_t<XV, YV>;
    if constexpr (is_complex_v<XT>)
    {
        if constexpr (is_complex_v<YT>)
            return complex<C>(std::real(x) - std::real(y),
                std::imag(x) - std::imag(y));
        else
            return complex<C>(std::real(x) - cast<C>(y), std::imag(x));
    }
    else
    {
        if constexpr (is_complex_v<YT>)
            return complex<C>(cast<C>(x) - std::real(y), -std::imag(y));
        else
            return cast<C>(cast<C>(x) - cast<C>(y));
    }
};
constexpr auto _scalar_times = [](const auto& x, const auto& y)
{
    using XT = remove_cvref_t<decltype(x)>;
    using YT = remove_cvref_t<decltype(y)>;
    using XV = value_type_t<XT>;
    using YV = value_type_t<YT>;
    using C = common_type_t<XV, YV>;
    if constexpr (is_complex_v<XT>)
    {
        if constexpr (is_complex_v<YT>)
            return complex<C>(x) * complex<C>(y);
        else
            return complex<C>(std::real(x) * cast<C>(y),
                std::imag(x) * cast<C>(y));
    }
    else
    {
        if constexpr (is_complex_v<YT>)
            return complex<C>(cast<C>(x) * std::real(y),
                cast<C>(x) * std::imag(y));
        else
            return cast<C>(cast<C>(x) * cast<C>(y));
    }
};
constexpr auto _scalar_divide = [](const auto& x, const auto& y)
{
    using XT = remove_cvref_t<decltype(x)>;
    using YT = remove_cvref_t<decltype(y)>;
    using XV = value_type_t<XT>;
    using YV = value_type_t<YT>;
    using C = common_type_t<XV, YV>;
    if constexpr (is_complex_v<XT>)
    {
        if constexpr (is_complex_v<YT>)
            return complex<C>(x) / complex<C>(y);
        else
            return complex<C>(x) / cast<C>(y);
    }
    else
    {
        if constexpr (is_complex_v<YT>)
            return cast<C>(x) / complex<C>(y);
        else if constexpr (is_integral_v<XT>&& is_integral_v<YT>)
            return double(x) / double(y);
        else
            return cast<C>(x) / cast<C>(y);
    }
};
#define WL_DEFINE_MUTABLE_SCALAR_OPERATIONS(name, func)                 \
template<typename X, typename Y>                                        \
auto _scalar_##name(X& x, const Y& y)                                   \
{                                                                       \
    static_assert(is_convertible_v<common_type_t<X, Y>, X>,             \
        WL_ERROR_MUTABLE_TYPE);                                         \
    x = X(_scalar_##func(x, y));                                        \
    return x;                                                           \
}
WL_DEFINE_MUTABLE_SCALAR_OPERATIONS(add_to, plus)
WL_DEFINE_MUTABLE_SCALAR_OPERATIONS(subtract_from, subtract)
WL_DEFINE_MUTABLE_SCALAR_OPERATIONS(times_by, times)
WL_DEFINE_MUTABLE_SCALAR_OPERATIONS(divide_by, divide)
#define WL_DEFINE_MUTABLE_ARITHMETIC_FUNCTION(name)                         \
template<typename X, typename Y>                                            \
auto name(X&& x, Y&& y) -> decltype(auto)                                   \
{                                                                           \
    WL_TRY_BEGIN()                                                          \
    using XType = remove_cvref_t<X>;                                        \
    using YType = remove_cvref_t<Y>;                                        \
    constexpr auto x_rank = array_rank_v<XType>;                            \
    constexpr auto y_rank = array_rank_v<YType>;                            \
    static_assert(std::is_lvalue_reference_v<X&&> ||                        \
        is_array_view_v<XType>, WL_ERROR_MODIFY_TARGET);                    \
    if constexpr (x_rank > 0)                                               \
    {                                                                       \
        if constexpr (y_rank == 0)                                          \
        {                                                                   \
            x.for_each([y](auto& dst) { _scalar_##name(dst, y); });         \
        }                                                                   \
        else                                                                \
        {                                                                   \
            static_assert(x_rank == y_rank, WL_ERROR_OPERAND_RANK);         \
            if (!utils::check_dims<x_rank>(x.dims_ptr(), y.dims_ptr()))     \
                throw std::logic_error(WL_ERROR_ARITHMETIC_DIMS);           \
            if (has_aliasing(x, y))                                         \
            {                                                               \
                std::vector<value_type_t<YType>> buffer(y.size());          \
                y.copy_to(buffer.begin());                                  \
                x.for_each([](auto& dst, const auto& src)                   \
                    { _scalar_##name(dst, src); }, buffer.begin());         \
            }                                                               \
            else if constexpr (YType::category != view_category::General)   \
                x.for_each([](auto& dst, const auto& src)                   \
                    { _scalar_##name(dst, src); }, y.begin());              \
            else if constexpr (XType::category != view_category::General)   \
                y.for_each([](const auto& src, auto& dst)                   \
                    { _scalar_##name(dst, src); }, x.begin());              \
            else /* general_view ?= general_view */                         \
            {                                                               \
                std::vector<value_type_t<YType>> buffer(y.size());          \
                y.copy_to(buffer.begin());                                  \
                x.for_each([](auto& dst, const auto& src)                   \
                    { _scalar_##name(dst, src); }, buffer.begin());         \
            }                                                               \
        }                                                                   \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        static_assert(y_rank == 0, WL_ERROR_MUTABLE_RANK);                  \
        _scalar_##name(x, y);                                               \
    }                                                                       \
    return std::forward<decltype(x)>(x);                                    \
    WL_TRY_END(__func__, __FILE__, __LINE__)                                \
}
WL_DEFINE_MUTABLE_ARITHMETIC_FUNCTION(add_to)
WL_DEFINE_MUTABLE_ARITHMETIC_FUNCTION(subtract_from)
WL_DEFINE_MUTABLE_ARITHMETIC_FUNCTION(times_by)
WL_DEFINE_MUTABLE_ARITHMETIC_FUNCTION(divide_by)
template<typename X>
auto pre_increment(X&& x) -> decltype(auto)
{
    WL_TRY_BEGIN()
    return add_to(std::forward<decltype(x)>(x), int64_t(1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto pre_decrement(X&& x) -> decltype(auto)
{
    WL_TRY_BEGIN()
    return subtract_from(std::forward<decltype(x)>(x), int64_t(1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto increment(X&& x)
{
    WL_TRY_BEGIN()
    auto valx = val(x);
    pre_increment(std::forward<decltype(x)>(x));
    return valx;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto decrement(X&& x)
{
    WL_TRY_BEGIN()
    auto valx = val(x);
    pre_decrement(std::forward<decltype(x)>(x));
    return valx;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto minus(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    return utils::listable_function([](const auto& x) { return -x; },
        std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Iter, bool HasStride>
auto _variadic_plus(const argument_pack<Iter, HasStride>& args)
{
    auto ret = val(args.get(0));
    WL_CHECK_ABORT_LOOP_BEGIN(args.size() - 1u)
        for (auto i = _loop_begin; i < _loop_end; ++i)
            add_to(ret, args.get(i + 1, dim_checked{}));
    WL_CHECK_ABORT_LOOP_END()
    return ret;
}
template<typename X, typename Y>
auto plus(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    WL_VARIADIC_FUNCTION_DEFAULT_IF_PARAMETER_PACK(plus)
    {
        static_assert(is_numerical_type_v<remove_cvref_t<X>> &&
            is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);
        return utils::listable_function(_scalar_plus,
            std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(plus, int64_t(0))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(plus)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(plus)
template<typename X, typename Y>
auto subtract(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>> &&
        is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);
    return utils::listable_function(_scalar_subtract,
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Iter, bool HasStride>
auto _variadic_times(const argument_pack<Iter, HasStride>& args)
{
    auto ret = val(args.get(0));
    WL_CHECK_ABORT_LOOP_BEGIN(args.size() - 1u)
        for (auto i = _loop_begin; i < _loop_end; ++i)
            times_by(ret, args.get(i + 1, dim_checked{}));
    WL_CHECK_ABORT_LOOP_END()
    return ret;
}
template<typename X, typename Y>
auto times(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    WL_VARIADIC_FUNCTION_DEFAULT_IF_PARAMETER_PACK(times)
    {
        static_assert(is_numerical_type_v<remove_cvref_t<X>> &&
            is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);
        return utils::listable_function(_scalar_times,
            std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(times, int64_t(1))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(times)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(times)
template<typename X, typename Y>
auto divide(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>> &&
        is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);
    return utils::listable_function(_scalar_divide,
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
namespace io
{
#if defined(WL_USE_MATHLINK)
template<typename X>
auto print(const X& x);
template<typename X>
auto echo(X&& x);
#else
template<typename X>
auto print(const X& x)
{
    return const_null;
}
template<typename X>
auto echo(X&& x)
{
    return std::forward<decltype(x)>(x);
}
#endif
template<typename Function>
auto echo_function(Function f)
{
    return [=](auto&& x)
    {
        const auto& xref = x;
        echo(f(x));
        return std::forward<decltype(x)>(x);
    };
}
}
}
namespace wl
{
template<typename F>
struct function;
template<typename Ret, typename... Args>
struct function<Ret(Args...)>
{
    std::function<Ret(const Args&...)> f_;
    function()
    {
        f_ = [](const Args&...) { return Ret{}; };
    }
    template<typename F>
    explicit function(F f)
    {
        static_assert(std::is_same_v<Ret, remove_cvref_t<decltype(
            f(std::declval<const Args&>()...))>>);
        f_ = f;
    }
    template<typename F>
    auto& operator=(F f)
    {
        static_assert(std::is_same_v<Ret, remove_cvref_t<decltype(
            f(std::declval<const Args&>()...))>>);
        f_ = f;
        return *this;
    }
    template<typename... Any>
    auto operator()(Any&&... any) -> decltype(auto)
    {
        static_assert(sizeof...(Any) == sizeof...(Args));
        static_assert((std::is_same_v<remove_cvref_t<Any>, Args> && ...));
        return f_(std::forward<decltype(any)>(any)...);
    }
};
template<typename ArgIter, bool HasStride>
struct argument_pack
{
    using value_type = remove_cvref_t<decltype(*std::declval<ArgIter>())>;
    const ArgIter iter_;
    const size_t size_;
    const size_t stride_;
    argument_pack(ArgIter iter, size_t size, size_t stride = 1u) :
        iter_{iter}, size_{size}, stride_{stride}
    {
    }
    size_t size() const
    {
        return this->size_;
    }
    auto get(size_t i) const
    {
        if (i >= size_)
            throw std::logic_error(WL_ERROR_ARGPACK_OUT_OF_RANGE);
        if constexpr (HasStride)
            return *(this->iter_ + i * stride_);
        else
            return *(this->iter_ + i);
    }
    auto get(size_t i, dim_checked) const
    {
        if constexpr (HasStride)
            return *(this->iter_ + i * stride_);
        else
            return *(this->iter_ + i);
    }
    auto get_pack(size_t i) const
    {
        if (i > size_)
            throw std::logic_error(WL_ERROR_ARGPACK_OUT_OF_RANGE);
        if constexpr (HasStride)
            return argument_pack(iter_ + i * stride_, size_ - i, stride_);
        else
            return argument_pack(iter_ + i, size_ - i);
    }
};
template<typename Normal, typename Variadic>
struct variadic
{
    Normal nf_;
    Variadic vf_;
    variadic(Normal nf, Variadic vf) :
        nf_{std::move(nf)}, vf_{std::move(vf)}
    {
    }
    template<typename... Args>
    auto operator()(Args&&... args) const -> decltype(auto)
    {
        return nf_(std::forward<decltype(args)>(args)...);
    }
    template<typename Arg, typename = std::enable_if_t<
        std::is_invocable_v<Variadic, Arg&&> ||
        !is_argument_pack_v<remove_cvref_t<Arg>>>>
    auto operator()(Arg&& arg) const -> decltype(auto)
    {
        if constexpr (is_argument_pack_v<remove_cvref_t<Arg>>)
            return vf_(std::forward<decltype(arg)>(arg));
        else
            return nf_(std::forward<decltype(arg)>(arg));
    }
};
template<typename T, typename Args>
struct _tuple_append;
template<typename T, typename... Args>
struct _tuple_append<T, std::tuple<Args...>>
{
    using type = std::tuple<Args..., T>;
};
template<typename T, typename Args>
using _tuple_append_t = typename _tuple_append<T, Args>::type;
template<typename Fn, typename T, typename Args, typename = void>
struct _apply_nargs : _apply_nargs<Fn, T, _tuple_append_t<T, Args>>
{
    static_assert(std::tuple_size_v<Args> <= MaximumArgCount, 
        WL_ERROR_INTERNAL);
};
template<typename Fn, typename T, typename... Args>
struct _apply_nargs<Fn, T, std::tuple<Args...>,
    std::void_t<std::invoke_result_t<Fn, Args...>>> :
    std::integral_constant<size_t, sizeof...(Args)> {};
template<typename Fn, typename T>
constexpr auto _apply_nargs_v = _apply_nargs<Fn, T, std::tuple<>>::value;
template<typename Function, typename Iter, size_t... Is>
auto _apply_fixed_impl(Function f, Iter iter, ptrdiff_t step,
    std::index_sequence<Is...>)
{
    return f(*(iter + step * Is)...);
}
template<typename Function, typename Iter, size_t... Is>
auto _apply_fixed_impl(Function f, Iter iter, std::index_sequence<Is...>)
{
    return f(*(iter + Is)...);
}
template<typename Function, typename X, int64_t I>
auto apply(Function f, const X& x, const_int<I>)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto R = array_rank_v<XT>;
    static_assert(R >= 1u, WL_ERROR_REQUIRE_ARRAY);
    constexpr int64_t Level = I >= 0 ? I : I + int64_t(R) + 1;
    static_assert(0 <= Level && Level < int64_t(R), WL_ERROR_BAD_LEVEL);
    const auto& valx = val(std::forward<decltype(x)>(x));
    auto x_iter = valx.template view_begin<Level + 1u>();
    const auto argc = valx.dims()[Level];
    const auto apply_dims = utils::dims_take<1u, Level>(valx.dims());
    if constexpr (is_variadic_function_v<Function>)
    {
        using PackType = argument_pack<decltype(x_iter)>;
        using RT = remove_cvref_t<decltype(f(std::declval<PackType>()))>;
        if constexpr (Level == 0u)
        {
            return f(PackType(x_iter, argc));
        }
        else if constexpr (array_rank_v<RT> == 0u)
        {
            ndarray<RT, Level> ret(apply_dims);
            auto ret_iter = ret.begin();
            auto ret_size = ret.size();
            for (size_t i = 0u; i < ret_size; ++i, ++ret_iter, x_iter += argc)
                *ret_iter = f(PackType(x_iter, argc));
            return ret;
        }
        else
        {
            auto first_item = f(PackType(x_iter, argc));
            const auto item_dims = first_item.dims();
            ndarray<value_type_t<RT>, Level + array_rank_v<RT>> ret(
                utils::dims_join(apply_dims, item_dims));
            auto ret_iter = ret.template view_begin<Level>();
            first_item.copy_to(ret_iter.begin());
            x_iter += argc;
            ++ret_iter;
            for (size_t i = 1; i < utils::size_of_dims(apply_dims);
                ++i, x_iter += argc, ++ret_iter)
            {
                auto item = f(PackType(x_iter, argc));
                if (!utils::check_dims(item.dims(), item_dims))
                    throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
                item.copy_to(ret_iter.begin());
            }
            return ret;
        }
    }
    else
    {
        constexpr auto function_nargs =
            _apply_nargs_v<Function, remove_cvref_t<decltype(*x_iter)>>;
        if (function_nargs > argc)
            throw std::logic_error(WL_ERROR_ARGPACK_OUT_OF_RANGE);
        constexpr auto index_seq = std::make_index_sequence<function_nargs>{};
        using RT = remove_cvref_t<decltype(
            _apply_fixed_impl(f, x_iter, index_seq))>;
        if constexpr (Level == 0u)
        {
            return _apply_fixed_impl(f, x_iter, index_seq);
        }
        else if constexpr (array_rank_v<RT> == 0u)
        {
            ndarray<RT, Level> ret(apply_dims);
            auto ret_iter = ret.begin();
            auto ret_size = ret.size();
            for (size_t i = 0u; i < ret_size; ++i, ++ret_iter, x_iter += argc)
                *ret_iter = _apply_fixed_impl(f, x_iter, index_seq);
            return ret;
        }
        else
        {
            auto first_item = _apply_fixed_impl(f, x_iter, index_seq);
            const auto item_dims = first_item.dims();
            ndarray<value_type_t<RT>, Level + array_rank_v<RT>> ret(
                utils::dims_join(apply_dims, item_dims));
            auto ret_iter = ret.template view_begin<Level>();
            first_item.copy_to(ret_iter.begin());
            x_iter += argc;
            ++ret_iter;
            for (size_t i = 1; i < utils::size_of_dims(apply_dims);
                ++i, x_iter += argc, ++ret_iter)
            {
                auto item = _apply_fixed_impl(f, x_iter, index_seq);
                if (!utils::check_dims(item.dims(), item_dims))
                    throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
                item.copy_to(ret_iter.begin());
            }
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto apply(Function f, X&& x)
{
    WL_TRY_BEGIN()
    return apply(f, std::forward<decltype(x)>(x), const_int<0>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename T, size_t R, typename Function>
auto _select_impl(const ndarray<T, R>& a, Function f)
{
    static_assert(R >= 2u, WL_ERROR_INTERNAL);
    ndarray<T, R> ret;
    auto view_iter = a.template view_begin<1u>();
    auto view_end = a.template view_end<1u>();
    size_t item_size = view_iter.size();
    for (; view_iter != view_end; ++view_iter)
    {
        auto out = f(*view_iter);
        static_assert(is_boolean_v<decltype(out)>, WL_ERROR_PRED_TYPE);
        if (out)
            ret.append(*view_iter);
    }
    return ret;
}
template<typename X, typename Function>
auto select(X&& x, Function f)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    static_assert(array_rank_v<XT> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<XT>;
    if constexpr (array_rank_v<XT> == 1u)
    {
        std::vector<XV> ret;
        using RT = remove_cvref_t<decltype(f(XV{}))>;
        static_assert(is_boolean_v<RT>, WL_ERROR_PRED_TYPE);
        x.for_each([&](const auto& a) { if (f(a)) ret.push_back(a); });
        return ndarray<value_type_t<XT>, 1u>(
            std::array<size_t, 1u>{ret.size()}, std::move(ret));
    }
    else
        return _select_impl(std::forward<decltype(x)>(x).to_array(), f);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Function, int64_t I>
auto count(const X& x, varg_tag, Function f, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    static_assert(1u <= Level && Level <= XR, WL_ERROR_BAD_LEVEL);
    size_t item_count = 0;
    if constexpr (XR == Level)
    {
        using RT = remove_cvref_t<decltype(f(value_type_t<X>{}))>;
        static_assert(is_boolean_v<RT>, WL_ERROR_PRED_TYPE);
        x.for_each([&](const auto& a) { if (f(a)) ++item_count; });
    }
    else
    {
        const auto& valx = allows<view_category::Array>(x);
        auto view_iter = valx.template view_begin<Level>();
        const auto view_end = valx.template view_end<Level>();
        using RT = remove_cvref_t<decltype(f(*view_iter))>;
        static_assert(is_boolean_v<RT>, WL_ERROR_PRED_TYPE);
        for (; view_iter != view_end; ++view_iter)
        {
            if (f(*view_iter))
                ++item_count;
        }
    }
    return item_count;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Function>
auto count(const X& x, varg_tag, Function f)
{
    return count(x, varg_tag{}, f, const_int<1>{});
}
template<typename X, typename Y, int64_t I>
auto count(const X& x, const Y& y, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(1u <= Level && Level + YR == XR, WL_ERROR_BAD_LEVEL);
    size_t item_count = 0;
    const auto& valy = allows<view_category::Array>(y);
    if constexpr (YR == 0u)
    {
        x.for_each([&](const auto& a) { if (equal(a, valy)) ++item_count; });
    }
    else
    {
        const auto& valx = allows<view_category::Array>(x);
        auto view_iter = valx.template view_begin<Level>();
        const auto view_end = valx.template view_end<Level>();
        for (; view_iter != view_end; ++view_iter)
        {
            if (equal(*view_iter, valy))
                ++item_count;
        }
    }
    return item_count;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto count(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    return count(x, y, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<size_t Level, typename Function, typename T, size_t R>
auto _map_impl(Function f, const ndarray<T, R>& a)
{
    static_assert(1 <= Level && Level <= R, WL_ERROR_BAD_LEVEL);
    auto a_iter = a.template view_begin<Level>();
    using RT = remove_cvref_t<decltype(f(*a_iter))>;
    const auto map_dims = utils::dims_take<1, Level>(a.dims());
    if constexpr (array_rank_v<RT> == 0u)
    {
        ndarray<RT, Level> ret(map_dims);
        ret.for_each([&](auto& r) { r = f(*a_iter); ++a_iter; });
        return ret;
    }
    else
    {
        auto first_item = f(*a_iter);
        const auto item_dims = first_item.dims();
        ndarray<value_type_t<RT>, Level + array_rank_v<RT>> ret(
            utils::dims_join(map_dims, item_dims));
        auto ret_iter = ret.template view_begin<Level>();
        first_item.copy_to(ret_iter.begin());
        ++a_iter;
        ++ret_iter;
        for (size_t i = 1; i < utils::size_of_dims(map_dims);
            ++i, ++a_iter, ++ret_iter)
        {
            auto item = f(*a_iter);
            if (!utils::check_dims(item.dims(), item_dims))
                throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
            item.copy_to(ret_iter.begin());
        }
        return ret;
    }
}
template<typename Function, typename X, int64_t I>
auto map(Function f, X&& x, const_int<I>)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto R = array_rank_v<XT>;
    static_assert(R >= 1, WL_ERROR_REQUIRE_ARRAY);
    constexpr int64_t Level = I >= 0 ? I : I + int64_t(R) + 1;
    static_assert(1 <= Level && Level <= int64_t(R), WL_ERROR_BAD_LEVEL);
    if constexpr (R == size_t(Level))
    {
        using RT = remove_cvref_t<decltype(f(value_type_t<XT>{}))>;
        if constexpr (array_rank_v<RT> == 0u)
            return utils::listable_function(f, std::forward<decltype(x)>(x));
        else
            return _map_impl<Level>(f, x.to_array());
    }
    else
        return _map_impl<Level>(f, x.to_array());
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto map(Function f, X&& x)
{
    WL_TRY_BEGIN()
    return map(f, std::forward<decltype(x)>(x), const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, int64_t I>
auto scan(Function f, X&& x, const_int<I>)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto R = array_rank_v<XT>;
    static_assert(R >= 1, WL_ERROR_REQUIRE_ARRAY);
    constexpr int64_t Level = I >= 0 ? I : I + int64_t(R) + 1;
    static_assert(1 <= Level && Level <= int64_t(R), WL_ERROR_BAD_LEVEL);
    const auto& valx = val(std::forward<decltype(x)>(x));
    auto x_iter = valx.template view_begin<Level>();
    const auto x_end = valx.template view_end<Level>();
    for (; x_iter != x_end; ++x_iter)
        f(*x_iter);
    return const_null;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto scan(Function f, X&& x)
{
    WL_TRY_BEGIN()
    return scan(f, std::forward<decltype(x)>(x), const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, size_t R, typename... Iters>
auto _map_thread_impl2(Function f, const std::array<size_t, R>& map_dims,
    Iters... iters)
{
    using RT = remove_cvref_t<decltype(f(*iters...))>;
    if constexpr (array_rank_v<RT> == 0u)
    {
        ndarray<RT, 1u> ret(map_dims);
        const auto ret_size = ret.size();
        auto ret_iter = ret.begin();
        for (size_t i = 0u; i < ret_size; ++i, ++ret_iter, (++iters, ...))
            *ret_iter = f(*iters...);
        return ret;
    }
    else
    {
        auto first_item = f(*iters...);
        const auto item_dims = first_item.dims();
        ndarray<value_type_t<RT>, R + array_rank_v<RT>> ret(
            utils::dims_join(map_dims, item_dims));
        const auto ret_size = utils::size_of_dims(map_dims);
        auto ret_iter = ret.template view_begin<R>();
        first_item.copy_to(ret_iter.begin());
        [[maybe_unused]] const auto& _1 = (++iters, ...);
        ++ret_iter;
        for (size_t i = 1; i < ret_size; ++i, ++ret_iter, (++iters, ...))
        {
            auto item = f(*iters...);
            if (!utils::check_dims(item.dims(), item_dims))
                throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
            item.copy_to(ret_iter.begin());
        }
        return ret;
    }
}
template<size_t I, typename Function, typename Arg1, typename... Args>
auto _map_thread_impl1(Function f, const Arg1& arg1, const Args&... args)
{
    const auto dims = utils::dims_take<1u, I>(arg1.dims());
    if (!(utils::check_dims(dims, utils::dims_take<1, I>(args.dims())) && ...))
        throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
    return _map_thread_impl2(f, dims, arg1.template view_begin<size_t(I)>(),
        args.template view_begin<size_t(I)>()...);
}
template<typename Function, int64_t I, typename... Args>
auto map_thread(Function f, const_int<I>, varg_tag, Args&&... args)
{
    WL_TRY_BEGIN()
    static_assert(1 <= I, WL_ERROR_BAD_LEVEL);
    static_assert(((array_rank_v<remove_cvref_t<Args>> >= size_t(I)) && ...),
        WL_ERROR_MAP_THREAD_LEVEL);
    if constexpr (sizeof...(Args) == 0u)
    {
        using RT = remove_cvref_t<decltype(f())>;
        constexpr auto RR = array_rank_v<RT>;
        if constexpr (RR > 0u)
            return ndarray<value_type_t<RT>, RR + size_t(I)>{};
        else
            return ndarray<RT, size_t(I)>{};
    }
    else
    {
        return _map_thread_impl1<size_t(I)>(f,
            val(std::forward<decltype(args)>(args))...);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename... Args>
auto map_thread(Function f, varg_tag, Args&&... args)
{
    WL_TRY_BEGIN()
    return map_thread(f, const_int<1>{}, varg_tag{},
        std::forward<decltype(args)>(args)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, int64_t I>
auto map_thread(Function f, X&& x, const_int<I>)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto R = array_rank_v<XT>;
    static_assert(R >= 2u, WL_ERROR_REQUIRE_ARRAY_RANK"two or higher.");
    constexpr int64_t Level = I >= 0 ? I : I + int64_t(R) + 1;
    static_assert(1 <= Level && Level < int64_t(R), WL_ERROR_BAD_LEVEL);
    const auto& valx = val(std::forward<decltype(x)>(x));
    const auto map_dims = utils::dims_take<2u, Level + 1u>(valx.dims());
    const auto pack_size = valx.dims()[0];
    const auto pack_stride = utils::size_of_dims(map_dims);
    auto x_iter = valx.template view_begin<Level + 1u>();
    if constexpr (is_variadic_function_v<Function>)
    {
        using PackType = argument_pack<decltype(x_iter), true>;
        using RT = remove_cvref_t<decltype(f(std::declval<PackType>()))>;
        if constexpr (array_rank_v<RT> == 0u)
        {
            ndarray<RT, Level> ret(map_dims);
            auto ret_iter = ret.begin();
            const auto ret_size = ret.size();
            for (size_t i = 0; i < ret_size; ++i, ++ret_iter, ++x_iter)
                *ret_iter = f(PackType(x_iter, pack_size, pack_stride));
            return ret;
        }
        else
        {
            auto first_item = f(PackType(x_iter, pack_size, pack_stride));
            const auto item_dims = first_item.dims();
            ndarray<value_type_t<RT>, Level + array_rank_v<RT>> ret(
                utils::dims_join(map_dims, item_dims));
            auto ret_iter = ret.template view_begin<Level>();
            first_item.copy_to(ret_iter.begin());
            ++x_iter;
            ++ret_iter;
            for (size_t i = 1; i < pack_stride; ++i, ++x_iter, ++ret_iter)
            {
                auto item = f(PackType(x_iter, pack_size, pack_stride));
                if (!utils::check_dims(item.dims(), item_dims))
                    throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
                item.copy_to(ret_iter.begin());
            }
            return ret;
        }
    }
    else
    {
        constexpr auto function_nargs =
            _apply_nargs_v<Function, remove_cvref_t<decltype(*x_iter)>>;
        if (function_nargs > pack_size)
            throw std::logic_error(WL_ERROR_ARGPACK_OUT_OF_RANGE);
        constexpr auto index_seq = std::make_index_sequence<function_nargs>{};
        using RT = remove_cvref_t<decltype(
            _apply_fixed_impl(f, x_iter, pack_stride, index_seq))>;
        if constexpr (array_rank_v<RT> == 0u)
        {
            ndarray<RT, Level> ret(map_dims);
            auto ret_iter = ret.begin();
            const auto ret_size = ret.size();
            for (size_t i = 0; i < ret_size; ++i, ++ret_iter, ++x_iter)
                *ret_iter = _apply_fixed_impl(
                    f, x_iter, pack_stride, index_seq);
            return ret;
        }
        else
        {
            auto first_item = _apply_fixed_impl(
                f, x_iter, pack_stride, index_seq);
            const auto item_dims = first_item.dims();
            ndarray<value_type_t<RT>, Level + array_rank_v<RT>> ret(
                utils::dims_join(map_dims, item_dims));
            auto ret_iter = ret.template view_begin<Level>();
            first_item.copy_to(ret_iter.begin());
            ++x_iter;
            ++ret_iter;
            for (size_t i = 1; i < pack_stride; ++i, ++x_iter, ++ret_iter)
            {
                auto item = _apply_fixed_impl(
                    f, x_iter, pack_stride, index_seq);
                if (!utils::check_dims(item.dims(), item_dims))
                    throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
                item.copy_to(ret_iter.begin());
            }
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto map_thread(Function f, X&& x)
{
    WL_TRY_BEGIN()
    return map_thread(f, std::forward<decltype(x)>(x), const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto nest(Function f, X&& x, const int64_t n)
{
    WL_TRY_BEGIN()
    using XT0 = remove_cvref_t<decltype(val(x))>;
    using XT1 = remove_cvref_t<decltype(val(f(std::declval<X&&>())))>;
    using XT2 = remove_cvref_t<decltype(val(f(std::declval<XT1&&>())))>;
    static_assert(is_convertible_v<XT0, XT2> && std::is_same_v<XT1, XT2>,
        WL_ERROR_NEST_TYPE);
    constexpr auto rank = array_rank_v<XT0>;
    if (n < 0) throw std::logic_error(WL_ERROR_ITERATION_NEGATIVE);
    if (n == 0)
        return cast<XT2>(std::forward<decltype(x)>(x));
    else // n >= 1
    {
        auto ret = cast<XT2>(f(std::forward<decltype(x)>(x)));
        for (size_t i = 1u; i < size_t(n); ++i)
        {
            if constexpr (rank == 0u)
                ret = cast<XT2>(f(ret));
            else
            {
                auto temp = val(f(std::move(ret)));
                ret = std::move(temp);
            }
        }
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto nest_list(Function f, X&& x, const int64_t n)
{
    WL_TRY_BEGIN()
    using XT0 = remove_cvref_t<decltype(val(x))>;
    using XT1 = remove_cvref_t<decltype(val(f(std::declval<X&&>())))>;
    using XT2 = remove_cvref_t<decltype(val(f(std::declval<XT1&&>())))>;
    static_assert(is_convertible_v<XT0, XT2> && std::is_same_v<XT1, XT2>,
        WL_ERROR_NEST_TYPE);
    constexpr auto rank = array_rank_v<XT0>;
    if (n < 0) throw std::logic_error(WL_ERROR_ITERATION_NEGATIVE);
    if constexpr (rank == 0u)
    {
        ndarray<XT2, 1u> ret(std::array<size_t, 1u>{size_t(n) + 1u});
        auto ret_iter = ret.begin();
        *ret_iter = cast<XT2>(std::forward<decltype(x)>(x));
        for (size_t i = 1; i <= size_t(n); ++i, ++ret_iter)
            *(ret_iter + 1) = cast<XT2>(f(*ret_iter));
        return ret;
    }
    else
    {
        using XV2 = value_type_t<XT2>;
        auto item_dims = x.dims();
        auto ret_dims = utils::dims_join(
            std::array<size_t, 1u>{size_t(n) + 1u}, item_dims);
        if (n == 0)
        {
            auto item = cast<XT2>(std::forward<decltype(x)>(x));
            return ndarray<XV2, rank + 1u>(
                ret_dims, std::move(item).data_vector());
        }
        else // n >= 1
        {
            ndarray<XV2, rank + 1u> ret(ret_dims);
            auto view_iter = ret.template view_begin<1u>();
            x.copy_to(view_iter.begin());
            ++view_iter;
            auto item = val(f(std::forward<decltype(x)>(x)));
            if (!utils::check_dims(item.dims(), item_dims))
                throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
            item.copy_to(view_iter.begin());
            ++view_iter;
            for (size_t i = 2; i <= size_t(n); ++i, ++view_iter)
            {
                auto temp = val(f(std::move(item)));
                item = std::move(temp);
                if (!utils::check_dims(item.dims(), item_dims))
                    throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
                item.copy_to(view_iter.begin());
            }
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename T, size_t R>
struct _nest_while_queue
{
    static constexpr auto _is_scalar = (R == 0u);
    using _elem_t = std::conditional_t<_is_scalar, T, ndarray<T, R>>;
    const size_t size_;
    size_t elements_count_;
    size_t current_;
    std::vector<_elem_t> queue_;
    _nest_while_queue(size_t size) :
        size_{size}, elements_count_{0u}, current_{0u}, queue_(size)
    {
    }
    template<typename X>
    void push(X&& x)
    {
        using XT = remove_cvref_t<X>;
        static_assert(array_rank_v<XT> == R, WL_ERROR_NEST_TYPE);
        ++current_;
        ++elements_count_;
        if (current_ == size_)
            current_ = 0u;
        auto& dst = queue_[current_];
        if constexpr (_is_scalar)
        {
            static_assert(is_convertible_v<XT, T>, WL_ERROR_NEST_TYPE);
            dst = cast<_elem_t>(std::forward<decltype(x)>(x));
        }
        else
        {
            using XV = value_type_t<XT>;
            static_assert(is_convertible_v<XV, T>, WL_ERROR_NEST_TYPE);
            if constexpr (std::is_same_v<XV, T> && is_movable_v<X&&>)
                dst = std::move(x);
            else
            {
                dst.uninitialized_resize(x.dims(), x.size());
                x.copy_to(dst.data());
            }
        }
    }
    auto last() const & -> const auto&
    {
        return queue_[current_];
    }
    auto last() && -> auto&&
    {
        return std::move(queue_[current_]);
    }
    auto get(size_t i) const & -> const auto&
    {
        return queue_.at(current_ - i + (i > current_ ? size_ : size_t(0)));
    }
    auto get(size_t i) && -> auto&&
    {
        if (i >= elements_count_)
            throw std::logic_error(WL_ERROR_NEST_WHILE_OFFSET);
        return std::move(
            queue_.at(current_ - i + (i > current_ ? size_ : size_t(0))));
    }
    template<size_t N, typename Fn, size_t... Is>
    auto _apply_test_impl(Fn&& fn, std::index_sequence<Is...>) const
    {
        auto res = std::forward<decltype(fn)>(fn)(
            queue_[current_ - (N - Is - 1u) +
                ((N - Is - 1u) > current_ ? size_ : size_t(0))]...);
        static_assert(is_boolean_v<decltype(res)>, WL_ERROR_PRED_TYPE);
        return res;
    }
    template<size_t N, typename Fn>
    auto apply_test(Fn&& fn) const
    {
        return _apply_test_impl<N>(std::forward<decltype(fn)>(fn),
            std::make_index_sequence<N>{});
    }
};
template<typename Function, typename X, typename Test, int64_t N>
auto nest_while(Function f, X&& x, Test test, const_int<N>,
    const int64_t input_max = const_int_infinity,
    const int64_t offset = 0u)
{
    WL_TRY_BEGIN()
    static_assert(0 <= N && N <= MaximumArgCount, WL_ERROR_LARGE_ARGC);
    constexpr auto num_args = size_t(N);
    constexpr auto effective_num_args = std::max(num_args, size_t(1));
    const auto history_size = size_t(std::max(int64_t(num_args), -offset + 1));
    const auto max_steps = std::max(input_max, int64_t(0));
    using XT0 = remove_cvref_t<decltype(val(x))>;
    using XT1 = remove_cvref_t<decltype(val(f(std::declval<X&&>())))>;
    using XT2 = remove_cvref_t<decltype(val(f(std::declval<XT1&&>())))>;
    static_assert(is_convertible_v<XT0, XT2> && std::is_same_v<XT1, XT2>,
        WL_ERROR_NEST_TYPE);
    constexpr auto XR = array_rank_v<XT0>;
    if (max_steps < int64_t(effective_num_args))
    {
        if (int64_t(max_steps + offset) < 0)
            throw std::logic_error(WL_ERROR_NEST_WHILE_OFFSET);
        return nest(f, std::forward<decltype(x)>(x), max_steps + offset);
    }
    else if (effective_num_args == 1u && offset >= 0)
    {
        auto ret = cast<XT2>(std::forward<decltype(x)>(x));
        bool continue_flag = false;
        if constexpr (num_args == 0u)
            continue_flag = test();
        else if constexpr (num_args == 1u)
            continue_flag = test(ret);
        if (continue_flag)
        {
            WL_CHECK_ABORT_LOOP_BEGIN(max_steps)
                for (auto i = _loop_zero; i < _loop_size; ++i)
                {
                    if constexpr (XR == 0u)
                        ret = cast<XT2>(f(ret));
                    else
                    {
                        auto temp = val(f(std::move(ret)));
                        set(ret, std::move(temp));
                    }
                    if constexpr (num_args == 0u)
                        continue_flag = test();
                    else if constexpr (num_args == 1u)
                        continue_flag = test(ret);
                    if (!continue_flag)
                        goto nest_while_exit_no_queue;
                }
            WL_CHECK_ABORT_LOOP_END()
        }
nest_while_exit_no_queue:
        if (offset == 0u)
            return ret;
        else
            return nest(f, ret, offset);
    }
    else
    {
        using XV = std::conditional_t<XR == 0u, XT2, value_type_t<XT2>>;
        _nest_while_queue<XV, XR> queue(history_size);
        queue.push(std::forward<decltype(x)>(x));
        
        for (int64_t i = 1; i < int64_t(num_args); ++i)
        {
            queue.push(f(queue.last()));
        }
        bool continue_flag = queue.template apply_test<num_args>(test);
        if (continue_flag)
        {
            WL_CHECK_ABORT_LOOP_BEGIN(max_steps - effective_num_args + 1)
                for (auto i = _loop_zero; i < _loop_size; ++i)
                {
                    queue.push(f(queue.last()));
                    continue_flag = queue.template apply_test<num_args>(test);
                    if (!continue_flag)
                        goto nest_while_exit_queue;
                }
            WL_CHECK_ABORT_LOOP_END()
        }
nest_while_exit_queue:
        const auto reverse_offset = int64_t(effective_num_args) - 1 - offset;
        if (offset <= 0)
            return std::move(queue).get(size_t(-offset));
        else
            return nest(f, std::move(queue).last(), offset);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, typename Test>
auto nest_while(Function f, X&& x, Test test)
{
    WL_TRY_BEGIN()
    return nest_while(f, std::forward<decltype(x)>(x), test, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Test, typename Iter, size_t... Is>
auto _nest_while_list_apply_test(Test test, Iter iter,
    std::index_sequence<Is...>)
{
    constexpr auto N = sizeof...(Is);
    return test(*(iter + int64_t(Is - N + 1u))...);
}
template<typename Function, typename X, typename Test, int64_t N>
auto nest_while_list(Function f, X&& x, Test test, const_int<N>,
    const int64_t input_max = const_int_infinity,
    const int64_t offset = 0u)
{
    WL_TRY_BEGIN()
    static_assert(0 <= N && N <= MaximumArgCount, WL_ERROR_LARGE_ARGC);
    const auto max_steps = std::max(input_max, int64_t(0));
    constexpr auto num_args = size_t(N);
    constexpr auto effective_num_args = std::max(num_args, size_t(1));
    using XT0 = remove_cvref_t<decltype(val(x))>;
    using XT1 = remove_cvref_t<decltype(val(f(std::declval<X&&>())))>;
    using XT2 = remove_cvref_t<decltype(val(f(std::declval<XT1&&>())))>;
    static_assert(is_convertible_v<XT0, XT2> && std::is_same_v<XT1, XT2>,
        WL_ERROR_NEST_TYPE);
    constexpr auto XR = array_rank_v<XT0>;
    if (max_steps < int64_t(effective_num_args))
    {
        if (int64_t(max_steps + offset) < 0)
            throw std::logic_error(WL_ERROR_NEST_WHILE_LIST_OFFSET);
        return nest_list(f, std::forward<decltype(x)>(x), max_steps + offset);
    }
    else if constexpr (XR == 0u)
    {
        ndarray<XT2, 1u> ret;
        auto last = cast<XT2>(std::forward<decltype(x)>(x));
        ret.append(last);
        int64_t i = 1;
        for (; i < int64_t(num_args); ++i)
        {
            auto temp = f(std::move(last));
            last = std::move(temp);
            ret.append(last);
        }
        bool continue_flag = false;
        do
        {
            WL_THROW_IF_ABORT()
            if constexpr (num_args == 0u)
                continue_flag = test();
            else if constexpr (num_args == 1u)
                continue_flag = test(last);
            else
                continue_flag = _nest_while_list_apply_test(test,
                    ret.begin() + i - 1, std::make_index_sequence<num_args>{});
            if (!continue_flag)
                break;
            if (i++ > max_steps)
                break;
            auto temp = f(std::move(last));
            last = std::move(temp);
            ret.append(last);
        } while (true);
        if (offset > 0)
        {
            for (int64_t i = 0; i < offset; ++i)
            {
                auto temp = f(std::move(last));
                last = std::move(temp);
                ret.append(last);
            }
        }
        else if (offset < 0)
        {
            const auto new_dim0 = int64_t(offset + ret.dims()[0]);
            if (new_dim0 <= 0)
                throw std::logic_error(WL_ERROR_NEST_WHILE_LIST_OFFSET);
            ret.uninitialized_resize(
                std::array<size_t, 1u>{size_t(new_dim0)}, new_dim0);
        }
        return ret;
    }
    else
    {
        using XV = value_type_t<XT2>;
        ndarray<XV, XR + 1u> ret;
        auto last = cast<XT2>(std::forward<decltype(x)>(x));
        const auto item_dims = last.dims();
        ret.append(last);
        int64_t i = 1;
        for (; i < int64_t(num_args); ++i)
        {
            auto temp = val(f(std::move(last)));
            last = std::move(temp);
            if (!utils::check_dims(item_dims, last.dims()))
                throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
            ret.append(last);
        }
        bool continue_flag = false;
        do
        {
            WL_THROW_IF_ABORT()
            if constexpr (num_args == 0u)
                continue_flag = test();
            else if constexpr (false && num_args == 1u)
                continue_flag = test(last);
            else
                continue_flag = _nest_while_list_apply_test(test,
                    ret.template view_begin<1u>() + i - 1,
                    std::make_index_sequence<num_args>{});
            if (!continue_flag)
                break;
            if (i++ > max_steps)
                break;
            auto temp = val(f(std::move(last)));
            last = std::move(temp);
            if (!utils::check_dims(item_dims, last.dims()))
                throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
            ret.append(last);
        } while (true);
        if (offset > 0)
        {
            for (int64_t i = 0; i < offset; ++i)
            {
                auto temp = val(f(std::move(last)));
                last = std::move(temp);
                if (!utils::check_dims(item_dims, last.dims()))
                    throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
                ret.append(last);
            }
        }
        else if (offset < 0)
        {
            const auto new_dim0 = int64_t(offset + ret.dims()[0]);
            if (new_dim0 <= 0)
                throw std::logic_error(WL_ERROR_NEST_WHILE_LIST_OFFSET);
            auto new_dims = ret.dims();
            new_dims[0] = size_t(new_dim0);
            ret.uninitialized_resize(new_dims, size_t(new_dim0) * last.size());
        }
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, typename Test>
auto nest_while_list(Function f, X&& x, Test test)
{
    WL_TRY_BEGIN()
    return nest_while_list(
        f, std::forward<decltype(x)>(x), test, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, typename YIter, typename YInc>
auto _fold_single_impl(Function f, X&& x, YIter y_iter, YInc y_inc,
    const size_t n)
{
    auto nest_f = [&](auto&& arg)
    {
        auto item = f(arg, *y_iter);
        y_inc(y_iter);
        return item;
    };
    return nest(nest_f, std::forward<decltype(x)>(x), n);
}
template<typename Function, typename X, typename YIter, typename YInc>
auto _fold_list_impl(Function f, X&& x, YIter y_iter, YInc y_inc,
    const size_t n)
{
    auto nest_f = [&](auto&& arg)
    {
        auto item = f(arg, *y_iter);
        y_inc(y_iter);
        return item;
    };
    return nest_list(nest_f, std::forward<decltype(x)>(x), n);
}
template<bool List, bool FoldL, typename Function, typename Y>
auto _fold_impl1(Function f, Y&& y)
{
    static_assert(array_rank_v<remove_cvref_t<Y>> >= 1u,
        WL_ERROR_REQUIRE_ARRAY);
    const size_t n = y.dims()[0];
    if (n < 1u) throw std::logic_error(WL_ERROR_REQUIRE_NON_EMPTY);
    const auto& valy = val(std::forward<decltype(y)>(y));
    if constexpr (List)
    {
        if constexpr (FoldL)
            return _fold_list_impl(f, *valy.template view_begin<1u>(),
                valy.template view_begin<1u>() + 1,
                [](auto& iter) { ++iter; }, n - 1u);
        else
            return _fold_list_impl(f, *(valy.template view_end<1u>() - 1),
                valy.template view_end<1u>() - 2,
                [](auto& iter) { --iter; }, n - 1u);
    }
    else
    {
        if constexpr (FoldL)
            return _fold_single_impl(f, *valy.template view_begin<1u>(),
                valy.template view_begin<1u>() + 1,
                [](auto& iter) { ++iter; }, n - 1u);
        else
            return _fold_single_impl(f, *(valy.template view_end<1u>() - 1),
                valy.template view_end<1u>() - 2,
                [](auto& iter) { --iter; }, n - 1u);
    }
}
template<bool List, bool FoldL, typename Function, typename X, typename Y>
auto _fold_impl1(Function f, X&& x, Y&& y)
{
    using YT = remove_cvref_t<Y>;
    static_assert(array_rank_v<YT> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto& valy = val(std::forward<decltype(y)>(y));
    const size_t n = valy.dims()[0];
    if constexpr (List)
    {
        if constexpr (FoldL)
            return _fold_list_impl(f, std::forward<decltype(x)>(x),
                valy.template view_begin<1u>(),
                [](auto& iter) { ++iter; }, n);
        else
            return _fold_list_impl(f, std::forward<decltype(x)>(x),
                valy.template view_end<1u>() - 1,
                [](auto& iter) { --iter; }, n);
    }
    else
    {
        if constexpr (FoldL)
            return _fold_single_impl(f, std::forward<decltype(x)>(x),
                valy.template view_begin<1u>(),
                [](auto& iter) { ++iter; }, n);
        else
            return _fold_single_impl(f, std::forward<decltype(x)>(x),
                valy.template view_end<1u>() - 1,
                [](auto& iter) { --iter; }, n);
    }
}
template<typename Function, typename... Any>
auto fold(Function f, Any&&... any)
{
    WL_TRY_BEGIN()
    return _fold_impl1<false, true>(f, std::forward<decltype(any)>(any)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename... Any>
auto foldr(Function f, Any&&... any)
{
    WL_TRY_BEGIN()
    return _fold_impl1<false, false>(f, std::forward<decltype(any)>(any)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename... Any>
auto fold_list(Function f, Any&&... any)
{
    WL_TRY_BEGIN()
    return _fold_impl1<true, true>(f, std::forward<decltype(any)>(any)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename... Any>
auto foldr_list(Function f, Any&&... any)
{
    WL_TRY_BEGIN()
    return _fold_impl1<true, false>(f, std::forward<decltype(any)>(any)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, typename Pred>
auto fixed_point(Function f, X&& x, const int64_t max, varg_tag, Pred pred)
{
    WL_TRY_BEGIN()
    return nest_while(f, std::forward<decltype(x)>(x),
        [=](const auto& a, const auto& b)
        {
            auto same = pred(a, b);
            static_assert(is_boolean_v<decltype(same)>, WL_ERROR_PRED_TYPE);
            return !same;
        }, const_int<2>{}, max);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, typename Pred>
auto fixed_point(Function f, X&& x, varg_tag, Pred pred)
{
    WL_TRY_BEGIN()
    return fixed_point(f, std::forward<decltype(x)>(x),
        const_int_infinity, varg_tag{}, pred);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto fixed_point(Function f, X&& x, const int64_t max)
{
    WL_TRY_BEGIN()
    return nest_while(f, std::forward<decltype(x)>(x),
        [=](const auto& a, const auto& b) { return unequal(a, b); },
        const_int<2>{}, max);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto fixed_point(Function f, X&& x)
{
    WL_TRY_BEGIN()
    return fixed_point(f, std::forward<decltype(x)>(x), const_int_infinity);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, typename Pred>
auto fixed_point_list(Function f, X&& x, const int64_t max,
    varg_tag, Pred pred)
{
    WL_TRY_BEGIN()
    return nest_while_list(f, std::forward<decltype(x)>(x),
        [=](const auto& a, const auto& b)
        {
            auto same = pred(a, b);
            static_assert(is_boolean_v<decltype(same)>, WL_ERROR_PRED_TYPE);
            return !same;
        }, const_int<2>{}, max);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X, typename Pred>
auto fixed_point_list(Function f, X&& x, varg_tag, Pred pred)
{
    WL_TRY_BEGIN()
    return fixed_point_list(f, std::forward<decltype(x)>(x),
        const_int_infinity, varg_tag{}, pred);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto fixed_point_list(Function f, X&& x, const int64_t max)
{
    WL_TRY_BEGIN()
    return nest_while_list(f, std::forward<decltype(x)>(x),
        [=](const auto& a, const auto& b) { return unequal(a, b); },
        const_int<2>{}, max);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Function, typename X>
auto fixed_point_list(Function f, X&& x)
{
    WL_TRY_BEGIN()
    return fixed_point_list(f, std::forward<decltype(x)>(x),
        const_int_infinity);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Arg>
auto identity(Arg&& arg) -> decltype(auto)
{
    WL_TRY_BEGIN()
    return val(arg);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<bool Reverse, typename... Fs>
struct composite_function
{
    static constexpr auto N = sizeof...(Fs);
    std::tuple<Fs...> fs_;
    composite_function(Fs... fs) :
        fs_{std::make_tuple(std::move(fs)...)}
    {
    }
    template<typename... Args>
    auto operator()(Args&&... args) const -> decltype(auto)
    {
        return _apply<0u>(std::forward<decltype(args)>(args)...);
    }
    template<size_t I, typename... Args>
    auto _apply(Args&&... args) const -> decltype(auto)
    {
        if constexpr (I + 1u < N)
            return std::get<(Reverse ? (N - 1u - I) : I)>(fs_)(
                _apply<I + 1u>(std::forward<decltype(args)>(args)...));
        else
            return std::get<(Reverse ? (N - 1u - I) : I)>(fs_)(
                std::forward<decltype(args)>(args)...);
    }
};
template<bool Reverse, typename... Fn>
auto _composition_impl(Fn&&... fn)
{
    static constexpr auto N = sizeof...(Fn);
    constexpr auto is_variadic = is_variadic_function_v<
        std::tuple_element_t<N - 1u, std::tuple<remove_cvref_t<Fn>...>>>;
    auto ret = composite_function<Reverse, remove_cvref_t<Fn>...>(
        std::forward<decltype(fn)>(fn)...);
    if constexpr (is_variadic)
        return variadic<decltype(ret), decltype(ret)>(ret, ret);
    else
        return ret;
}
template<bool Reverse>
auto _composition_impl()
{
    return [](auto&& arg) -> decltype(auto)
    {
        return std::forward<decltype(arg)>(arg);
    };
}
template<typename... Fn>
auto composition(Fn&&... fn) -> decltype(auto)
{
    WL_TRY_BEGIN()
    return _composition_impl<false>(std::forward<decltype(fn)>(fn)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename... Fn>
auto right_composition(Fn&&... fn) -> decltype(auto)
{
    WL_TRY_BEGIN()
    return _composition_impl<true>(std::forward<decltype(fn)>(fn)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test, int64_t I>
auto all_true(X&& x, Test test, const_int<I>)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    static_assert(1 <= I && I <= XR, WL_ERROR_BAD_LEVEL);
    const auto& valx = val(std::forward<decltype(x)>(x));
    auto x_iter = valx.template view_begin<I>();
    static_assert(is_boolean_v<remove_cvref_t<decltype(test(*x_iter))>>,
        WL_ERROR_PRED_TYPE);
    auto ret = true;
    const auto outer_size = utils::size_of_dims<I>(valx.dims().data());
    WL_CHECK_ABORT_LOOP_BEGIN(outer_size)
        for (auto i = _loop_zero; i < _loop_size && ret; ++i, ++x_iter)
            ret = ret && test(*x_iter);
    WL_CHECK_ABORT_LOOP_END()
    return boolean(ret);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test>
auto all_true(X&& x, Test test)
{
    WL_TRY_BEGIN()
    return all_true(std::forward<decltype(x)>(x), test, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test, int64_t I>
auto any_true(X&& x, Test test, const_int<I>)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    static_assert(1 <= I && I <= XR, WL_ERROR_BAD_LEVEL);
    const auto& valx = val(std::forward<decltype(x)>(x));
    auto x_iter = valx.template view_begin<I>();
    static_assert(is_boolean_v<remove_cvref_t<decltype(test(*x_iter))>>,
        WL_ERROR_PRED_TYPE);
    auto ret = false;
    const auto outer_size = utils::size_of_dims<I>(valx.dims().data());
    WL_CHECK_ABORT_LOOP_BEGIN(outer_size)
        for (auto i = _loop_zero; i < _loop_size && !ret; ++i, ++x_iter)
            ret = ret || test(*x_iter);
    WL_CHECK_ABORT_LOOP_END()
    return boolean(ret);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test>
auto any_true(X&& x, Test test)
{
    WL_TRY_BEGIN()
    return any_true(std::forward<decltype(x)>(x), test, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test, int64_t I>
auto none_true(X&& x, Test test, const_int<I>)
{
    WL_TRY_BEGIN()
    return !any_true(std::forward<decltype(x)>(x), test, const_int<I>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test>
auto none_true(X&& x, Test test)
{
    WL_TRY_BEGIN()
    return none_true(std::forward<decltype(x)>(x), test, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test>
auto vector_q(X&& x, Test test)
{
    WL_TRY_BEGIN()
    if constexpr (array_rank_v<remove_cvref_t<X>> == 0u)
        return const_false;
    else
        return all_true(std::forward<decltype(x)>(x), test, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto vector_q(X&& x)
{
    WL_TRY_BEGIN()
    return boolean(array_rank_v<remove_cvref_t<X>> == 1u);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Test>
auto matrix_q(X&& x, Test test)
{
    WL_TRY_BEGIN()
    if constexpr (array_rank_v<remove_cvref_t<X>> <= 1u)
        return const_false;
    else
        return all_true(std::forward<decltype(x)>(x), test, const_int<2>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto matrix_q(X&& x)
{
    WL_TRY_BEGIN()
    return boolean(array_rank_v<remove_cvref_t<X>> == 2u);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
namespace utf8
{
using char_t = uint8_t;
constexpr char_t null_character = '\0';
inline bool is_ascii(char_t ch)
{
    return ch < char_t(0b1000'0000);
}
inline size_t _get_byte_size(const char_t* str, bool& ret_ascii_only)
{
#if defined(___AVX2__) || defined(___SSE4_1__)
    using namespace wl::simd;
#  if defined(__AVX2__)
    using M = __m256i;
#  else
    using M = __m128i;
#  endif
    const auto upper = set1<M>(int8_t(0b1100'0000));
    size_t i_byte = 0u;
    bool ascii_only = true;
    int zmask = 0;
    M data;
    for (; true; str += sizeof(M), i_byte += sizeof(M))
    {
        data = loadu<M>(str);
        zmask = movemask_epi8(cmpeq_epi8(data, zero<M>()));
        if (zmask)
            break;
        if (ascii_only && movemask_epi8(data))
            ascii_only = false;
    }
    auto excess_byte = utils::tzcnt_u64(uint64_t(unsigned(zmask)));
    if (ascii_only && excess_byte > 0)
    {
        auto nmask = uint64_t(unsigned(movemask_epi8(data)));
        ascii_only = !bool(nmask << (64u - excess_byte));
    }
    ret_ascii_only = ascii_only;
    return i_byte + excess_byte;
#else
    auto str0 = str;
    bool ascii_only = true;
    for (; ascii_only; ++str)
    {
        auto byte = *str;
        if (!byte)
        {
            ret_ascii_only = true;
            return size_t(str - str0);
        }
        else if (uint8_t(byte) >= 0b1000'0000u)
        {
            ret_ascii_only = false;
            ++str;
            break;
        }
    }
    while (*str++)
    {
    }
    return size_t(str - str0);
#endif
}
inline size_t _get_string_size_impl(const char_t* str, const size_t byte_size)
{
#if defined(__AVX2__) || defined(__SSE4_1__)
    using namespace wl::simd;
#  if defined(__AVX2__)
    using M = __m256i;
#  else
    using M = __m128i;
#  endif
    const auto upper = set1<M>(int8_t(0b1100'0000));
    auto trailing = zero<M>();
    size_t trailing_size = 0u;
    size_t i_byte = 0u;
    for (size_t i = 0u; i_byte + sizeof(M) < byte_size;
        ++i, str += sizeof(M), i_byte += sizeof(M))
    {
        trailing = sub_epi8(trailing, cmpgt_epi8(upper, loadu<M>(str)));
        if (i >= 100u)
        {
            trailing_size += hsum_epi8(trailing);
            trailing = zero<M>();
            i = 0u;
        }
    }
    auto tmask = unsigned(movemask_epi8(cmpgt_epi8(upper, loadu<M>(str))));
    auto excess_trailing = utils::_popcnt(
        uint64_t(tmask) << (64u - (byte_size - i_byte)));
    trailing_size += hsum_epi8(trailing);
    trailing_size += excess_trailing;
    return byte_size - trailing_size;
#else
    size_t trailing_size = 0u;
    for (size_t i = 0; i < byte_size; ++i)
    {
        if (int8_t(str[i]) < int8_t(0b1100'0000))
            ++trailing_size;
    }
    return byte_size - trailing_size;
#endif
}
inline size_t _get_string_size_check_valid_impl(
    const char_t* in_str, const size_t ref_byte_size)
{
    size_t byte_size = 0;
    size_t trailing_size = 0;
    auto str_begin = reinterpret_cast<const int8_t*>(in_str);
    auto str = str_begin;
    for (;;)
    {
        size_t n_bytes = 0u;
        char_t byte = *str++;
        if (!byte)
        {
            if (byte_size != ref_byte_size)
                throw std::logic_error(WL_ERROR_INTERNAL);
            return byte_size - trailing_size;
        }
        if (byte_size >= ref_byte_size)
            throw std::logic_error(WL_ERROR_BAD_UTF8_NULL_TERMINATED);
        if (byte < 0b1000'0000u)
            n_bytes = 1u;
        else if ((byte & 0b1110'0000u) == 0b1100'0000u)
            n_bytes = 2u;
        else if ((byte & 0b1111'0000u) == 0b1110'0000u)
            n_bytes = 3u;
        else if ((byte & 0b1111'1000u) == 0b1111'0000u)
            n_bytes = 4u;
        else
            throw std::logic_error(WL_ERROR_BAD_UTF8_CODEPOINT);
        for (size_t i = 1u; i < n_bytes; ++i)
        {
            if ((*str++ & 0b1100'0000u) != 0b1000'0000u)
                throw std::logic_error(WL_ERROR_BAD_UTF8_CODEPOINT);
        }
        trailing_size += n_bytes - 1u;
        byte_size += n_bytes;
    }
}
template<bool CheckValid = false>
size_t get_string_size(const char_t* str, const size_t byte_size)
{
    if (CheckValid)
        return _get_string_size_check_valid_impl(str, byte_size);
    else
        return _get_string_size_impl(str, byte_size);
}
bool is_ascii_only(const char_t* str, const size_t byte_size)
{
#if defined(__AVX2__) || defined(__SSE4_1__)
    using namespace wl::simd;
#  if defined(__AVX2__)
    using M = __m256i;
#  else
    using M = __m128i;
#endif
    const auto upper = set1<M>(int8_t(0b1100'0000));
    size_t i_byte = 0u;
    for (size_t i = 0u; i_byte + sizeof(M) < byte_size;
        ++i, str += sizeof(M), i_byte += sizeof(M))
    {
        auto tmask = unsigned(movemask_epi8(loadu<M>(str)));
        if (tmask)
            return false;
    }
    auto tmask = unsigned(movemask_epi8(loadu<M>(str)));
    return !bool(uint64_t(tmask) << (64u - (byte_size - i_byte)));
#else
    size_t trailing_size = 0u;
    for (size_t i = 0; i < byte_size; ++i)
    {
        if (int8_t(str[i]) < int8_t(0b1100'0000))
            return true;
    }
    return false;
#endif
}
struct iterator
{
    const uint8_t* ptr_;
    WL_INLINE static bool _is_valid_codepoint_begin(uint8_t byte)
    {
        return (byte < 0b1000'0000u) || (byte >= 0b1100'0000u);
    }
    WL_INLINE static bool _is_valid_codepoint_tailing(uint8_t byte)
    {
        return (byte & 0b1100'0000u) == 0b1000'0000u;
    }
    const uint8_t* pointer() const
    {
        return ptr_;
    }
    iterator& operator++()
    {
        ptr_ += num_bytes();
        return *this;
    }
    iterator& operator--()
    {
        ptr_ -= previous_num_bytes();
        return *this;
    }
    iterator& operator+=(ptrdiff_t n)
    {
        apply_offset(n);
        return *this;
    }
    iterator& operator-=(ptrdiff_t n)
    {
        apply_offset(-n);
        return *this;
    }
    bool operator==(const iterator& other) const
    {
        assert(_is_valid_codepoint_begin(*this->ptr_));
        assert(_is_valid_codepoint_begin(*other.ptr_));
        return this->ptr_ == other.ptr_;
    }
    bool operator!=(const iterator& other) const
    {
        return !(this->ptr_ == other.ptr_);
    }
    bool operator<(const iterator& other) const
    {
        return this->ptr_ < other.ptr_;
    }
    ptrdiff_t operator-(const iterator& other) const
    {
        bool this_is_behind = this->ptr_ > other.ptr_;
        const auto* begin = this_is_behind ? other.ptr_ : this->ptr_;
        const auto* end = this_is_behind ? this->ptr_ : other.ptr_;
        assert(_is_valid_codepoint_begin(*begin));
        assert(_is_valid_codepoint_begin(*end));
        ptrdiff_t n = 0;
        for (; begin != end; ++begin)
            n += ptrdiff_t(_is_valid_codepoint_begin(*begin));
        return this_is_behind ? n : -n;
    }
    uint32_t operator*() const
    {
        return codepoint();
    }
    ptrdiff_t byte_difference(const iterator& other) const
    {
        return ptrdiff_t(this->ptr_ - other.ptr_);
    }
    void apply_offset(ptrdiff_t n)
    {
        if (n >= 0)
        {
            for (ptrdiff_t i = 0u; i < n;)
                i += ptrdiff_t(_is_valid_codepoint_begin(*++ptr_));
        }
        else
        {
            for (ptrdiff_t i = 0u; i < n;)
                i += ptrdiff_t(_is_valid_codepoint_begin(*--ptr_));
        }
    }
    void apply_offset(ptrdiff_t n, const iterator& end)
    {
        if (n >= 0)
        {
            for (ptrdiff_t i = 0u; (i < n) && (ptr_ <= end.ptr_);)
                i += ptrdiff_t(_is_valid_codepoint_begin(*++ptr_));
        }
        else
        {
            for (ptrdiff_t i = 0u; (i < -n) && (ptr_ >= end.ptr_);)
                i += ptrdiff_t(_is_valid_codepoint_begin(*--ptr_));
        }
    }
    size_t previous_num_bytes() const
    {
        if (ptr_[-1] < 0b1000'0000u)
        {
            return 1u;
        }
        else if (ptr_[-2] >= 0b1100'0000u)
        {
            assert(_is_valid_codepoint_tailing(ptr_[-1]));
            return 2u;
        }
        else if (ptr_[-3] >= 0b1100'0000u)
        {
            assert(_is_valid_codepoint_tailing(ptr_[-1]));
            assert(_is_valid_codepoint_tailing(ptr_[-2]));
            return 3u;
        }
        else
        {
            assert(_is_valid_codepoint_tailing(ptr_[-1]));
            assert(_is_valid_codepoint_tailing(ptr_[-2]));
            assert(_is_valid_codepoint_tailing(ptr_[-3]));
            assert((*ptr_ > 0u) && _is_valid_codepoint_begin(ptr_[-4]));
            return 4u;
        }
    }
    size_t num_bytes() const
    {
        assert((*ptr_ > 0u) && _is_valid_codepoint_begin(*ptr_));
        if (*ptr_ < 0b1000'0000u)
        {
            return 1u;
        }
        else if (*ptr_ < 0b1110'0000u)
        {
            assert(_is_valid_codepoint_tailing(ptr_[1]));
            return 2u;
        }
        else if (*ptr_ < 0b1111'0000u)
        {
            assert(_is_valid_codepoint_tailing(ptr_[1]));
            assert(_is_valid_codepoint_tailing(ptr_[2]));
            return 3u;
        }
        else
        {
            assert(_is_valid_codepoint_tailing(ptr_[1]));
            assert(_is_valid_codepoint_tailing(ptr_[2]));
            assert(_is_valid_codepoint_tailing(ptr_[3]));
            return 4u;
        }
    }
    uint32_t codepoint() const
    {
        assert((*ptr_ > 0u) && _is_valid_codepoint_begin(*ptr_));
        switch (num_bytes())
        {
        case 1:
            return uint32_t(ptr_[0]);
        case 2:
            return uint32_t(
                ((ptr_[0] & 0b0001'1111) << 6) |
                ((ptr_[1] & 0b0011'1111)));
        case 3:
            return uint32_t(
                ((ptr_[0] & 0b0000'1111) << 12) |
                ((ptr_[1] & 0b0011'1111) << 6) |
                ((ptr_[2] & 0b0011'1111)));
        case 4:
            return uint32_t(
                ((ptr_[0] & 0b0000'0111) << 18) |
                ((ptr_[1] & 0b0011'1111) << 12) |
                ((ptr_[2] & 0b0011'1111) << 6) |
                ((ptr_[2] & 0b0011'1111)));
        default:
            return uint32_t(0);
        }
    }
};
}
union u8string
{
    static constexpr size_t small_string_byte_size = 28u; // excluding \0
    static_assert(sizeof(char) == 1u, WL_ERROR_SIZEOF_CHAR);
    enum class trilean_t : uint8_t { True, False, Unknown };
    
    struct static_t
    {
        static constexpr size_t capacity_ = small_string_byte_size;
        bool is_static_ = true;
        mutable trilean_t ascii_only_ = trilean_t::Unknown;
        uint8_t byte_size_ = 0u;
        utf8::char_t string_[small_string_byte_size + 1u];
        static_t() = default;
        static_t(size_t byte_size, trilean_t ascii_only) :
            byte_size_{uint8_t(byte_size)}, ascii_only_{ascii_only}
        {
            assert(byte_size_ <= capacity_);
        }
        void place_null_character()
        {
            string_[byte_size_] = utf8::null_character;
        }
        template<bool PlaceNull = true, bool UpdateASCII = true>
        void push(utf8::char_t ch)
        {
            assert(byte_size_ + 1u <= capacity_);
            string_[byte_size_++] = ch;
            if constexpr (UpdateASCII)
                if (!utf8::is_ascii(ch))
                    ascii_only_ = trilean_t::False;
            if constexpr (PlaceNull)
                place_null_character();
        }
        template<bool PlaceNull = true, bool UpdateASCII = true>
        void push(const utf8::char_t* ch, size_t size)
        {
            assert(byte_size_ + size <= capacity_);
            utils::restrict_copy_n(ch, size, string_ + byte_size_);
            byte_size_ += uint8_t(size);
            if constexpr (UpdateASCII)
                ascii_only_ = trilean_t::Unknown;
            if constexpr (PlaceNull)
                place_null_character();
        }
    };
    struct dynamic_t
    {
        bool is_static_ = false;
        mutable trilean_t ascii_only_ = trilean_t::Unknown;
        uint64_t byte_size_ = 0u;
        uint64_t capacity_ = 0u;
        utf8::char_t* string_ = nullptr;
        dynamic_t(size_t byte_size, trilean_t ascii_only) :
            byte_size_{byte_size}, ascii_only_{ascii_only}
        {
            resize_buffer(byte_size_);
        }
        dynamic_t(size_t byte_size, size_t capacity, trilean_t ascii_only) :
            byte_size_{byte_size}, ascii_only_{ascii_only}
        {
            capacity = std::max(byte_size, capacity);
            resize_buffer(capacity);
        }
        ~dynamic_t()
        {
            free_buffer();
        }
        dynamic_t(const dynamic_t& other)
        {
            ascii_only_ = other.ascii_only_;
            byte_size_  = other.byte_size_;
            resize_buffer(byte_size_);
            std::copy_n(other.string_, byte_size_ + 1u, string_);
        }
        dynamic_t(dynamic_t&& other)
        {
            ascii_only_ = other.ascii_only_;
            byte_size_  = other.byte_size_;
            std::swap(string_, other.string_);
            std::swap(capacity_, other.capacity_);
        }
        dynamic_t& operator=(const dynamic_t& other)
        {
            free_buffer();
            ascii_only_ = other.ascii_only_;
            byte_size_  = other.byte_size_;
            resize_buffer(byte_size_);
            std::copy_n(other.string_, byte_size_ + 1u, string_);
            return *this;
        }
        dynamic_t& operator=(dynamic_t&& other)
        {
            ascii_only_ = other.ascii_only_;
            byte_size_  = other.byte_size_;
            std::swap(string_, other.string_);
            std::swap(capacity_, other.capacity_);
            return *this;
        }
        void place_null_character()
        {
            string_[byte_size_] = utf8::null_character;
        }
        template<bool PlaceNull = true, bool UpdateASCII = true>
        void push(utf8::char_t ch)
        {
            if (byte_size_ >= capacity_)
                grow_buffer();
            assert(byte_size_ + 1u <= capacity_);
            string_[byte_size_++] = ch;
            if constexpr (UpdateASCII)
                if (!utf8::is_ascii(ch))
                    ascii_only_ = trilean_t::False;
            if constexpr (PlaceNull)
                place_null_character();
        }
        template<bool PlaceNull = true, bool UpdateASCII = true>
        void push(const utf8::char_t* ch, size_t size)
        {
            if (byte_size_ + size > capacity_)
                grow_buffer(size);
            assert(byte_size_ + size <= capacity_);
            utils::restrict_copy_n(ch, size, string_ + byte_size_);
            byte_size_ += uint8_t(size);
            if constexpr (UpdateASCII)
                ascii_only_ = trilean_t::Unknown;
            if constexpr (PlaceNull)
                place_null_character();
        }
        void resize_buffer(size_t new_capacity)
        {
            if (new_capacity <= capacity_)
                return;
            auto new_buffer_size = new_capacity + 1u;
            auto storage = (uint8_t*)std::realloc(string_, new_buffer_size);
            if (!storage)
                throw std::bad_alloc();
            string_ = storage;
            capacity_ = new_capacity;
        }
        void grow_buffer(size_t extra = 0u)
        {
            auto new_buffer_size = capacity_ + 1u;
            new_buffer_size += std::max(capacity_ + 1u, extra);
            auto storage = (uint8_t*)std::realloc(string_, new_buffer_size);
            if (!storage)
                throw std::bad_alloc();
            string_ = storage;
            capacity_ = new_buffer_size - 1u;
        }
        void free_buffer()
        {
            assert(string_);
            std::free(string_);
            capacity_ = 0u;
        }
    };
    
    static_assert(sizeof(bool) == 1u, WL_ERROR_INTERNAL);
    static_assert(sizeof(static_t) == 32u, WL_ERROR_INTERNAL);
    static_assert(sizeof(dynamic_t) == 32u, WL_ERROR_INTERNAL);
    static_t  static_;
    dynamic_t dynamic_;
    u8string()
    {
        new(&static_) static_t(0u, trilean_t::True);
        static_.place_null_character();
        assert(check_validity());
    }
    explicit u8string(size_t byte_size)
    {
        if (byte_size <= small_string_byte_size)
        {
            new(&static_) static_t(byte_size, trilean_t::Unknown);
            static_.place_null_character();
        }
        else
        {
            new(&dynamic_) dynamic_t(byte_size, trilean_t::Unknown);
            dynamic_.place_null_character();
        }
    }
    explicit u8string(size_t byte_size, bool ascii_only) : u8string(byte_size)
    {
        set_ascii_only(ascii_only);
    }
    u8string(const utf8::char_t* str, const size_t byte_size)
    {
        if (byte_size <= small_string_byte_size)
        {
            new(&static_) static_t(byte_size, trilean_t::Unknown);
            if (byte_size > 0)
                utils::restrict_copy_n(str, byte_size, static_.string_);
            static_.place_null_character();
        }
        else
        {
            new(&dynamic_) dynamic_t(byte_size, trilean_t::Unknown);
            utils::restrict_copy_n(str, byte_size, dynamic_.string_);
            dynamic_.place_null_character();
        }
        assert(check_validity());
    }
    u8string(const utf8::char_t* str, const size_t byte_size,
        bool ascii_only) : u8string(str, byte_size)
    {
        set_ascii_only(ascii_only);
        assert(check_validity());
    }
    template<size_t N>
    explicit u8string(const char(&str)[N]) :
        u8string((const utf8::char_t*)str, N - 1u)
    {
        static_assert(N >= 1u, WL_ERROR_INTERNAL);
        assert(check_validity());
    }
    template<size_t N>
    explicit u8string(const char(&str)[N], bool ascii_only) : u8string(str)
    {
        set_ascii_only(ascii_only);
        assert(check_validity());
    }
    u8string(const u8string& other)
    {
        copy_from(other);
        assert(check_validity());
    }
    u8string(u8string&& other)
    {
        swap_with(other);
        assert(check_validity());
    }
    ~u8string()
    {
        destroy();
    }
    u8string& operator=(const u8string& other)
    {
        destroy();
        copy_from(other);
        return *this;
    }
    u8string& operator=(u8string&& other)
    {
        swap_with(other);
        return *this;
    }
    void destroy()
    {
        if (!is_static())
            dynamic_.~dynamic_t();
    }
    void swap_with(u8string& other)
    {
        char buffer[sizeof(u8string)];
        std::memcpy(buffer, &other, sizeof(u8string));
        std::memcpy(&other, this, sizeof(u8string));
        std::memcpy(this, buffer, sizeof(u8string));
    }
    void copy_from(const u8string& other)
    {
        if (other.is_static())
        {
            new(&static_) static_t(other.static_);
        }
        else
        {
            const auto byte_size = other.byte_size();
            if (byte_size <= small_string_byte_size)
            { // convert to static
                new(&static_) static_t(byte_size, other.static_.ascii_only_);
                utils::restrict_copy_n(
                    other.byte_data(), byte_size + 1u, byte_data());
            }
            else
            { // remain dynamic
                new(&dynamic_) dynamic_t(byte_size, other.static_.ascii_only_);
                utils::restrict_copy_n(
                    other.byte_data(), byte_size + 1u, byte_data());
            }
        }
    }
    void set_dynamic_capacity(size_t capacity)
    {
        if (is_static())
        {
            const auto copy = static_;
            const auto byte_size = copy.byte_size_;
            const auto ascii_only = copy.ascii_only_;
            new(&dynamic_) dynamic_t(byte_size, capacity, ascii_only);
            utils::restrict_copy_n(
                copy.string_, byte_size + 1u, dynamic_.string_);
            dynamic_.ascii_only_ = copy.ascii_only_;
        }
        else
        {
            dynamic_.resize_buffer(capacity);
        }
    }
    WL_INLINE bool is_static() const
    {
        bool value;
        std::memcpy(&value, &static_.is_static_, sizeof(bool));
        return value;
    }
    WL_INLINE size_t byte_size() const
    {
        return is_static() ? static_.byte_size_ : dynamic_.byte_size_;
    }
    WL_INLINE size_t capacity() const
    {
        return is_static() ? static_.capacity_ : dynamic_.capacity_;
    }
    WL_INLINE size_t size() const
    {
        size_t string_size = 0;
        if (is_static())
        {
            if (static_.ascii_only_ == trilean_t::True)
                return static_.byte_size_;
            else
                string_size = utf8::get_string_size(
                    static_.string_, static_.byte_size_);
        }
        else
        {
            if (dynamic_.ascii_only_ == trilean_t::True)
                return dynamic_.byte_size_;
            else
                string_size = utf8::get_string_size(
                    dynamic_.string_, dynamic_.byte_size_);
        }
        set_ascii_only(string_size == byte_size());
        return string_size;
    }
    WL_INLINE uint8_t* byte_data()
    {
        return is_static() ? static_.string_ : dynamic_.string_;
    }
    WL_INLINE const uint8_t* byte_data() const
    {
        return is_static() ? static_.string_ : dynamic_.string_;
    }
    WL_INLINE const char* c_str() const
    {
        return reinterpret_cast<const char*>(byte_data());
    }
    bool ascii_only() const
    {
        auto only = is_static() ? &static_.ascii_only_ : &dynamic_.ascii_only_;
        if (*only == trilean_t::Unknown)
        {
            if (utf8::is_ascii_only(byte_data(), byte_size()))
                *only = trilean_t::True;
            else
                *only = trilean_t::False;
        }
        return *only == trilean_t::True ? true : false;
    }
    void set_ascii_only(bool ascii_only) const
    {
        auto only = is_static() ? &static_.ascii_only_ : &dynamic_.ascii_only_;
        *only = ascii_only ? trilean_t::True : trilean_t::False;
    }
    uint8_t* byte_begin() { return byte_data(); }
    uint8_t* byte_end() { return byte_data() + byte_size(); }
    const uint8_t* byte_begin() const { return byte_data(); }
    const uint8_t* byte_end() const { return byte_data() + byte_size(); }
    utf8::iterator begin() const { return utf8::iterator{byte_begin()}; }
    utf8::iterator end() const { return utf8::iterator{byte_end()}; }
    auto place_null_character()
    {
        if (is_static())
            static_.place_null_character();
        else
            dynamic_.place_null_character();
    }
    void append(const utf8::char_t* str, const size_t append_size)
    {
        const size_t new_byte_size = byte_size() + append_size;
        if (is_static())
        {
            if (new_byte_size > small_string_byte_size)
            {
                set_dynamic_capacity(new_byte_size);
                assert(!is_static());
                dynamic_.push(str, append_size);
            }
            else
            {
                static_.push(str, append_size);
            }
        }
        else
        {
            dynamic_.push(str, append_size);
        }
    }
    bool check_validity() const
    {
        if (capacity() < byte_size())
        {
            return false;
        }
        try
        {
            utf8::get_string_size<true>(byte_data(), byte_size());
            return true;
        }
        catch (std::logic_error&)
        {
            return false;
        }
    }
    std::string _ascii_string() const
    {
        std::string str(size(), ' ');
        const size_t size = this->size();
        auto begin = this->begin();
        auto end = this->end();
        for (size_t i = 0; i < size; ++i, ++begin)
        {
            const auto cp = *begin;
            str[i] = cp > 128u ? '?' : char(cp);
        }
        assert(begin == end);
        return str;
    }
    std::string _string_info() const
    {
        std::string info = "{ ";
        info += "is_static=" +
            std::string(is_static() ? "true" : "false") + ", ";
        info += "ascii_only=" +
            std::string(ascii_only() ? "true" : "false") + ", ";
        info += "size=" + std::to_string(size()) + ", ";
        info += "byte_size=" + std::to_string(byte_size()) + ", ";
        info += "capacity=" + std::to_string(capacity()) + ", ";
        info += "content=";
        info += _ascii_string();
        info += " }";
        return info;
    }
};
}
/*****************************************************************************
**
**  SRELL (std::regex-like library) version 2.500
**
**  Copyright (c) 2012-2019, Nozomu Katoo. All rights reserved.
**
**  Redistribution and use in source and binary forms, with or without
**  modification, are permitted provided that the following conditions are
**  met:
**
**  1. Redistributions of source code must retain the above copyright notice,
**     this list of conditions and the following disclaimer.
**
**  2. Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in the
**     documentation and/or other materials provided with the distribution.
**
**  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
**  IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
**  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
**  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
**  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
**  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
**  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
**  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
**  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
**  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
******************************************************************************
**/
#ifndef SRELL_REGEX_TEMPLATE_LIBRARY
#define SRELL_REGEX_TEMPLATE_LIBRARY
#if defined(__cpp_unicode_characters) && !defined(SRELL_CPP11_CHAR1632_ENABLED)
#define SRELL_CPP11_CHAR1632_ENABLED
#endif
#ifdef __cpp_initializer_lists
  #ifndef SRELL_CPP11_INITIALIZER_LIST_ENABLED
  #define SRELL_CPP11_INITIALIZER_LIST_ENABLED
  #endif
#endif
#ifdef __cpp_rvalue_references
  #ifndef SRELL_CPP11_MOVE_ENABLED
  #define SRELL_CPP11_MOVE_ENABLED
  #endif
#endif
#ifdef SRELL_CPP11_MOVE_ENABLED
  #if defined(_MSC_VER) && _MSC_VER < 1900
  #define SRELL_NOEXCEPT
  #else
  #define SRELL_NOEXCEPT noexcept
  #endif
#endif
#ifdef __cpp_char8_t
  #ifndef SRELL_CPP20_CHAR8_ENABLED
	#ifdef __cpp_lib_char8_t
	#define SRELL_CPP20_CHAR8_ENABLED 2
	#else
	#define SRELL_CPP20_CHAR8_ENABLED 1
	#endif
  #endif
#endif
#ifdef SRELL_NO_UNICODE_DATA
#define SRELL_NO_UNICODE_ICASE
#define SRELL_NO_UNICODE_PROPERTY
#endif
#ifdef SRELL_V1_COMPATIBLE
#ifndef SRELL_NO_UNICODE_PROPERTY
#define SRELL_NO_UNICODE_PROPERTY
#endif
#define SRELL_NO_NAMEDCAPTURE
#define SRELL_NO_SINGLELINE
#define SRELL_FIXEDWIDTHLOOKBEHIND
#endif
namespace srell
{
	namespace regex_constants
	{
		enum syntax_option_type
		{
			icase      = 1 << 0,
			nosubs     = 1 << 1,
			optimize   = 1 << 2,
			collate    = 1 << 3,
			ECMAScript = 1 << 4,
			basic      = 1 << 5,
			extended   = 1 << 6,
			awk        = 1 << 7,
			grep       = 1 << 8,
			egrep      = 1 << 9,
			multiline  = 1 << 10,
			//  SRELL's extension.
			dotall     = 1 << 11	//  singleline.
		};
		syntax_option_type operator&(const syntax_option_type &left, const syntax_option_type &right)
		{
			return static_cast<syntax_option_type>(static_cast<int>(left) & static_cast<int>(right));
		}
		syntax_option_type operator|(const syntax_option_type &left, const syntax_option_type &right)
		{
			return static_cast<syntax_option_type>(static_cast<int>(left) | static_cast<int>(right));
		}
		syntax_option_type operator^(const syntax_option_type &left, const syntax_option_type &right)
		{
			return static_cast<syntax_option_type>(static_cast<int>(left) ^ static_cast<int>(right));
		}
		syntax_option_type operator~(const syntax_option_type &b)
		{
			return static_cast<syntax_option_type>(~static_cast<int>(b));
		}
		syntax_option_type &operator&=(syntax_option_type &left, const syntax_option_type &right)
		{
			left = left & right;
			return left;
		}
		syntax_option_type &operator|=(syntax_option_type &left, const syntax_option_type &right)
		{
			left = left | right;
			return left;
		}
		syntax_option_type &operator^=(syntax_option_type &left, const syntax_option_type &right)
		{
			left = left ^ right;
			return left;
		}
	}
	//  namespace regex_constants
	namespace regex_constants
	{
		enum match_flag_type
		{
			match_default     = 0,
			match_not_bol     = 1 <<  0,
			match_not_eol     = 1 <<  1,
			match_not_bow     = 1 <<  2,
			match_not_eow     = 1 <<  3,
			match_any         = 1 <<  4,
			match_not_null    = 1 <<  5,
			match_continuous  = 1 <<  6,
			match_prev_avail  = 1 <<  7,
			format_default    = 0,
			format_sed        = 1 <<  8,
			format_no_copy    = 1 <<  9,
			format_first_only = 1 << 10,
			//  SRELL's extension.
			match_lblim_avail = 1 << 13,	//  lookbehind limit.
				//  Not only the sequence [first, last) passed to an algorithm function,
				//  but also [m.lblim, first) where m is an instance of match_results is a
				//  valid iterator range.  When this flag is set the character ^ matches
				//  [m.lblim, m.lblims), not [first, first).  I.e., searching against
				//  [m.lblim, last) begins at first in the sequence.
			//  For internal use.
			match_last_tried_ = 1 << 11,
			match_match_      = 1 << 12
		};
		match_flag_type operator&(const match_flag_type &left, const match_flag_type &right)
		{
			return static_cast<match_flag_type>(static_cast<int>(left) & static_cast<int>(right));
		}
		match_flag_type operator|(const match_flag_type &left, const match_flag_type &right)
		{
			return static_cast<match_flag_type>(static_cast<int>(left) | static_cast<int>(right));
		}
		match_flag_type operator^(const match_flag_type &left, const match_flag_type &right)
		{
			return static_cast<match_flag_type>(static_cast<int>(left) ^ static_cast<int>(right));
		}
		match_flag_type operator~(const match_flag_type &b)
		{
			return static_cast<match_flag_type>(~static_cast<int>(b));
		}
		match_flag_type &operator&=(match_flag_type &left, const match_flag_type &right)
		{
			left = left & right;
			return left;
		}
		match_flag_type &operator|=(match_flag_type &left, const match_flag_type &right)
		{
			left = left | right;
			return left;
		}
		match_flag_type &operator^=(match_flag_type &left, const match_flag_type &right)
		{
			left = left ^ right;
			return left;
		}
	}
	//  namespace regex_constants
	//  28.5, regex constants:
	namespace regex_constants
	{
		typedef int error_type;
		static const error_type error_collate    = 100;
		static const error_type error_ctype      = 101;
		static const error_type error_escape     = 102;
		static const error_type error_backref    = 103;
		static const error_type error_brack      = 104;
		static const error_type error_paren      = 105;
		static const error_type error_brace      = 106;
		static const error_type error_badbrace   = 107;
		static const error_type error_range      = 108;
		static const error_type error_space      = 109;
		static const error_type error_badrepeat  = 110;
		static const error_type error_complexity = 111;
		static const error_type error_stack      = 112;
#if defined(SRELL_FIXEDWIDTHLOOKBEHIND)
		static const error_type error_lookbehind = 200;
#endif
		static const error_type error_internal   = 999;
	}
	//  namespace regex_constants
class regex_error : public std::runtime_error
{
public:
	explicit regex_error(const regex_constants::error_type ecode)
		: std::runtime_error("regex_error")	//  added for error C2512.
		, ecode_(ecode)
	{
	}
	regex_constants::error_type code() const
	{
		return ecode_;
	}
private:
	regex_constants::error_type ecode_;
};
	namespace regex_internal
	{
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
		typedef char32_t uchar21_t;
#else	//  !defined(SRELL_CPP11_CHAR1632_ENABLED)
	#if defined(WCHAR_MAX) && WCHAR_MAX >= 0x1FFFFF
		typedef wchar_t uchar21_t;
	#elif defined(UINT_MAX) && UINT_MAX >= 0x1FFFFF
		typedef unsigned int uchar21_t;
	#elif defined(ULONG_MAX) && ULONG_MAX >= 0x1FFFFF
		typedef unsigned long uchar21_t;
	#else
		#error could not find a suitable type for 21-bit Unicode integers.
	#endif
#endif	//  defined(SRELL_CPP11_CHAR1632_ENABLED)
	}	//  regex_internal
	namespace regex_internal
	{
		enum re_state_type
		{
			st_character,               //  0x00
			st_character_class,         //  0x01
			st_epsilon,                 //  0x02
			st_check_counter,           //  0x03
			st_increment_counter,       //  0x04
			st_decrement_counter,       //  0x05
			st_save_and_reset_counter,  //  0x06
			st_restore_counter,         //  0x07
			st_roundbracket_open,       //  0x08
			st_roundbracket_pop,        //  0x09
			st_roundbracket_close,      //  0x0a
			st_repeat_in_push,          //  0x0b
			st_repeat_in_pop,           //  0x0c
			st_check_0_width_repeat,    //  0x0d
			st_backreference,           //  0x0e
			st_lookaround_open,         //  0x0f
			st_lookaround_pop,          //  0x10
			st_bol,                     //  0x11
			st_eol,                     //  0x12
			st_boundary,                //  0x13
			st_success,                 //  0x14
#if !defined(SRELLDBG_NO_NEXTPOS_OPT)
			st_move_nextpos,            //  0x15
#endif
			st_lookaround_close        = st_success,
			st_zero_width_boundary     = st_lookaround_open,
			//st_assertions_boundary     = st_lookaround_open,
		};
		//  re_state_type
		namespace constants
		{
			static const uchar21_t unicode_max_codepoint = 0x10ffff;
			static const uchar21_t invalid_u21value = static_cast<uchar21_t>(~0);
			static const uchar21_t replacement_character = 0xfffd;
		}
		//  constants
		namespace meta_char
		{
			static const uchar21_t mc_exclam = 0x21;	//  '!'
			static const uchar21_t mc_dollar = 0x24;	//  '$'
			static const uchar21_t mc_rbraop = 0x28;	//  '('
			static const uchar21_t mc_rbracl = 0x29;	//  ')'
			static const uchar21_t mc_astrsk = 0x2a;	//  '*'
			static const uchar21_t mc_plus   = 0x2b;	//  '+'
			static const uchar21_t mc_comma  = 0x2c;	//  ','
			static const uchar21_t mc_minus  = 0x2d;	//  '-'
			static const uchar21_t mc_period = 0x2e;	//  '.'
			static const uchar21_t mc_colon  = 0x3a;	//  ':'
			static const uchar21_t mc_lt = 0x3c;		//  '<'
			static const uchar21_t mc_eq = 0x3d;		//  '='
			static const uchar21_t mc_gt = 0x3e;		//  '>'
			static const uchar21_t mc_query  = 0x3f;	//  '?'
			static const uchar21_t mc_sbraop = 0x5b;	//  '['
			static const uchar21_t mc_escape = 0x5c;	//  '\\'
			static const uchar21_t mc_sbracl = 0x5d;	//  ']'
			static const uchar21_t mc_caret  = 0x5e;	//  '^'
			static const uchar21_t mc_cbraop = 0x7b;	//  '{'
			static const uchar21_t mc_bar    = 0x7c;	//  '|'
			static const uchar21_t mc_cbracl = 0x7d;	//  '}'
		}
		//  meta_char
		namespace char_ctrl
		{
			static const uchar21_t cc_nul  = 0x00;	//  '\0'	//0x00:NUL
			static const uchar21_t cc_bs   = 0x08;	//  '\b'	//0x08:BS
			static const uchar21_t cc_htab = 0x09;	//  '\t'	//0x09:HT
			static const uchar21_t cc_nl   = 0x0a;	//  '\n'	//0x0a:LF
			static const uchar21_t cc_vtab = 0x0b;	//  '\v'	//0x0b:VT
			static const uchar21_t cc_ff   = 0x0c;	//  '\f'	//0x0c:FF
			static const uchar21_t cc_cr   = 0x0d;	//  '\r'	//0x0d:CR
		}
		//  char_ctrl
		namespace char_alnum
		{
			static const uchar21_t ch_0 = 0x30;	//  '0'
			static const uchar21_t ch_1 = 0x31;	//  '1'
			static const uchar21_t ch_7 = 0x37;	//  '7'
			static const uchar21_t ch_8 = 0x38;	//  '8'
			static const uchar21_t ch_9 = 0x39;	//  '9'
			static const uchar21_t ch_A = 0x41;	//  'A'
			static const uchar21_t ch_B = 0x42;	//  'B'
			static const uchar21_t ch_D = 0x44;	//  'D'
			static const uchar21_t ch_F = 0x46;	//  'F'
			static const uchar21_t ch_P = 0x50;	//  'P'
			static const uchar21_t ch_S = 0x53;	//  'S'
			static const uchar21_t ch_W = 0x57;	//  'W'
			static const uchar21_t ch_Z = 0x5a;	//  'Z'
			static const uchar21_t ch_a = 0x61;	//  'a'
			static const uchar21_t ch_b = 0x62;	//  'b'
			static const uchar21_t ch_c = 0x63;	//  'c'
			static const uchar21_t ch_d = 0x64;	//  'd'
			static const uchar21_t ch_f = 0x66;	//  'f'
			static const uchar21_t ch_k = 0x6b;	//  'k'
			static const uchar21_t ch_n = 0x6e;	//  'n'
			static const uchar21_t ch_p = 0x70;	//  'p'
			static const uchar21_t ch_r = 0x72;	//  'r'
			static const uchar21_t ch_s = 0x73;	//  's'
			static const uchar21_t ch_t = 0x74;	//  't'
			static const uchar21_t ch_u = 0x75;	//  'u'
			static const uchar21_t ch_v = 0x76;	//  'v'
			static const uchar21_t ch_w = 0x77;	//  'w'
			static const uchar21_t ch_x = 0x78;	//  'x'
			static const uchar21_t ch_z = 0x7a;	//  'z'
		}
		//  char_alnum
		namespace char_other
		{
			static const uchar21_t co_sp    = 0x20;	//  ' '
			static const uchar21_t co_amp   = 0x26;	//  '&'
			static const uchar21_t co_apos  = 0x27;	//  '\''
			static const uchar21_t co_slash = 0x2f;	//  '/'
			static const uchar21_t co_ll    = 0x5f;	//  '_'
			static const uchar21_t co_grav  = 0x60;	//  '`'
		}
		//  char_other
	}
	//  namespace regex_internal
	namespace regex_internal
	{
template <typename charT>
struct utf_traits_core
{
public:
	static const std::size_t maxseqlen = 1;
	//  *iter
	template <typename ForwardIterator>
	static uchar21_t codepoint(ForwardIterator begin, const ForwardIterator /* end */)
	{
		return static_cast<uchar21_t>(*begin);
		//  Caller is responsible for begin != end.
	}
	//  *iter++
	template <typename ForwardIterator>
	static uchar21_t codepoint_inc(ForwardIterator &begin, const ForwardIterator /* end */)
	{
		return static_cast<uchar21_t>(*begin++);
		//  Caller is responsible for begin != end.
	}
	//  iter2 = iter; return *--iter2;
	template <typename BidirectionalIterator>
	static uchar21_t prevcodepoint(BidirectionalIterator cur)
	{
		return static_cast<uchar21_t>(*--cur);
		//  No range check is done on purpose. As this function is called
		//  when regex_constants::match_prev_avail is specified, it is
		//  possible to exceed [begin, end).
	}
	//  *--iter
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur, const BidirectionalIterator /* begin */)
	{
		return static_cast<uchar21_t>(*--cur);
		//  Caller is responsible for cur != begin.
	}
#if !defined(SRELLDBG_NO_BMH)
	//  *--iter without range check.
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur)
	{
		return static_cast<uchar21_t>(*--cur);
	}
	//  iter += advsize
	template <typename ForwardIterator>
	static bool advance(ForwardIterator &begin, const ForwardIterator end, std::size_t advsize)
	{
		//  Caller is responsible for begin != end.
		for (++begin; begin != end; ++begin)
		{
			if (--advsize == 0)
				return true;
		}
		return false;	//  reaching end.
	}
	template <typename ForwardIterator>
	static bool is_trailing(const ForwardIterator /* begin */)
	{
		return false;
	}
	static uchar21_t to_codeunits(charT out[maxseqlen], uchar21_t cp)
	{
		out[0] = static_cast<charT>(cp);
		return 1;
	}
#endif	//  !defined(SRELLDBG_NO_BMH)
	template <typename ForwardIterator>
	static bool seek_charboundary(ForwardIterator &begin, const ForwardIterator end)
	{
		return begin != end;
	}
};	//  utf_traits_core
template <class charT>
struct utf_traits : public utf_traits_core<charT>
{
};	//  utf_traits
template <class charT>
struct utf8_traits : public utf_traits_core<charT>
{
public:
	//  utf-8 specific.
	static const std::size_t maxseqlen = 4;
	template <typename ForwardIterator>
	static uchar21_t codepoint(ForwardIterator begin, const ForwardIterator end)
	{
		uchar21_t codepoint = static_cast<uchar21_t>(*begin);
		if ((codepoint & 0x80) == 0)	//  1 octet
		{
			return static_cast<uchar21_t>(codepoint & 0x7f);
		}
		else if (++begin != end)
		{
			if ((codepoint & 0xe0) == 0xc0)	//  2 octets
			{
				if ((*begin & 0xc0) == 0x80)
					return static_cast<uchar21_t>(((codepoint << 6) | (*begin & 0x3f)) & 0x7ff);
			}
			else if ((codepoint & 0xf0) == 0xe0)	//  3 octets
			{
				if ((*begin & 0xc0) == 0x80)
				{
					codepoint = static_cast<uchar21_t>((codepoint << 6) | (*begin & 0x3f));
					if (++begin != end && (*begin & 0xc0) == 0x80)
						return static_cast<uchar21_t>(((codepoint << 6) | (*begin & 0x3f)) & 0xffff);
				}
			}
			else if ((codepoint & 0xf8) == 0xf0)	//  4 octets
			{
				if ((*begin & 0xc0) == 0x80)
				{
					codepoint = static_cast<uchar21_t>((codepoint << 6) | (*begin & 0x3f));
					if (++begin != end && (*begin & 0xc0) == 0x80)
					{
						codepoint = static_cast<uchar21_t>((codepoint << 6) | (*begin & 0x3f));
						if (++begin != end && (*begin & 0xc0) == 0x80)
							return static_cast<uchar21_t>(((codepoint << 6) | (*begin & 0x3f)) & 0x1fffff);
					}
				}
			}
		}
		return regex_internal::constants::replacement_character;
	}
	template <typename ForwardIterator>
	static uchar21_t codepoint_inc(ForwardIterator &begin, const ForwardIterator end)
	{
		uchar21_t codepoint = static_cast<uchar21_t>(*begin++);
		if ((codepoint & 0x80) == 0)	//  1 octet
		{
			return static_cast<uchar21_t>(codepoint & 0x7f);
		}
		else if (begin != end)
		{
			if ((codepoint & 0xe0) == 0xc0)	//  2 octets
			{
				//  c080-c1bf: invalid. 00-7F.
				//  c280-dfbf: valid. 080-7FF.
				if ((*begin & 0xc0) == 0x80)	//  1 1111 11 1111
					return static_cast<uchar21_t>(((codepoint << 6) | (*begin++ & 0x3f)) & 0x7ff);
			}
			else if ((codepoint & 0xf0) == 0xe0)	//  3 octets
			{
				//  e08080-e09fbf: invalid. 000-7FF.
				//  e0a080-efbfbf: valid. 0800-FFFF.
				if ((*begin & 0xc0) == 0x80)
				{
					codepoint = static_cast<uchar21_t>((codepoint << 6) | (*begin & 0x3f));
					if (++begin != end && (*begin & 0xc0) == 0x80)	//  1111 11 1111 11 1111
						return static_cast<uchar21_t>(((codepoint << 6) | (*begin++ & 0x3f)) & 0xffff);
				}
			}
			else if ((codepoint & 0xfc) == 0xf0)	//  4 octets, f0-f3.
			{
				//  f0808080-f08fbfbf: invalid. 0000-FFFF.
				//  f0908080-f3bfbfbf: valid. 10000-FFFFF.
				if ((*begin & 0xc0) == 0x80)
				{
					FOUROCTETS:
					codepoint = static_cast<uchar21_t>((codepoint << 6) | (*begin & 0x3f));
					if (++begin != end && (*begin & 0xc0) == 0x80)
					{
						codepoint = static_cast<uchar21_t>((codepoint << 6) | (*begin & 0x3f));
																		//  100 00 | 1111 11 11|11 11 1111
						if (++begin != end && (*begin & 0xc0) == 0x80)	//  011 11 | 1111 11 11|11 11 1111
							return static_cast<uchar21_t>(((codepoint << 6) | (*begin++ & 0x3f)) & 0x1fffff);
					}
				}
			}
			else if ((codepoint & 0xff) == 0xf4)	//  4 octets. f4.
			{
				//  f4808080-f48fbfbf: valid. 100000-10FFFF.
				//  f4908080-f7bfbfbf: invalid. 110000-1FFFFF.
				if ((*begin & 0xf0) == 0x80)	//  f4 80-8f.
					goto FOUROCTETS;
			}
		}
		//  Commented out to make the behaviour consistent with dec_codepoint(BidiIter &);
		//  f0 9b 80 80 81 82 40 -> 1B000, FFFD, FFFD, 0040, instead of 1B000, FFFD, 0040.
		return regex_internal::constants::replacement_character;
	}
	template <typename BidirectionalIterator>
	static uchar21_t prevcodepoint(BidirectionalIterator cur)
	{
		if ((*--cur & 0x80) == 0)
			return static_cast<uchar21_t>(*cur & 0x7f);
		if ((*cur & 0xc0) == 0x80)
		{
			uchar21_t codepoint = static_cast<uchar21_t>(*cur & 0x3f);
			if ((*--cur & 0xe0) == 0xc0)
				return static_cast<uchar21_t>((codepoint | (*cur << 6)) & 0x7ff);
			if ((*cur & 0xc0) == 0x80)
			{
				codepoint = static_cast<uchar21_t>(codepoint | ((*cur & 0x3f) << 6));
				if ((*--cur & 0xf0) == 0xe0)
					return static_cast<uchar21_t>((codepoint | (*cur << 12)) & 0xffff);
				if ((*cur & 0xc0) == 0x80)
				{
					codepoint = static_cast<uchar21_t>(codepoint | ((*cur & 0x3f) << 12));
					if ((*--cur & 0xf8) == 0xf0)
						return static_cast<uchar21_t>((codepoint | (*cur << 18)) & 0x1fffff);
				}
			}
		}
		return regex_internal::constants::replacement_character;
	}
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur, const BidirectionalIterator begin)
	{
		if ((*--cur & 0x80) == 0)
			return static_cast<uchar21_t>(*cur & 0x7f);
		if ((*cur & 0xc0) == 0x80 && cur != begin)
		{
			uchar21_t codepoint = static_cast<uchar21_t>(*cur & 0x3f);
			if ((*--cur & 0xe0) == 0xc0)
				return static_cast<uchar21_t>((codepoint | (*cur << 6)) & 0x7ff);
			if ((*cur & 0xc0) == 0x80 && cur != begin)
			{
				codepoint = static_cast<uchar21_t>(codepoint | ((*cur & 0x3f) << 6));
				if ((*--cur & 0xf0) == 0xe0)
					return static_cast<uchar21_t>((codepoint | (*cur << 12)) & 0xffff);
				if ((*cur & 0xc0) == 0x80 && cur != begin)
				{
					codepoint = static_cast<uchar21_t>(codepoint | ((*cur & 0x3f) << 12));
					if ((*--cur & 0xf8) == 0xf0)
						return static_cast<uchar21_t>((codepoint | (*cur << 18)) & 0x1fffff);
					++cur;
				}
				++cur;
			}
			++cur;
		}
		return regex_internal::constants::replacement_character;
	}
#if !defined(SRELLDBG_NO_BMH)
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur)
	{
		//  As we go back the way we came, already know that there is a [\x00-\x7f\xc0-\xff] backwards.
		if ((*--cur & 0x80) == 0)
			return static_cast<uchar21_t>(*cur & 0x7f);
		if ((*cur & 0xc0) == 0x80)
		{
			uchar21_t codepoint = static_cast<uchar21_t>(*cur & 0x3f);
			if ((*--cur & 0xe0) == 0xc0)
				return static_cast<uchar21_t>((codepoint | (*cur << 6)) & 0x7ff);
			if ((*cur & 0xc0) == 0x80)	//  [\x80-\xbf]{2}.
			{
				codepoint = static_cast<uchar21_t>(codepoint | ((*cur & 0x3f) << 6));
				if ((*--cur & 0xf0) == 0xe0)
					return static_cast<uchar21_t>((codepoint | (*cur << 12)) & 0xffff);
				if ((*cur & 0xc0) == 0x80)	//  [\x80-\xbf]{3}.
				{
					codepoint = static_cast<uchar21_t>(codepoint | ((*cur & 0x3f) << 12));
					if ((*--cur & 0xf8) == 0xf0)
						return static_cast<uchar21_t>((codepoint | (*cur << 18)) & 0x1fffff);
					//else	//  [\0-\xef\xf8-\xff][\x80-\xbf]{3}.
					//  Sequences [\xc0-\xdf][\x80-\xbf] and [\xe0-\xef][\x80-\xbf]{2} are valid.
					//  To give a chance to them, rewinds cur.
					++cur;
				}
				//else	//  [\0-\x7f\xc0-\xdf\xf0-\xff][\x80-\xbf]{2}.
				++cur;	//  Sequence [\xc0-\xdf][\x80-\xbf] is valid. Rewinds to give a chance to it.
			}
			//else	//  [\0-\x7f\xe0-\xff][\x80-\xbf].
			++cur;	//  Rewinds to give a chance to [\0-\x7f].
		}
		//else	//  [\xc0-\xff].
		//  This can yield multiple U+FFFDs per invalid UTF-8 sequence. E.g,:
		//  f0 9b 80 80 81 82 40 -> 0040, FFFD, FFFD, 1B000, instead of 0040, FFFD, 1B000.
		return regex_internal::constants::replacement_character;
	}
	template <typename ForwardIterator>
	static bool advance(ForwardIterator &begin, const ForwardIterator end, std::size_t advsize)
	{
		for (++begin; begin != end; ++begin)
		{
			if ((*begin & 0xc0) != 0x80)
				if (--advsize == 0)
					return true;
		}
		return false;
	}
	template <typename ForwardIterator>
	static bool is_trailing(const ForwardIterator begin)
	{
		return (*begin & 0xc0) == 0x80;
	}
	static uchar21_t to_codeunits(charT out[maxseqlen], uchar21_t cp)
	{
		if (cp < 0x80)
		{
			out[0] = static_cast<charT>(cp);
			return 1;
		}
		else if (cp < 0x800)
		{
			out[0] = static_cast<charT>(((cp >> 6) & 0x1f) | 0xc0);
			out[1] = static_cast<charT>((cp & 0x3f) | 0x80);
			return 2;
		}
		else if (cp < 0x10000)
		{
			out[0] = static_cast<charT>(((cp >> 12) & 0x0f) | 0xe0);
			out[1] = static_cast<charT>(((cp >> 6) & 0x3f) | 0x80);
			out[2] = static_cast<charT>((cp & 0x3f) | 0x80);
			return 3;
		}
		{
			out[0] = static_cast<charT>(((cp >> 18) & 0x07) | 0xf0);
			out[1] = static_cast<charT>(((cp >> 12) & 0x3f) | 0x80);
			out[2] = static_cast<charT>(((cp >> 6) & 0x3f) | 0x80);
			out[3] = static_cast<charT>((cp & 0x3f) | 0x80);
			return 4;
		}
	}
#endif	//  !defined(SRELLDBG_NO_BMH)
	template <typename ForwardIterator>
	static bool seek_charboundary(ForwardIterator &begin, const ForwardIterator end)
	{
		for (; begin != end; ++begin)
		{
			if ((*begin & 0xc0) != 0x80)	//  00-7f, c0-ff.
				return true;
		}
		return false;
	}
};	//  utf8_traits
template <class charT>
struct utf16_traits : public utf_traits_core<charT>
{
public:
	//  utf-16 specific.
	static const std::size_t maxseqlen = 2;
	template <typename ForwardIterator>
	static uchar21_t codepoint(ForwardIterator begin, const ForwardIterator end)
	{
		const charT codeunit = *begin;
		if ((codeunit & 0xdc00) != 0xd800)
			return static_cast<uchar21_t>(codeunit & 0xffff);
		if (++begin != end && (*begin & 0xdc00) == 0xdc00)
			return static_cast<uchar21_t>((((codeunit & 0x3ff) << 10) | (*begin & 0x3ff)) + 0x10000);
		return static_cast<uchar21_t>(codeunit & 0xffff);
	}
	template <typename ForwardIterator>
	static uchar21_t codepoint_inc(ForwardIterator &begin, const ForwardIterator end)
	{
		const charT codeunit = *begin++;
		if ((codeunit & 0xdc00) != 0xd800)
			return static_cast<uchar21_t>(codeunit & 0xffff);
		if (begin != end && (*begin & 0xdc00) == 0xdc00)
			return static_cast<uchar21_t>((((codeunit & 0x3ff) << 10) | (*begin++ & 0x3ff)) + 0x10000);
		return static_cast<uchar21_t>(codeunit & 0xffff);
	}
	template <typename BidirectionalIterator>
	static uchar21_t prevcodepoint(BidirectionalIterator cur)
	{
		const charT codeunit = *--cur;
		if ((codeunit & 0xdc00) != 0xdc00)
			return static_cast<uchar21_t>(codeunit & 0xffff);
		if ((*--cur & 0xdc00) == 0xd800)
			return static_cast<uchar21_t>((((*cur & 0x3ff) << 10) | (codeunit & 0x3ff)) + 0x10000);
		return static_cast<uchar21_t>(codeunit & 0xffff);
	}
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur, const BidirectionalIterator begin)
	{
		const charT codeunit = *--cur;
		if ((codeunit & 0xdc00) != 0xdc00 || cur == begin)
			return static_cast<uchar21_t>(codeunit & 0xffff);
		if ((*--cur & 0xdc00) == 0xd800)
			return static_cast<uchar21_t>((((*cur & 0x3ff) << 10) | (codeunit & 0x3ff)) + 0x10000);
		//else	//  (codeunit & 0xdc00) == 0xdc00 && (*cur & 0xdc00) != 0xd800
			++cur;
		return static_cast<uchar21_t>(codeunit & 0xffff);
	}
#if !defined(SRELLDBG_NO_BMH)
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur)
	{
		const charT codeunit = *--cur;
		if ((codeunit & 0xdc00) != 0xdc00)
			return static_cast<uchar21_t>(codeunit & 0xffff);
		if ((*--cur & 0xdc00) == 0xd800)
			return static_cast<uchar21_t>((((*cur & 0x3ff) << 10) | (codeunit & 0x3ff)) + 0x10000);
		//else	//  (codeunit & 0xdc00) == 0xdc00 && (*cur & 0xdc00) != 0xd800
			++cur;
		return static_cast<uchar21_t>(codeunit & 0xffff);
	}
	template <typename ForwardIterator>
	static bool advance(ForwardIterator &begin, const ForwardIterator end, std::size_t advsize)
	{
		for (++begin; begin != end; ++begin)
		{
			if ((*begin & 0xdc00) != 0xdc00)
				if (--advsize == 0)
					return true;
		}
		return false;
	}
	template <typename ForwardIterator>
	static bool is_trailing(const ForwardIterator begin)
	{
		return (*begin & 0xdc00) == 0xdc00;
	}
	static uchar21_t to_codeunits(charT out[maxseqlen], uchar21_t cp)
	{
		if (cp < 0x10000)
		{
			out[0] = static_cast<charT>(cp);
			return 1;
		}
		{
			cp -= 0x10000;
			out[0] = static_cast<charT>(((cp >> 10) & 0x3ff) | 0xd800);
			out[1] = static_cast<charT>((cp & 0x3ff) | 0xdc00);
			return 2;
		}
	}
#endif	//  !defined(SRELLDBG_NO_BMH)
	template <typename ForwardIterator>
	static bool seek_charboundary(ForwardIterator &begin, const ForwardIterator end)
	{
		for (; begin != end; ++begin)
		{
			if ((*begin & 0xdc00) != 0xdc00)
				return true;
		}
		return false;
	}
};	//  utf16_traits
template <>
struct utf_traits<char> : public utf_traits_core<char>
{
public:
	template <typename ForwardIterator>
	static uchar21_t codepoint(ForwardIterator begin, const ForwardIterator /* end */)
	{
		return static_cast<uchar21_t>(static_cast<unsigned char>(*begin));
	}
	template <typename ForwardIterator>
	static uchar21_t codepoint_inc(ForwardIterator &begin, const ForwardIterator /* end */)
	{
		return static_cast<uchar21_t>(static_cast<unsigned char>(*begin++));
	}
	template <typename BidirectionalIterator>
	static uchar21_t prevcodepoint(BidirectionalIterator cur)
	{
		return static_cast<uchar21_t>(static_cast<unsigned char>(*--cur));
	}
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur, const BidirectionalIterator /* begin */)
	{
		return static_cast<uchar21_t>(static_cast<unsigned char>(*--cur));
	}
#if !defined(SRELLDBG_NO_BMH)
	template <typename BidirectionalIterator>
	static uchar21_t dec_codepoint(BidirectionalIterator &cur)
	{
		return static_cast<uchar21_t>(static_cast<unsigned char>(*--cur));
	}
#endif	//  !defined(SRELLDBG_NO_BMH)
};	//  utf_traits<char>
template <>
struct utf_traits<signed char> : public utf_traits<char>
{
};
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
template <>
struct utf_traits<char16_t> : public utf16_traits<char16_t>
{
};
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED)
template <>
struct utf_traits<char8_t> : public utf8_traits<char8_t>
{
};
#endif
#if !defined(SRELL_NO_NAMEDCAPTURE)
	//  for match_results::format(), operator[](...) const.
template <typename charT>
struct utf_translator : utf_traits<charT>
{
};
template <>
struct utf_translator<char> : utf8_traits<char>
{
};
#if defined(WCHAR_MAX)
  #if WCHAR_MAX >= 0x10ffff
	//  ok with the default.
  #elif WCHAR_MAX >= 0xffff
template <>
struct utf_translator<wchar_t> : utf16_traits<wchar_t>
{
};
  #endif
#endif
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
template <>
struct utf_translator<char16_t> : utf16_traits<char16_t>
{
};
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED)
template <>
struct utf_translator<char8_t> : utf8_traits<char8_t>
{
};
#endif
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
	}	//  regex_internal
template <class charT>
struct regex_traits
{
public:
	typedef charT char_type;
	typedef std::basic_string<char_type> string_type;
	typedef std::locale locale_type;
	typedef unsigned int char_class_type;
	typedef regex_internal::utf_traits<charT> utf_traits;
public:
	static std::size_t length(const char_type *p)
	{
		return std::char_traits<charT>::length(p);
	}
	charT translate(const charT c) const
	{
		return c;
	}
	charT translate_nocase(const charT c) const
	{
		return c;
	}
	template <class ForwardIterator>
	string_type transform(ForwardIterator first, ForwardIterator last) const
	{
		return string_type(first, last);
	}
	template <class ForwardIterator>
	string_type transform_primary(ForwardIterator first, ForwardIterator last) const
	{
		return string_type(first, last);
	}
	template <class ForwardIterator>
	string_type lookup_collatename(ForwardIterator first, ForwardIterator last) const
	{
		return string_type(first, last);
	}
	template <class ForwardIterator>
	char_class_type lookup_classname(ForwardIterator /* first */, ForwardIterator /* last */, bool /* icase */ = false) const
	{
		return static_cast<char_class_type>(0);
	}
	bool isctype(const charT /* c */, const char_class_type /* f */) const
	{
		return false;
	}
	int value(const charT /* ch */, const int /* radix */) const
	{
		return -1;
	}
	locale_type imbue(const locale_type /* l */)
	{
		return locale_type();
	}
	locale_type getloc() const
	{
		return locale_type();
	}
};	//  regex_traits
template <class charT>
struct u8regex_traits : public regex_traits<charT>
{
	typedef regex_internal::utf8_traits<charT> utf_traits;
};
template <class charT>
struct u16regex_traits : public regex_traits<charT>
{
	typedef regex_internal::utf16_traits<charT> utf_traits;
};
	namespace regex_internal
	{
/*
 *  Similar to std::basic_string, except for:
 *    a. only allocates memory, does not initialise it.
 *    b. uses realloc() to avoid moving data as much as possible when
 *       resizing an allocated buffer.
 */
template <typename ElemT>
class simple_array
{
public:
	typedef ElemT value_type;
	typedef std::size_t size_type;
	typedef ElemT &reference;
	typedef const ElemT &const_reference;
	typedef ElemT *pointer;
	typedef const ElemT *const_pointer;
	static const size_type npos = static_cast<size_type>(-1);
public:
	simple_array()
		: buffer_(NULL)
		, size_(0)
		, capacity_(0)
	{
	}
	simple_array(const size_type initsize)
		: buffer_(static_cast<pointer>(std::malloc(initsize * sizeof (ElemT))))
		, size_(initsize)
		, capacity_(initsize)
	{
		if (buffer_ == NULL)
		{
			size_ = capacity_ = 0;
			throw std::bad_alloc();
		}
	}
	simple_array(const simple_array &right, size_type pos, size_type size = npos)
	{
		if (pos > right.size_)
			pos = right.size_;
		if (size > right.size_ - pos)
			size = right.size_ - pos;
		buffer_ = static_cast<pointer>(std::malloc(size * sizeof (ElemT)));
		if (buffer_ != NULL)
		{
			for (size_ = 0; size_ < size; ++size_, ++pos)
				buffer_[size_] = right[pos];
			capacity_ = size_;
			return;
		}
		size_ = capacity_ = 0;
		throw std::bad_alloc();
	}
	simple_array(const simple_array &right)
		: buffer_(NULL)
		, size_(0)
		, capacity_(0)
	{
		operator=(right);
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	simple_array(simple_array &&right) SRELL_NOEXCEPT
		: buffer_(right.buffer_)
		, size_(right.size_)
		, capacity_(right.capacity_)
	{
		right.size_ = 0;
		right.capacity_ = 0;
		right.buffer_ = NULL;
	}
#endif
	simple_array &operator=(const simple_array &right)
	{
		if (this != &right)
		{
			resize(right.size_);
			for (size_type i = 0; i < right.size_; ++i)
				buffer_[i] = right.buffer_[i];
		}
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	simple_array &operator=(simple_array &&right) SRELL_NOEXCEPT
	{
		if (this != &right)
		{
			this->size_ = right.size_;
			this->capacity_ = right.capacity_;
			this->buffer_ = right.buffer_;
			right.size_ = 0;
			right.capacity_ = 0;
			right.buffer_ = NULL;
		}
		return *this;
	}
#endif
	~simple_array()
	{
		if (buffer_ != NULL)
			std::free(buffer_);
	}
	size_type size() const
	{
		return size_;
	}
	void clear()
	{
		size_ = 0;
	}
	void resize(const size_type newsize)
	{
		if (newsize > capacity_)
			reserve(newsize);
		size_ = newsize;
	}
	void resize(const size_type newsize, const ElemT &type)
	{
		size_type oldsize = size_;
		resize(newsize);
		for (; oldsize < size_; ++oldsize)
			buffer_[oldsize] = type;
	}
	reference operator[](const size_type pos)
	{
		return buffer_[pos];
	}
	const_reference operator[](const size_type &pos) const
	{
		return buffer_[pos];
	}
	void push_back(const_reference n)
	{
		const size_type oldsize = size_;
		if (++size_ > capacity_)
			reserve(size_);
		buffer_[oldsize] = n;
	}
	const_reference back() const
	{
		return buffer_[size_ - 1];
	}
	reference back()
	{
		return buffer_[size_ - 1];
	}
	void pop_back()
	{
		--size_;
	}
	simple_array &operator+=(const simple_array &right)
	{
		return append(right);
	}
	simple_array &append(const size_type size, const ElemT &type)
	{
		resize(size_ + size, type);
		return *this;
	}
	simple_array &append(const simple_array &right)
	{
		size_type oldsize = size_;
		resize(size_ + right.size_);
		for (size_type i = 0; i < right.size_; ++i, ++oldsize)
			buffer_[oldsize] = right.buffer_[i];
		return *this;
	}
	//  For regex_char_class class.
	void erase(const size_type pos)
	{
		if (pos < size_)
		{
			std::memmove(buffer_ + pos, buffer_ + pos + 1, (size_ - pos - 1) * sizeof (ElemT));
			--size_;
		}
	}
	//  For regex_compiler class.
	void insert(const size_type pos, const ElemT &type)
	{
		move_forward(pos, 1);
		buffer_[pos] = type;
	}
	void insert(size_type pos, const simple_array &right)
	{
		move_forward(pos, right.size_);
		for (size_type i = 0; i < right.size_; ++i, ++pos)
			buffer_[pos] = right.buffer_[i];
	}
	simple_array &replace(size_type pos, size_type count, const simple_array &right)
	{
		if (count < right.size_)
			move_forward(pos + count, right.size_ - count);
		else if (count > right.size_)
		{
			const pointer base = buffer_ + pos;
			std::memmove(base + right.size_, base + count, (size_ - pos - count) * sizeof (ElemT));
			size_ -= count - right.size_;
		}
		for (size_type i = 0; i < right.size_; ++pos, ++i)
			buffer_[pos] = right[i];
		return *this;
	}
	size_type find(const value_type c, size_type pos = 0) const
	{
		for (; pos <= size_; ++pos)
			if (buffer_[pos] == c)
				return pos;
		return npos;
	}
	const_pointer data() const
	{
		return buffer_;
	}
	int compare(size_type pos, const size_type count1, const_pointer p, const size_type count2) const
	{
		size_type count = count1 <= count2 ? count1 : count2;
		for (; count; ++pos, ++p, --count)
		{
			const value_type &v = buffer_[pos];
			if (v != *p)
				return v < *p ? -1 : 1;
		}
		return count1 == count2 ? 0 : (count1 < count2 ? -1 : 1);
	}
	size_type max_size() const
	{
		return maxsize_;
	}
	void swap(simple_array &right)
	{
		if (this != &right)
		{
			const pointer tmpbuffer = this->buffer_;
			const size_type tmpsize = this->size_;
			const size_type tmpcapacity = this->capacity_;
			this->buffer_ = right.buffer_;
			this->size_ = right.size_;
			this->capacity_ = right.capacity_;
			right.buffer_ = tmpbuffer;
			right.size_ = tmpsize;
			right.capacity_ = tmpcapacity;
		}
	}
private:
	void reserve(const size_type newsize)
	{
		{
			if (newsize <= maxsize_)
			{
				capacity_ = ((newsize >> 8) + 1) << 8;	//  round up to a multiple of 256.
				if (capacity_ > maxsize_)
					capacity_ = maxsize_;
				const size_type newsize_in_byte = capacity_ * sizeof (ElemT);
				const pointer oldbuffer = buffer_;
				buffer_ = static_cast<pointer>(std::realloc(buffer_, newsize_in_byte));
				if (buffer_ != NULL)
					return;
				//  Even if realloc() failed, already-existing buffer remains valid.
				std::free(oldbuffer);
				size_ = capacity_ = 0;
			}
			throw std::bad_alloc();
		}
	}
	void move_forward(const size_type pos, const size_type count)
	{
		size_type oldsize = size_;
		resize(size_ + count);
		const pointer begin = buffer_ + pos;
		pointer src = buffer_ + oldsize;
		pointer dest = src + count;
		while (src > begin)
			*--dest = *--src;
	}
private:
	pointer buffer_;
	size_type size_;
	size_type capacity_;
	static const size_type maxsize_ = (npos - sizeof (pointer) - sizeof (size_type) * 2) / sizeof (ElemT) / 2;
};
	}	//  namespace regex_internal
	namespace regex_internal
	{
template <typename std::size_t Bits>
class bitset
{
private:
	typedef unsigned long Type;
public:
	bitset()
		: buffer_(static_cast<Type *>(std::malloc(size_in_byte)))
	{
		if (buffer_ != NULL)
		{
			reset();
			return;
		}
		throw std::bad_alloc();
	}
	bitset(const bitset &right)
		: buffer_(static_cast<Type *>(std::malloc(size_in_byte)))
	{
		if (buffer_ != NULL)
		{
			operator=(right);
			return;
		}
		throw std::bad_alloc();
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	bitset(bitset &&right) SRELL_NOEXCEPT
		: buffer_(right.buffer_)
	{
		right.buffer_ = NULL;
	}
#endif
	bitset &operator=(const bitset &right)
	{
		if (this != &right)
		{
			for (std::size_t i = 0; i < arraylength_; ++i)
				buffer_[i] = right.buffer_[i];
		}
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	bitset &operator=(bitset &&right) SRELL_NOEXCEPT
	{
		if (this != &right)
		{
			this->buffer_ = right.buffer_;
			right.buffer_ = NULL;
		}
		return *this;
	}
#endif
	~bitset()
	{
		if (buffer_ != NULL)
			std::free(buffer_);
	}
	bitset &reset()
	{
		std::memset(buffer_, 0, size_in_byte);
		return *this;
	}
	bitset &reset(const std::size_t bit)
	{
		buffer_[bit / bits_per_ulong_] &= ~(1 << (bit & bitmask_));
		return *this;
	}
	bitset &set(const std::size_t bit)
	{
		buffer_[bit / bits_per_ulong_] |= (1 << (bit & bitmask_));
		return *this;
	}
#if 0
	bitset &set_range(const std::size_t firstbit, const std::size_t lastbit)
	{
		const std::size_t lastelem = lastbit / bits_per_ulong_;
		std::size_t firstelem = firstbit / bits_per_ulong_;
		const unsigned int lastbitshift = static_cast<unsigned int>(lastbit & bitmask_);
		const unsigned int lastelemmask = ~(~0 << lastbitshift) | (1 << lastbitshift);
		unsigned int ormask = ~0 << (firstbit & bitmask_);
		if (firstelem < lastelem)
		{
			buffer_[firstelem] |= ormask;
			ormask = static_cast<unsigned int>(~0);
			for (++firstelem; firstelem < lastelem; ++firstelem)
				buffer_[firstelem] |= ormask;
		}
		ormask &= lastelemmask;
		buffer_[lastelem] |= ormask;
		return *this;
	}
#endif
	bool test(const std::size_t bit) const
	{
		return (buffer_[bit / bits_per_ulong_] & (1 << (bit & bitmask_))) != 0;
	}
	bool operator[](const std::size_t &bit) const
	{
		return (buffer_[bit / bits_per_ulong_] & (1 << (bit & bitmask_))) != 0;
	}
	bitset<Bits> &flip()
	{
		for (std::size_t i = 0; i < arraylength_; ++i)
			buffer_[i] = ~buffer_[i];
		return *this;
	}
	void swap(bitset &right)
	{
		if (this != &right)
		{
			Type *const tmpbuffer = this->buffer_;
			this->buffer_ = right.buffer_;
			right.buffer_ = tmpbuffer;
		}
	}
private:
	static const std::size_t bits_per_ulong_ = CHAR_BIT * sizeof (Type);
	static const std::size_t bitmask_ = bits_per_ulong_ - 1;
	static const std::size_t arraylength_ = (Bits + bitmask_) / bits_per_ulong_;
	static const std::size_t size_in_byte = arraylength_ * sizeof (Type);
	Type *buffer_;
};
	}	//  namespace regex_internal
	namespace regex_internal
	{
#if !defined(SRELL_NO_UNICODE_ICASE)
template <typename T2, typename T3>
struct unicode_casefolding
{
	static const T2 ucf_maxcodepoint = 0x1E921;
	static const T3 ucf_deltatablesize = 0x1800;
	static const T2 rev_maxcodepoint = 0x1E943;
	static const T3 rev_indextablesize = 0x1A00;
	static const T3 rev_charsettablesize = 4174;	//  1 + 1381 * 2 + 1411
	static const T3 rev_maxset = 4;
	static const T2 eos = 0;
	static const T2 ucf_deltatable[];
	static const T3 ucf_segmenttable[];
	static const T3 rev_indextable[];
	static const T3 rev_segmenttable[];
	static const T2 rev_charsettable[];
	static const T2 *ucf_deltatable_ptr()
	{
		return ucf_deltatable;
	}
	static const T3 *ucf_segmenttable_ptr()
	{
		return ucf_segmenttable;
	}
	static const T3 *rev_indextable_ptr()
	{
		return rev_indextable;
	}
	static const T3 *rev_segmenttable_ptr()
	{
		return rev_segmenttable;
	}
	static const T2 *rev_charsettable_ptr()
	{
		return rev_charsettable;
	}
};
template <typename T2, typename T3>
const T2 unicode_casefolding<T2, T3>::ucf_deltatable[] =
{
	//  For common (0)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+00xx (256)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 775, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	32, 32, 32, 32,  32, 32, 32, 0,  32, 32, 32, 32,  32, 32, 32, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+01xx (512)
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	0, 0, 1, 0,  1, 0, 1, 0,  0, 1, 0, 1,  0, 1, 0, 1,
	0, 1, 0, 1,  0, 1, 0, 1,  0, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  static_cast<T2>(-121), 1, 0, 1,  0, 1, 0, static_cast<T2>(-268),
	0, 210, 1, 0,  1, 0, 206, 1,  0, 205, 205, 1,  0, 0, 79, 202,
	203, 1, 0, 205,  207, 0, 211, 209,  1, 0, 0, 0,  211, 213, 0, 214,
	1, 0, 1, 0,  1, 0, 218, 1,  0, 218, 0, 0,  1, 0, 218, 1,
	0, 217, 217, 1,  0, 1, 0, 219,  1, 0, 0, 0,  1, 0, 0, 0,
	0, 0, 0, 0,  2, 1, 0, 2,  1, 0, 2, 1,  0, 1, 0, 1,
	0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,  0, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	0, 2, 1, 0,  1, 0, static_cast<T2>(-97), static_cast<T2>(-56),  1, 0, 1, 0,  1, 0, 1, 0,
	//  For u+02xx (768)
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	static_cast<T2>(-130), 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  0, 0, 0, 0,  0, 0, 10795, 1,  0, static_cast<T2>(-163), 10792, 0,
	0, 1, 0, static_cast<T2>(-195),  69, 71, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+03xx (1024)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 116, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	1, 0, 1, 0,  0, 0, 1, 0,  0, 0, 0, 0,  0, 0, 0, 116,
	0, 0, 0, 0,  0, 0, 38, 0,  37, 37, 37, 0,  64, 0, 63, 63,
	0, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	32, 32, 0, 32,  32, 32, 32, 32,  32, 32, 32, 32,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 1, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 8,
	static_cast<T2>(-30), static_cast<T2>(-25), 0, 0,  0, static_cast<T2>(-15), static_cast<T2>(-22), 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	static_cast<T2>(-54), static_cast<T2>(-48), 0, 0,  static_cast<T2>(-60), static_cast<T2>(-64), 0, 1,  0, static_cast<T2>(-7), 1, 0,  0, static_cast<T2>(-130), static_cast<T2>(-130), static_cast<T2>(-130),
	//  For u+04xx (1280)
	80, 80, 80, 80,  80, 80, 80, 80,  80, 80, 80, 80,  80, 80, 80, 80,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	15, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	//  For u+05xx (1536)
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	0, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,
	48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,
	48, 48, 48, 48,  48, 48, 48, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+10xx (1792)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	7264, 7264, 7264, 7264,  7264, 7264, 7264, 7264,  7264, 7264, 7264, 7264,  7264, 7264, 7264, 7264,
	7264, 7264, 7264, 7264,  7264, 7264, 7264, 7264,  7264, 7264, 7264, 7264,  7264, 7264, 7264, 7264,
	7264, 7264, 7264, 7264,  7264, 7264, 0, 7264,  0, 0, 0, 0,  0, 7264, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+13xx (2048)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), 0, 0,
	//  For u+1Cxx (2304)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	static_cast<T2>(-6222), static_cast<T2>(-6221), static_cast<T2>(-6212), static_cast<T2>(-6210),  static_cast<T2>(-6210), static_cast<T2>(-6211), static_cast<T2>(-6204), static_cast<T2>(-6180),  35267, 0, 0, 0,  0, 0, 0, 0,
	static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),
	static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),
	static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),  static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008), 0,  0, static_cast<T2>(-3008), static_cast<T2>(-3008), static_cast<T2>(-3008),
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+1Exx (2560)
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 0, 0,  0, 0, 0, static_cast<T2>(-58),  0, 0, static_cast<T2>(-7615), 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	//  For u+1Fxx (2816)
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, static_cast<T2>(-8), 0, static_cast<T2>(-8),  0, static_cast<T2>(-8), 0, static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-8),
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-74), static_cast<T2>(-74),  static_cast<T2>(-9), 0, static_cast<T2>(-7173), 0,
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-86), static_cast<T2>(-86), static_cast<T2>(-86), static_cast<T2>(-86),  static_cast<T2>(-9), 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-100), static_cast<T2>(-100),  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-8), static_cast<T2>(-8), static_cast<T2>(-112), static_cast<T2>(-112),  static_cast<T2>(-7), 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  static_cast<T2>(-128), static_cast<T2>(-128), static_cast<T2>(-126), static_cast<T2>(-126),  static_cast<T2>(-9), 0, 0, 0,
	//  For u+21xx (3072)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, static_cast<T2>(-7517), 0,  0, 0, static_cast<T2>(-8383), static_cast<T2>(-8262),  0, 0, 0, 0,
	0, 0, 28, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	16, 16, 16, 16,  16, 16, 16, 16,  16, 16, 16, 16,  16, 16, 16, 16,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 1,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+24xx (3328)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 26, 26,  26, 26, 26, 26,  26, 26, 26, 26,
	26, 26, 26, 26,  26, 26, 26, 26,  26, 26, 26, 26,  26, 26, 26, 26,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+2Cxx (3584)
	48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,
	48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,
	48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 48,  48, 48, 48, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	1, 0, static_cast<T2>(-10743), static_cast<T2>(-3814),  static_cast<T2>(-10727), 0, 0, 1,  0, 1, 0, 1,  0, static_cast<T2>(-10780), static_cast<T2>(-10749), static_cast<T2>(-10783),
	static_cast<T2>(-10782), 0, 1, 0,  0, 1, 0, 0,  0, 0, 0, 0,  0, 0, static_cast<T2>(-10815), static_cast<T2>(-10815),
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  0, 0, 0, 0,  0, 0, 0, 1,  0, 1, 0, 0,
	0, 0, 1, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+A6xx (3840)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+A7xx (4096)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	0, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 1, 0, 1,  0, static_cast<T2>(-35332), 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  0, 0, 0, 1,  0, static_cast<T2>(-42280), 0, 0,
	1, 0, 1, 0,  0, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	1, 0, 1, 0,  1, 0, 1, 0,  1, 0, static_cast<T2>(-42308), static_cast<T2>(-42319),  static_cast<T2>(-42315), static_cast<T2>(-42305), static_cast<T2>(-42308), 0,
	static_cast<T2>(-42258), static_cast<T2>(-42282), static_cast<T2>(-42261), 928,  1, 0, 1, 0,  1, 0, 1, 0,  1, 0, 1, 0,
	0, 0, 1, 0,  static_cast<T2>(-48), static_cast<T2>(-42307), static_cast<T2>(-35384), 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+ABxx (4352)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),
	static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),
	static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),
	static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),
	static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),  static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864), static_cast<T2>(-38864),
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+FFxx (4608)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+104xx (4864)
	40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,
	40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,
	40, 40, 40, 40,  40, 40, 40, 40,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,
	40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,  40, 40, 40, 40,
	40, 40, 40, 40,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+10Cxx (5120)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	64, 64, 64, 64,  64, 64, 64, 64,  64, 64, 64, 64,  64, 64, 64, 64,
	64, 64, 64, 64,  64, 64, 64, 64,  64, 64, 64, 64,  64, 64, 64, 64,
	64, 64, 64, 64,  64, 64, 64, 64,  64, 64, 64, 64,  64, 64, 64, 64,
	64, 64, 64, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+118xx (5376)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+16Exx (5632)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,  32, 32, 32, 32,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+1E9xx (5888)
	34, 34, 34, 34,  34, 34, 34, 34,  34, 34, 34, 34,  34, 34, 34, 34,
	34, 34, 34, 34,  34, 34, 34, 34,  34, 34, 34, 34,  34, 34, 34, 34,
	34, 34, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0
};
template <typename T2, typename T3>
const T3 unicode_casefolding<T2, T3>::ucf_segmenttable[] =
{
	256, 512, 768, 1024,  1280, 1536, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	1792, 0, 0, 2048,  0, 0, 0, 0,  0, 0, 0, 0,  2304, 0, 2560, 2816,
	0, 3072, 0, 0,  3328, 0, 0, 0,  0, 0, 0, 0,  3584, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 3840, 4096,  0, 0, 0, 4352,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 4608,
	0, 0, 0, 0,  4864, 0, 0, 0,  0, 0, 0, 0,  5120, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  5376, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 5632, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 5888
};
template <typename T2, typename T3>
const T3 unicode_casefolding<T2, T3>::rev_indextable[] =
{
	//  For common (0)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+00xx (256)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 1, 4, 7,  10, 13, 16, 19,  22, 25, 28, 31,  35, 38, 41, 44,
	47, 50, 53, 56,  60, 63, 66, 69,  72, 75, 78, 0,  0, 0, 0, 0,
	0, 1, 4, 7,  10, 13, 16, 19,  22, 25, 28, 31,  35, 38, 41, 44,
	47, 50, 53, 56,  60, 63, 66, 69,  72, 75, 78, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 81, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	85, 88, 91, 94,  97, 100, 104, 107,  110, 113, 116, 119,  122, 125, 128, 131,
	134, 137, 140, 143,  146, 149, 152, 0,  155, 158, 161, 164,  167, 170, 173, 1924,
	85, 88, 91, 94,  97, 100, 104, 107,  110, 113, 116, 119,  122, 125, 128, 131,
	134, 137, 140, 143,  146, 149, 152, 0,  155, 158, 161, 164,  167, 170, 173, 350,
	//  For u+21xx (512)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 785, 0,  0, 0, 31, 100,  0, 0, 0, 0,
	0, 0, 2359, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 2359, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	2362, 2365, 2368, 2371,  2374, 2377, 2380, 2383,  2386, 2389, 2392, 2395,  2398, 2401, 2404, 2407,
	2362, 2365, 2368, 2371,  2374, 2377, 2380, 2383,  2386, 2389, 2392, 2395,  2398, 2401, 2404, 2407,
	0, 0, 0, 2410,  2410, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+01xx (768)
	176, 176, 179, 179,  182, 182, 185, 185,  188, 188, 191, 191,  194, 194, 197, 197,
	200, 200, 203, 203,  206, 206, 209, 209,  212, 212, 215, 215,  218, 218, 221, 221,
	224, 224, 227, 227,  230, 230, 233, 233,  236, 236, 239, 239,  242, 242, 245, 245,
	0, 0, 248, 248,  251, 251, 254, 254,  0, 257, 257, 260,  260, 263, 263, 266,
	266, 269, 269, 272,  272, 275, 275, 278,  278, 0, 281, 281,  284, 284, 287, 287,
	290, 290, 293, 293,  296, 296, 299, 299,  302, 302, 305, 305,  308, 308, 311, 311,
	314, 314, 317, 317,  320, 320, 323, 323,  326, 326, 329, 329,  332, 332, 335, 335,
	338, 338, 341, 341,  344, 344, 347, 347,  350, 353, 353, 356,  356, 359, 359, 56,
	651, 362, 365, 365,  368, 368, 371, 374,  374, 377, 380, 383,  383, 0, 386, 389,
	392, 395, 395, 398,  401, 540, 404, 407,  410, 410, 642, 0,  413, 416, 606, 419,
	422, 422, 425, 425,  428, 428, 431, 434,  434, 437, 0, 0,  440, 440, 443, 446,
	446, 449, 452, 455,  455, 458, 458, 461,  464, 464, 0, 0,  467, 467, 0, 543,
	0, 0, 0, 0,  470, 470, 470, 474,  474, 474, 478, 478,  478, 482, 482, 485,
	485, 488, 488, 491,  491, 494, 494, 497,  497, 500, 500, 503,  503, 386, 506, 506,
	509, 509, 512, 512,  515, 515, 518, 518,  521, 521, 524, 524,  527, 527, 530, 530,
	0, 533, 533, 533,  537, 537, 540, 543,  546, 546, 549, 549,  552, 552, 555, 555,
	//  For u+03xx (1024)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 675, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	680, 680, 683, 683,  0, 0, 686, 686,  0, 0, 0, 843,  846, 849, 0, 689,
	0, 0, 0, 0,  0, 0, 692, 0,  695, 698, 701, 0,  704, 0, 707, 710,
	0, 713, 716, 720,  723, 726, 730, 733,  736, 675, 741, 745,  81, 748, 751, 754,
	757, 761, 0, 765,  769, 772, 775, 779,  782, 785, 789, 792,  692, 695, 698, 701,
	0, 713, 716, 720,  723, 726, 730, 733,  736, 675, 741, 745,  81, 748, 751, 754,
	757, 761, 765, 765,  769, 772, 775, 779,  782, 785, 789, 792,  704, 707, 710, 795,
	716, 736, 0, 0,  0, 775, 757, 795,  798, 798, 801, 801,  804, 804, 807, 807,
	810, 810, 813, 813,  816, 816, 819, 819,  822, 822, 825, 825,  828, 828, 831, 831,
	741, 761, 837, 689,  736, 726, 0, 834,  834, 837, 840, 840,  0, 843, 846, 849,
	//  For u+02xx (1280)
	558, 558, 561, 561,  564, 564, 567, 567,  570, 570, 573, 573,  576, 576, 579, 579,
	582, 582, 585, 585,  588, 588, 591, 591,  594, 594, 597, 597,  600, 600, 603, 603,
	606, 0, 609, 609,  612, 612, 615, 615,  618, 618, 621, 621,  624, 624, 627, 627,
	630, 630, 633, 633,  0, 0, 0, 0,  0, 0, 636, 639,  639, 642, 645, 2671,
	2674, 648, 648, 651,  654, 657, 660, 660,  663, 663, 666, 666,  669, 669, 672, 672,
	2659, 2653, 2662, 362,  371, 0, 377, 380,  0, 389, 0, 392,  3127, 0, 0, 0,
	398, 3130, 0, 401,  0, 3085, 3124, 0,  407, 404, 3136, 2635,  3133, 0, 0, 413,
	0, 2656, 416, 0,  0, 419, 0, 0,  0, 0, 0, 0,  0, 2641, 0, 0,
	431, 0, 3175, 437,  0, 0, 0, 3142,  443, 654, 449, 452,  657, 0, 0, 0,
	0, 0, 461, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 3145, 3139, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+2Cxx (1536)
	2491, 2494, 2497, 2500,  2503, 2506, 2509, 2512,  2515, 2518, 2521, 2524,  2527, 2530, 2533, 2536,
	2539, 2542, 2545, 2548,  2551, 2554, 2557, 2560,  2563, 2566, 2569, 2572,  2575, 2578, 2581, 2584,
	2587, 2590, 2593, 2596,  2599, 2602, 2605, 2608,  2611, 2614, 2617, 2620,  2623, 2626, 2629, 0,
	2491, 2494, 2497, 2500,  2503, 2506, 2509, 2512,  2515, 2518, 2521, 2524,  2527, 2530, 2533, 2536,
	2539, 2542, 2545, 2548,  2551, 2554, 2557, 2560,  2563, 2566, 2569, 2572,  2575, 2578, 2581, 2584,
	2587, 2590, 2593, 2596,  2599, 2602, 2605, 2608,  2611, 2614, 2617, 2620,  2623, 2626, 2629, 0,
	2632, 2632, 2635, 2638,  2641, 636, 645, 2644,  2644, 2647, 2647, 2650,  2650, 2653, 2656, 2659,
	2662, 0, 2665, 2665,  0, 2668, 2668, 0,  0, 0, 0, 0,  0, 0, 2671, 2674,
	2677, 2677, 2680, 2680,  2683, 2683, 2686, 2686,  2689, 2689, 2692, 2692,  2695, 2695, 2698, 2698,
	2701, 2701, 2704, 2704,  2707, 2707, 2710, 2710,  2713, 2713, 2716, 2716,  2719, 2719, 2722, 2722,
	2725, 2725, 2728, 2728,  2731, 2731, 2734, 2734,  2737, 2737, 2740, 2740,  2743, 2743, 2746, 2746,
	2749, 2749, 2752, 2752,  2755, 2755, 2758, 2758,  2761, 2761, 2764, 2764,  2767, 2767, 2770, 2770,
	2773, 2773, 2776, 2776,  2779, 2779, 2782, 2782,  2785, 2785, 2788, 2788,  2791, 2791, 2794, 2794,
	2797, 2797, 2800, 2800,  2803, 2803, 2806, 2806,  2809, 2809, 2812, 2812,  2815, 2815, 2818, 2818,
	2821, 2821, 2824, 2824,  0, 0, 0, 0,  0, 0, 0, 2827,  2827, 2830, 2830, 0,
	0, 0, 2833, 2833,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+1Fxx (1792)
	2071, 2074, 2077, 2080,  2083, 2086, 2089, 2092,  2071, 2074, 2077, 2080,  2083, 2086, 2089, 2092,
	2095, 2098, 2101, 2104,  2107, 2110, 0, 0,  2095, 2098, 2101, 2104,  2107, 2110, 0, 0,
	2113, 2116, 2119, 2122,  2125, 2128, 2131, 2134,  2113, 2116, 2119, 2122,  2125, 2128, 2131, 2134,
	2137, 2140, 2143, 2146,  2149, 2152, 2155, 2158,  2137, 2140, 2143, 2146,  2149, 2152, 2155, 2158,
	2161, 2164, 2167, 2170,  2173, 2176, 0, 0,  2161, 2164, 2167, 2170,  2173, 2176, 0, 0,
	0, 2179, 0, 2182,  0, 2185, 0, 2188,  0, 2179, 0, 2182,  0, 2185, 0, 2188,
	2191, 2194, 2197, 2200,  2203, 2206, 2209, 2212,  2191, 2194, 2197, 2200,  2203, 2206, 2209, 2212,
	2293, 2296, 2302, 2305,  2308, 2311, 2323, 2326,  2344, 2347, 2335, 2338,  2350, 2353, 0, 0,
	2215, 2218, 2221, 2224,  2227, 2230, 2233, 2236,  2215, 2218, 2221, 2224,  2227, 2230, 2233, 2236,
	2239, 2242, 2245, 2248,  2251, 2254, 2257, 2260,  2239, 2242, 2245, 2248,  2251, 2254, 2257, 2260,
	2263, 2266, 2269, 2272,  2275, 2278, 2281, 2284,  2263, 2266, 2269, 2272,  2275, 2278, 2281, 2284,
	2287, 2290, 0, 2299,  0, 0, 0, 0,  2287, 2290, 2293, 2296,  2299, 0, 675, 0,
	0, 0, 0, 2314,  0, 0, 0, 0,  2302, 2305, 2308, 2311,  2314, 0, 0, 0,
	2317, 2320, 0, 0,  0, 0, 0, 0,  2317, 2320, 2323, 2326,  0, 0, 0, 0,
	2329, 2332, 0, 0,  0, 2341, 0, 0,  2329, 2332, 2335, 2338,  2341, 0, 0, 0,
	0, 0, 0, 2356,  0, 0, 0, 0,  2344, 2347, 2350, 2353,  2356, 0, 0, 0,
	//  For u+04xx (2048)
	852, 855, 858, 861,  864, 867, 870, 873,  876, 879, 882, 885,  888, 891, 894, 897,
	900, 903, 906, 910,  913, 917, 920, 923,  926, 929, 932, 935,  938, 941, 944, 948,
	951, 954, 958, 963,  966, 969, 972, 975,  978, 981, 984, 988,  991, 994, 997, 1000,
	900, 903, 906, 910,  913, 917, 920, 923,  926, 929, 932, 935,  938, 941, 944, 948,
	951, 954, 958, 963,  966, 969, 972, 975,  978, 981, 984, 988,  991, 994, 997, 1000,
	852, 855, 858, 861,  864, 867, 870, 873,  876, 879, 882, 885,  888, 891, 894, 897,
	1003, 1003, 1006, 1006,  1010, 1010, 1013, 1013,  1016, 1016, 1019, 1019,  1022, 1022, 1025, 1025,
	1028, 1028, 1031, 1031,  1034, 1034, 1037, 1037,  1040, 1040, 1043, 1043,  1046, 1046, 1049, 1049,
	1052, 1052, 0, 0,  0, 0, 0, 0,  0, 0, 1055, 1055,  1058, 1058, 1061, 1061,
	1064, 1064, 1067, 1067,  1070, 1070, 1073, 1073,  1076, 1076, 1079, 1079,  1082, 1082, 1085, 1085,
	1088, 1088, 1091, 1091,  1094, 1094, 1097, 1097,  1100, 1100, 1103, 1103,  1106, 1106, 1109, 1109,
	1112, 1112, 1115, 1115,  1118, 1118, 1121, 1121,  1124, 1124, 1127, 1127,  1130, 1130, 1133, 1133,
	1136, 1139, 1139, 1142,  1142, 1145, 1145, 1148,  1148, 1151, 1151, 1154,  1154, 1157, 1157, 1136,
	1160, 1160, 1163, 1163,  1166, 1166, 1169, 1169,  1172, 1172, 1175, 1175,  1178, 1178, 1181, 1181,
	1184, 1184, 1187, 1187,  1190, 1190, 1193, 1193,  1196, 1196, 1199, 1199,  1202, 1202, 1205, 1205,
	1208, 1208, 1211, 1211,  1214, 1214, 1217, 1217,  1220, 1220, 1223, 1223,  1226, 1226, 1229, 1229,
	//  For u+1Cxx (2304)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	906, 913, 944, 954,  958, 958, 984, 1006,  1556, 0, 0, 0,  0, 0, 0, 0,
	1560, 1563, 1566, 1569,  1572, 1575, 1578, 1581,  1584, 1587, 1590, 1593,  1596, 1599, 1602, 1605,
	1608, 1611, 1614, 1617,  1620, 1623, 1626, 1629,  1632, 1635, 1638, 1641,  1644, 1647, 1650, 1653,
	1656, 1659, 1662, 1665,  1668, 1671, 1674, 1677,  1680, 1683, 1686, 0,  0, 1689, 1692, 1695,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+05xx (2560)
	1232, 1232, 1235, 1235,  1238, 1238, 1241, 1241,  1244, 1244, 1247, 1247,  1250, 1250, 1253, 1253,
	1256, 1256, 1259, 1259,  1262, 1262, 1265, 1265,  1268, 1268, 1271, 1271,  1274, 1274, 1277, 1277,
	1280, 1280, 1283, 1283,  1286, 1286, 1289, 1289,  1292, 1292, 1295, 1295,  1298, 1298, 1301, 1301,
	0, 1304, 1307, 1310,  1313, 1316, 1319, 1322,  1325, 1328, 1331, 1334,  1337, 1340, 1343, 1346,
	1349, 1352, 1355, 1358,  1361, 1364, 1367, 1370,  1373, 1376, 1379, 1382,  1385, 1388, 1391, 1394,
	1397, 1400, 1403, 1406,  1409, 1412, 1415, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 1304, 1307, 1310,  1313, 1316, 1319, 1322,  1325, 1328, 1331, 1334,  1337, 1340, 1343, 1346,
	1349, 1352, 1355, 1358,  1361, 1364, 1367, 1370,  1373, 1376, 1379, 1382,  1385, 1388, 1391, 1394,
	1397, 1400, 1403, 1406,  1409, 1412, 1415, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+2Dxx (2816)
	1418, 1421, 1424, 1427,  1430, 1433, 1436, 1439,  1442, 1445, 1448, 1451,  1454, 1457, 1460, 1463,
	1466, 1469, 1472, 1475,  1478, 1481, 1484, 1487,  1490, 1493, 1496, 1499,  1502, 1505, 1508, 1511,
	1514, 1517, 1520, 1523,  1526, 1529, 0, 1532,  0, 0, 0, 0,  0, 1535, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+10xx (3072)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	1418, 1421, 1424, 1427,  1430, 1433, 1436, 1439,  1442, 1445, 1448, 1451,  1454, 1457, 1460, 1463,
	1466, 1469, 1472, 1475,  1478, 1481, 1484, 1487,  1490, 1493, 1496, 1499,  1502, 1505, 1508, 1511,
	1514, 1517, 1520, 1523,  1526, 1529, 0, 1532,  0, 0, 0, 0,  0, 1535, 0, 0,
	1560, 1563, 1566, 1569,  1572, 1575, 1578, 1581,  1584, 1587, 1590, 1593,  1596, 1599, 1602, 1605,
	1608, 1611, 1614, 1617,  1620, 1623, 1626, 1629,  1632, 1635, 1638, 1641,  1644, 1647, 1650, 1653,
	1656, 1659, 1662, 1665,  1668, 1671, 1674, 1677,  1680, 1683, 1686, 0,  0, 1689, 1692, 1695,
	//  For u+13xx (3328)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3181, 3184, 3187, 3190,  3193, 3196, 3199, 3202,  3205, 3208, 3211, 3214,  3217, 3220, 3223, 3226,
	3229, 3232, 3235, 3238,  3241, 3244, 3247, 3250,  3253, 3256, 3259, 3262,  3265, 3268, 3271, 3274,
	3277, 3280, 3283, 3286,  3289, 3292, 3295, 3298,  3301, 3304, 3307, 3310,  3313, 3316, 3319, 3322,
	3325, 3328, 3331, 3334,  3337, 3340, 3343, 3346,  3349, 3352, 3355, 3358,  3361, 3364, 3367, 3370,
	3373, 3376, 3379, 3382,  3385, 3388, 3391, 3394,  3397, 3400, 3403, 3406,  3409, 3412, 3415, 3418,
	1538, 1541, 1544, 1547,  1550, 1553, 0, 0,  1538, 1541, 1544, 1547,  1550, 1553, 0, 0,
	//  For u+A6xx (3584)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	2836, 2836, 2839, 2839,  2842, 2842, 2845, 2845,  2848, 2848, 1556, 1556,  2851, 2851, 2854, 2854,
	2857, 2857, 2860, 2860,  2863, 2863, 2866, 2866,  2869, 2869, 2872, 2872,  2875, 2875, 2878, 2878,
	2881, 2881, 2884, 2884,  2887, 2887, 2890, 2890,  2893, 2893, 2896, 2896,  2899, 2899, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	2902, 2902, 2905, 2905,  2908, 2908, 2911, 2911,  2914, 2914, 2917, 2917,  2920, 2920, 2923, 2923,
	2926, 2926, 2929, 2929,  2932, 2932, 2935, 2935,  2938, 2938, 2941, 2941,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+1Exx (3840)
	1698, 1698, 1701, 1701,  1704, 1704, 1707, 1707,  1710, 1710, 1713, 1713,  1716, 1716, 1719, 1719,
	1722, 1722, 1725, 1725,  1728, 1728, 1731, 1731,  1734, 1734, 1737, 1737,  1740, 1740, 1743, 1743,
	1746, 1746, 1749, 1749,  1752, 1752, 1755, 1755,  1758, 1758, 1761, 1761,  1764, 1764, 1767, 1767,
	1770, 1770, 1773, 1773,  1776, 1776, 1779, 1779,  1782, 1782, 1785, 1785,  1788, 1788, 1791, 1791,
	1794, 1794, 1797, 1797,  1800, 1800, 1803, 1803,  1806, 1806, 1809, 1809,  1812, 1812, 1815, 1815,
	1818, 1818, 1821, 1821,  1824, 1824, 1827, 1827,  1830, 1830, 1833, 1833,  1836, 1836, 1839, 1839,
	1842, 1842, 1846, 1846,  1849, 1849, 1852, 1852,  1855, 1855, 1858, 1858,  1861, 1861, 1864, 1864,
	1867, 1867, 1870, 1870,  1873, 1873, 1876, 1876,  1879, 1879, 1882, 1882,  1885, 1885, 1888, 1888,
	1891, 1891, 1894, 1894,  1897, 1897, 1900, 1900,  1903, 1903, 1906, 1906,  1909, 1909, 1912, 1912,
	1915, 1915, 1918, 1918,  1921, 1921, 0, 0,  0, 0, 0, 1842,  0, 0, 1924, 0,
	1927, 1927, 1930, 1930,  1933, 1933, 1936, 1936,  1939, 1939, 1942, 1942,  1945, 1945, 1948, 1948,
	1951, 1951, 1954, 1954,  1957, 1957, 1960, 1960,  1963, 1963, 1966, 1966,  1969, 1969, 1972, 1972,
	1975, 1975, 1978, 1978,  1981, 1981, 1984, 1984,  1987, 1987, 1990, 1990,  1993, 1993, 1996, 1996,
	1999, 1999, 2002, 2002,  2005, 2005, 2008, 2008,  2011, 2011, 2014, 2014,  2017, 2017, 2020, 2020,
	2023, 2023, 2026, 2026,  2029, 2029, 2032, 2032,  2035, 2035, 2038, 2038,  2041, 2041, 2044, 2044,
	2047, 2047, 2050, 2050,  2053, 2053, 2056, 2056,  2059, 2059, 2062, 2062,  2065, 2065, 2068, 2068,
	//  For u+24xx (4096)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 2413, 2416,  2419, 2422, 2425, 2428,  2431, 2434, 2437, 2440,
	2443, 2446, 2449, 2452,  2455, 2458, 2461, 2464,  2467, 2470, 2473, 2476,  2479, 2482, 2485, 2488,
	2413, 2416, 2419, 2422,  2425, 2428, 2431, 2434,  2437, 2440, 2443, 2446,  2449, 2452, 2455, 2458,
	2461, 2464, 2467, 2470,  2473, 2476, 2479, 2482,  2485, 2488, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+1Dxx (4352)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 3064, 0, 0,  0, 2638, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 3178, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+A7xx (4608)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 2944, 2944,  2947, 2947, 2950, 2950,  2953, 2953, 2956, 2956,  2959, 2959, 2962, 2962,
	0, 0, 2965, 2965,  2968, 2968, 2971, 2971,  2974, 2974, 2977, 2977,  2980, 2980, 2983, 2983,
	2986, 2986, 2989, 2989,  2992, 2992, 2995, 2995,  2998, 2998, 3001, 3001,  3004, 3004, 3007, 3007,
	3010, 3010, 3013, 3013,  3016, 3016, 3019, 3019,  3022, 3022, 3025, 3025,  3028, 3028, 3031, 3031,
	3034, 3034, 3037, 3037,  3040, 3040, 3043, 3043,  3046, 3046, 3049, 3049,  3052, 3052, 3055, 3055,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 3058, 3058, 3061,  3061, 3064, 3067, 3067,
	3070, 3070, 3073, 3073,  3076, 3076, 3079, 3079,  0, 0, 0, 3082,  3082, 3085, 0, 0,
	3088, 3088, 3091, 3091,  3172, 0, 3094, 3094,  3097, 3097, 3100, 3100,  3103, 3103, 3106, 3106,
	3109, 3109, 3112, 3112,  3115, 3115, 3118, 3118,  3121, 3121, 3124, 3127,  3130, 3133, 3136, 0,
	3139, 3142, 3145, 3148,  3151, 3151, 3154, 3154,  3157, 3157, 3160, 3160,  3163, 3163, 3166, 3166,
	0, 0, 3169, 3169,  3172, 3175, 3178, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+ABxx (4864)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 3148,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3181, 3184, 3187, 3190,  3193, 3196, 3199, 3202,  3205, 3208, 3211, 3214,  3217, 3220, 3223, 3226,
	3229, 3232, 3235, 3238,  3241, 3244, 3247, 3250,  3253, 3256, 3259, 3262,  3265, 3268, 3271, 3274,
	3277, 3280, 3283, 3286,  3289, 3292, 3295, 3298,  3301, 3304, 3307, 3310,  3313, 3316, 3319, 3322,
	3325, 3328, 3331, 3334,  3337, 3340, 3343, 3346,  3349, 3352, 3355, 3358,  3361, 3364, 3367, 3370,
	3373, 3376, 3379, 3382,  3385, 3388, 3391, 3394,  3397, 3400, 3403, 3406,  3409, 3412, 3415, 3418,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+FFxx (5120)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 3421, 3424, 3427,  3430, 3433, 3436, 3439,  3442, 3445, 3448, 3451,  3454, 3457, 3460, 3463,
	3466, 3469, 3472, 3475,  3478, 3481, 3484, 3487,  3490, 3493, 3496, 0,  0, 0, 0, 0,
	0, 3421, 3424, 3427,  3430, 3433, 3436, 3439,  3442, 3445, 3448, 3451,  3454, 3457, 3460, 3463,
	3466, 3469, 3472, 3475,  3478, 3481, 3484, 3487,  3490, 3493, 3496, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+104xx (5376)
	3499, 3502, 3505, 3508,  3511, 3514, 3517, 3520,  3523, 3526, 3529, 3532,  3535, 3538, 3541, 3544,
	3547, 3550, 3553, 3556,  3559, 3562, 3565, 3568,  3571, 3574, 3577, 3580,  3583, 3586, 3589, 3592,
	3595, 3598, 3601, 3604,  3607, 3610, 3613, 3616,  3499, 3502, 3505, 3508,  3511, 3514, 3517, 3520,
	3523, 3526, 3529, 3532,  3535, 3538, 3541, 3544,  3547, 3550, 3553, 3556,  3559, 3562, 3565, 3568,
	3571, 3574, 3577, 3580,  3583, 3586, 3589, 3592,  3595, 3598, 3601, 3604,  3607, 3610, 3613, 3616,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3619, 3622, 3625, 3628,  3631, 3634, 3637, 3640,  3643, 3646, 3649, 3652,  3655, 3658, 3661, 3664,
	3667, 3670, 3673, 3676,  3679, 3682, 3685, 3688,  3691, 3694, 3697, 3700,  3703, 3706, 3709, 3712,
	3715, 3718, 3721, 3724,  0, 0, 0, 0,  3619, 3622, 3625, 3628,  3631, 3634, 3637, 3640,
	3643, 3646, 3649, 3652,  3655, 3658, 3661, 3664,  3667, 3670, 3673, 3676,  3679, 3682, 3685, 3688,
	3691, 3694, 3697, 3700,  3703, 3706, 3709, 3712,  3715, 3718, 3721, 3724,  0, 0, 0, 0,
	//  For u+10Cxx (5632)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3727, 3730, 3733, 3736,  3739, 3742, 3745, 3748,  3751, 3754, 3757, 3760,  3763, 3766, 3769, 3772,
	3775, 3778, 3781, 3784,  3787, 3790, 3793, 3796,  3799, 3802, 3805, 3808,  3811, 3814, 3817, 3820,
	3823, 3826, 3829, 3832,  3835, 3838, 3841, 3844,  3847, 3850, 3853, 3856,  3859, 3862, 3865, 3868,
	3871, 3874, 3877, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3727, 3730, 3733, 3736,  3739, 3742, 3745, 3748,  3751, 3754, 3757, 3760,  3763, 3766, 3769, 3772,
	3775, 3778, 3781, 3784,  3787, 3790, 3793, 3796,  3799, 3802, 3805, 3808,  3811, 3814, 3817, 3820,
	3823, 3826, 3829, 3832,  3835, 3838, 3841, 3844,  3847, 3850, 3853, 3856,  3859, 3862, 3865, 3868,
	3871, 3874, 3877, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+118xx (5888)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3880, 3883, 3886, 3889,  3892, 3895, 3898, 3901,  3904, 3907, 3910, 3913,  3916, 3919, 3922, 3925,
	3928, 3931, 3934, 3937,  3940, 3943, 3946, 3949,  3952, 3955, 3958, 3961,  3964, 3967, 3970, 3973,
	3880, 3883, 3886, 3889,  3892, 3895, 3898, 3901,  3904, 3907, 3910, 3913,  3916, 3919, 3922, 3925,
	3928, 3931, 3934, 3937,  3940, 3943, 3946, 3949,  3952, 3955, 3958, 3961,  3964, 3967, 3970, 3973,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+16Exx (6144)
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3976, 3979, 3982, 3985,  3988, 3991, 3994, 3997,  4000, 4003, 4006, 4009,  4012, 4015, 4018, 4021,
	4024, 4027, 4030, 4033,  4036, 4039, 4042, 4045,  4048, 4051, 4054, 4057,  4060, 4063, 4066, 4069,
	3976, 3979, 3982, 3985,  3988, 3991, 3994, 3997,  4000, 4003, 4006, 4009,  4012, 4015, 4018, 4021,
	4024, 4027, 4030, 4033,  4036, 4039, 4042, 4045,  4048, 4051, 4054, 4057,  4060, 4063, 4066, 4069,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	//  For u+1E9xx (6400)
	4072, 4075, 4078, 4081,  4084, 4087, 4090, 4093,  4096, 4099, 4102, 4105,  4108, 4111, 4114, 4117,
	4120, 4123, 4126, 4129,  4132, 4135, 4138, 4141,  4144, 4147, 4150, 4153,  4156, 4159, 4162, 4165,
	4168, 4171, 4072, 4075,  4078, 4081, 4084, 4087,  4090, 4093, 4096, 4099,  4102, 4105, 4108, 4111,
	4114, 4117, 4120, 4123,  4126, 4129, 4132, 4135,  4138, 4141, 4144, 4147,  4150, 4153, 4156, 4159,
	4162, 4165, 4168, 4171,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0
};
template <typename T2, typename T3>
const T3 unicode_casefolding<T2, T3>::rev_segmenttable[] =
{
	256, 768, 1280, 1024,  2048, 2560, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	3072, 0, 0, 3328,  0, 0, 0, 0,  0, 0, 0, 0,  2304, 4352, 3840, 1792,
	0, 512, 0, 0,  4096, 0, 0, 0,  0, 0, 0, 0,  1536, 2816, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 3584, 4608,  0, 0, 0, 4864,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 5120,
	0, 0, 0, 0,  5376, 0, 0, 0,  0, 0, 0, 0,  5632, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  5888, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 6144, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
	0, 0, 0, 0,  0, 0, 0, 0,  0, 6400
};
template <typename T2, typename T3>
const T2 unicode_casefolding<T2, T3>::rev_charsettable[] =
{
	eos,	//  0
	0x0061, 0x0041, eos,
	0x0062, 0x0042, eos,
	0x0063, 0x0043, eos,
	0x0064, 0x0044, eos,	//  10
	0x0065, 0x0045, eos,
	0x0066, 0x0046, eos,
	0x0067, 0x0047, eos,
	0x0068, 0x0048, eos,	//  22
	0x0069, 0x0049, eos,
	0x006A, 0x004A, eos,
	0x006B, 0x004B, 0x212A, eos,	//  31
	0x006C, 0x004C, eos,
	0x006D, 0x004D, eos,
	0x006E, 0x004E, eos,	//  41
	0x006F, 0x004F, eos,
	0x0070, 0x0050, eos,
	0x0071, 0x0051, eos,	//  50
	0x0072, 0x0052, eos,
	0x0073, 0x0053, 0x017F, eos,
	0x0074, 0x0054, eos,	//  60
	0x0075, 0x0055, eos,
	0x0076, 0x0056, eos,
	0x0077, 0x0057, eos,
	0x0078, 0x0058, eos,	//  72
	0x0079, 0x0059, eos,
	0x007A, 0x005A, eos,
	0x03BC, 0x00B5, 0x039C, eos,	//  81
	0x00E0, 0x00C0, eos,
	0x00E1, 0x00C1, eos,
	0x00E2, 0x00C2, eos,	//  91
	0x00E3, 0x00C3, eos,
	0x00E4, 0x00C4, eos,
	0x00E5, 0x00C5, 0x212B, eos,	//  100
	0x00E6, 0x00C6, eos,
	0x00E7, 0x00C7, eos,
	0x00E8, 0x00C8, eos,	//  110
	0x00E9, 0x00C9, eos,
	0x00EA, 0x00CA, eos,
	0x00EB, 0x00CB, eos,
	0x00EC, 0x00CC, eos,	//  122
	0x00ED, 0x00CD, eos,
	0x00EE, 0x00CE, eos,
	0x00EF, 0x00CF, eos,	//  131
	0x00F0, 0x00D0, eos,
	0x00F1, 0x00D1, eos,
	0x00F2, 0x00D2, eos,	//  140
	0x00F3, 0x00D3, eos,
	0x00F4, 0x00D4, eos,
	0x00F5, 0x00D5, eos,
	0x00F6, 0x00D6, eos,	//  152
	0x00F8, 0x00D8, eos,
	0x00F9, 0x00D9, eos,
	0x00FA, 0x00DA, eos,	//  161
	0x00FB, 0x00DB, eos,
	0x00FC, 0x00DC, eos,
	0x00FD, 0x00DD, eos,	//  170
	0x00FE, 0x00DE, eos,
	0x0101, 0x0100, eos,
	0x0103, 0x0102, eos,
	0x0105, 0x0104, eos,	//  182
	0x0107, 0x0106, eos,
	0x0109, 0x0108, eos,
	0x010B, 0x010A, eos,	//  191
	0x010D, 0x010C, eos,
	0x010F, 0x010E, eos,
	0x0111, 0x0110, eos,	//  200
	0x0113, 0x0112, eos,
	0x0115, 0x0114, eos,
	0x0117, 0x0116, eos,
	0x0119, 0x0118, eos,	//  212
	0x011B, 0x011A, eos,
	0x011D, 0x011C, eos,
	0x011F, 0x011E, eos,	//  221
	0x0121, 0x0120, eos,
	0x0123, 0x0122, eos,
	0x0125, 0x0124, eos,	//  230
	0x0127, 0x0126, eos,
	0x0129, 0x0128, eos,
	0x012B, 0x012A, eos,
	0x012D, 0x012C, eos,	//  242
	0x012F, 0x012E, eos,
	0x0133, 0x0132, eos,
	0x0135, 0x0134, eos,	//  251
	0x0137, 0x0136, eos,
	0x013A, 0x0139, eos,
	0x013C, 0x013B, eos,	//  260
	0x013E, 0x013D, eos,
	0x0140, 0x013F, eos,
	0x0142, 0x0141, eos,
	0x0144, 0x0143, eos,	//  272
	0x0146, 0x0145, eos,
	0x0148, 0x0147, eos,
	0x014B, 0x014A, eos,	//  281
	0x014D, 0x014C, eos,
	0x014F, 0x014E, eos,
	0x0151, 0x0150, eos,	//  290
	0x0153, 0x0152, eos,
	0x0155, 0x0154, eos,
	0x0157, 0x0156, eos,
	0x0159, 0x0158, eos,	//  302
	0x015B, 0x015A, eos,
	0x015D, 0x015C, eos,
	0x015F, 0x015E, eos,	//  311
	0x0161, 0x0160, eos,
	0x0163, 0x0162, eos,
	0x0165, 0x0164, eos,	//  320
	0x0167, 0x0166, eos,
	0x0169, 0x0168, eos,
	0x016B, 0x016A, eos,
	0x016D, 0x016C, eos,	//  332
	0x016F, 0x016E, eos,
	0x0171, 0x0170, eos,
	0x0173, 0x0172, eos,	//  341
	0x0175, 0x0174, eos,
	0x0177, 0x0176, eos,
	0x00FF, 0x0178, eos,	//  350
	0x017A, 0x0179, eos,
	0x017C, 0x017B, eos,
	0x017E, 0x017D, eos,
	0x0253, 0x0181, eos,	//  362
	0x0183, 0x0182, eos,
	0x0185, 0x0184, eos,
	0x0254, 0x0186, eos,	//  371
	0x0188, 0x0187, eos,
	0x0256, 0x0189, eos,
	0x0257, 0x018A, eos,	//  380
	0x018C, 0x018B, eos,
	0x01DD, 0x018E, eos,
	0x0259, 0x018F, eos,
	0x025B, 0x0190, eos,	//  392
	0x0192, 0x0191, eos,
	0x0260, 0x0193, eos,
	0x0263, 0x0194, eos,	//  401
	0x0269, 0x0196, eos,
	0x0268, 0x0197, eos,
	0x0199, 0x0198, eos,	//  410
	0x026F, 0x019C, eos,
	0x0272, 0x019D, eos,
	0x0275, 0x019F, eos,
	0x01A1, 0x01A0, eos,	//  422
	0x01A3, 0x01A2, eos,
	0x01A5, 0x01A4, eos,
	0x0280, 0x01A6, eos,	//  431
	0x01A8, 0x01A7, eos,
	0x0283, 0x01A9, eos,
	0x01AD, 0x01AC, eos,	//  440
	0x0288, 0x01AE, eos,
	0x01B0, 0x01AF, eos,
	0x028A, 0x01B1, eos,
	0x028B, 0x01B2, eos,	//  452
	0x01B4, 0x01B3, eos,
	0x01B6, 0x01B5, eos,
	0x0292, 0x01B7, eos,	//  461
	0x01B9, 0x01B8, eos,
	0x01BD, 0x01BC, eos,
	0x01C6, 0x01C4, 0x01C5, eos,	//  470
	0x01C9, 0x01C7, 0x01C8, eos,
	0x01CC, 0x01CA, 0x01CB, eos,
	0x01CE, 0x01CD, eos,	//  482
	0x01D0, 0x01CF, eos,
	0x01D2, 0x01D1, eos,
	0x01D4, 0x01D3, eos,	//  491
	0x01D6, 0x01D5, eos,
	0x01D8, 0x01D7, eos,
	0x01DA, 0x01D9, eos,	//  500
	0x01DC, 0x01DB, eos,
	0x01DF, 0x01DE, eos,
	0x01E1, 0x01E0, eos,
	0x01E3, 0x01E2, eos,	//  512
	0x01E5, 0x01E4, eos,
	0x01E7, 0x01E6, eos,
	0x01E9, 0x01E8, eos,	//  521
	0x01EB, 0x01EA, eos,
	0x01ED, 0x01EC, eos,
	0x01EF, 0x01EE, eos,	//  530
	0x01F3, 0x01F1, 0x01F2, eos,
	0x01F5, 0x01F4, eos,
	0x0195, 0x01F6, eos,	//  540
	0x01BF, 0x01F7, eos,
	0x01F9, 0x01F8, eos,
	0x01FB, 0x01FA, eos,
	0x01FD, 0x01FC, eos,	//  552
	0x01FF, 0x01FE, eos,
	0x0201, 0x0200, eos,
	0x0203, 0x0202, eos,	//  561
	0x0205, 0x0204, eos,
	0x0207, 0x0206, eos,
	0x0209, 0x0208, eos,	//  570
	0x020B, 0x020A, eos,
	0x020D, 0x020C, eos,
	0x020F, 0x020E, eos,
	0x0211, 0x0210, eos,	//  582
	0x0213, 0x0212, eos,
	0x0215, 0x0214, eos,
	0x0217, 0x0216, eos,	//  591
	0x0219, 0x0218, eos,
	0x021B, 0x021A, eos,
	0x021D, 0x021C, eos,	//  600
	0x021F, 0x021E, eos,
	0x019E, 0x0220, eos,
	0x0223, 0x0222, eos,
	0x0225, 0x0224, eos,	//  612
	0x0227, 0x0226, eos,
	0x0229, 0x0228, eos,
	0x022B, 0x022A, eos,	//  621
	0x022D, 0x022C, eos,
	0x022F, 0x022E, eos,
	0x0231, 0x0230, eos,	//  630
	0x0233, 0x0232, eos,
	0x2C65, 0x023A, eos,
	0x023C, 0x023B, eos,
	0x019A, 0x023D, eos,	//  642
	0x2C66, 0x023E, eos,
	0x0242, 0x0241, eos,
	0x0180, 0x0243, eos,	//  651
	0x0289, 0x0244, eos,
	0x028C, 0x0245, eos,
	0x0247, 0x0246, eos,	//  660
	0x0249, 0x0248, eos,
	0x024B, 0x024A, eos,
	0x024D, 0x024C, eos,
	0x024F, 0x024E, eos,	//  672
	0x03B9, 0x0345, 0x0399, 0x1FBE, eos,
	0x0371, 0x0370, eos,	//  680
	0x0373, 0x0372, eos,
	0x0377, 0x0376, eos,
	0x03F3, 0x037F, eos,
	0x03AC, 0x0386, eos,	//  692
	0x03AD, 0x0388, eos,
	0x03AE, 0x0389, eos,
	0x03AF, 0x038A, eos,	//  701
	0x03CC, 0x038C, eos,
	0x03CD, 0x038E, eos,
	0x03CE, 0x038F, eos,	//  710
	0x03B1, 0x0391, eos,
	0x03B2, 0x0392, 0x03D0, eos,
	0x03B3, 0x0393, eos,	//  720
	0x03B4, 0x0394, eos,
	0x03B5, 0x0395, 0x03F5, eos,
	0x03B6, 0x0396, eos,	//  730
	0x03B7, 0x0397, eos,
	0x03B8, 0x0398, 0x03D1, 0x03F4, eos,
	0x03BA, 0x039A, 0x03F0, eos,	//  741
	0x03BB, 0x039B, eos,
	0x03BD, 0x039D, eos,
	0x03BE, 0x039E, eos,	//  751
	0x03BF, 0x039F, eos,
	0x03C0, 0x03A0, 0x03D6, eos,
	0x03C1, 0x03A1, 0x03F1, eos,	//  761
	0x03C3, 0x03A3, 0x03C2, eos,
	0x03C4, 0x03A4, eos,
	0x03C5, 0x03A5, eos,	//  772
	0x03C6, 0x03A6, 0x03D5, eos,
	0x03C7, 0x03A7, eos,
	0x03C8, 0x03A8, eos,	//  782
	0x03C9, 0x03A9, 0x2126, eos,
	0x03CA, 0x03AA, eos,
	0x03CB, 0x03AB, eos,	//  792
	0x03D7, 0x03CF, eos,
	0x03D9, 0x03D8, eos,
	0x03DB, 0x03DA, eos,	//  801
	0x03DD, 0x03DC, eos,
	0x03DF, 0x03DE, eos,
	0x03E1, 0x03E0, eos,	//  810
	0x03E3, 0x03E2, eos,
	0x03E5, 0x03E4, eos,
	0x03E7, 0x03E6, eos,
	0x03E9, 0x03E8, eos,	//  822
	0x03EB, 0x03EA, eos,
	0x03ED, 0x03EC, eos,
	0x03EF, 0x03EE, eos,	//  831
	0x03F8, 0x03F7, eos,
	0x03F2, 0x03F9, eos,
	0x03FB, 0x03FA, eos,	//  840
	0x037B, 0x03FD, eos,
	0x037C, 0x03FE, eos,
	0x037D, 0x03FF, eos,
	0x0450, 0x0400, eos,	//  852
	0x0451, 0x0401, eos,
	0x0452, 0x0402, eos,
	0x0453, 0x0403, eos,	//  861
	0x0454, 0x0404, eos,
	0x0455, 0x0405, eos,
	0x0456, 0x0406, eos,	//  870
	0x0457, 0x0407, eos,
	0x0458, 0x0408, eos,
	0x0459, 0x0409, eos,
	0x045A, 0x040A, eos,	//  882
	0x045B, 0x040B, eos,
	0x045C, 0x040C, eos,
	0x045D, 0x040D, eos,	//  891
	0x045E, 0x040E, eos,
	0x045F, 0x040F, eos,
	0x0430, 0x0410, eos,	//  900
	0x0431, 0x0411, eos,
	0x0432, 0x0412, 0x1C80, eos,
	0x0433, 0x0413, eos,	//  910
	0x0434, 0x0414, 0x1C81, eos,
	0x0435, 0x0415, eos,
	0x0436, 0x0416, eos,	//  920
	0x0437, 0x0417, eos,
	0x0438, 0x0418, eos,
	0x0439, 0x0419, eos,
	0x043A, 0x041A, eos,	//  932
	0x043B, 0x041B, eos,
	0x043C, 0x041C, eos,
	0x043D, 0x041D, eos,	//  941
	0x043E, 0x041E, 0x1C82, eos,
	0x043F, 0x041F, eos,
	0x0440, 0x0420, eos,	//  951
	0x0441, 0x0421, 0x1C83, eos,
	0x0442, 0x0422, 0x1C84, 0x1C85, eos,
	0x0443, 0x0423, eos,	//  963
	0x0444, 0x0424, eos,
	0x0445, 0x0425, eos,
	0x0446, 0x0426, eos,	//  972
	0x0447, 0x0427, eos,
	0x0448, 0x0428, eos,
	0x0449, 0x0429, eos,	//  981
	0x044A, 0x042A, 0x1C86, eos,
	0x044B, 0x042B, eos,
	0x044C, 0x042C, eos,	//  991
	0x044D, 0x042D, eos,
	0x044E, 0x042E, eos,
	0x044F, 0x042F, eos,	//  1000
	0x0461, 0x0460, eos,
	0x0463, 0x0462, 0x1C87, eos,
	0x0465, 0x0464, eos,	//  1010
	0x0467, 0x0466, eos,
	0x0469, 0x0468, eos,
	0x046B, 0x046A, eos,
	0x046D, 0x046C, eos,	//  1022
	0x046F, 0x046E, eos,
	0x0471, 0x0470, eos,
	0x0473, 0x0472, eos,	//  1031
	0x0475, 0x0474, eos,
	0x0477, 0x0476, eos,
	0x0479, 0x0478, eos,	//  1040
	0x047B, 0x047A, eos,
	0x047D, 0x047C, eos,
	0x047F, 0x047E, eos,
	0x0481, 0x0480, eos,	//  1052
	0x048B, 0x048A, eos,
	0x048D, 0x048C, eos,
	0x048F, 0x048E, eos,	//  1061
	0x0491, 0x0490, eos,
	0x0493, 0x0492, eos,
	0x0495, 0x0494, eos,	//  1070
	0x0497, 0x0496, eos,
	0x0499, 0x0498, eos,
	0x049B, 0x049A, eos,
	0x049D, 0x049C, eos,	//  1082
	0x049F, 0x049E, eos,
	0x04A1, 0x04A0, eos,
	0x04A3, 0x04A2, eos,	//  1091
	0x04A5, 0x04A4, eos,
	0x04A7, 0x04A6, eos,
	0x04A9, 0x04A8, eos,	//  1100
	0x04AB, 0x04AA, eos,
	0x04AD, 0x04AC, eos,
	0x04AF, 0x04AE, eos,
	0x04B1, 0x04B0, eos,	//  1112
	0x04B3, 0x04B2, eos,
	0x04B5, 0x04B4, eos,
	0x04B7, 0x04B6, eos,	//  1121
	0x04B9, 0x04B8, eos,
	0x04BB, 0x04BA, eos,
	0x04BD, 0x04BC, eos,	//  1130
	0x04BF, 0x04BE, eos,
	0x04CF, 0x04C0, eos,
	0x04C2, 0x04C1, eos,
	0x04C4, 0x04C3, eos,	//  1142
	0x04C6, 0x04C5, eos,
	0x04C8, 0x04C7, eos,
	0x04CA, 0x04C9, eos,	//  1151
	0x04CC, 0x04CB, eos,
	0x04CE, 0x04CD, eos,
	0x04D1, 0x04D0, eos,	//  1160
	0x04D3, 0x04D2, eos,
	0x04D5, 0x04D4, eos,
	0x04D7, 0x04D6, eos,
	0x04D9, 0x04D8, eos,	//  1172
	0x04DB, 0x04DA, eos,
	0x04DD, 0x04DC, eos,
	0x04DF, 0x04DE, eos,	//  1181
	0x04E1, 0x04E0, eos,
	0x04E3, 0x04E2, eos,
	0x04E5, 0x04E4, eos,	//  1190
	0x04E7, 0x04E6, eos,
	0x04E9, 0x04E8, eos,
	0x04EB, 0x04EA, eos,
	0x04ED, 0x04EC, eos,	//  1202
	0x04EF, 0x04EE, eos,
	0x04F1, 0x04F0, eos,
	0x04F3, 0x04F2, eos,	//  1211
	0x04F5, 0x04F4, eos,
	0x04F7, 0x04F6, eos,
	0x04F9, 0x04F8, eos,	//  1220
	0x04FB, 0x04FA, eos,
	0x04FD, 0x04FC, eos,
	0x04FF, 0x04FE, eos,
	0x0501, 0x0500, eos,	//  1232
	0x0503, 0x0502, eos,
	0x0505, 0x0504, eos,
	0x0507, 0x0506, eos,	//  1241
	0x0509, 0x0508, eos,
	0x050B, 0x050A, eos,
	0x050D, 0x050C, eos,	//  1250
	0x050F, 0x050E, eos,
	0x0511, 0x0510, eos,
	0x0513, 0x0512, eos,
	0x0515, 0x0514, eos,	//  1262
	0x0517, 0x0516, eos,
	0x0519, 0x0518, eos,
	0x051B, 0x051A, eos,	//  1271
	0x051D, 0x051C, eos,
	0x051F, 0x051E, eos,
	0x0521, 0x0520, eos,	//  1280
	0x0523, 0x0522, eos,
	0x0525, 0x0524, eos,
	0x0527, 0x0526, eos,
	0x0529, 0x0528, eos,	//  1292
	0x052B, 0x052A, eos,
	0x052D, 0x052C, eos,
	0x052F, 0x052E, eos,	//  1301
	0x0561, 0x0531, eos,
	0x0562, 0x0532, eos,
	0x0563, 0x0533, eos,	//  1310
	0x0564, 0x0534, eos,
	0x0565, 0x0535, eos,
	0x0566, 0x0536, eos,
	0x0567, 0x0537, eos,	//  1322
	0x0568, 0x0538, eos,
	0x0569, 0x0539, eos,
	0x056A, 0x053A, eos,	//  1331
	0x056B, 0x053B, eos,
	0x056C, 0x053C, eos,
	0x056D, 0x053D, eos,	//  1340
	0x056E, 0x053E, eos,
	0x056F, 0x053F, eos,
	0x0570, 0x0540, eos,
	0x0571, 0x0541, eos,	//  1352
	0x0572, 0x0542, eos,
	0x0573, 0x0543, eos,
	0x0574, 0x0544, eos,	//  1361
	0x0575, 0x0545, eos,
	0x0576, 0x0546, eos,
	0x0577, 0x0547, eos,	//  1370
	0x0578, 0x0548, eos,
	0x0579, 0x0549, eos,
	0x057A, 0x054A, eos,
	0x057B, 0x054B, eos,	//  1382
	0x057C, 0x054C, eos,
	0x057D, 0x054D, eos,
	0x057E, 0x054E, eos,	//  1391
	0x057F, 0x054F, eos,
	0x0580, 0x0550, eos,
	0x0581, 0x0551, eos,	//  1400
	0x0582, 0x0552, eos,
	0x0583, 0x0553, eos,
	0x0584, 0x0554, eos,
	0x0585, 0x0555, eos,	//  1412
	0x0586, 0x0556, eos,
	0x2D00, 0x10A0, eos,
	0x2D01, 0x10A1, eos,	//  1421
	0x2D02, 0x10A2, eos,
	0x2D03, 0x10A3, eos,
	0x2D04, 0x10A4, eos,	//  1430
	0x2D05, 0x10A5, eos,
	0x2D06, 0x10A6, eos,
	0x2D07, 0x10A7, eos,
	0x2D08, 0x10A8, eos,	//  1442
	0x2D09, 0x10A9, eos,
	0x2D0A, 0x10AA, eos,
	0x2D0B, 0x10AB, eos,	//  1451
	0x2D0C, 0x10AC, eos,
	0x2D0D, 0x10AD, eos,
	0x2D0E, 0x10AE, eos,	//  1460
	0x2D0F, 0x10AF, eos,
	0x2D10, 0x10B0, eos,
	0x2D11, 0x10B1, eos,
	0x2D12, 0x10B2, eos,	//  1472
	0x2D13, 0x10B3, eos,
	0x2D14, 0x10B4, eos,
	0x2D15, 0x10B5, eos,	//  1481
	0x2D16, 0x10B6, eos,
	0x2D17, 0x10B7, eos,
	0x2D18, 0x10B8, eos,	//  1490
	0x2D19, 0x10B9, eos,
	0x2D1A, 0x10BA, eos,
	0x2D1B, 0x10BB, eos,
	0x2D1C, 0x10BC, eos,	//  1502
	0x2D1D, 0x10BD, eos,
	0x2D1E, 0x10BE, eos,
	0x2D1F, 0x10BF, eos,	//  1511
	0x2D20, 0x10C0, eos,
	0x2D21, 0x10C1, eos,
	0x2D22, 0x10C2, eos,	//  1520
	0x2D23, 0x10C3, eos,
	0x2D24, 0x10C4, eos,
	0x2D25, 0x10C5, eos,
	0x2D27, 0x10C7, eos,	//  1532
	0x2D2D, 0x10CD, eos,
	0x13F0, 0x13F8, eos,
	0x13F1, 0x13F9, eos,	//  1541
	0x13F2, 0x13FA, eos,
	0x13F3, 0x13FB, eos,
	0x13F4, 0x13FC, eos,	//  1550
	0x13F5, 0x13FD, eos,
	0xA64B, 0x1C88, 0xA64A, eos,
	0x10D0, 0x1C90, eos,	//  1560
	0x10D1, 0x1C91, eos,
	0x10D2, 0x1C92, eos,
	0x10D3, 0x1C93, eos,
	0x10D4, 0x1C94, eos,	//  1572
	0x10D5, 0x1C95, eos,
	0x10D6, 0x1C96, eos,
	0x10D7, 0x1C97, eos,	//  1581
	0x10D8, 0x1C98, eos,
	0x10D9, 0x1C99, eos,
	0x10DA, 0x1C9A, eos,	//  1590
	0x10DB, 0x1C9B, eos,
	0x10DC, 0x1C9C, eos,
	0x10DD, 0x1C9D, eos,
	0x10DE, 0x1C9E, eos,	//  1602
	0x10DF, 0x1C9F, eos,
	0x10E0, 0x1CA0, eos,
	0x10E1, 0x1CA1, eos,	//  1611
	0x10E2, 0x1CA2, eos,
	0x10E3, 0x1CA3, eos,
	0x10E4, 0x1CA4, eos,	//  1620
	0x10E5, 0x1CA5, eos,
	0x10E6, 0x1CA6, eos,
	0x10E7, 0x1CA7, eos,
	0x10E8, 0x1CA8, eos,	//  1632
	0x10E9, 0x1CA9, eos,
	0x10EA, 0x1CAA, eos,
	0x10EB, 0x1CAB, eos,	//  1641
	0x10EC, 0x1CAC, eos,
	0x10ED, 0x1CAD, eos,
	0x10EE, 0x1CAE, eos,	//  1650
	0x10EF, 0x1CAF, eos,
	0x10F0, 0x1CB0, eos,
	0x10F1, 0x1CB1, eos,
	0x10F2, 0x1CB2, eos,	//  1662
	0x10F3, 0x1CB3, eos,
	0x10F4, 0x1CB4, eos,
	0x10F5, 0x1CB5, eos,	//  1671
	0x10F6, 0x1CB6, eos,
	0x10F7, 0x1CB7, eos,
	0x10F8, 0x1CB8, eos,	//  1680
	0x10F9, 0x1CB9, eos,
	0x10FA, 0x1CBA, eos,
	0x10FD, 0x1CBD, eos,
	0x10FE, 0x1CBE, eos,	//  1692
	0x10FF, 0x1CBF, eos,
	0x1E01, 0x1E00, eos,
	0x1E03, 0x1E02, eos,	//  1701
	0x1E05, 0x1E04, eos,
	0x1E07, 0x1E06, eos,
	0x1E09, 0x1E08, eos,	//  1710
	0x1E0B, 0x1E0A, eos,
	0x1E0D, 0x1E0C, eos,
	0x1E0F, 0x1E0E, eos,
	0x1E11, 0x1E10, eos,	//  1722
	0x1E13, 0x1E12, eos,
	0x1E15, 0x1E14, eos,
	0x1E17, 0x1E16, eos,	//  1731
	0x1E19, 0x1E18, eos,
	0x1E1B, 0x1E1A, eos,
	0x1E1D, 0x1E1C, eos,	//  1740
	0x1E1F, 0x1E1E, eos,
	0x1E21, 0x1E20, eos,
	0x1E23, 0x1E22, eos,
	0x1E25, 0x1E24, eos,	//  1752
	0x1E27, 0x1E26, eos,
	0x1E29, 0x1E28, eos,
	0x1E2B, 0x1E2A, eos,	//  1761
	0x1E2D, 0x1E2C, eos,
	0x1E2F, 0x1E2E, eos,
	0x1E31, 0x1E30, eos,	//  1770
	0x1E33, 0x1E32, eos,
	0x1E35, 0x1E34, eos,
	0x1E37, 0x1E36, eos,
	0x1E39, 0x1E38, eos,	//  1782
	0x1E3B, 0x1E3A, eos,
	0x1E3D, 0x1E3C, eos,
	0x1E3F, 0x1E3E, eos,	//  1791
	0x1E41, 0x1E40, eos,
	0x1E43, 0x1E42, eos,
	0x1E45, 0x1E44, eos,	//  1800
	0x1E47, 0x1E46, eos,
	0x1E49, 0x1E48, eos,
	0x1E4B, 0x1E4A, eos,
	0x1E4D, 0x1E4C, eos,	//  1812
	0x1E4F, 0x1E4E, eos,
	0x1E51, 0x1E50, eos,
	0x1E53, 0x1E52, eos,	//  1821
	0x1E55, 0x1E54, eos,
	0x1E57, 0x1E56, eos,
	0x1E59, 0x1E58, eos,	//  1830
	0x1E5B, 0x1E5A, eos,
	0x1E5D, 0x1E5C, eos,
	0x1E5F, 0x1E5E, eos,
	0x1E61, 0x1E60, 0x1E9B, eos,	//  1842
	0x1E63, 0x1E62, eos,
	0x1E65, 0x1E64, eos,
	0x1E67, 0x1E66, eos,	//  1852
	0x1E69, 0x1E68, eos,
	0x1E6B, 0x1E6A, eos,
	0x1E6D, 0x1E6C, eos,	//  1861
	0x1E6F, 0x1E6E, eos,
	0x1E71, 0x1E70, eos,
	0x1E73, 0x1E72, eos,	//  1870
	0x1E75, 0x1E74, eos,
	0x1E77, 0x1E76, eos,
	0x1E79, 0x1E78, eos,
	0x1E7B, 0x1E7A, eos,	//  1882
	0x1E7D, 0x1E7C, eos,
	0x1E7F, 0x1E7E, eos,
	0x1E81, 0x1E80, eos,	//  1891
	0x1E83, 0x1E82, eos,
	0x1E85, 0x1E84, eos,
	0x1E87, 0x1E86, eos,	//  1900
	0x1E89, 0x1E88, eos,
	0x1E8B, 0x1E8A, eos,
	0x1E8D, 0x1E8C, eos,
	0x1E8F, 0x1E8E, eos,	//  1912
	0x1E91, 0x1E90, eos,
	0x1E93, 0x1E92, eos,
	0x1E95, 0x1E94, eos,	//  1921
	0x00DF, 0x1E9E, eos,
	0x1EA1, 0x1EA0, eos,
	0x1EA3, 0x1EA2, eos,	//  1930
	0x1EA5, 0x1EA4, eos,
	0x1EA7, 0x1EA6, eos,
	0x1EA9, 0x1EA8, eos,
	0x1EAB, 0x1EAA, eos,	//  1942
	0x1EAD, 0x1EAC, eos,
	0x1EAF, 0x1EAE, eos,
	0x1EB1, 0x1EB0, eos,	//  1951
	0x1EB3, 0x1EB2, eos,
	0x1EB5, 0x1EB4, eos,
	0x1EB7, 0x1EB6, eos,	//  1960
	0x1EB9, 0x1EB8, eos,
	0x1EBB, 0x1EBA, eos,
	0x1EBD, 0x1EBC, eos,
	0x1EBF, 0x1EBE, eos,	//  1972
	0x1EC1, 0x1EC0, eos,
	0x1EC3, 0x1EC2, eos,
	0x1EC5, 0x1EC4, eos,	//  1981
	0x1EC7, 0x1EC6, eos,
	0x1EC9, 0x1EC8, eos,
	0x1ECB, 0x1ECA, eos,	//  1990
	0x1ECD, 0x1ECC, eos,
	0x1ECF, 0x1ECE, eos,
	0x1ED1, 0x1ED0, eos,
	0x1ED3, 0x1ED2, eos,	//  2002
	0x1ED5, 0x1ED4, eos,
	0x1ED7, 0x1ED6, eos,
	0x1ED9, 0x1ED8, eos,	//  2011
	0x1EDB, 0x1EDA, eos,
	0x1EDD, 0x1EDC, eos,
	0x1EDF, 0x1EDE, eos,	//  2020
	0x1EE1, 0x1EE0, eos,
	0x1EE3, 0x1EE2, eos,
	0x1EE5, 0x1EE4, eos,
	0x1EE7, 0x1EE6, eos,	//  2032
	0x1EE9, 0x1EE8, eos,
	0x1EEB, 0x1EEA, eos,
	0x1EED, 0x1EEC, eos,	//  2041
	0x1EEF, 0x1EEE, eos,
	0x1EF1, 0x1EF0, eos,
	0x1EF3, 0x1EF2, eos,	//  2050
	0x1EF5, 0x1EF4, eos,
	0x1EF7, 0x1EF6, eos,
	0x1EF9, 0x1EF8, eos,
	0x1EFB, 0x1EFA, eos,	//  2062
	0x1EFD, 0x1EFC, eos,
	0x1EFF, 0x1EFE, eos,
	0x1F00, 0x1F08, eos,	//  2071
	0x1F01, 0x1F09, eos,
	0x1F02, 0x1F0A, eos,
	0x1F03, 0x1F0B, eos,	//  2080
	0x1F04, 0x1F0C, eos,
	0x1F05, 0x1F0D, eos,
	0x1F06, 0x1F0E, eos,
	0x1F07, 0x1F0F, eos,	//  2092
	0x1F10, 0x1F18, eos,
	0x1F11, 0x1F19, eos,
	0x1F12, 0x1F1A, eos,	//  2101
	0x1F13, 0x1F1B, eos,
	0x1F14, 0x1F1C, eos,
	0x1F15, 0x1F1D, eos,	//  2110
	0x1F20, 0x1F28, eos,
	0x1F21, 0x1F29, eos,
	0x1F22, 0x1F2A, eos,
	0x1F23, 0x1F2B, eos,	//  2122
	0x1F24, 0x1F2C, eos,
	0x1F25, 0x1F2D, eos,
	0x1F26, 0x1F2E, eos,	//  2131
	0x1F27, 0x1F2F, eos,
	0x1F30, 0x1F38, eos,
	0x1F31, 0x1F39, eos,	//  2140
	0x1F32, 0x1F3A, eos,
	0x1F33, 0x1F3B, eos,
	0x1F34, 0x1F3C, eos,
	0x1F35, 0x1F3D, eos,	//  2152
	0x1F36, 0x1F3E, eos,
	0x1F37, 0x1F3F, eos,
	0x1F40, 0x1F48, eos,	//  2161
	0x1F41, 0x1F49, eos,
	0x1F42, 0x1F4A, eos,
	0x1F43, 0x1F4B, eos,	//  2170
	0x1F44, 0x1F4C, eos,
	0x1F45, 0x1F4D, eos,
	0x1F51, 0x1F59, eos,
	0x1F53, 0x1F5B, eos,	//  2182
	0x1F55, 0x1F5D, eos,
	0x1F57, 0x1F5F, eos,
	0x1F60, 0x1F68, eos,	//  2191
	0x1F61, 0x1F69, eos,
	0x1F62, 0x1F6A, eos,
	0x1F63, 0x1F6B, eos,	//  2200
	0x1F64, 0x1F6C, eos,
	0x1F65, 0x1F6D, eos,
	0x1F66, 0x1F6E, eos,
	0x1F67, 0x1F6F, eos,	//  2212
	0x1F80, 0x1F88, eos,
	0x1F81, 0x1F89, eos,
	0x1F82, 0x1F8A, eos,	//  2221
	0x1F83, 0x1F8B, eos,
	0x1F84, 0x1F8C, eos,
	0x1F85, 0x1F8D, eos,	//  2230
	0x1F86, 0x1F8E, eos,
	0x1F87, 0x1F8F, eos,
	0x1F90, 0x1F98, eos,
	0x1F91, 0x1F99, eos,	//  2242
	0x1F92, 0x1F9A, eos,
	0x1F93, 0x1F9B, eos,
	0x1F94, 0x1F9C, eos,	//  2251
	0x1F95, 0x1F9D, eos,
	0x1F96, 0x1F9E, eos,
	0x1F97, 0x1F9F, eos,	//  2260
	0x1FA0, 0x1FA8, eos,
	0x1FA1, 0x1FA9, eos,
	0x1FA2, 0x1FAA, eos,
	0x1FA3, 0x1FAB, eos,	//  2272
	0x1FA4, 0x1FAC, eos,
	0x1FA5, 0x1FAD, eos,
	0x1FA6, 0x1FAE, eos,	//  2281
	0x1FA7, 0x1FAF, eos,
	0x1FB0, 0x1FB8, eos,
	0x1FB1, 0x1FB9, eos,	//  2290
	0x1F70, 0x1FBA, eos,
	0x1F71, 0x1FBB, eos,
	0x1FB3, 0x1FBC, eos,
	0x1F72, 0x1FC8, eos,	//  2302
	0x1F73, 0x1FC9, eos,
	0x1F74, 0x1FCA, eos,
	0x1F75, 0x1FCB, eos,	//  2311
	0x1FC3, 0x1FCC, eos,
	0x1FD0, 0x1FD8, eos,
	0x1FD1, 0x1FD9, eos,	//  2320
	0x1F76, 0x1FDA, eos,
	0x1F77, 0x1FDB, eos,
	0x1FE0, 0x1FE8, eos,
	0x1FE1, 0x1FE9, eos,	//  2332
	0x1F7A, 0x1FEA, eos,
	0x1F7B, 0x1FEB, eos,
	0x1FE5, 0x1FEC, eos,	//  2341
	0x1F78, 0x1FF8, eos,
	0x1F79, 0x1FF9, eos,
	0x1F7C, 0x1FFA, eos,	//  2350
	0x1F7D, 0x1FFB, eos,
	0x1FF3, 0x1FFC, eos,
	0x214E, 0x2132, eos,
	0x2170, 0x2160, eos,	//  2362
	0x2171, 0x2161, eos,
	0x2172, 0x2162, eos,
	0x2173, 0x2163, eos,	//  2371
	0x2174, 0x2164, eos,
	0x2175, 0x2165, eos,
	0x2176, 0x2166, eos,	//  2380
	0x2177, 0x2167, eos,
	0x2178, 0x2168, eos,
	0x2179, 0x2169, eos,
	0x217A, 0x216A, eos,	//  2392
	0x217B, 0x216B, eos,
	0x217C, 0x216C, eos,
	0x217D, 0x216D, eos,	//  2401
	0x217E, 0x216E, eos,
	0x217F, 0x216F, eos,
	0x2184, 0x2183, eos,	//  2410
	0x24D0, 0x24B6, eos,
	0x24D1, 0x24B7, eos,
	0x24D2, 0x24B8, eos,
	0x24D3, 0x24B9, eos,	//  2422
	0x24D4, 0x24BA, eos,
	0x24D5, 0x24BB, eos,
	0x24D6, 0x24BC, eos,	//  2431
	0x24D7, 0x24BD, eos,
	0x24D8, 0x24BE, eos,
	0x24D9, 0x24BF, eos,	//  2440
	0x24DA, 0x24C0, eos,
	0x24DB, 0x24C1, eos,
	0x24DC, 0x24C2, eos,
	0x24DD, 0x24C3, eos,	//  2452
	0x24DE, 0x24C4, eos,
	0x24DF, 0x24C5, eos,
	0x24E0, 0x24C6, eos,	//  2461
	0x24E1, 0x24C7, eos,
	0x24E2, 0x24C8, eos,
	0x24E3, 0x24C9, eos,	//  2470
	0x24E4, 0x24CA, eos,
	0x24E5, 0x24CB, eos,
	0x24E6, 0x24CC, eos,
	0x24E7, 0x24CD, eos,	//  2482
	0x24E8, 0x24CE, eos,
	0x24E9, 0x24CF, eos,
	0x2C30, 0x2C00, eos,	//  2491
	0x2C31, 0x2C01, eos,
	0x2C32, 0x2C02, eos,
	0x2C33, 0x2C03, eos,	//  2500
	0x2C34, 0x2C04, eos,
	0x2C35, 0x2C05, eos,
	0x2C36, 0x2C06, eos,
	0x2C37, 0x2C07, eos,	//  2512
	0x2C38, 0x2C08, eos,
	0x2C39, 0x2C09, eos,
	0x2C3A, 0x2C0A, eos,	//  2521
	0x2C3B, 0x2C0B, eos,
	0x2C3C, 0x2C0C, eos,
	0x2C3D, 0x2C0D, eos,	//  2530
	0x2C3E, 0x2C0E, eos,
	0x2C3F, 0x2C0F, eos,
	0x2C40, 0x2C10, eos,
	0x2C41, 0x2C11, eos,	//  2542
	0x2C42, 0x2C12, eos,
	0x2C43, 0x2C13, eos,
	0x2C44, 0x2C14, eos,	//  2551
	0x2C45, 0x2C15, eos,
	0x2C46, 0x2C16, eos,
	0x2C47, 0x2C17, eos,	//  2560
	0x2C48, 0x2C18, eos,
	0x2C49, 0x2C19, eos,
	0x2C4A, 0x2C1A, eos,
	0x2C4B, 0x2C1B, eos,	//  2572
	0x2C4C, 0x2C1C, eos,
	0x2C4D, 0x2C1D, eos,
	0x2C4E, 0x2C1E, eos,	//  2581
	0x2C4F, 0x2C1F, eos,
	0x2C50, 0x2C20, eos,
	0x2C51, 0x2C21, eos,	//  2590
	0x2C52, 0x2C22, eos,
	0x2C53, 0x2C23, eos,
	0x2C54, 0x2C24, eos,
	0x2C55, 0x2C25, eos,	//  2602
	0x2C56, 0x2C26, eos,
	0x2C57, 0x2C27, eos,
	0x2C58, 0x2C28, eos,	//  2611
	0x2C59, 0x2C29, eos,
	0x2C5A, 0x2C2A, eos,
	0x2C5B, 0x2C2B, eos,	//  2620
	0x2C5C, 0x2C2C, eos,
	0x2C5D, 0x2C2D, eos,
	0x2C5E, 0x2C2E, eos,
	0x2C61, 0x2C60, eos,	//  2632
	0x026B, 0x2C62, eos,
	0x1D7D, 0x2C63, eos,
	0x027D, 0x2C64, eos,	//  2641
	0x2C68, 0x2C67, eos,
	0x2C6A, 0x2C69, eos,
	0x2C6C, 0x2C6B, eos,	//  2650
	0x0251, 0x2C6D, eos,
	0x0271, 0x2C6E, eos,
	0x0250, 0x2C6F, eos,
	0x0252, 0x2C70, eos,	//  2662
	0x2C73, 0x2C72, eos,
	0x2C76, 0x2C75, eos,
	0x023F, 0x2C7E, eos,	//  2671
	0x0240, 0x2C7F, eos,
	0x2C81, 0x2C80, eos,
	0x2C83, 0x2C82, eos,	//  2680
	0x2C85, 0x2C84, eos,
	0x2C87, 0x2C86, eos,
	0x2C89, 0x2C88, eos,
	0x2C8B, 0x2C8A, eos,	//  2692
	0x2C8D, 0x2C8C, eos,
	0x2C8F, 0x2C8E, eos,
	0x2C91, 0x2C90, eos,	//  2701
	0x2C93, 0x2C92, eos,
	0x2C95, 0x2C94, eos,
	0x2C97, 0x2C96, eos,	//  2710
	0x2C99, 0x2C98, eos,
	0x2C9B, 0x2C9A, eos,
	0x2C9D, 0x2C9C, eos,
	0x2C9F, 0x2C9E, eos,	//  2722
	0x2CA1, 0x2CA0, eos,
	0x2CA3, 0x2CA2, eos,
	0x2CA5, 0x2CA4, eos,	//  2731
	0x2CA7, 0x2CA6, eos,
	0x2CA9, 0x2CA8, eos,
	0x2CAB, 0x2CAA, eos,	//  2740
	0x2CAD, 0x2CAC, eos,
	0x2CAF, 0x2CAE, eos,
	0x2CB1, 0x2CB0, eos,
	0x2CB3, 0x2CB2, eos,	//  2752
	0x2CB5, 0x2CB4, eos,
	0x2CB7, 0x2CB6, eos,
	0x2CB9, 0x2CB8, eos,	//  2761
	0x2CBB, 0x2CBA, eos,
	0x2CBD, 0x2CBC, eos,
	0x2CBF, 0x2CBE, eos,	//  2770
	0x2CC1, 0x2CC0, eos,
	0x2CC3, 0x2CC2, eos,
	0x2CC5, 0x2CC4, eos,
	0x2CC7, 0x2CC6, eos,	//  2782
	0x2CC9, 0x2CC8, eos,
	0x2CCB, 0x2CCA, eos,
	0x2CCD, 0x2CCC, eos,	//  2791
	0x2CCF, 0x2CCE, eos,
	0x2CD1, 0x2CD0, eos,
	0x2CD3, 0x2CD2, eos,	//  2800
	0x2CD5, 0x2CD4, eos,
	0x2CD7, 0x2CD6, eos,
	0x2CD9, 0x2CD8, eos,
	0x2CDB, 0x2CDA, eos,	//  2812
	0x2CDD, 0x2CDC, eos,
	0x2CDF, 0x2CDE, eos,
	0x2CE1, 0x2CE0, eos,	//  2821
	0x2CE3, 0x2CE2, eos,
	0x2CEC, 0x2CEB, eos,
	0x2CEE, 0x2CED, eos,	//  2830
	0x2CF3, 0x2CF2, eos,
	0xA641, 0xA640, eos,
	0xA643, 0xA642, eos,
	0xA645, 0xA644, eos,	//  2842
	0xA647, 0xA646, eos,
	0xA649, 0xA648, eos,
	0xA64D, 0xA64C, eos,	//  2851
	0xA64F, 0xA64E, eos,
	0xA651, 0xA650, eos,
	0xA653, 0xA652, eos,	//  2860
	0xA655, 0xA654, eos,
	0xA657, 0xA656, eos,
	0xA659, 0xA658, eos,
	0xA65B, 0xA65A, eos,	//  2872
	0xA65D, 0xA65C, eos,
	0xA65F, 0xA65E, eos,
	0xA661, 0xA660, eos,	//  2881
	0xA663, 0xA662, eos,
	0xA665, 0xA664, eos,
	0xA667, 0xA666, eos,	//  2890
	0xA669, 0xA668, eos,
	0xA66B, 0xA66A, eos,
	0xA66D, 0xA66C, eos,
	0xA681, 0xA680, eos,	//  2902
	0xA683, 0xA682, eos,
	0xA685, 0xA684, eos,
	0xA687, 0xA686, eos,	//  2911
	0xA689, 0xA688, eos,
	0xA68B, 0xA68A, eos,
	0xA68D, 0xA68C, eos,	//  2920
	0xA68F, 0xA68E, eos,
	0xA691, 0xA690, eos,
	0xA693, 0xA692, eos,
	0xA695, 0xA694, eos,	//  2932
	0xA697, 0xA696, eos,
	0xA699, 0xA698, eos,
	0xA69B, 0xA69A, eos,	//  2941
	0xA723, 0xA722, eos,
	0xA725, 0xA724, eos,
	0xA727, 0xA726, eos,	//  2950
	0xA729, 0xA728, eos,
	0xA72B, 0xA72A, eos,
	0xA72D, 0xA72C, eos,
	0xA72F, 0xA72E, eos,	//  2962
	0xA733, 0xA732, eos,
	0xA735, 0xA734, eos,
	0xA737, 0xA736, eos,	//  2971
	0xA739, 0xA738, eos,
	0xA73B, 0xA73A, eos,
	0xA73D, 0xA73C, eos,	//  2980
	0xA73F, 0xA73E, eos,
	0xA741, 0xA740, eos,
	0xA743, 0xA742, eos,
	0xA745, 0xA744, eos,	//  2992
	0xA747, 0xA746, eos,
	0xA749, 0xA748, eos,
	0xA74B, 0xA74A, eos,	//  3001
	0xA74D, 0xA74C, eos,
	0xA74F, 0xA74E, eos,
	0xA751, 0xA750, eos,	//  3010
	0xA753, 0xA752, eos,
	0xA755, 0xA754, eos,
	0xA757, 0xA756, eos,
	0xA759, 0xA758, eos,	//  3022
	0xA75B, 0xA75A, eos,
	0xA75D, 0xA75C, eos,
	0xA75F, 0xA75E, eos,	//  3031
	0xA761, 0xA760, eos,
	0xA763, 0xA762, eos,
	0xA765, 0xA764, eos,	//  3040
	0xA767, 0xA766, eos,
	0xA769, 0xA768, eos,
	0xA76B, 0xA76A, eos,
	0xA76D, 0xA76C, eos,	//  3052
	0xA76F, 0xA76E, eos,
	0xA77A, 0xA779, eos,
	0xA77C, 0xA77B, eos,	//  3061
	0x1D79, 0xA77D, eos,
	0xA77F, 0xA77E, eos,
	0xA781, 0xA780, eos,	//  3070
	0xA783, 0xA782, eos,
	0xA785, 0xA784, eos,
	0xA787, 0xA786, eos,
	0xA78C, 0xA78B, eos,	//  3082
	0x0265, 0xA78D, eos,
	0xA791, 0xA790, eos,
	0xA793, 0xA792, eos,	//  3091
	0xA797, 0xA796, eos,
	0xA799, 0xA798, eos,
	0xA79B, 0xA79A, eos,	//  3100
	0xA79D, 0xA79C, eos,
	0xA79F, 0xA79E, eos,
	0xA7A1, 0xA7A0, eos,
	0xA7A3, 0xA7A2, eos,	//  3112
	0xA7A5, 0xA7A4, eos,
	0xA7A7, 0xA7A6, eos,
	0xA7A9, 0xA7A8, eos,	//  3121
	0x0266, 0xA7AA, eos,
	0x025C, 0xA7AB, eos,
	0x0261, 0xA7AC, eos,	//  3130
	0x026C, 0xA7AD, eos,
	0x026A, 0xA7AE, eos,
	0x029E, 0xA7B0, eos,
	0x0287, 0xA7B1, eos,	//  3142
	0x029D, 0xA7B2, eos,
	0xAB53, 0xA7B3, eos,
	0xA7B5, 0xA7B4, eos,	//  3151
	0xA7B7, 0xA7B6, eos,
	0xA7B9, 0xA7B8, eos,
	0xA7BB, 0xA7BA, eos,	//  3160
	0xA7BD, 0xA7BC, eos,
	0xA7BF, 0xA7BE, eos,
	0xA7C3, 0xA7C2, eos,
	0xA794, 0xA7C4, eos,	//  3172
	0x0282, 0xA7C5, eos,
	0x1D8E, 0xA7C6, eos,
	0x13A0, 0xAB70, eos,	//  3181
	0x13A1, 0xAB71, eos,
	0x13A2, 0xAB72, eos,
	0x13A3, 0xAB73, eos,	//  3190
	0x13A4, 0xAB74, eos,
	0x13A5, 0xAB75, eos,
	0x13A6, 0xAB76, eos,
	0x13A7, 0xAB77, eos,	//  3202
	0x13A8, 0xAB78, eos,
	0x13A9, 0xAB79, eos,
	0x13AA, 0xAB7A, eos,	//  3211
	0x13AB, 0xAB7B, eos,
	0x13AC, 0xAB7C, eos,
	0x13AD, 0xAB7D, eos,	//  3220
	0x13AE, 0xAB7E, eos,
	0x13AF, 0xAB7F, eos,
	0x13B0, 0xAB80, eos,
	0x13B1, 0xAB81, eos,	//  3232
	0x13B2, 0xAB82, eos,
	0x13B3, 0xAB83, eos,
	0x13B4, 0xAB84, eos,	//  3241
	0x13B5, 0xAB85, eos,
	0x13B6, 0xAB86, eos,
	0x13B7, 0xAB87, eos,	//  3250
	0x13B8, 0xAB88, eos,
	0x13B9, 0xAB89, eos,
	0x13BA, 0xAB8A, eos,
	0x13BB, 0xAB8B, eos,	//  3262
	0x13BC, 0xAB8C, eos,
	0x13BD, 0xAB8D, eos,
	0x13BE, 0xAB8E, eos,	//  3271
	0x13BF, 0xAB8F, eos,
	0x13C0, 0xAB90, eos,
	0x13C1, 0xAB91, eos,	//  3280
	0x13C2, 0xAB92, eos,
	0x13C3, 0xAB93, eos,
	0x13C4, 0xAB94, eos,
	0x13C5, 0xAB95, eos,	//  3292
	0x13C6, 0xAB96, eos,
	0x13C7, 0xAB97, eos,
	0x13C8, 0xAB98, eos,	//  3301
	0x13C9, 0xAB99, eos,
	0x13CA, 0xAB9A, eos,
	0x13CB, 0xAB9B, eos,	//  3310
	0x13CC, 0xAB9C, eos,
	0x13CD, 0xAB9D, eos,
	0x13CE, 0xAB9E, eos,
	0x13CF, 0xAB9F, eos,	//  3322
	0x13D0, 0xABA0, eos,
	0x13D1, 0xABA1, eos,
	0x13D2, 0xABA2, eos,	//  3331
	0x13D3, 0xABA3, eos,
	0x13D4, 0xABA4, eos,
	0x13D5, 0xABA5, eos,	//  3340
	0x13D6, 0xABA6, eos,
	0x13D7, 0xABA7, eos,
	0x13D8, 0xABA8, eos,
	0x13D9, 0xABA9, eos,	//  3352
	0x13DA, 0xABAA, eos,
	0x13DB, 0xABAB, eos,
	0x13DC, 0xABAC, eos,	//  3361
	0x13DD, 0xABAD, eos,
	0x13DE, 0xABAE, eos,
	0x13DF, 0xABAF, eos,	//  3370
	0x13E0, 0xABB0, eos,
	0x13E1, 0xABB1, eos,
	0x13E2, 0xABB2, eos,
	0x13E3, 0xABB3, eos,	//  3382
	0x13E4, 0xABB4, eos,
	0x13E5, 0xABB5, eos,
	0x13E6, 0xABB6, eos,	//  3391
	0x13E7, 0xABB7, eos,
	0x13E8, 0xABB8, eos,
	0x13E9, 0xABB9, eos,	//  3400
	0x13EA, 0xABBA, eos,
	0x13EB, 0xABBB, eos,
	0x13EC, 0xABBC, eos,
	0x13ED, 0xABBD, eos,	//  3412
	0x13EE, 0xABBE, eos,
	0x13EF, 0xABBF, eos,
	0xFF41, 0xFF21, eos,	//  3421
	0xFF42, 0xFF22, eos,
	0xFF43, 0xFF23, eos,
	0xFF44, 0xFF24, eos,	//  3430
	0xFF45, 0xFF25, eos,
	0xFF46, 0xFF26, eos,
	0xFF47, 0xFF27, eos,
	0xFF48, 0xFF28, eos,	//  3442
	0xFF49, 0xFF29, eos,
	0xFF4A, 0xFF2A, eos,
	0xFF4B, 0xFF2B, eos,	//  3451
	0xFF4C, 0xFF2C, eos,
	0xFF4D, 0xFF2D, eos,
	0xFF4E, 0xFF2E, eos,	//  3460
	0xFF4F, 0xFF2F, eos,
	0xFF50, 0xFF30, eos,
	0xFF51, 0xFF31, eos,
	0xFF52, 0xFF32, eos,	//  3472
	0xFF53, 0xFF33, eos,
	0xFF54, 0xFF34, eos,
	0xFF55, 0xFF35, eos,	//  3481
	0xFF56, 0xFF36, eos,
	0xFF57, 0xFF37, eos,
	0xFF58, 0xFF38, eos,	//  3490
	0xFF59, 0xFF39, eos,
	0xFF5A, 0xFF3A, eos,
	0x10428, 0x10400, eos,
	0x10429, 0x10401, eos,	//  3502
	0x1042A, 0x10402, eos,
	0x1042B, 0x10403, eos,
	0x1042C, 0x10404, eos,	//  3511
	0x1042D, 0x10405, eos,
	0x1042E, 0x10406, eos,
	0x1042F, 0x10407, eos,	//  3520
	0x10430, 0x10408, eos,
	0x10431, 0x10409, eos,
	0x10432, 0x1040A, eos,
	0x10433, 0x1040B, eos,	//  3532
	0x10434, 0x1040C, eos,
	0x10435, 0x1040D, eos,
	0x10436, 0x1040E, eos,	//  3541
	0x10437, 0x1040F, eos,
	0x10438, 0x10410, eos,
	0x10439, 0x10411, eos,	//  3550
	0x1043A, 0x10412, eos,
	0x1043B, 0x10413, eos,
	0x1043C, 0x10414, eos,
	0x1043D, 0x10415, eos,	//  3562
	0x1043E, 0x10416, eos,
	0x1043F, 0x10417, eos,
	0x10440, 0x10418, eos,	//  3571
	0x10441, 0x10419, eos,
	0x10442, 0x1041A, eos,
	0x10443, 0x1041B, eos,	//  3580
	0x10444, 0x1041C, eos,
	0x10445, 0x1041D, eos,
	0x10446, 0x1041E, eos,
	0x10447, 0x1041F, eos,	//  3592
	0x10448, 0x10420, eos,
	0x10449, 0x10421, eos,
	0x1044A, 0x10422, eos,	//  3601
	0x1044B, 0x10423, eos,
	0x1044C, 0x10424, eos,
	0x1044D, 0x10425, eos,	//  3610
	0x1044E, 0x10426, eos,
	0x1044F, 0x10427, eos,
	0x104D8, 0x104B0, eos,
	0x104D9, 0x104B1, eos,	//  3622
	0x104DA, 0x104B2, eos,
	0x104DB, 0x104B3, eos,
	0x104DC, 0x104B4, eos,	//  3631
	0x104DD, 0x104B5, eos,
	0x104DE, 0x104B6, eos,
	0x104DF, 0x104B7, eos,	//  3640
	0x104E0, 0x104B8, eos,
	0x104E1, 0x104B9, eos,
	0x104E2, 0x104BA, eos,
	0x104E3, 0x104BB, eos,	//  3652
	0x104E4, 0x104BC, eos,
	0x104E5, 0x104BD, eos,
	0x104E6, 0x104BE, eos,	//  3661
	0x104E7, 0x104BF, eos,
	0x104E8, 0x104C0, eos,
	0x104E9, 0x104C1, eos,	//  3670
	0x104EA, 0x104C2, eos,
	0x104EB, 0x104C3, eos,
	0x104EC, 0x104C4, eos,
	0x104ED, 0x104C5, eos,	//  3682
	0x104EE, 0x104C6, eos,
	0x104EF, 0x104C7, eos,
	0x104F0, 0x104C8, eos,	//  3691
	0x104F1, 0x104C9, eos,
	0x104F2, 0x104CA, eos,
	0x104F3, 0x104CB, eos,	//  3700
	0x104F4, 0x104CC, eos,
	0x104F5, 0x104CD, eos,
	0x104F6, 0x104CE, eos,
	0x104F7, 0x104CF, eos,	//  3712
	0x104F8, 0x104D0, eos,
	0x104F9, 0x104D1, eos,
	0x104FA, 0x104D2, eos,	//  3721
	0x104FB, 0x104D3, eos,
	0x10CC0, 0x10C80, eos,
	0x10CC1, 0x10C81, eos,	//  3730
	0x10CC2, 0x10C82, eos,
	0x10CC3, 0x10C83, eos,
	0x10CC4, 0x10C84, eos,
	0x10CC5, 0x10C85, eos,	//  3742
	0x10CC6, 0x10C86, eos,
	0x10CC7, 0x10C87, eos,
	0x10CC8, 0x10C88, eos,	//  3751
	0x10CC9, 0x10C89, eos,
	0x10CCA, 0x10C8A, eos,
	0x10CCB, 0x10C8B, eos,	//  3760
	0x10CCC, 0x10C8C, eos,
	0x10CCD, 0x10C8D, eos,
	0x10CCE, 0x10C8E, eos,
	0x10CCF, 0x10C8F, eos,	//  3772
	0x10CD0, 0x10C90, eos,
	0x10CD1, 0x10C91, eos,
	0x10CD2, 0x10C92, eos,	//  3781
	0x10CD3, 0x10C93, eos,
	0x10CD4, 0x10C94, eos,
	0x10CD5, 0x10C95, eos,	//  3790
	0x10CD6, 0x10C96, eos,
	0x10CD7, 0x10C97, eos,
	0x10CD8, 0x10C98, eos,
	0x10CD9, 0x10C99, eos,	//  3802
	0x10CDA, 0x10C9A, eos,
	0x10CDB, 0x10C9B, eos,
	0x10CDC, 0x10C9C, eos,	//  3811
	0x10CDD, 0x10C9D, eos,
	0x10CDE, 0x10C9E, eos,
	0x10CDF, 0x10C9F, eos,	//  3820
	0x10CE0, 0x10CA0, eos,
	0x10CE1, 0x10CA1, eos,
	0x10CE2, 0x10CA2, eos,
	0x10CE3, 0x10CA3, eos,	//  3832
	0x10CE4, 0x10CA4, eos,
	0x10CE5, 0x10CA5, eos,
	0x10CE6, 0x10CA6, eos,	//  3841
	0x10CE7, 0x10CA7, eos,
	0x10CE8, 0x10CA8, eos,
	0x10CE9, 0x10CA9, eos,	//  3850
	0x10CEA, 0x10CAA, eos,
	0x10CEB, 0x10CAB, eos,
	0x10CEC, 0x10CAC, eos,
	0x10CED, 0x10CAD, eos,	//  3862
	0x10CEE, 0x10CAE, eos,
	0x10CEF, 0x10CAF, eos,
	0x10CF0, 0x10CB0, eos,	//  3871
	0x10CF1, 0x10CB1, eos,
	0x10CF2, 0x10CB2, eos,
	0x118C0, 0x118A0, eos,	//  3880
	0x118C1, 0x118A1, eos,
	0x118C2, 0x118A2, eos,
	0x118C3, 0x118A3, eos,
	0x118C4, 0x118A4, eos,	//  3892
	0x118C5, 0x118A5, eos,
	0x118C6, 0x118A6, eos,
	0x118C7, 0x118A7, eos,	//  3901
	0x118C8, 0x118A8, eos,
	0x118C9, 0x118A9, eos,
	0x118CA, 0x118AA, eos,	//  3910
	0x118CB, 0x118AB, eos,
	0x118CC, 0x118AC, eos,
	0x118CD, 0x118AD, eos,
	0x118CE, 0x118AE, eos,	//  3922
	0x118CF, 0x118AF, eos,
	0x118D0, 0x118B0, eos,
	0x118D1, 0x118B1, eos,	//  3931
	0x118D2, 0x118B2, eos,
	0x118D3, 0x118B3, eos,
	0x118D4, 0x118B4, eos,	//  3940
	0x118D5, 0x118B5, eos,
	0x118D6, 0x118B6, eos,
	0x118D7, 0x118B7, eos,
	0x118D8, 0x118B8, eos,	//  3952
	0x118D9, 0x118B9, eos,
	0x118DA, 0x118BA, eos,
	0x118DB, 0x118BB, eos,	//  3961
	0x118DC, 0x118BC, eos,
	0x118DD, 0x118BD, eos,
	0x118DE, 0x118BE, eos,	//  3970
	0x118DF, 0x118BF, eos,
	0x16E60, 0x16E40, eos,
	0x16E61, 0x16E41, eos,
	0x16E62, 0x16E42, eos,	//  3982
	0x16E63, 0x16E43, eos,
	0x16E64, 0x16E44, eos,
	0x16E65, 0x16E45, eos,	//  3991
	0x16E66, 0x16E46, eos,
	0x16E67, 0x16E47, eos,
	0x16E68, 0x16E48, eos,	//  4000
	0x16E69, 0x16E49, eos,
	0x16E6A, 0x16E4A, eos,
	0x16E6B, 0x16E4B, eos,
	0x16E6C, 0x16E4C, eos,	//  4012
	0x16E6D, 0x16E4D, eos,
	0x16E6E, 0x16E4E, eos,
	0x16E6F, 0x16E4F, eos,	//  4021
	0x16E70, 0x16E50, eos,
	0x16E71, 0x16E51, eos,
	0x16E72, 0x16E52, eos,	//  4030
	0x16E73, 0x16E53, eos,
	0x16E74, 0x16E54, eos,
	0x16E75, 0x16E55, eos,
	0x16E76, 0x16E56, eos,	//  4042
	0x16E77, 0x16E57, eos,
	0x16E78, 0x16E58, eos,
	0x16E79, 0x16E59, eos,	//  4051
	0x16E7A, 0x16E5A, eos,
	0x16E7B, 0x16E5B, eos,
	0x16E7C, 0x16E5C, eos,	//  4060
	0x16E7D, 0x16E5D, eos,
	0x16E7E, 0x16E5E, eos,
	0x16E7F, 0x16E5F, eos,
	0x1E922, 0x1E900, eos,	//  4072
	0x1E923, 0x1E901, eos,
	0x1E924, 0x1E902, eos,
	0x1E925, 0x1E903, eos,	//  4081
	0x1E926, 0x1E904, eos,
	0x1E927, 0x1E905, eos,
	0x1E928, 0x1E906, eos,	//  4090
	0x1E929, 0x1E907, eos,
	0x1E92A, 0x1E908, eos,
	0x1E92B, 0x1E909, eos,
	0x1E92C, 0x1E90A, eos,	//  4102
	0x1E92D, 0x1E90B, eos,
	0x1E92E, 0x1E90C, eos,
	0x1E92F, 0x1E90D, eos,	//  4111
	0x1E930, 0x1E90E, eos,
	0x1E931, 0x1E90F, eos,
	0x1E932, 0x1E910, eos,	//  4120
	0x1E933, 0x1E911, eos,
	0x1E934, 0x1E912, eos,
	0x1E935, 0x1E913, eos,
	0x1E936, 0x1E914, eos,	//  4132
	0x1E937, 0x1E915, eos,
	0x1E938, 0x1E916, eos,
	0x1E939, 0x1E917, eos,	//  4141
	0x1E93A, 0x1E918, eos,
	0x1E93B, 0x1E919, eos,
	0x1E93C, 0x1E91A, eos,	//  4150
	0x1E93D, 0x1E91B, eos,
	0x1E93E, 0x1E91C, eos,
	0x1E93F, 0x1E91D, eos,
	0x1E940, 0x1E91E, eos,	//  4162
	0x1E941, 0x1E91F, eos,
	0x1E942, 0x1E920, eos,
	0x1E943, 0x1E921, eos	//  4171
};
#define SRELL_UCFDATA_VERSION 200
		namespace ucf_internal
		{
typedef unicode_casefolding<uchar21_t, uchar21_t> ucf_data;
		}	//  namespace ucf_internal
#endif	//  !defined(SRELL_NO_UNICODE_ICASE)
class unicode_case_folding
{
public:
#if !defined(SRELL_NO_UNICODE_ICASE)
	static const uchar21_t rev_maxset = ucf_internal::ucf_data::rev_maxset;
#else
	static const uchar21_t rev_maxset = 2;
#endif
	static uchar21_t do_casefolding(const uchar21_t cp)
	{
#if !defined(SRELL_NO_UNICODE_ICASE)
		if (cp <= ucf_internal::ucf_data::ucf_maxcodepoint)
			return cp + ucf_internal::ucf_data::ucf_deltatable[ucf_internal::ucf_data::ucf_segmenttable[cp >> 8] + (cp & 0xff)];
#else
		if (cp >= char_alnum::ch_A && cp <= char_alnum::ch_Z)	//  'A' && 'Z'
			return static_cast<uchar21_t>(cp - char_alnum::ch_A + char_alnum::ch_a);	//  - 'A' + 'a'
#endif
		return cp;
	}
	static uchar21_t casefoldedcharset(uchar21_t out[rev_maxset], const uchar21_t cp)
	{
#if !defined(SRELL_NO_UNICODE_ICASE)
		uchar21_t count = 0;
		if (cp <= ucf_internal::ucf_data::rev_maxcodepoint)
		{
			const uchar21_t offset_of_charset = ucf_internal::ucf_data::rev_indextable[ucf_internal::ucf_data::rev_segmenttable[cp >> 8] + (cp & 0xff)];
			const uchar21_t *ptr = &ucf_internal::ucf_data::rev_charsettable[offset_of_charset];
			for (; *ptr != cfcharset_eos_ && count < rev_maxset; ++ptr, ++count)
				out[count] = *ptr;
		}
		if (count == 0)
			out[count++] = cp;
		return count;
#else
		const uchar21_t nocase = static_cast<uchar21_t>(cp | 0x20);
		out[0] = cp;
		if (nocase >= char_alnum::ch_a && nocase <= char_alnum::ch_z)
		{
			out[1] = static_cast<uchar21_t>(cp ^ 0x20);
			return 2;
		}
		return 1;
#endif
	}
	unicode_case_folding &operator=(const unicode_case_folding &)
	{
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	unicode_case_folding &operator=(unicode_case_folding &&) SRELL_NOEXCEPT
	{
		return *this;
	}
#endif
	void swap(unicode_case_folding & /* right */)
	{
	}
private:
#if !defined(SRELL_NO_UNICODE_ICASE)
	static const uchar21_t cfcharset_eos_ = ucf_internal::ucf_data::eos;
#endif
public:	//  for debug.
	void print_tables() const;
};
	}	//  namespace regex_internal
	namespace regex_internal
	{
#if !defined(SRELL_NO_UNICODE_PROPERTY)
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct unicode_property_data
{
	static const T1 unknown = 0;
	static const T1 gc_Other = 1;	//  #1
	static const T1 gc_Control = 2;	//  #2
	static const T1 gc_Format = 3;	//  #3
	static const T1 gc_Unassigned = 4;	//  #4
	static const T1 gc_Private_Use = 5;	//  #5
	static const T1 gc_Surrogate = 6;	//  #6
	static const T1 gc_Letter = 7;	//  #7
	static const T1 gc_Cased_Letter = 8;	//  #8
	static const T1 gc_Lowercase_Letter = 9;	//  #9
	static const T1 gc_Titlecase_Letter = 10;	//  #10
	static const T1 gc_Uppercase_Letter = 11;	//  #11
	static const T1 gc_Modifier_Letter = 12;	//  #12
	static const T1 gc_Other_Letter = 13;	//  #13
	static const T1 gc_Mark = 14;	//  #14
	static const T1 gc_Spacing_Mark = 15;	//  #15
	static const T1 gc_Enclosing_Mark = 16;	//  #16
	static const T1 gc_Nonspacing_Mark = 17;	//  #17
	static const T1 gc_Number = 18;	//  #18
	static const T1 gc_Decimal_Number = 19;	//  #19
	static const T1 gc_Letter_Number = 20;	//  #20
	static const T1 gc_Other_Number = 21;	//  #21
	static const T1 gc_Punctuation = 22;	//  #22
	static const T1 gc_Connector_Punctuation = 23;	//  #23
	static const T1 gc_Dash_Punctuation = 24;	//  #24
	static const T1 gc_Close_Punctuation = 25;	//  #25
	static const T1 gc_Final_Punctuation = 26;	//  #26
	static const T1 gc_Initial_Punctuation = 27;	//  #27
	static const T1 gc_Other_Punctuation = 28;	//  #28
	static const T1 gc_Open_Punctuation = 29;	//  #29
	static const T1 gc_Symbol = 30;	//  #30
	static const T1 gc_Currency_Symbol = 31;	//  #31
	static const T1 gc_Modifier_Symbol = 32;	//  #32
	static const T1 gc_Math_Symbol = 33;	//  #33
	static const T1 gc_Other_Symbol = 34;	//  #34
	static const T1 gc_Separator = 35;	//  #35
	static const T1 gc_Line_Separator = 36;	//  #36
	static const T1 gc_Paragraph_Separator = 37;	//  #37
	static const T1 gc_Space_Separator = 38;	//  #38
	static const T1 bp_ASCII = 39;	//  #39
	static const T1 bp_ASCII_Hex_Digit = 40;	//  #40
	static const T1 bp_Alphabetic = 41;	//  #41
	static const T1 bp_Any = 42;	//  #42
	static const T1 bp_Assigned = 43;	//  #43
	static const T1 bp_Bidi_Control = 44;	//  #44
	static const T1 bp_Bidi_Mirrored = 45;	//  #45
	static const T1 bp_Case_Ignorable = 46;	//  #46
	static const T1 bp_Cased = 47;	//  #47
	static const T1 bp_Changes_When_Casefolded = 48;	//  #48
	static const T1 bp_Changes_When_Casemapped = 49;	//  #49
	static const T1 bp_Changes_When_Lowercased = 50;	//  #50
	static const T1 bp_Changes_When_NFKC_Casefolded = 51;	//  #51
	static const T1 bp_Changes_When_Titlecased = 52;	//  #52
	static const T1 bp_Changes_When_Uppercased = 53;	//  #53
	static const T1 bp_Dash = 54;	//  #54
	static const T1 bp_Default_Ignorable_Code_Point = 55;	//  #55
	static const T1 bp_Deprecated = 56;	//  #56
	static const T1 bp_Diacritic = 57;	//  #57
	static const T1 bp_Emoji = 58;	//  #58
	static const T1 bp_Emoji_Component = 59;	//  #59
	static const T1 bp_Emoji_Modifier = 60;	//  #60
	static const T1 bp_Emoji_Modifier_Base = 61;	//  #61
	static const T1 bp_Emoji_Presentation = 62;	//  #62
	static const T1 bp_Extender = 63;	//  #63
	static const T1 bp_Grapheme_Base = 64;	//  #64
	static const T1 bp_Grapheme_Extend = 65;	//  #65
	static const T1 bp_Hex_Digit = 66;	//  #66
	static const T1 bp_IDS_Binary_Operator = 67;	//  #67
	static const T1 bp_IDS_Trinary_Operator = 68;	//  #68
	static const T1 bp_ID_Continue = 69;	//  #69
	static const T1 bp_ID_Start = 70;	//  #70
	static const T1 bp_Ideographic = 71;	//  #71
	static const T1 bp_Join_Control = 72;	//  #72
	static const T1 bp_Logical_Order_Exception = 73;	//  #73
	static const T1 bp_Lowercase = 74;	//  #74
	static const T1 bp_Math = 75;	//  #75
	static const T1 bp_Noncharacter_Code_Point = 76;	//  #76
	static const T1 bp_Pattern_Syntax = 77;	//  #77
	static const T1 bp_Pattern_White_Space = 78;	//  #78
	static const T1 bp_Quotation_Mark = 79;	//  #79
	static const T1 bp_Radical = 80;	//  #80
	static const T1 bp_Regional_Indicator = 81;	//  #81
	static const T1 bp_Sentence_Terminal = 82;	//  #82
	static const T1 bp_Soft_Dotted = 83;	//  #83
	static const T1 bp_Terminal_Punctuation = 84;	//  #84
	static const T1 bp_Unified_Ideograph = 85;	//  #85
	static const T1 bp_Uppercase = 86;	//  #86
	static const T1 bp_Variation_Selector = 87;	//  #87
	static const T1 bp_White_Space = 88;	//  #88
	static const T1 bp_XID_Continue = 89;	//  #89
	static const T1 bp_XID_Start = 90;	//  #90
	static const T1 bp_Extended_Pictographic = 91;	//  #91
	static const T1 sc_Adlam = 92;	//  #92
	static const T1 sc_Ahom = 93;	//  #93
	static const T1 sc_Anatolian_Hieroglyphs = 94;	//  #94
	static const T1 sc_Arabic = 95;	//  #95
	static const T1 sc_Armenian = 96;	//  #96
	static const T1 sc_Avestan = 97;	//  #97
	static const T1 sc_Balinese = 98;	//  #98
	static const T1 sc_Bamum = 99;	//  #99
	static const T1 sc_Bassa_Vah = 100;	//  #100
	static const T1 sc_Batak = 101;	//  #101
	static const T1 sc_Bengali = 102;	//  #102
	static const T1 sc_Bhaiksuki = 103;	//  #103
	static const T1 sc_Bopomofo = 104;	//  #104
	static const T1 sc_Brahmi = 105;	//  #105
	static const T1 sc_Braille = 106;	//  #106
	static const T1 sc_Buginese = 107;	//  #107
	static const T1 sc_Buhid = 108;	//  #108
	static const T1 sc_Canadian_Aboriginal = 109;	//  #109
	static const T1 sc_Carian = 110;	//  #110
	static const T1 sc_Caucasian_Albanian = 111;	//  #111
	static const T1 sc_Chakma = 112;	//  #112
	static const T1 sc_Cham = 113;	//  #113
	static const T1 sc_Cherokee = 114;	//  #114
	static const T1 sc_Common = 115;	//  #115
	static const T1 sc_Coptic = 116;	//  #116
	static const T1 sc_Cuneiform = 117;	//  #117
	static const T1 sc_Cypriot = 118;	//  #118
	static const T1 sc_Cyrillic = 119;	//  #119
	static const T1 sc_Deseret = 120;	//  #120
	static const T1 sc_Devanagari = 121;	//  #121
	static const T1 sc_Duployan = 122;	//  #122
	static const T1 sc_Egyptian_Hieroglyphs = 123;	//  #123
	static const T1 sc_Elbasan = 124;	//  #124
	static const T1 sc_Ethiopic = 125;	//  #125
	static const T1 sc_Georgian = 126;	//  #126
	static const T1 sc_Glagolitic = 127;	//  #127
	static const T1 sc_Gothic = 128;	//  #128
	static const T1 sc_Grantha = 129;	//  #129
	static const T1 sc_Greek = 130;	//  #130
	static const T1 sc_Gujarati = 131;	//  #131
	static const T1 sc_Gurmukhi = 132;	//  #132
	static const T1 sc_Han = 133;	//  #133
	static const T1 sc_Hangul = 134;	//  #134
	static const T1 sc_Hanunoo = 135;	//  #135
	static const T1 sc_Hatran = 136;	//  #136
	static const T1 sc_Hebrew = 137;	//  #137
	static const T1 sc_Hiragana = 138;	//  #138
	static const T1 sc_Imperial_Aramaic = 139;	//  #139
	static const T1 sc_Inherited = 140;	//  #140
	static const T1 sc_Inscriptional_Pahlavi = 141;	//  #141
	static const T1 sc_Inscriptional_Parthian = 142;	//  #142
	static const T1 sc_Javanese = 143;	//  #143
	static const T1 sc_Kaithi = 144;	//  #144
	static const T1 sc_Kannada = 145;	//  #145
	static const T1 sc_Katakana = 146;	//  #146
	static const T1 sc_Kayah_Li = 147;	//  #147
	static const T1 sc_Kharoshthi = 148;	//  #148
	static const T1 sc_Khmer = 149;	//  #149
	static const T1 sc_Khojki = 150;	//  #150
	static const T1 sc_Khudawadi = 151;	//  #151
	static const T1 sc_Lao = 152;	//  #152
	static const T1 sc_Latin = 153;	//  #153
	static const T1 sc_Lepcha = 154;	//  #154
	static const T1 sc_Limbu = 155;	//  #155
	static const T1 sc_Linear_A = 156;	//  #156
	static const T1 sc_Linear_B = 157;	//  #157
	static const T1 sc_Lisu = 158;	//  #158
	static const T1 sc_Lycian = 159;	//  #159
	static const T1 sc_Lydian = 160;	//  #160
	static const T1 sc_Mahajani = 161;	//  #161
	static const T1 sc_Malayalam = 162;	//  #162
	static const T1 sc_Mandaic = 163;	//  #163
	static const T1 sc_Manichaean = 164;	//  #164
	static const T1 sc_Marchen = 165;	//  #165
	static const T1 sc_Masaram_Gondi = 166;	//  #166
	static const T1 sc_Meetei_Mayek = 167;	//  #167
	static const T1 sc_Mende_Kikakui = 168;	//  #168
	static const T1 sc_Meroitic_Cursive = 169;	//  #169
	static const T1 sc_Meroitic_Hieroglyphs = 170;	//  #170
	static const T1 sc_Miao = 171;	//  #171
	static const T1 sc_Modi = 172;	//  #172
	static const T1 sc_Mongolian = 173;	//  #173
	static const T1 sc_Mro = 174;	//  #174
	static const T1 sc_Multani = 175;	//  #175
	static const T1 sc_Myanmar = 176;	//  #176
	static const T1 sc_Nabataean = 177;	//  #177
	static const T1 sc_New_Tai_Lue = 178;	//  #178
	static const T1 sc_Newa = 179;	//  #179
	static const T1 sc_Nko = 180;	//  #180
	static const T1 sc_Nushu = 181;	//  #181
	static const T1 sc_Ogham = 182;	//  #182
	static const T1 sc_Ol_Chiki = 183;	//  #183
	static const T1 sc_Old_Hungarian = 184;	//  #184
	static const T1 sc_Old_Italic = 185;	//  #185
	static const T1 sc_Old_North_Arabian = 186;	//  #186
	static const T1 sc_Old_Permic = 187;	//  #187
	static const T1 sc_Old_Persian = 188;	//  #188
	static const T1 sc_Old_South_Arabian = 189;	//  #189
	static const T1 sc_Old_Turkic = 190;	//  #190
	static const T1 sc_Oriya = 191;	//  #191
	static const T1 sc_Osage = 192;	//  #192
	static const T1 sc_Osmanya = 193;	//  #193
	static const T1 sc_Pahawh_Hmong = 194;	//  #194
	static const T1 sc_Palmyrene = 195;	//  #195
	static const T1 sc_Pau_Cin_Hau = 196;	//  #196
	static const T1 sc_Phags_Pa = 197;	//  #197
	static const T1 sc_Phoenician = 198;	//  #198
	static const T1 sc_Psalter_Pahlavi = 199;	//  #199
	static const T1 sc_Rejang = 200;	//  #200
	static const T1 sc_Runic = 201;	//  #201
	static const T1 sc_Samaritan = 202;	//  #202
	static const T1 sc_Saurashtra = 203;	//  #203
	static const T1 sc_Sharada = 204;	//  #204
	static const T1 sc_Shavian = 205;	//  #205
	static const T1 sc_Siddham = 206;	//  #206
	static const T1 sc_SignWriting = 207;	//  #207
	static const T1 sc_Sinhala = 208;	//  #208
	static const T1 sc_Sora_Sompeng = 209;	//  #209
	static const T1 sc_Soyombo = 210;	//  #210
	static const T1 sc_Sundanese = 211;	//  #211
	static const T1 sc_Syloti_Nagri = 212;	//  #212
	static const T1 sc_Syriac = 213;	//  #213
	static const T1 sc_Tagalog = 214;	//  #214
	static const T1 sc_Tagbanwa = 215;	//  #215
	static const T1 sc_Tai_Le = 216;	//  #216
	static const T1 sc_Tai_Tham = 217;	//  #217
	static const T1 sc_Tai_Viet = 218;	//  #218
	static const T1 sc_Takri = 219;	//  #219
	static const T1 sc_Tamil = 220;	//  #220
	static const T1 sc_Tangut = 221;	//  #221
	static const T1 sc_Telugu = 222;	//  #222
	static const T1 sc_Thaana = 223;	//  #223
	static const T1 sc_Thai = 224;	//  #224
	static const T1 sc_Tibetan = 225;	//  #225
	static const T1 sc_Tifinagh = 226;	//  #226
	static const T1 sc_Tirhuta = 227;	//  #227
	static const T1 sc_Ugaritic = 228;	//  #228
	static const T1 sc_Vai = 229;	//  #229
	static const T1 sc_Warang_Citi = 230;	//  #230
	static const T1 sc_Yi = 231;	//  #231
	static const T1 sc_Zanabazar_Square = 232;	//  #232
	static const T1 sc_Dogra = 233;	//  #233
	static const T1 sc_Gunjala_Gondi = 234;	//  #234
	static const T1 sc_Hanifi_Rohingya = 235;	//  #235
	static const T1 sc_Makasar = 236;	//  #236
	static const T1 sc_Medefaidrin = 237;	//  #237
	static const T1 sc_Old_Sogdian = 238;	//  #238
	static const T1 sc_Sogdian = 239;	//  #239
	static const T1 sc_Elymaic = 240;	//  #240
	static const T1 sc_Nandinagari = 241;	//  #241
	static const T1 sc_Nyiakeng_Puachue_Hmong = 242;	//  #242
	static const T1 sc_Wancho = 243;	//  #243
	static const T1 scx_Adlam = 244;	//  #244
	static const T1 scx_Ahom = 245;	//  #93
	static const T1 scx_Anatolian_Hieroglyphs = 246;	//  #94
	static const T1 scx_Arabic = 247;	//  #245
	static const T1 scx_Armenian = 248;	//  #246
	static const T1 scx_Avestan = 249;	//  #97
	static const T1 scx_Balinese = 250;	//  #98
	static const T1 scx_Bamum = 251;	//  #99
	static const T1 scx_Bassa_Vah = 252;	//  #100
	static const T1 scx_Batak = 253;	//  #101
	static const T1 scx_Bengali = 254;	//  #247
	static const T1 scx_Bhaiksuki = 255;	//  #103
	static const T1 scx_Bopomofo = 256;	//  #248
	static const T1 scx_Brahmi = 257;	//  #105
	static const T1 scx_Braille = 258;	//  #106
	static const T1 scx_Buginese = 259;	//  #249
	static const T1 scx_Buhid = 260;	//  #250
	static const T1 scx_Canadian_Aboriginal = 261;	//  #109
	static const T1 scx_Carian = 262;	//  #110
	static const T1 scx_Caucasian_Albanian = 263;	//  #111
	static const T1 scx_Chakma = 264;	//  #251
	static const T1 scx_Cham = 265;	//  #113
	static const T1 scx_Cherokee = 266;	//  #114
	static const T1 scx_Common = 267;	//  #252
	static const T1 scx_Coptic = 268;	//  #253
	static const T1 scx_Cuneiform = 269;	//  #117
	static const T1 scx_Cypriot = 270;	//  #254
	static const T1 scx_Cyrillic = 271;	//  #255
	static const T1 scx_Deseret = 272;	//  #120
	static const T1 scx_Devanagari = 273;	//  #256
	static const T1 scx_Duployan = 274;	//  #257
	static const T1 scx_Egyptian_Hieroglyphs = 275;	//  #123
	static const T1 scx_Elbasan = 276;	//  #124
	static const T1 scx_Ethiopic = 277;	//  #125
	static const T1 scx_Georgian = 278;	//  #258
	static const T1 scx_Glagolitic = 279;	//  #259
	static const T1 scx_Gothic = 280;	//  #128
	static const T1 scx_Grantha = 281;	//  #260
	static const T1 scx_Greek = 282;	//  #261
	static const T1 scx_Gujarati = 283;	//  #262
	static const T1 scx_Gurmukhi = 284;	//  #263
	static const T1 scx_Han = 285;	//  #264
	static const T1 scx_Hangul = 286;	//  #265
	static const T1 scx_Hanunoo = 287;	//  #266
	static const T1 scx_Hatran = 288;	//  #136
	static const T1 scx_Hebrew = 289;	//  #137
	static const T1 scx_Hiragana = 290;	//  #267
	static const T1 scx_Imperial_Aramaic = 291;	//  #139
	static const T1 scx_Inherited = 292;	//  #268
	static const T1 scx_Inscriptional_Pahlavi = 293;	//  #141
	static const T1 scx_Inscriptional_Parthian = 294;	//  #142
	static const T1 scx_Javanese = 295;	//  #269
	static const T1 scx_Kaithi = 296;	//  #270
	static const T1 scx_Kannada = 297;	//  #271
	static const T1 scx_Katakana = 298;	//  #272
	static const T1 scx_Kayah_Li = 299;	//  #273
	static const T1 scx_Kharoshthi = 300;	//  #148
	static const T1 scx_Khmer = 301;	//  #149
	static const T1 scx_Khojki = 302;	//  #274
	static const T1 scx_Khudawadi = 303;	//  #275
	static const T1 scx_Lao = 304;	//  #152
	static const T1 scx_Latin = 305;	//  #276
	static const T1 scx_Lepcha = 306;	//  #154
	static const T1 scx_Limbu = 307;	//  #277
	static const T1 scx_Linear_A = 308;	//  #278
	static const T1 scx_Linear_B = 309;	//  #279
	static const T1 scx_Lisu = 310;	//  #158
	static const T1 scx_Lycian = 311;	//  #159
	static const T1 scx_Lydian = 312;	//  #160
	static const T1 scx_Mahajani = 313;	//  #280
	static const T1 scx_Malayalam = 314;	//  #281
	static const T1 scx_Mandaic = 315;	//  #282
	static const T1 scx_Manichaean = 316;	//  #283
	static const T1 scx_Marchen = 317;	//  #165
	static const T1 scx_Masaram_Gondi = 318;	//  #284
	static const T1 scx_Meetei_Mayek = 319;	//  #167
	static const T1 scx_Mende_Kikakui = 320;	//  #168
	static const T1 scx_Meroitic_Cursive = 321;	//  #169
	static const T1 scx_Meroitic_Hieroglyphs = 322;	//  #170
	static const T1 scx_Miao = 323;	//  #171
	static const T1 scx_Modi = 324;	//  #285
	static const T1 scx_Mongolian = 325;	//  #286
	static const T1 scx_Mro = 326;	//  #174
	static const T1 scx_Multani = 327;	//  #287
	static const T1 scx_Myanmar = 328;	//  #288
	static const T1 scx_Nabataean = 329;	//  #177
	static const T1 scx_New_Tai_Lue = 330;	//  #178
	static const T1 scx_Newa = 331;	//  #179
	static const T1 scx_Nko = 332;	//  #180
	static const T1 scx_Nushu = 333;	//  #181
	static const T1 scx_Ogham = 334;	//  #182
	static const T1 scx_Ol_Chiki = 335;	//  #183
	static const T1 scx_Old_Hungarian = 336;	//  #184
	static const T1 scx_Old_Italic = 337;	//  #185
	static const T1 scx_Old_North_Arabian = 338;	//  #186
	static const T1 scx_Old_Permic = 339;	//  #289
	static const T1 scx_Old_Persian = 340;	//  #188
	static const T1 scx_Old_South_Arabian = 341;	//  #189
	static const T1 scx_Old_Turkic = 342;	//  #190
	static const T1 scx_Oriya = 343;	//  #290
	static const T1 scx_Osage = 344;	//  #192
	static const T1 scx_Osmanya = 345;	//  #193
	static const T1 scx_Pahawh_Hmong = 346;	//  #194
	static const T1 scx_Palmyrene = 347;	//  #195
	static const T1 scx_Pau_Cin_Hau = 348;	//  #196
	static const T1 scx_Phags_Pa = 349;	//  #291
	static const T1 scx_Phoenician = 350;	//  #198
	static const T1 scx_Psalter_Pahlavi = 351;	//  #292
	static const T1 scx_Rejang = 352;	//  #200
	static const T1 scx_Runic = 353;	//  #201
	static const T1 scx_Samaritan = 354;	//  #202
	static const T1 scx_Saurashtra = 355;	//  #203
	static const T1 scx_Sharada = 356;	//  #293
	static const T1 scx_Shavian = 357;	//  #205
	static const T1 scx_Siddham = 358;	//  #206
	static const T1 scx_SignWriting = 359;	//  #207
	static const T1 scx_Sinhala = 360;	//  #294
	static const T1 scx_Sora_Sompeng = 361;	//  #209
	static const T1 scx_Soyombo = 362;	//  #210
	static const T1 scx_Sundanese = 363;	//  #211
	static const T1 scx_Syloti_Nagri = 364;	//  #295
	static const T1 scx_Syriac = 365;	//  #296
	static const T1 scx_Tagalog = 366;	//  #297
	static const T1 scx_Tagbanwa = 367;	//  #298
	static const T1 scx_Tai_Le = 368;	//  #299
	static const T1 scx_Tai_Tham = 369;	//  #217
	static const T1 scx_Tai_Viet = 370;	//  #218
	static const T1 scx_Takri = 371;	//  #300
	static const T1 scx_Tamil = 372;	//  #301
	static const T1 scx_Tangut = 373;	//  #221
	static const T1 scx_Telugu = 374;	//  #302
	static const T1 scx_Thaana = 375;	//  #303
	static const T1 scx_Thai = 376;	//  #224
	static const T1 scx_Tibetan = 377;	//  #225
	static const T1 scx_Tifinagh = 378;	//  #226
	static const T1 scx_Tirhuta = 379;	//  #304
	static const T1 scx_Ugaritic = 380;	//  #228
	static const T1 scx_Vai = 381;	//  #229
	static const T1 scx_Warang_Citi = 382;	//  #230
	static const T1 scx_Yi = 383;	//  #305
	static const T1 scx_Zanabazar_Square = 384;	//  #232
	static const T1 scx_Dogra = 385;	//  #306
	static const T1 scx_Gunjala_Gondi = 386;	//  #307
	static const T1 scx_Hanifi_Rohingya = 387;	//  #308
	static const T1 scx_Makasar = 388;	//  #236
	static const T1 scx_Medefaidrin = 389;	//  #237
	static const T1 scx_Old_Sogdian = 390;	//  #238
	static const T1 scx_Sogdian = 391;	//  #309
	static const T1 scx_Elymaic = 392;	//  #240
	static const T1 scx_Nandinagari = 393;	//  #310
	static const T1 scx_Nyiakeng_Puachue_Hmong = 394;	//  #242
	static const T1 scx_Wancho = 395;	//  #243
	static const T1 last_property_number = 310;
	struct ptype
	{
		static const T2 unknown = 0;
		static const T2 binary = 1;
		static const T2 general_category = 2;
		static const T2 script = 3;
		static const T2 script_extensions = 4;
	};
	static const T3 propertynametable[];
	static const T4 rangetable[];
	static const T5 rangenumbertable[];
	static const T6 positiontable[];
	static const T3 *propertyname_table()
	{
		return propertynametable;
	}
	static const T4 *ranges()
	{
		return rangetable;
	}
	static const T5 *rangenumber_table()
	{
		return rangenumbertable;
	}
	static const T6 *position_table()
	{
		return positiontable;
	}
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
const T3 unicode_property_data<T1, T2, T3, T4, T5, T6>::propertynametable[] =
{
	"*",	//  #0:unknown
	"*",	//  #1:binary
	"General_Category:gc",	//  #2
	"Script:sc",	//  #3
	"Script_Extensions:scx",	//  #4
	""
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
const T4 unicode_property_data<T1, T2, T3, T4, T5, T6>::rangetable[] =
{
	//  #1 (0+692): gc=Other:C
	//  Cc:2 + Cf:20 + Cn:666 + Co:3 + Cs:1
	//  #2 (0+2): gc=Control:Cc:cntrl
	0x0000, 0x001F, 0x007F, 0x009F,
	//  #3 (2+20): gc=Format:Cf
	0x00AD, 0x00AD, 0x0600, 0x0605, 0x061C, 0x061C, 0x06DD, 0x06DD,
	0x070F, 0x070F, 0x08E2, 0x08E2, 0x180E, 0x180E, 0x200B, 0x200F,
	0x202A, 0x202E, 0x2060, 0x2064, 0x2066, 0x206F, 0xFEFF, 0xFEFF,
	0xFFF9, 0xFFFB, 0x110BD, 0x110BD, 0x110CD, 0x110CD, 0x13430, 0x13438,
	0x1BCA0, 0x1BCA3, 0x1D173, 0x1D17A, 0xE0001, 0xE0001, 0xE0020, 0xE007F,
	//  #4 (22+666): gc=Unassigned:Cn
	0x0378, 0x0379, 0x0380, 0x0383, 0x038B, 0x038B, 0x038D, 0x038D,
	0x03A2, 0x03A2, 0x0530, 0x0530, 0x0557, 0x0558, 0x058B, 0x058C,
	0x0590, 0x0590, 0x05C8, 0x05CF, 0x05EB, 0x05EE, 0x05F5, 0x05FF,
	0x061D, 0x061D, 0x070E, 0x070E, 0x074B, 0x074C, 0x07B2, 0x07BF,
	0x07FB, 0x07FC, 0x082E, 0x082F, 0x083F, 0x083F, 0x085C, 0x085D,
	0x085F, 0x085F, 0x086B, 0x089F, 0x08B5, 0x08B5, 0x08BE, 0x08D2,
	0x0984, 0x0984, 0x098D, 0x098E, 0x0991, 0x0992, 0x09A9, 0x09A9,
	0x09B1, 0x09B1, 0x09B3, 0x09B5, 0x09BA, 0x09BB, 0x09C5, 0x09C6,
	0x09C9, 0x09CA, 0x09CF, 0x09D6, 0x09D8, 0x09DB, 0x09DE, 0x09DE,
	0x09E4, 0x09E5, 0x09FF, 0x0A00, 0x0A04, 0x0A04, 0x0A0B, 0x0A0E,
	0x0A11, 0x0A12, 0x0A29, 0x0A29, 0x0A31, 0x0A31, 0x0A34, 0x0A34,
	0x0A37, 0x0A37, 0x0A3A, 0x0A3B, 0x0A3D, 0x0A3D, 0x0A43, 0x0A46,
	0x0A49, 0x0A4A, 0x0A4E, 0x0A50, 0x0A52, 0x0A58, 0x0A5D, 0x0A5D,
	0x0A5F, 0x0A65, 0x0A77, 0x0A80, 0x0A84, 0x0A84, 0x0A8E, 0x0A8E,
	0x0A92, 0x0A92, 0x0AA9, 0x0AA9, 0x0AB1, 0x0AB1, 0x0AB4, 0x0AB4,
	0x0ABA, 0x0ABB, 0x0AC6, 0x0AC6, 0x0ACA, 0x0ACA, 0x0ACE, 0x0ACF,
	0x0AD1, 0x0ADF, 0x0AE4, 0x0AE5, 0x0AF2, 0x0AF8, 0x0B00, 0x0B00,
	0x0B04, 0x0B04, 0x0B0D, 0x0B0E, 0x0B11, 0x0B12, 0x0B29, 0x0B29,
	0x0B31, 0x0B31, 0x0B34, 0x0B34, 0x0B3A, 0x0B3B, 0x0B45, 0x0B46,
	0x0B49, 0x0B4A, 0x0B4E, 0x0B55, 0x0B58, 0x0B5B, 0x0B5E, 0x0B5E,
	0x0B64, 0x0B65, 0x0B78, 0x0B81, 0x0B84, 0x0B84, 0x0B8B, 0x0B8D,
	0x0B91, 0x0B91, 0x0B96, 0x0B98, 0x0B9B, 0x0B9B, 0x0B9D, 0x0B9D,
	0x0BA0, 0x0BA2, 0x0BA5, 0x0BA7, 0x0BAB, 0x0BAD, 0x0BBA, 0x0BBD,
	0x0BC3, 0x0BC5, 0x0BC9, 0x0BC9, 0x0BCE, 0x0BCF, 0x0BD1, 0x0BD6,
	0x0BD8, 0x0BE5, 0x0BFB, 0x0BFF, 0x0C0D, 0x0C0D, 0x0C11, 0x0C11,
	0x0C29, 0x0C29, 0x0C3A, 0x0C3C, 0x0C45, 0x0C45, 0x0C49, 0x0C49,
	0x0C4E, 0x0C54, 0x0C57, 0x0C57, 0x0C5B, 0x0C5F, 0x0C64, 0x0C65,
	0x0C70, 0x0C76, 0x0C8D, 0x0C8D, 0x0C91, 0x0C91, 0x0CA9, 0x0CA9,
	0x0CB4, 0x0CB4, 0x0CBA, 0x0CBB, 0x0CC5, 0x0CC5, 0x0CC9, 0x0CC9,
	0x0CCE, 0x0CD4, 0x0CD7, 0x0CDD, 0x0CDF, 0x0CDF, 0x0CE4, 0x0CE5,
	0x0CF0, 0x0CF0, 0x0CF3, 0x0CFF, 0x0D04, 0x0D04, 0x0D0D, 0x0D0D,
	0x0D11, 0x0D11, 0x0D45, 0x0D45, 0x0D49, 0x0D49, 0x0D50, 0x0D53,
	0x0D64, 0x0D65, 0x0D80, 0x0D81, 0x0D84, 0x0D84, 0x0D97, 0x0D99,
	0x0DB2, 0x0DB2, 0x0DBC, 0x0DBC, 0x0DBE, 0x0DBF, 0x0DC7, 0x0DC9,
	0x0DCB, 0x0DCE, 0x0DD5, 0x0DD5, 0x0DD7, 0x0DD7, 0x0DE0, 0x0DE5,
	0x0DF0, 0x0DF1, 0x0DF5, 0x0E00, 0x0E3B, 0x0E3E, 0x0E5C, 0x0E80,
	0x0E83, 0x0E83, 0x0E85, 0x0E85, 0x0E8B, 0x0E8B, 0x0EA4, 0x0EA4,
	0x0EA6, 0x0EA6, 0x0EBE, 0x0EBF, 0x0EC5, 0x0EC5, 0x0EC7, 0x0EC7,
	0x0ECE, 0x0ECF, 0x0EDA, 0x0EDB, 0x0EE0, 0x0EFF, 0x0F48, 0x0F48,
	0x0F6D, 0x0F70, 0x0F98, 0x0F98, 0x0FBD, 0x0FBD, 0x0FCD, 0x0FCD,
	0x0FDB, 0x0FFF, 0x10C6, 0x10C6, 0x10C8, 0x10CC, 0x10CE, 0x10CF,
	0x1249, 0x1249, 0x124E, 0x124F, 0x1257, 0x1257, 0x1259, 0x1259,
	0x125E, 0x125F, 0x1289, 0x1289, 0x128E, 0x128F, 0x12B1, 0x12B1,
	0x12B6, 0x12B7, 0x12BF, 0x12BF, 0x12C1, 0x12C1, 0x12C6, 0x12C7,
	0x12D7, 0x12D7, 0x1311, 0x1311, 0x1316, 0x1317, 0x135B, 0x135C,
	0x137D, 0x137F, 0x139A, 0x139F, 0x13F6, 0x13F7, 0x13FE, 0x13FF,
	0x169D, 0x169F, 0x16F9, 0x16FF, 0x170D, 0x170D, 0x1715, 0x171F,
	0x1737, 0x173F, 0x1754, 0x175F, 0x176D, 0x176D, 0x1771, 0x1771,
	0x1774, 0x177F, 0x17DE, 0x17DF, 0x17EA, 0x17EF, 0x17FA, 0x17FF,
	0x180F, 0x180F, 0x181A, 0x181F, 0x1879, 0x187F, 0x18AB, 0x18AF,
	0x18F6, 0x18FF, 0x191F, 0x191F, 0x192C, 0x192F, 0x193C, 0x193F,
	0x1941, 0x1943, 0x196E, 0x196F, 0x1975, 0x197F, 0x19AC, 0x19AF,
	0x19CA, 0x19CF, 0x19DB, 0x19DD, 0x1A1C, 0x1A1D, 0x1A5F, 0x1A5F,
	0x1A7D, 0x1A7E, 0x1A8A, 0x1A8F, 0x1A9A, 0x1A9F, 0x1AAE, 0x1AAF,
	0x1ABF, 0x1AFF, 0x1B4C, 0x1B4F, 0x1B7D, 0x1B7F, 0x1BF4, 0x1BFB,
	0x1C38, 0x1C3A, 0x1C4A, 0x1C4C, 0x1C89, 0x1C8F, 0x1CBB, 0x1CBC,
	0x1CC8, 0x1CCF, 0x1CFB, 0x1CFF, 0x1DFA, 0x1DFA, 0x1F16, 0x1F17,
	0x1F1E, 0x1F1F, 0x1F46, 0x1F47, 0x1F4E, 0x1F4F, 0x1F58, 0x1F58,
	0x1F5A, 0x1F5A, 0x1F5C, 0x1F5C, 0x1F5E, 0x1F5E, 0x1F7E, 0x1F7F,
	0x1FB5, 0x1FB5, 0x1FC5, 0x1FC5, 0x1FD4, 0x1FD5, 0x1FDC, 0x1FDC,
	0x1FF0, 0x1FF1, 0x1FF5, 0x1FF5, 0x1FFF, 0x1FFF, 0x2065, 0x2065,
	0x2072, 0x2073, 0x208F, 0x208F, 0x209D, 0x209F, 0x20C0, 0x20CF,
	0x20F1, 0x20FF, 0x218C, 0x218F, 0x2427, 0x243F, 0x244B, 0x245F,
	0x2B74, 0x2B75, 0x2B96, 0x2B97, 0x2C2F, 0x2C2F, 0x2C5F, 0x2C5F,
	0x2CF4, 0x2CF8, 0x2D26, 0x2D26, 0x2D28, 0x2D2C, 0x2D2E, 0x2D2F,
	0x2D68, 0x2D6E, 0x2D71, 0x2D7E, 0x2D97, 0x2D9F, 0x2DA7, 0x2DA7,
	0x2DAF, 0x2DAF, 0x2DB7, 0x2DB7, 0x2DBF, 0x2DBF, 0x2DC7, 0x2DC7,
	0x2DCF, 0x2DCF, 0x2DD7, 0x2DD7, 0x2DDF, 0x2DDF, 0x2E50, 0x2E7F,
	0x2E9A, 0x2E9A, 0x2EF4, 0x2EFF, 0x2FD6, 0x2FEF, 0x2FFC, 0x2FFF,
	0x3040, 0x3040, 0x3097, 0x3098, 0x3100, 0x3104, 0x3130, 0x3130,
	0x318F, 0x318F, 0x31BB, 0x31BF, 0x31E4, 0x31EF, 0x321F, 0x321F,
	0x4DB6, 0x4DBF, 0x9FF0, 0x9FFF, 0xA48D, 0xA48F, 0xA4C7, 0xA4CF,
	0xA62C, 0xA63F, 0xA6F8, 0xA6FF, 0xA7C0, 0xA7C1, 0xA7C7, 0xA7F6,
	0xA82C, 0xA82F, 0xA83A, 0xA83F, 0xA878, 0xA87F, 0xA8C6, 0xA8CD,
	0xA8DA, 0xA8DF, 0xA954, 0xA95E, 0xA97D, 0xA97F, 0xA9CE, 0xA9CE,
	0xA9DA, 0xA9DD, 0xA9FF, 0xA9FF, 0xAA37, 0xAA3F, 0xAA4E, 0xAA4F,
	0xAA5A, 0xAA5B, 0xAAC3, 0xAADA, 0xAAF7, 0xAB00, 0xAB07, 0xAB08,
	0xAB0F, 0xAB10, 0xAB17, 0xAB1F, 0xAB27, 0xAB27, 0xAB2F, 0xAB2F,
	0xAB68, 0xAB6F, 0xABEE, 0xABEF, 0xABFA, 0xABFF, 0xD7A4, 0xD7AF,
	0xD7C7, 0xD7CA, 0xD7FC, 0xD7FF, 0xFA6E, 0xFA6F, 0xFADA, 0xFAFF,
	0xFB07, 0xFB12, 0xFB18, 0xFB1C, 0xFB37, 0xFB37, 0xFB3D, 0xFB3D,
	0xFB3F, 0xFB3F, 0xFB42, 0xFB42, 0xFB45, 0xFB45, 0xFBC2, 0xFBD2,
	0xFD40, 0xFD4F, 0xFD90, 0xFD91, 0xFDC8, 0xFDEF, 0xFDFE, 0xFDFF,
	0xFE1A, 0xFE1F, 0xFE53, 0xFE53, 0xFE67, 0xFE67, 0xFE6C, 0xFE6F,
	0xFE75, 0xFE75, 0xFEFD, 0xFEFE, 0xFF00, 0xFF00, 0xFFBF, 0xFFC1,
	0xFFC8, 0xFFC9, 0xFFD0, 0xFFD1, 0xFFD8, 0xFFD9, 0xFFDD, 0xFFDF,
	0xFFE7, 0xFFE7, 0xFFEF, 0xFFF8, 0xFFFE, 0xFFFF, 0x1000C, 0x1000C,
	0x10027, 0x10027, 0x1003B, 0x1003B, 0x1003E, 0x1003E, 0x1004E, 0x1004F,
	0x1005E, 0x1007F, 0x100FB, 0x100FF, 0x10103, 0x10106, 0x10134, 0x10136,
	0x1018F, 0x1018F, 0x1019C, 0x1019F, 0x101A1, 0x101CF, 0x101FE, 0x1027F,
	0x1029D, 0x1029F, 0x102D1, 0x102DF, 0x102FC, 0x102FF, 0x10324, 0x1032C,
	0x1034B, 0x1034F, 0x1037B, 0x1037F, 0x1039E, 0x1039E, 0x103C4, 0x103C7,
	0x103D6, 0x103FF, 0x1049E, 0x1049F, 0x104AA, 0x104AF, 0x104D4, 0x104D7,
	0x104FC, 0x104FF, 0x10528, 0x1052F, 0x10564, 0x1056E, 0x10570, 0x105FF,
	0x10737, 0x1073F, 0x10756, 0x1075F, 0x10768, 0x107FF, 0x10806, 0x10807,
	0x10809, 0x10809, 0x10836, 0x10836, 0x10839, 0x1083B, 0x1083D, 0x1083E,
	0x10856, 0x10856, 0x1089F, 0x108A6, 0x108B0, 0x108DF, 0x108F3, 0x108F3,
	0x108F6, 0x108FA, 0x1091C, 0x1091E, 0x1093A, 0x1093E, 0x10940, 0x1097F,
	0x109B8, 0x109BB, 0x109D0, 0x109D1, 0x10A04, 0x10A04, 0x10A07, 0x10A0B,
	0x10A14, 0x10A14, 0x10A18, 0x10A18, 0x10A36, 0x10A37, 0x10A3B, 0x10A3E,
	0x10A49, 0x10A4F, 0x10A59, 0x10A5F, 0x10AA0, 0x10ABF, 0x10AE7, 0x10AEA,
	0x10AF7, 0x10AFF, 0x10B36, 0x10B38, 0x10B56, 0x10B57, 0x10B73, 0x10B77,
	0x10B92, 0x10B98, 0x10B9D, 0x10BA8, 0x10BB0, 0x10BFF, 0x10C49, 0x10C7F,
	0x10CB3, 0x10CBF, 0x10CF3, 0x10CF9, 0x10D28, 0x10D2F, 0x10D3A, 0x10E5F,
	0x10E7F, 0x10EFF, 0x10F28, 0x10F2F, 0x10F5A, 0x10FDF, 0x10FF7, 0x10FFF,
	0x1104E, 0x11051, 0x11070, 0x1107E, 0x110C2, 0x110CC, 0x110CE, 0x110CF,
	0x110E9, 0x110EF, 0x110FA, 0x110FF, 0x11135, 0x11135, 0x11147, 0x1114F,
	0x11177, 0x1117F, 0x111CE, 0x111CF, 0x111E0, 0x111E0, 0x111F5, 0x111FF,
	0x11212, 0x11212, 0x1123F, 0x1127F, 0x11287, 0x11287, 0x11289, 0x11289,
	0x1128E, 0x1128E, 0x1129E, 0x1129E, 0x112AA, 0x112AF, 0x112EB, 0x112EF,
	0x112FA, 0x112FF, 0x11304, 0x11304, 0x1130D, 0x1130E, 0x11311, 0x11312,
	0x11329, 0x11329, 0x11331, 0x11331, 0x11334, 0x11334, 0x1133A, 0x1133A,
	0x11345, 0x11346, 0x11349, 0x1134A, 0x1134E, 0x1134F, 0x11351, 0x11356,
	0x11358, 0x1135C, 0x11364, 0x11365, 0x1136D, 0x1136F, 0x11375, 0x113FF,
	0x1145A, 0x1145A, 0x1145C, 0x1145C, 0x11460, 0x1147F, 0x114C8, 0x114CF,
	0x114DA, 0x1157F, 0x115B6, 0x115B7, 0x115DE, 0x115FF, 0x11645, 0x1164F,
	0x1165A, 0x1165F, 0x1166D, 0x1167F, 0x116B9, 0x116BF, 0x116CA, 0x116FF,
	0x1171B, 0x1171C, 0x1172C, 0x1172F, 0x11740, 0x117FF, 0x1183C, 0x1189F,
	0x118F3, 0x118FE, 0x11900, 0x1199F, 0x119A8, 0x119A9, 0x119D8, 0x119D9,
	0x119E5, 0x119FF, 0x11A48, 0x11A4F, 0x11AA3, 0x11ABF, 0x11AF9, 0x11BFF,
	0x11C09, 0x11C09, 0x11C37, 0x11C37, 0x11C46, 0x11C4F, 0x11C6D, 0x11C6F,
	0x11C90, 0x11C91, 0x11CA8, 0x11CA8, 0x11CB7, 0x11CFF, 0x11D07, 0x11D07,
	0x11D0A, 0x11D0A, 0x11D37, 0x11D39, 0x11D3B, 0x11D3B, 0x11D3E, 0x11D3E,
	0x11D48, 0x11D4F, 0x11D5A, 0x11D5F, 0x11D66, 0x11D66, 0x11D69, 0x11D69,
	0x11D8F, 0x11D8F, 0x11D92, 0x11D92, 0x11D99, 0x11D9F, 0x11DAA, 0x11EDF,
	0x11EF9, 0x11FBF, 0x11FF2, 0x11FFE, 0x1239A, 0x123FF, 0x1246F, 0x1246F,
	0x12475, 0x1247F, 0x12544, 0x12FFF, 0x1342F, 0x1342F, 0x13439, 0x143FF,
	0x14647, 0x167FF, 0x16A39, 0x16A3F, 0x16A5F, 0x16A5F, 0x16A6A, 0x16A6D,
	0x16A70, 0x16ACF, 0x16AEE, 0x16AEF, 0x16AF6, 0x16AFF, 0x16B46, 0x16B4F,
	0x16B5A, 0x16B5A, 0x16B62, 0x16B62, 0x16B78, 0x16B7C, 0x16B90, 0x16E3F,
	0x16E9B, 0x16EFF, 0x16F4B, 0x16F4E, 0x16F88, 0x16F8E, 0x16FA0, 0x16FDF,
	0x16FE4, 0x16FFF, 0x187F8, 0x187FF, 0x18AF3, 0x1AFFF, 0x1B11F, 0x1B14F,
	0x1B153, 0x1B163, 0x1B168, 0x1B16F, 0x1B2FC, 0x1BBFF, 0x1BC6B, 0x1BC6F,
	0x1BC7D, 0x1BC7F, 0x1BC89, 0x1BC8F, 0x1BC9A, 0x1BC9B, 0x1BCA4, 0x1CFFF,
	0x1D0F6, 0x1D0FF, 0x1D127, 0x1D128, 0x1D1E9, 0x1D1FF, 0x1D246, 0x1D2DF,
	0x1D2F4, 0x1D2FF, 0x1D357, 0x1D35F, 0x1D379, 0x1D3FF, 0x1D455, 0x1D455,
	0x1D49D, 0x1D49D, 0x1D4A0, 0x1D4A1, 0x1D4A3, 0x1D4A4, 0x1D4A7, 0x1D4A8,
	0x1D4AD, 0x1D4AD, 0x1D4BA, 0x1D4BA, 0x1D4BC, 0x1D4BC, 0x1D4C4, 0x1D4C4,
	0x1D506, 0x1D506, 0x1D50B, 0x1D50C, 0x1D515, 0x1D515, 0x1D51D, 0x1D51D,
	0x1D53A, 0x1D53A, 0x1D53F, 0x1D53F, 0x1D545, 0x1D545, 0x1D547, 0x1D549,
	0x1D551, 0x1D551, 0x1D6A6, 0x1D6A7, 0x1D7CC, 0x1D7CD, 0x1DA8C, 0x1DA9A,
	0x1DAA0, 0x1DAA0, 0x1DAB0, 0x1DFFF, 0x1E007, 0x1E007, 0x1E019, 0x1E01A,
	0x1E022, 0x1E022, 0x1E025, 0x1E025, 0x1E02B, 0x1E0FF, 0x1E12D, 0x1E12F,
	0x1E13E, 0x1E13F, 0x1E14A, 0x1E14D, 0x1E150, 0x1E2BF, 0x1E2FA, 0x1E2FE,
	0x1E300, 0x1E7FF, 0x1E8C5, 0x1E8C6, 0x1E8D7, 0x1E8FF, 0x1E94C, 0x1E94F,
	0x1E95A, 0x1E95D, 0x1E960, 0x1EC70, 0x1ECB5, 0x1ED00, 0x1ED3E, 0x1EDFF,
	0x1EE04, 0x1EE04, 0x1EE20, 0x1EE20, 0x1EE23, 0x1EE23, 0x1EE25, 0x1EE26,
	0x1EE28, 0x1EE28, 0x1EE33, 0x1EE33, 0x1EE38, 0x1EE38, 0x1EE3A, 0x1EE3A,
	0x1EE3C, 0x1EE41, 0x1EE43, 0x1EE46, 0x1EE48, 0x1EE48, 0x1EE4A, 0x1EE4A,
	0x1EE4C, 0x1EE4C, 0x1EE50, 0x1EE50, 0x1EE53, 0x1EE53, 0x1EE55, 0x1EE56,
	0x1EE58, 0x1EE58, 0x1EE5A, 0x1EE5A, 0x1EE5C, 0x1EE5C, 0x1EE5E, 0x1EE5E,
	0x1EE60, 0x1EE60, 0x1EE63, 0x1EE63, 0x1EE65, 0x1EE66, 0x1EE6B, 0x1EE6B,
	0x1EE73, 0x1EE73, 0x1EE78, 0x1EE78, 0x1EE7D, 0x1EE7D, 0x1EE7F, 0x1EE7F,
	0x1EE8A, 0x1EE8A, 0x1EE9C, 0x1EEA0, 0x1EEA4, 0x1EEA4, 0x1EEAA, 0x1EEAA,
	0x1EEBC, 0x1EEEF, 0x1EEF2, 0x1EFFF, 0x1F02C, 0x1F02F, 0x1F094, 0x1F09F,
	0x1F0AF, 0x1F0B0, 0x1F0C0, 0x1F0C0, 0x1F0D0, 0x1F0D0, 0x1F0F6, 0x1F0FF,
	0x1F10D, 0x1F10F, 0x1F16D, 0x1F16F, 0x1F1AD, 0x1F1E5, 0x1F203, 0x1F20F,
	0x1F23C, 0x1F23F, 0x1F249, 0x1F24F, 0x1F252, 0x1F25F, 0x1F266, 0x1F2FF,
	0x1F6D6, 0x1F6DF, 0x1F6ED, 0x1F6EF, 0x1F6FB, 0x1F6FF, 0x1F774, 0x1F77F,
	0x1F7D9, 0x1F7DF, 0x1F7EC, 0x1F7FF, 0x1F80C, 0x1F80F, 0x1F848, 0x1F84F,
	0x1F85A, 0x1F85F, 0x1F888, 0x1F88F, 0x1F8AE, 0x1F8FF, 0x1F90C, 0x1F90C,
	0x1F972, 0x1F972, 0x1F977, 0x1F979, 0x1F9A3, 0x1F9A4, 0x1F9AB, 0x1F9AD,
	0x1F9CB, 0x1F9CC, 0x1FA54, 0x1FA5F, 0x1FA6E, 0x1FA6F, 0x1FA74, 0x1FA77,
	0x1FA7B, 0x1FA7F, 0x1FA83, 0x1FA8F, 0x1FA96, 0x1FFFF, 0x2A6D7, 0x2A6FF,
	0x2B735, 0x2B73F, 0x2B81E, 0x2B81F, 0x2CEA2, 0x2CEAF, 0x2EBE1, 0x2F7FF,
	0x2FA1E, 0xE0000, 0xE0002, 0xE001F, 0xE0080, 0xE00FF, 0xE01F0, 0xEFFFF,
	0xFFFFE, 0xFFFFF, 0x10FFFE, 0x10FFFF,
	//  #5 (688+3): gc=Private_Use:Co
	0xE000, 0xF8FF, 0xF0000, 0xFFFFD, 0x100000, 0x10FFFD,
	//  #6 (691+1): gc=Surrogate:Cs
	0xD800, 0xDFFF,
	//  #7 (692+1824): gc=Letter:L
	//  Ll:642 + Lt:10 + Lu:636 + Lm:60 + Lo:476
	//  #8 (692+1288): gc=Cased_Letter:LC
	//  Ll:642 + Lt:10 + Lu:636
	//  #9 (692+642): gc=Lowercase_Letter:Ll
	0x0061, 0x007A, 0x00B5, 0x00B5, 0x00DF, 0x00F6, 0x00F8, 0x00FF,
	0x0101, 0x0101, 0x0103, 0x0103, 0x0105, 0x0105, 0x0107, 0x0107,
	0x0109, 0x0109, 0x010B, 0x010B, 0x010D, 0x010D, 0x010F, 0x010F,
	0x0111, 0x0111, 0x0113, 0x0113, 0x0115, 0x0115, 0x0117, 0x0117,
	0x0119, 0x0119, 0x011B, 0x011B, 0x011D, 0x011D, 0x011F, 0x011F,
	0x0121, 0x0121, 0x0123, 0x0123, 0x0125, 0x0125, 0x0127, 0x0127,
	0x0129, 0x0129, 0x012B, 0x012B, 0x012D, 0x012D, 0x012F, 0x012F,
	0x0131, 0x0131, 0x0133, 0x0133, 0x0135, 0x0135, 0x0137, 0x0138,
	0x013A, 0x013A, 0x013C, 0x013C, 0x013E, 0x013E, 0x0140, 0x0140,
	0x0142, 0x0142, 0x0144, 0x0144, 0x0146, 0x0146, 0x0148, 0x0149,
	0x014B, 0x014B, 0x014D, 0x014D, 0x014F, 0x014F, 0x0151, 0x0151,
	0x0153, 0x0153, 0x0155, 0x0155, 0x0157, 0x0157, 0x0159, 0x0159,
	0x015B, 0x015B, 0x015D, 0x015D, 0x015F, 0x015F, 0x0161, 0x0161,
	0x0163, 0x0163, 0x0165, 0x0165, 0x0167, 0x0167, 0x0169, 0x0169,
	0x016B, 0x016B, 0x016D, 0x016D, 0x016F, 0x016F, 0x0171, 0x0171,
	0x0173, 0x0173, 0x0175, 0x0175, 0x0177, 0x0177, 0x017A, 0x017A,
	0x017C, 0x017C, 0x017E, 0x0180, 0x0183, 0x0183, 0x0185, 0x0185,
	0x0188, 0x0188, 0x018C, 0x018D, 0x0192, 0x0192, 0x0195, 0x0195,
	0x0199, 0x019B, 0x019E, 0x019E, 0x01A1, 0x01A1, 0x01A3, 0x01A3,
	0x01A5, 0x01A5, 0x01A8, 0x01A8, 0x01AA, 0x01AB, 0x01AD, 0x01AD,
	0x01B0, 0x01B0, 0x01B4, 0x01B4, 0x01B6, 0x01B6, 0x01B9, 0x01BA,
	0x01BD, 0x01BF, 0x01C6, 0x01C6, 0x01C9, 0x01C9, 0x01CC, 0x01CC,
	0x01CE, 0x01CE, 0x01D0, 0x01D0, 0x01D2, 0x01D2, 0x01D4, 0x01D4,
	0x01D6, 0x01D6, 0x01D8, 0x01D8, 0x01DA, 0x01DA, 0x01DC, 0x01DD,
	0x01DF, 0x01DF, 0x01E1, 0x01E1, 0x01E3, 0x01E3, 0x01E5, 0x01E5,
	0x01E7, 0x01E7, 0x01E9, 0x01E9, 0x01EB, 0x01EB, 0x01ED, 0x01ED,
	0x01EF, 0x01F0, 0x01F3, 0x01F3, 0x01F5, 0x01F5, 0x01F9, 0x01F9,
	0x01FB, 0x01FB, 0x01FD, 0x01FD, 0x01FF, 0x01FF, 0x0201, 0x0201,
	0x0203, 0x0203, 0x0205, 0x0205, 0x0207, 0x0207, 0x0209, 0x0209,
	0x020B, 0x020B, 0x020D, 0x020D, 0x020F, 0x020F, 0x0211, 0x0211,
	0x0213, 0x0213, 0x0215, 0x0215, 0x0217, 0x0217, 0x0219, 0x0219,
	0x021B, 0x021B, 0x021D, 0x021D, 0x021F, 0x021F, 0x0221, 0x0221,
	0x0223, 0x0223, 0x0225, 0x0225, 0x0227, 0x0227, 0x0229, 0x0229,
	0x022B, 0x022B, 0x022D, 0x022D, 0x022F, 0x022F, 0x0231, 0x0231,
	0x0233, 0x0239, 0x023C, 0x023C, 0x023F, 0x0240, 0x0242, 0x0242,
	0x0247, 0x0247, 0x0249, 0x0249, 0x024B, 0x024B, 0x024D, 0x024D,
	0x024F, 0x0293, 0x0295, 0x02AF, 0x0371, 0x0371, 0x0373, 0x0373,
	0x0377, 0x0377, 0x037B, 0x037D, 0x0390, 0x0390, 0x03AC, 0x03CE,
	0x03D0, 0x03D1, 0x03D5, 0x03D7, 0x03D9, 0x03D9, 0x03DB, 0x03DB,
	0x03DD, 0x03DD, 0x03DF, 0x03DF, 0x03E1, 0x03E1, 0x03E3, 0x03E3,
	0x03E5, 0x03E5, 0x03E7, 0x03E7, 0x03E9, 0x03E9, 0x03EB, 0x03EB,
	0x03ED, 0x03ED, 0x03EF, 0x03F3, 0x03F5, 0x03F5, 0x03F8, 0x03F8,
	0x03FB, 0x03FC, 0x0430, 0x045F, 0x0461, 0x0461, 0x0463, 0x0463,
	0x0465, 0x0465, 0x0467, 0x0467, 0x0469, 0x0469, 0x046B, 0x046B,
	0x046D, 0x046D, 0x046F, 0x046F, 0x0471, 0x0471, 0x0473, 0x0473,
	0x0475, 0x0475, 0x0477, 0x0477, 0x0479, 0x0479, 0x047B, 0x047B,
	0x047D, 0x047D, 0x047F, 0x047F, 0x0481, 0x0481, 0x048B, 0x048B,
	0x048D, 0x048D, 0x048F, 0x048F, 0x0491, 0x0491, 0x0493, 0x0493,
	0x0495, 0x0495, 0x0497, 0x0497, 0x0499, 0x0499, 0x049B, 0x049B,
	0x049D, 0x049D, 0x049F, 0x049F, 0x04A1, 0x04A1, 0x04A3, 0x04A3,
	0x04A5, 0x04A5, 0x04A7, 0x04A7, 0x04A9, 0x04A9, 0x04AB, 0x04AB,
	0x04AD, 0x04AD, 0x04AF, 0x04AF, 0x04B1, 0x04B1, 0x04B3, 0x04B3,
	0x04B5, 0x04B5, 0x04B7, 0x04B7, 0x04B9, 0x04B9, 0x04BB, 0x04BB,
	0x04BD, 0x04BD, 0x04BF, 0x04BF, 0x04C2, 0x04C2, 0x04C4, 0x04C4,
	0x04C6, 0x04C6, 0x04C8, 0x04C8, 0x04CA, 0x04CA, 0x04CC, 0x04CC,
	0x04CE, 0x04CF, 0x04D1, 0x04D1, 0x04D3, 0x04D3, 0x04D5, 0x04D5,
	0x04D7, 0x04D7, 0x04D9, 0x04D9, 0x04DB, 0x04DB, 0x04DD, 0x04DD,
	0x04DF, 0x04DF, 0x04E1, 0x04E1, 0x04E3, 0x04E3, 0x04E5, 0x04E5,
	0x04E7, 0x04E7, 0x04E9, 0x04E9, 0x04EB, 0x04EB, 0x04ED, 0x04ED,
	0x04EF, 0x04EF, 0x04F1, 0x04F1, 0x04F3, 0x04F3, 0x04F5, 0x04F5,
	0x04F7, 0x04F7, 0x04F9, 0x04F9, 0x04FB, 0x04FB, 0x04FD, 0x04FD,
	0x04FF, 0x04FF, 0x0501, 0x0501, 0x0503, 0x0503, 0x0505, 0x0505,
	0x0507, 0x0507, 0x0509, 0x0509, 0x050B, 0x050B, 0x050D, 0x050D,
	0x050F, 0x050F, 0x0511, 0x0511, 0x0513, 0x0513, 0x0515, 0x0515,
	0x0517, 0x0517, 0x0519, 0x0519, 0x051B, 0x051B, 0x051D, 0x051D,
	0x051F, 0x051F, 0x0521, 0x0521, 0x0523, 0x0523, 0x0525, 0x0525,
	0x0527, 0x0527, 0x0529, 0x0529, 0x052B, 0x052B, 0x052D, 0x052D,
	0x052F, 0x052F, 0x0560, 0x0588, 0x10D0, 0x10FA, 0x10FD, 0x10FF,
	0x13F8, 0x13FD, 0x1C80, 0x1C88, 0x1D00, 0x1D2B, 0x1D6B, 0x1D77,
	0x1D79, 0x1D9A, 0x1E01, 0x1E01, 0x1E03, 0x1E03, 0x1E05, 0x1E05,
	0x1E07, 0x1E07, 0x1E09, 0x1E09, 0x1E0B, 0x1E0B, 0x1E0D, 0x1E0D,
	0x1E0F, 0x1E0F, 0x1E11, 0x1E11, 0x1E13, 0x1E13, 0x1E15, 0x1E15,
	0x1E17, 0x1E17, 0x1E19, 0x1E19, 0x1E1B, 0x1E1B, 0x1E1D, 0x1E1D,
	0x1E1F, 0x1E1F, 0x1E21, 0x1E21, 0x1E23, 0x1E23, 0x1E25, 0x1E25,
	0x1E27, 0x1E27, 0x1E29, 0x1E29, 0x1E2B, 0x1E2B, 0x1E2D, 0x1E2D,
	0x1E2F, 0x1E2F, 0x1E31, 0x1E31, 0x1E33, 0x1E33, 0x1E35, 0x1E35,
	0x1E37, 0x1E37, 0x1E39, 0x1E39, 0x1E3B, 0x1E3B, 0x1E3D, 0x1E3D,
	0x1E3F, 0x1E3F, 0x1E41, 0x1E41, 0x1E43, 0x1E43, 0x1E45, 0x1E45,
	0x1E47, 0x1E47, 0x1E49, 0x1E49, 0x1E4B, 0x1E4B, 0x1E4D, 0x1E4D,
	0x1E4F, 0x1E4F, 0x1E51, 0x1E51, 0x1E53, 0x1E53, 0x1E55, 0x1E55,
	0x1E57, 0x1E57, 0x1E59, 0x1E59, 0x1E5B, 0x1E5B, 0x1E5D, 0x1E5D,
	0x1E5F, 0x1E5F, 0x1E61, 0x1E61, 0x1E63, 0x1E63, 0x1E65, 0x1E65,
	0x1E67, 0x1E67, 0x1E69, 0x1E69, 0x1E6B, 0x1E6B, 0x1E6D, 0x1E6D,
	0x1E6F, 0x1E6F, 0x1E71, 0x1E71, 0x1E73, 0x1E73, 0x1E75, 0x1E75,
	0x1E77, 0x1E77, 0x1E79, 0x1E79, 0x1E7B, 0x1E7B, 0x1E7D, 0x1E7D,
	0x1E7F, 0x1E7F, 0x1E81, 0x1E81, 0x1E83, 0x1E83, 0x1E85, 0x1E85,
	0x1E87, 0x1E87, 0x1E89, 0x1E89, 0x1E8B, 0x1E8B, 0x1E8D, 0x1E8D,
	0x1E8F, 0x1E8F, 0x1E91, 0x1E91, 0x1E93, 0x1E93, 0x1E95, 0x1E9D,
	0x1E9F, 0x1E9F, 0x1EA1, 0x1EA1, 0x1EA3, 0x1EA3, 0x1EA5, 0x1EA5,
	0x1EA7, 0x1EA7, 0x1EA9, 0x1EA9, 0x1EAB, 0x1EAB, 0x1EAD, 0x1EAD,
	0x1EAF, 0x1EAF, 0x1EB1, 0x1EB1, 0x1EB3, 0x1EB3, 0x1EB5, 0x1EB5,
	0x1EB7, 0x1EB7, 0x1EB9, 0x1EB9, 0x1EBB, 0x1EBB, 0x1EBD, 0x1EBD,
	0x1EBF, 0x1EBF, 0x1EC1, 0x1EC1, 0x1EC3, 0x1EC3, 0x1EC5, 0x1EC5,
	0x1EC7, 0x1EC7, 0x1EC9, 0x1EC9, 0x1ECB, 0x1ECB, 0x1ECD, 0x1ECD,
	0x1ECF, 0x1ECF, 0x1ED1, 0x1ED1, 0x1ED3, 0x1ED3, 0x1ED5, 0x1ED5,
	0x1ED7, 0x1ED7, 0x1ED9, 0x1ED9, 0x1EDB, 0x1EDB, 0x1EDD, 0x1EDD,
	0x1EDF, 0x1EDF, 0x1EE1, 0x1EE1, 0x1EE3, 0x1EE3, 0x1EE5, 0x1EE5,
	0x1EE7, 0x1EE7, 0x1EE9, 0x1EE9, 0x1EEB, 0x1EEB, 0x1EED, 0x1EED,
	0x1EEF, 0x1EEF, 0x1EF1, 0x1EF1, 0x1EF3, 0x1EF3, 0x1EF5, 0x1EF5,
	0x1EF7, 0x1EF7, 0x1EF9, 0x1EF9, 0x1EFB, 0x1EFB, 0x1EFD, 0x1EFD,
	0x1EFF, 0x1F07, 0x1F10, 0x1F15, 0x1F20, 0x1F27, 0x1F30, 0x1F37,
	0x1F40, 0x1F45, 0x1F50, 0x1F57, 0x1F60, 0x1F67, 0x1F70, 0x1F7D,
	0x1F80, 0x1F87, 0x1F90, 0x1F97, 0x1FA0, 0x1FA7, 0x1FB0, 0x1FB4,
	0x1FB6, 0x1FB7, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FC7,
	0x1FD0, 0x1FD3, 0x1FD6, 0x1FD7, 0x1FE0, 0x1FE7, 0x1FF2, 0x1FF4,
	0x1FF6, 0x1FF7, 0x210A, 0x210A, 0x210E, 0x210F, 0x2113, 0x2113,
	0x212F, 0x212F, 0x2134, 0x2134, 0x2139, 0x2139, 0x213C, 0x213D,
	0x2146, 0x2149, 0x214E, 0x214E, 0x2184, 0x2184, 0x2C30, 0x2C5E,
	0x2C61, 0x2C61, 0x2C65, 0x2C66, 0x2C68, 0x2C68, 0x2C6A, 0x2C6A,
	0x2C6C, 0x2C6C, 0x2C71, 0x2C71, 0x2C73, 0x2C74, 0x2C76, 0x2C7B,
	0x2C81, 0x2C81, 0x2C83, 0x2C83, 0x2C85, 0x2C85, 0x2C87, 0x2C87,
	0x2C89, 0x2C89, 0x2C8B, 0x2C8B, 0x2C8D, 0x2C8D, 0x2C8F, 0x2C8F,
	0x2C91, 0x2C91, 0x2C93, 0x2C93, 0x2C95, 0x2C95, 0x2C97, 0x2C97,
	0x2C99, 0x2C99, 0x2C9B, 0x2C9B, 0x2C9D, 0x2C9D, 0x2C9F, 0x2C9F,
	0x2CA1, 0x2CA1, 0x2CA3, 0x2CA3, 0x2CA5, 0x2CA5, 0x2CA7, 0x2CA7,
	0x2CA9, 0x2CA9, 0x2CAB, 0x2CAB, 0x2CAD, 0x2CAD, 0x2CAF, 0x2CAF,
	0x2CB1, 0x2CB1, 0x2CB3, 0x2CB3, 0x2CB5, 0x2CB5, 0x2CB7, 0x2CB7,
	0x2CB9, 0x2CB9, 0x2CBB, 0x2CBB, 0x2CBD, 0x2CBD, 0x2CBF, 0x2CBF,
	0x2CC1, 0x2CC1, 0x2CC3, 0x2CC3, 0x2CC5, 0x2CC5, 0x2CC7, 0x2CC7,
	0x2CC9, 0x2CC9, 0x2CCB, 0x2CCB, 0x2CCD, 0x2CCD, 0x2CCF, 0x2CCF,
	0x2CD1, 0x2CD1, 0x2CD3, 0x2CD3, 0x2CD5, 0x2CD5, 0x2CD7, 0x2CD7,
	0x2CD9, 0x2CD9, 0x2CDB, 0x2CDB, 0x2CDD, 0x2CDD, 0x2CDF, 0x2CDF,
	0x2CE1, 0x2CE1, 0x2CE3, 0x2CE4, 0x2CEC, 0x2CEC, 0x2CEE, 0x2CEE,
	0x2CF3, 0x2CF3, 0x2D00, 0x2D25, 0x2D27, 0x2D27, 0x2D2D, 0x2D2D,
	0xA641, 0xA641, 0xA643, 0xA643, 0xA645, 0xA645, 0xA647, 0xA647,
	0xA649, 0xA649, 0xA64B, 0xA64B, 0xA64D, 0xA64D, 0xA64F, 0xA64F,
	0xA651, 0xA651, 0xA653, 0xA653, 0xA655, 0xA655, 0xA657, 0xA657,
	0xA659, 0xA659, 0xA65B, 0xA65B, 0xA65D, 0xA65D, 0xA65F, 0xA65F,
	0xA661, 0xA661, 0xA663, 0xA663, 0xA665, 0xA665, 0xA667, 0xA667,
	0xA669, 0xA669, 0xA66B, 0xA66B, 0xA66D, 0xA66D, 0xA681, 0xA681,
	0xA683, 0xA683, 0xA685, 0xA685, 0xA687, 0xA687, 0xA689, 0xA689,
	0xA68B, 0xA68B, 0xA68D, 0xA68D, 0xA68F, 0xA68F, 0xA691, 0xA691,
	0xA693, 0xA693, 0xA695, 0xA695, 0xA697, 0xA697, 0xA699, 0xA699,
	0xA69B, 0xA69B, 0xA723, 0xA723, 0xA725, 0xA725, 0xA727, 0xA727,
	0xA729, 0xA729, 0xA72B, 0xA72B, 0xA72D, 0xA72D, 0xA72F, 0xA731,
	0xA733, 0xA733, 0xA735, 0xA735, 0xA737, 0xA737, 0xA739, 0xA739,
	0xA73B, 0xA73B, 0xA73D, 0xA73D, 0xA73F, 0xA73F, 0xA741, 0xA741,
	0xA743, 0xA743, 0xA745, 0xA745, 0xA747, 0xA747, 0xA749, 0xA749,
	0xA74B, 0xA74B, 0xA74D, 0xA74D, 0xA74F, 0xA74F, 0xA751, 0xA751,
	0xA753, 0xA753, 0xA755, 0xA755, 0xA757, 0xA757, 0xA759, 0xA759,
	0xA75B, 0xA75B, 0xA75D, 0xA75D, 0xA75F, 0xA75F, 0xA761, 0xA761,
	0xA763, 0xA763, 0xA765, 0xA765, 0xA767, 0xA767, 0xA769, 0xA769,
	0xA76B, 0xA76B, 0xA76D, 0xA76D, 0xA76F, 0xA76F, 0xA771, 0xA778,
	0xA77A, 0xA77A, 0xA77C, 0xA77C, 0xA77F, 0xA77F, 0xA781, 0xA781,
	0xA783, 0xA783, 0xA785, 0xA785, 0xA787, 0xA787, 0xA78C, 0xA78C,
	0xA78E, 0xA78E, 0xA791, 0xA791, 0xA793, 0xA795, 0xA797, 0xA797,
	0xA799, 0xA799, 0xA79B, 0xA79B, 0xA79D, 0xA79D, 0xA79F, 0xA79F,
	0xA7A1, 0xA7A1, 0xA7A3, 0xA7A3, 0xA7A5, 0xA7A5, 0xA7A7, 0xA7A7,
	0xA7A9, 0xA7A9, 0xA7AF, 0xA7AF, 0xA7B5, 0xA7B5, 0xA7B7, 0xA7B7,
	0xA7B9, 0xA7B9, 0xA7BB, 0xA7BB, 0xA7BD, 0xA7BD, 0xA7BF, 0xA7BF,
	0xA7C3, 0xA7C3, 0xA7FA, 0xA7FA, 0xAB30, 0xAB5A, 0xAB60, 0xAB67,
	0xAB70, 0xABBF, 0xFB00, 0xFB06, 0xFB13, 0xFB17, 0xFF41, 0xFF5A,
	0x10428, 0x1044F, 0x104D8, 0x104FB, 0x10CC0, 0x10CF2, 0x118C0, 0x118DF,
	0x16E60, 0x16E7F, 0x1D41A, 0x1D433, 0x1D44E, 0x1D454, 0x1D456, 0x1D467,
	0x1D482, 0x1D49B, 0x1D4B6, 0x1D4B9, 0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3,
	0x1D4C5, 0x1D4CF, 0x1D4EA, 0x1D503, 0x1D51E, 0x1D537, 0x1D552, 0x1D56B,
	0x1D586, 0x1D59F, 0x1D5BA, 0x1D5D3, 0x1D5EE, 0x1D607, 0x1D622, 0x1D63B,
	0x1D656, 0x1D66F, 0x1D68A, 0x1D6A5, 0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6E1,
	0x1D6FC, 0x1D714, 0x1D716, 0x1D71B, 0x1D736, 0x1D74E, 0x1D750, 0x1D755,
	0x1D770, 0x1D788, 0x1D78A, 0x1D78F, 0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7C9,
	0x1D7CB, 0x1D7CB, 0x1E922, 0x1E943,
	//  #10 (1334+10): gc=Titlecase_Letter:Lt
	0x01C5, 0x01C5, 0x01C8, 0x01C8, 0x01CB, 0x01CB, 0x01F2, 0x01F2,
	0x1F88, 0x1F8F, 0x1F98, 0x1F9F, 0x1FA8, 0x1FAF, 0x1FBC, 0x1FBC,
	0x1FCC, 0x1FCC, 0x1FFC, 0x1FFC,
	//  #11 (1344+636): gc=Uppercase_Letter:Lu
	0x0041, 0x005A, 0x00C0, 0x00D6, 0x00D8, 0x00DE, 0x0100, 0x0100,
	0x0102, 0x0102, 0x0104, 0x0104, 0x0106, 0x0106, 0x0108, 0x0108,
	0x010A, 0x010A, 0x010C, 0x010C, 0x010E, 0x010E, 0x0110, 0x0110,
	0x0112, 0x0112, 0x0114, 0x0114, 0x0116, 0x0116, 0x0118, 0x0118,
	0x011A, 0x011A, 0x011C, 0x011C, 0x011E, 0x011E, 0x0120, 0x0120,
	0x0122, 0x0122, 0x0124, 0x0124, 0x0126, 0x0126, 0x0128, 0x0128,
	0x012A, 0x012A, 0x012C, 0x012C, 0x012E, 0x012E, 0x0130, 0x0130,
	0x0132, 0x0132, 0x0134, 0x0134, 0x0136, 0x0136, 0x0139, 0x0139,
	0x013B, 0x013B, 0x013D, 0x013D, 0x013F, 0x013F, 0x0141, 0x0141,
	0x0143, 0x0143, 0x0145, 0x0145, 0x0147, 0x0147, 0x014A, 0x014A,
	0x014C, 0x014C, 0x014E, 0x014E, 0x0150, 0x0150, 0x0152, 0x0152,
	0x0154, 0x0154, 0x0156, 0x0156, 0x0158, 0x0158, 0x015A, 0x015A,
	0x015C, 0x015C, 0x015E, 0x015E, 0x0160, 0x0160, 0x0162, 0x0162,
	0x0164, 0x0164, 0x0166, 0x0166, 0x0168, 0x0168, 0x016A, 0x016A,
	0x016C, 0x016C, 0x016E, 0x016E, 0x0170, 0x0170, 0x0172, 0x0172,
	0x0174, 0x0174, 0x0176, 0x0176, 0x0178, 0x0179, 0x017B, 0x017B,
	0x017D, 0x017D, 0x0181, 0x0182, 0x0184, 0x0184, 0x0186, 0x0187,
	0x0189, 0x018B, 0x018E, 0x0191, 0x0193, 0x0194, 0x0196, 0x0198,
	0x019C, 0x019D, 0x019F, 0x01A0, 0x01A2, 0x01A2, 0x01A4, 0x01A4,
	0x01A6, 0x01A7, 0x01A9, 0x01A9, 0x01AC, 0x01AC, 0x01AE, 0x01AF,
	0x01B1, 0x01B3, 0x01B5, 0x01B5, 0x01B7, 0x01B8, 0x01BC, 0x01BC,
	0x01C4, 0x01C4, 0x01C7, 0x01C7, 0x01CA, 0x01CA, 0x01CD, 0x01CD,
	0x01CF, 0x01CF, 0x01D1, 0x01D1, 0x01D3, 0x01D3, 0x01D5, 0x01D5,
	0x01D7, 0x01D7, 0x01D9, 0x01D9, 0x01DB, 0x01DB, 0x01DE, 0x01DE,
	0x01E0, 0x01E0, 0x01E2, 0x01E2, 0x01E4, 0x01E4, 0x01E6, 0x01E6,
	0x01E8, 0x01E8, 0x01EA, 0x01EA, 0x01EC, 0x01EC, 0x01EE, 0x01EE,
	0x01F1, 0x01F1, 0x01F4, 0x01F4, 0x01F6, 0x01F8, 0x01FA, 0x01FA,
	0x01FC, 0x01FC, 0x01FE, 0x01FE, 0x0200, 0x0200, 0x0202, 0x0202,
	0x0204, 0x0204, 0x0206, 0x0206, 0x0208, 0x0208, 0x020A, 0x020A,
	0x020C, 0x020C, 0x020E, 0x020E, 0x0210, 0x0210, 0x0212, 0x0212,
	0x0214, 0x0214, 0x0216, 0x0216, 0x0218, 0x0218, 0x021A, 0x021A,
	0x021C, 0x021C, 0x021E, 0x021E, 0x0220, 0x0220, 0x0222, 0x0222,
	0x0224, 0x0224, 0x0226, 0x0226, 0x0228, 0x0228, 0x022A, 0x022A,
	0x022C, 0x022C, 0x022E, 0x022E, 0x0230, 0x0230, 0x0232, 0x0232,
	0x023A, 0x023B, 0x023D, 0x023E, 0x0241, 0x0241, 0x0243, 0x0246,
	0x0248, 0x0248, 0x024A, 0x024A, 0x024C, 0x024C, 0x024E, 0x024E,
	0x0370, 0x0370, 0x0372, 0x0372, 0x0376, 0x0376, 0x037F, 0x037F,
	0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x038F,
	0x0391, 0x03A1, 0x03A3, 0x03AB, 0x03CF, 0x03CF, 0x03D2, 0x03D4,
	0x03D8, 0x03D8, 0x03DA, 0x03DA, 0x03DC, 0x03DC, 0x03DE, 0x03DE,
	0x03E0, 0x03E0, 0x03E2, 0x03E2, 0x03E4, 0x03E4, 0x03E6, 0x03E6,
	0x03E8, 0x03E8, 0x03EA, 0x03EA, 0x03EC, 0x03EC, 0x03EE, 0x03EE,
	0x03F4, 0x03F4, 0x03F7, 0x03F7, 0x03F9, 0x03FA, 0x03FD, 0x042F,
	0x0460, 0x0460, 0x0462, 0x0462, 0x0464, 0x0464, 0x0466, 0x0466,
	0x0468, 0x0468, 0x046A, 0x046A, 0x046C, 0x046C, 0x046E, 0x046E,
	0x0470, 0x0470, 0x0472, 0x0472, 0x0474, 0x0474, 0x0476, 0x0476,
	0x0478, 0x0478, 0x047A, 0x047A, 0x047C, 0x047C, 0x047E, 0x047E,
	0x0480, 0x0480, 0x048A, 0x048A, 0x048C, 0x048C, 0x048E, 0x048E,
	0x0490, 0x0490, 0x0492, 0x0492, 0x0494, 0x0494, 0x0496, 0x0496,
	0x0498, 0x0498, 0x049A, 0x049A, 0x049C, 0x049C, 0x049E, 0x049E,
	0x04A0, 0x04A0, 0x04A2, 0x04A2, 0x04A4, 0x04A4, 0x04A6, 0x04A6,
	0x04A8, 0x04A8, 0x04AA, 0x04AA, 0x04AC, 0x04AC, 0x04AE, 0x04AE,
	0x04B0, 0x04B0, 0x04B2, 0x04B2, 0x04B4, 0x04B4, 0x04B6, 0x04B6,
	0x04B8, 0x04B8, 0x04BA, 0x04BA, 0x04BC, 0x04BC, 0x04BE, 0x04BE,
	0x04C0, 0x04C1, 0x04C3, 0x04C3, 0x04C5, 0x04C5, 0x04C7, 0x04C7,
	0x04C9, 0x04C9, 0x04CB, 0x04CB, 0x04CD, 0x04CD, 0x04D0, 0x04D0,
	0x04D2, 0x04D2, 0x04D4, 0x04D4, 0x04D6, 0x04D6, 0x04D8, 0x04D8,
	0x04DA, 0x04DA, 0x04DC, 0x04DC, 0x04DE, 0x04DE, 0x04E0, 0x04E0,
	0x04E2, 0x04E2, 0x04E4, 0x04E4, 0x04E6, 0x04E6, 0x04E8, 0x04E8,
	0x04EA, 0x04EA, 0x04EC, 0x04EC, 0x04EE, 0x04EE, 0x04F0, 0x04F0,
	0x04F2, 0x04F2, 0x04F4, 0x04F4, 0x04F6, 0x04F6, 0x04F8, 0x04F8,
	0x04FA, 0x04FA, 0x04FC, 0x04FC, 0x04FE, 0x04FE, 0x0500, 0x0500,
	0x0502, 0x0502, 0x0504, 0x0504, 0x0506, 0x0506, 0x0508, 0x0508,
	0x050A, 0x050A, 0x050C, 0x050C, 0x050E, 0x050E, 0x0510, 0x0510,
	0x0512, 0x0512, 0x0514, 0x0514, 0x0516, 0x0516, 0x0518, 0x0518,
	0x051A, 0x051A, 0x051C, 0x051C, 0x051E, 0x051E, 0x0520, 0x0520,
	0x0522, 0x0522, 0x0524, 0x0524, 0x0526, 0x0526, 0x0528, 0x0528,
	0x052A, 0x052A, 0x052C, 0x052C, 0x052E, 0x052E, 0x0531, 0x0556,
	0x10A0, 0x10C5, 0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x13A0, 0x13F5,
	0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x1E00, 0x1E00, 0x1E02, 0x1E02,
	0x1E04, 0x1E04, 0x1E06, 0x1E06, 0x1E08, 0x1E08, 0x1E0A, 0x1E0A,
	0x1E0C, 0x1E0C, 0x1E0E, 0x1E0E, 0x1E10, 0x1E10, 0x1E12, 0x1E12,
	0x1E14, 0x1E14, 0x1E16, 0x1E16, 0x1E18, 0x1E18, 0x1E1A, 0x1E1A,
	0x1E1C, 0x1E1C, 0x1E1E, 0x1E1E, 0x1E20, 0x1E20, 0x1E22, 0x1E22,
	0x1E24, 0x1E24, 0x1E26, 0x1E26, 0x1E28, 0x1E28, 0x1E2A, 0x1E2A,
	0x1E2C, 0x1E2C, 0x1E2E, 0x1E2E, 0x1E30, 0x1E30, 0x1E32, 0x1E32,
	0x1E34, 0x1E34, 0x1E36, 0x1E36, 0x1E38, 0x1E38, 0x1E3A, 0x1E3A,
	0x1E3C, 0x1E3C, 0x1E3E, 0x1E3E, 0x1E40, 0x1E40, 0x1E42, 0x1E42,
	0x1E44, 0x1E44, 0x1E46, 0x1E46, 0x1E48, 0x1E48, 0x1E4A, 0x1E4A,
	0x1E4C, 0x1E4C, 0x1E4E, 0x1E4E, 0x1E50, 0x1E50, 0x1E52, 0x1E52,
	0x1E54, 0x1E54, 0x1E56, 0x1E56, 0x1E58, 0x1E58, 0x1E5A, 0x1E5A,
	0x1E5C, 0x1E5C, 0x1E5E, 0x1E5E, 0x1E60, 0x1E60, 0x1E62, 0x1E62,
	0x1E64, 0x1E64, 0x1E66, 0x1E66, 0x1E68, 0x1E68, 0x1E6A, 0x1E6A,
	0x1E6C, 0x1E6C, 0x1E6E, 0x1E6E, 0x1E70, 0x1E70, 0x1E72, 0x1E72,
	0x1E74, 0x1E74, 0x1E76, 0x1E76, 0x1E78, 0x1E78, 0x1E7A, 0x1E7A,
	0x1E7C, 0x1E7C, 0x1E7E, 0x1E7E, 0x1E80, 0x1E80, 0x1E82, 0x1E82,
	0x1E84, 0x1E84, 0x1E86, 0x1E86, 0x1E88, 0x1E88, 0x1E8A, 0x1E8A,
	0x1E8C, 0x1E8C, 0x1E8E, 0x1E8E, 0x1E90, 0x1E90, 0x1E92, 0x1E92,
	0x1E94, 0x1E94, 0x1E9E, 0x1E9E, 0x1EA0, 0x1EA0, 0x1EA2, 0x1EA2,
	0x1EA4, 0x1EA4, 0x1EA6, 0x1EA6, 0x1EA8, 0x1EA8, 0x1EAA, 0x1EAA,
	0x1EAC, 0x1EAC, 0x1EAE, 0x1EAE, 0x1EB0, 0x1EB0, 0x1EB2, 0x1EB2,
	0x1EB4, 0x1EB4, 0x1EB6, 0x1EB6, 0x1EB8, 0x1EB8, 0x1EBA, 0x1EBA,
	0x1EBC, 0x1EBC, 0x1EBE, 0x1EBE, 0x1EC0, 0x1EC0, 0x1EC2, 0x1EC2,
	0x1EC4, 0x1EC4, 0x1EC6, 0x1EC6, 0x1EC8, 0x1EC8, 0x1ECA, 0x1ECA,
	0x1ECC, 0x1ECC, 0x1ECE, 0x1ECE, 0x1ED0, 0x1ED0, 0x1ED2, 0x1ED2,
	0x1ED4, 0x1ED4, 0x1ED6, 0x1ED6, 0x1ED8, 0x1ED8, 0x1EDA, 0x1EDA,
	0x1EDC, 0x1EDC, 0x1EDE, 0x1EDE, 0x1EE0, 0x1EE0, 0x1EE2, 0x1EE2,
	0x1EE4, 0x1EE4, 0x1EE6, 0x1EE6, 0x1EE8, 0x1EE8, 0x1EEA, 0x1EEA,
	0x1EEC, 0x1EEC, 0x1EEE, 0x1EEE, 0x1EF0, 0x1EF0, 0x1EF2, 0x1EF2,
	0x1EF4, 0x1EF4, 0x1EF6, 0x1EF6, 0x1EF8, 0x1EF8, 0x1EFA, 0x1EFA,
	0x1EFC, 0x1EFC, 0x1EFE, 0x1EFE, 0x1F08, 0x1F0F, 0x1F18, 0x1F1D,
	0x1F28, 0x1F2F, 0x1F38, 0x1F3F, 0x1F48, 0x1F4D, 0x1F59, 0x1F59,
	0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F5F, 0x1F68, 0x1F6F,
	0x1FB8, 0x1FBB, 0x1FC8, 0x1FCB, 0x1FD8, 0x1FDB, 0x1FE8, 0x1FEC,
	0x1FF8, 0x1FFB, 0x2102, 0x2102, 0x2107, 0x2107, 0x210B, 0x210D,
	0x2110, 0x2112, 0x2115, 0x2115, 0x2119, 0x211D, 0x2124, 0x2124,
	0x2126, 0x2126, 0x2128, 0x2128, 0x212A, 0x212D, 0x2130, 0x2133,
	0x213E, 0x213F, 0x2145, 0x2145, 0x2183, 0x2183, 0x2C00, 0x2C2E,
	0x2C60, 0x2C60, 0x2C62, 0x2C64, 0x2C67, 0x2C67, 0x2C69, 0x2C69,
	0x2C6B, 0x2C6B, 0x2C6D, 0x2C70, 0x2C72, 0x2C72, 0x2C75, 0x2C75,
	0x2C7E, 0x2C80, 0x2C82, 0x2C82, 0x2C84, 0x2C84, 0x2C86, 0x2C86,
	0x2C88, 0x2C88, 0x2C8A, 0x2C8A, 0x2C8C, 0x2C8C, 0x2C8E, 0x2C8E,
	0x2C90, 0x2C90, 0x2C92, 0x2C92, 0x2C94, 0x2C94, 0x2C96, 0x2C96,
	0x2C98, 0x2C98, 0x2C9A, 0x2C9A, 0x2C9C, 0x2C9C, 0x2C9E, 0x2C9E,
	0x2CA0, 0x2CA0, 0x2CA2, 0x2CA2, 0x2CA4, 0x2CA4, 0x2CA6, 0x2CA6,
	0x2CA8, 0x2CA8, 0x2CAA, 0x2CAA, 0x2CAC, 0x2CAC, 0x2CAE, 0x2CAE,
	0x2CB0, 0x2CB0, 0x2CB2, 0x2CB2, 0x2CB4, 0x2CB4, 0x2CB6, 0x2CB6,
	0x2CB8, 0x2CB8, 0x2CBA, 0x2CBA, 0x2CBC, 0x2CBC, 0x2CBE, 0x2CBE,
	0x2CC0, 0x2CC0, 0x2CC2, 0x2CC2, 0x2CC4, 0x2CC4, 0x2CC6, 0x2CC6,
	0x2CC8, 0x2CC8, 0x2CCA, 0x2CCA, 0x2CCC, 0x2CCC, 0x2CCE, 0x2CCE,
	0x2CD0, 0x2CD0, 0x2CD2, 0x2CD2, 0x2CD4, 0x2CD4, 0x2CD6, 0x2CD6,
	0x2CD8, 0x2CD8, 0x2CDA, 0x2CDA, 0x2CDC, 0x2CDC, 0x2CDE, 0x2CDE,
	0x2CE0, 0x2CE0, 0x2CE2, 0x2CE2, 0x2CEB, 0x2CEB, 0x2CED, 0x2CED,
	0x2CF2, 0x2CF2, 0xA640, 0xA640, 0xA642, 0xA642, 0xA644, 0xA644,
	0xA646, 0xA646, 0xA648, 0xA648, 0xA64A, 0xA64A, 0xA64C, 0xA64C,
	0xA64E, 0xA64E, 0xA650, 0xA650, 0xA652, 0xA652, 0xA654, 0xA654,
	0xA656, 0xA656, 0xA658, 0xA658, 0xA65A, 0xA65A, 0xA65C, 0xA65C,
	0xA65E, 0xA65E, 0xA660, 0xA660, 0xA662, 0xA662, 0xA664, 0xA664,
	0xA666, 0xA666, 0xA668, 0xA668, 0xA66A, 0xA66A, 0xA66C, 0xA66C,
	0xA680, 0xA680, 0xA682, 0xA682, 0xA684, 0xA684, 0xA686, 0xA686,
	0xA688, 0xA688, 0xA68A, 0xA68A, 0xA68C, 0xA68C, 0xA68E, 0xA68E,
	0xA690, 0xA690, 0xA692, 0xA692, 0xA694, 0xA694, 0xA696, 0xA696,
	0xA698, 0xA698, 0xA69A, 0xA69A, 0xA722, 0xA722, 0xA724, 0xA724,
	0xA726, 0xA726, 0xA728, 0xA728, 0xA72A, 0xA72A, 0xA72C, 0xA72C,
	0xA72E, 0xA72E, 0xA732, 0xA732, 0xA734, 0xA734, 0xA736, 0xA736,
	0xA738, 0xA738, 0xA73A, 0xA73A, 0xA73C, 0xA73C, 0xA73E, 0xA73E,
	0xA740, 0xA740, 0xA742, 0xA742, 0xA744, 0xA744, 0xA746, 0xA746,
	0xA748, 0xA748, 0xA74A, 0xA74A, 0xA74C, 0xA74C, 0xA74E, 0xA74E,
	0xA750, 0xA750, 0xA752, 0xA752, 0xA754, 0xA754, 0xA756, 0xA756,
	0xA758, 0xA758, 0xA75A, 0xA75A, 0xA75C, 0xA75C, 0xA75E, 0xA75E,
	0xA760, 0xA760, 0xA762, 0xA762, 0xA764, 0xA764, 0xA766, 0xA766,
	0xA768, 0xA768, 0xA76A, 0xA76A, 0xA76C, 0xA76C, 0xA76E, 0xA76E,
	0xA779, 0xA779, 0xA77B, 0xA77B, 0xA77D, 0xA77E, 0xA780, 0xA780,
	0xA782, 0xA782, 0xA784, 0xA784, 0xA786, 0xA786, 0xA78B, 0xA78B,
	0xA78D, 0xA78D, 0xA790, 0xA790, 0xA792, 0xA792, 0xA796, 0xA796,
	0xA798, 0xA798, 0xA79A, 0xA79A, 0xA79C, 0xA79C, 0xA79E, 0xA79E,
	0xA7A0, 0xA7A0, 0xA7A2, 0xA7A2, 0xA7A4, 0xA7A4, 0xA7A6, 0xA7A6,
	0xA7A8, 0xA7A8, 0xA7AA, 0xA7AE, 0xA7B0, 0xA7B4, 0xA7B6, 0xA7B6,
	0xA7B8, 0xA7B8, 0xA7BA, 0xA7BA, 0xA7BC, 0xA7BC, 0xA7BE, 0xA7BE,
	0xA7C2, 0xA7C2, 0xA7C4, 0xA7C6, 0xFF21, 0xFF3A, 0x10400, 0x10427,
	0x104B0, 0x104D3, 0x10C80, 0x10CB2, 0x118A0, 0x118BF, 0x16E40, 0x16E5F,
	0x1D400, 0x1D419, 0x1D434, 0x1D44D, 0x1D468, 0x1D481, 0x1D49C, 0x1D49C,
	0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC,
	0x1D4AE, 0x1D4B5, 0x1D4D0, 0x1D4E9, 0x1D504, 0x1D505, 0x1D507, 0x1D50A,
	0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D538, 0x1D539, 0x1D53B, 0x1D53E,
	0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550, 0x1D56C, 0x1D585,
	0x1D5A0, 0x1D5B9, 0x1D5D4, 0x1D5ED, 0x1D608, 0x1D621, 0x1D63C, 0x1D655,
	0x1D670, 0x1D689, 0x1D6A8, 0x1D6C0, 0x1D6E2, 0x1D6FA, 0x1D71C, 0x1D734,
	0x1D756, 0x1D76E, 0x1D790, 0x1D7A8, 0x1D7CA, 0x1D7CA, 0x1E900, 0x1E921,
	//  #12 (1980+60): gc=Modifier_Letter:Lm
	0x02B0, 0x02C1, 0x02C6, 0x02D1, 0x02E0, 0x02E4, 0x02EC, 0x02EC,
	0x02EE, 0x02EE, 0x0374, 0x0374, 0x037A, 0x037A, 0x0559, 0x0559,
	0x0640, 0x0640, 0x06E5, 0x06E6, 0x07F4, 0x07F5, 0x07FA, 0x07FA,
	0x081A, 0x081A, 0x0824, 0x0824, 0x0828, 0x0828, 0x0971, 0x0971,
	0x0E46, 0x0E46, 0x0EC6, 0x0EC6, 0x10FC, 0x10FC, 0x17D7, 0x17D7,
	0x1843, 0x1843, 0x1AA7, 0x1AA7, 0x1C78, 0x1C7D, 0x1D2C, 0x1D6A,
	0x1D78, 0x1D78, 0x1D9B, 0x1DBF, 0x2071, 0x2071, 0x207F, 0x207F,
	0x2090, 0x209C, 0x2C7C, 0x2C7D, 0x2D6F, 0x2D6F, 0x2E2F, 0x2E2F,
	0x3005, 0x3005, 0x3031, 0x3035, 0x303B, 0x303B, 0x309D, 0x309E,
	0x30FC, 0x30FE, 0xA015, 0xA015, 0xA4F8, 0xA4FD, 0xA60C, 0xA60C,
	0xA67F, 0xA67F, 0xA69C, 0xA69D, 0xA717, 0xA71F, 0xA770, 0xA770,
	0xA788, 0xA788, 0xA7F8, 0xA7F9, 0xA9CF, 0xA9CF, 0xA9E6, 0xA9E6,
	0xAA70, 0xAA70, 0xAADD, 0xAADD, 0xAAF3, 0xAAF4, 0xAB5C, 0xAB5F,
	0xFF70, 0xFF70, 0xFF9E, 0xFF9F, 0x16B40, 0x16B43, 0x16F93, 0x16F9F,
	0x16FE0, 0x16FE1, 0x16FE3, 0x16FE3, 0x1E137, 0x1E13D, 0x1E94B, 0x1E94B,
	//  #13 (2040+476): gc=Other_Letter:Lo
	0x00AA, 0x00AA, 0x00BA, 0x00BA, 0x01BB, 0x01BB, 0x01C0, 0x01C3,
	0x0294, 0x0294, 0x05D0, 0x05EA, 0x05EF, 0x05F2, 0x0620, 0x063F,
	0x0641, 0x064A, 0x066E, 0x066F, 0x0671, 0x06D3, 0x06D5, 0x06D5,
	0x06EE, 0x06EF, 0x06FA, 0x06FC, 0x06FF, 0x06FF, 0x0710, 0x0710,
	0x0712, 0x072F, 0x074D, 0x07A5, 0x07B1, 0x07B1, 0x07CA, 0x07EA,
	0x0800, 0x0815, 0x0840, 0x0858, 0x0860, 0x086A, 0x08A0, 0x08B4,
	0x08B6, 0x08BD, 0x0904, 0x0939, 0x093D, 0x093D, 0x0950, 0x0950,
	0x0958, 0x0961, 0x0972, 0x0980, 0x0985, 0x098C, 0x098F, 0x0990,
	0x0993, 0x09A8, 0x09AA, 0x09B0, 0x09B2, 0x09B2, 0x09B6, 0x09B9,
	0x09BD, 0x09BD, 0x09CE, 0x09CE, 0x09DC, 0x09DD, 0x09DF, 0x09E1,
	0x09F0, 0x09F1, 0x09FC, 0x09FC, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10,
	0x0A13, 0x0A28, 0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36,
	0x0A38, 0x0A39, 0x0A59, 0x0A5C, 0x0A5E, 0x0A5E, 0x0A72, 0x0A74,
	0x0A85, 0x0A8D, 0x0A8F, 0x0A91, 0x0A93, 0x0AA8, 0x0AAA, 0x0AB0,
	0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9, 0x0ABD, 0x0ABD, 0x0AD0, 0x0AD0,
	0x0AE0, 0x0AE1, 0x0AF9, 0x0AF9, 0x0B05, 0x0B0C, 0x0B0F, 0x0B10,
	0x0B13, 0x0B28, 0x0B2A, 0x0B30, 0x0B32, 0x0B33, 0x0B35, 0x0B39,
	0x0B3D, 0x0B3D, 0x0B5C, 0x0B5D, 0x0B5F, 0x0B61, 0x0B71, 0x0B71,
	0x0B83, 0x0B83, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90, 0x0B92, 0x0B95,
	0x0B99, 0x0B9A, 0x0B9C, 0x0B9C, 0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4,
	0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9, 0x0BD0, 0x0BD0, 0x0C05, 0x0C0C,
	0x0C0E, 0x0C10, 0x0C12, 0x0C28, 0x0C2A, 0x0C39, 0x0C3D, 0x0C3D,
	0x0C58, 0x0C5A, 0x0C60, 0x0C61, 0x0C80, 0x0C80, 0x0C85, 0x0C8C,
	0x0C8E, 0x0C90, 0x0C92, 0x0CA8, 0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9,
	0x0CBD, 0x0CBD, 0x0CDE, 0x0CDE, 0x0CE0, 0x0CE1, 0x0CF1, 0x0CF2,
	0x0D05, 0x0D0C, 0x0D0E, 0x0D10, 0x0D12, 0x0D3A, 0x0D3D, 0x0D3D,
	0x0D4E, 0x0D4E, 0x0D54, 0x0D56, 0x0D5F, 0x0D61, 0x0D7A, 0x0D7F,
	0x0D85, 0x0D96, 0x0D9A, 0x0DB1, 0x0DB3, 0x0DBB, 0x0DBD, 0x0DBD,
	0x0DC0, 0x0DC6, 0x0E01, 0x0E30, 0x0E32, 0x0E33, 0x0E40, 0x0E45,
	0x0E81, 0x0E82, 0x0E84, 0x0E84, 0x0E86, 0x0E8A, 0x0E8C, 0x0EA3,
	0x0EA5, 0x0EA5, 0x0EA7, 0x0EB0, 0x0EB2, 0x0EB3, 0x0EBD, 0x0EBD,
	0x0EC0, 0x0EC4, 0x0EDC, 0x0EDF, 0x0F00, 0x0F00, 0x0F40, 0x0F47,
	0x0F49, 0x0F6C, 0x0F88, 0x0F8C, 0x1000, 0x102A, 0x103F, 0x103F,
	0x1050, 0x1055, 0x105A, 0x105D, 0x1061, 0x1061, 0x1065, 0x1066,
	0x106E, 0x1070, 0x1075, 0x1081, 0x108E, 0x108E, 0x1100, 0x1248,
	0x124A, 0x124D, 0x1250, 0x1256, 0x1258, 0x1258, 0x125A, 0x125D,
	0x1260, 0x1288, 0x128A, 0x128D, 0x1290, 0x12B0, 0x12B2, 0x12B5,
	0x12B8, 0x12BE, 0x12C0, 0x12C0, 0x12C2, 0x12C5, 0x12C8, 0x12D6,
	0x12D8, 0x1310, 0x1312, 0x1315, 0x1318, 0x135A, 0x1380, 0x138F,
	0x1401, 0x166C, 0x166F, 0x167F, 0x1681, 0x169A, 0x16A0, 0x16EA,
	0x16F1, 0x16F8, 0x1700, 0x170C, 0x170E, 0x1711, 0x1720, 0x1731,
	0x1740, 0x1751, 0x1760, 0x176C, 0x176E, 0x1770, 0x1780, 0x17B3,
	0x17DC, 0x17DC, 0x1820, 0x1842, 0x1844, 0x1878, 0x1880, 0x1884,
	0x1887, 0x18A8, 0x18AA, 0x18AA, 0x18B0, 0x18F5, 0x1900, 0x191E,
	0x1950, 0x196D, 0x1970, 0x1974, 0x1980, 0x19AB, 0x19B0, 0x19C9,
	0x1A00, 0x1A16, 0x1A20, 0x1A54, 0x1B05, 0x1B33, 0x1B45, 0x1B4B,
	0x1B83, 0x1BA0, 0x1BAE, 0x1BAF, 0x1BBA, 0x1BE5, 0x1C00, 0x1C23,
	0x1C4D, 0x1C4F, 0x1C5A, 0x1C77, 0x1CE9, 0x1CEC, 0x1CEE, 0x1CF3,
	0x1CF5, 0x1CF6, 0x1CFA, 0x1CFA, 0x2135, 0x2138, 0x2D30, 0x2D67,
	0x2D80, 0x2D96, 0x2DA0, 0x2DA6, 0x2DA8, 0x2DAE, 0x2DB0, 0x2DB6,
	0x2DB8, 0x2DBE, 0x2DC0, 0x2DC6, 0x2DC8, 0x2DCE, 0x2DD0, 0x2DD6,
	0x2DD8, 0x2DDE, 0x3006, 0x3006, 0x303C, 0x303C, 0x3041, 0x3096,
	0x309F, 0x309F, 0x30A1, 0x30FA, 0x30FF, 0x30FF, 0x3105, 0x312F,
	0x3131, 0x318E, 0x31A0, 0x31BA, 0x31F0, 0x31FF, 0x3400, 0x4DB5,
	0x4E00, 0x9FEF, 0xA000, 0xA014, 0xA016, 0xA48C, 0xA4D0, 0xA4F7,
	0xA500, 0xA60B, 0xA610, 0xA61F, 0xA62A, 0xA62B, 0xA66E, 0xA66E,
	0xA6A0, 0xA6E5, 0xA78F, 0xA78F, 0xA7F7, 0xA7F7, 0xA7FB, 0xA801,
	0xA803, 0xA805, 0xA807, 0xA80A, 0xA80C, 0xA822, 0xA840, 0xA873,
	0xA882, 0xA8B3, 0xA8F2, 0xA8F7, 0xA8FB, 0xA8FB, 0xA8FD, 0xA8FE,
	0xA90A, 0xA925, 0xA930, 0xA946, 0xA960, 0xA97C, 0xA984, 0xA9B2,
	0xA9E0, 0xA9E4, 0xA9E7, 0xA9EF, 0xA9FA, 0xA9FE, 0xAA00, 0xAA28,
	0xAA40, 0xAA42, 0xAA44, 0xAA4B, 0xAA60, 0xAA6F, 0xAA71, 0xAA76,
	0xAA7A, 0xAA7A, 0xAA7E, 0xAAAF, 0xAAB1, 0xAAB1, 0xAAB5, 0xAAB6,
	0xAAB9, 0xAABD, 0xAAC0, 0xAAC0, 0xAAC2, 0xAAC2, 0xAADB, 0xAADC,
	0xAAE0, 0xAAEA, 0xAAF2, 0xAAF2, 0xAB01, 0xAB06, 0xAB09, 0xAB0E,
	0xAB11, 0xAB16, 0xAB20, 0xAB26, 0xAB28, 0xAB2E, 0xABC0, 0xABE2,
	0xAC00, 0xD7A3, 0xD7B0, 0xD7C6, 0xD7CB, 0xD7FB, 0xF900, 0xFA6D,
	0xFA70, 0xFAD9, 0xFB1D, 0xFB1D, 0xFB1F, 0xFB28, 0xFB2A, 0xFB36,
	0xFB38, 0xFB3C, 0xFB3E, 0xFB3E, 0xFB40, 0xFB41, 0xFB43, 0xFB44,
	0xFB46, 0xFBB1, 0xFBD3, 0xFD3D, 0xFD50, 0xFD8F, 0xFD92, 0xFDC7,
	0xFDF0, 0xFDFB, 0xFE70, 0xFE74, 0xFE76, 0xFEFC, 0xFF66, 0xFF6F,
	0xFF71, 0xFF9D, 0xFFA0, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF,
	0xFFD2, 0xFFD7, 0xFFDA, 0xFFDC, 0x10000, 0x1000B, 0x1000D, 0x10026,
	0x10028, 0x1003A, 0x1003C, 0x1003D, 0x1003F, 0x1004D, 0x10050, 0x1005D,
	0x10080, 0x100FA, 0x10280, 0x1029C, 0x102A0, 0x102D0, 0x10300, 0x1031F,
	0x1032D, 0x10340, 0x10342, 0x10349, 0x10350, 0x10375, 0x10380, 0x1039D,
	0x103A0, 0x103C3, 0x103C8, 0x103CF, 0x10450, 0x1049D, 0x10500, 0x10527,
	0x10530, 0x10563, 0x10600, 0x10736, 0x10740, 0x10755, 0x10760, 0x10767,
	0x10800, 0x10805, 0x10808, 0x10808, 0x1080A, 0x10835, 0x10837, 0x10838,
	0x1083C, 0x1083C, 0x1083F, 0x10855, 0x10860, 0x10876, 0x10880, 0x1089E,
	0x108E0, 0x108F2, 0x108F4, 0x108F5, 0x10900, 0x10915, 0x10920, 0x10939,
	0x10980, 0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A00, 0x10A10, 0x10A13,
	0x10A15, 0x10A17, 0x10A19, 0x10A35, 0x10A60, 0x10A7C, 0x10A80, 0x10A9C,
	0x10AC0, 0x10AC7, 0x10AC9, 0x10AE4, 0x10B00, 0x10B35, 0x10B40, 0x10B55,
	0x10B60, 0x10B72, 0x10B80, 0x10B91, 0x10C00, 0x10C48, 0x10D00, 0x10D23,
	0x10F00, 0x10F1C, 0x10F27, 0x10F27, 0x10F30, 0x10F45, 0x10FE0, 0x10FF6,
	0x11003, 0x11037, 0x11083, 0x110AF, 0x110D0, 0x110E8, 0x11103, 0x11126,
	0x11144, 0x11144, 0x11150, 0x11172, 0x11176, 0x11176, 0x11183, 0x111B2,
	0x111C1, 0x111C4, 0x111DA, 0x111DA, 0x111DC, 0x111DC, 0x11200, 0x11211,
	0x11213, 0x1122B, 0x11280, 0x11286, 0x11288, 0x11288, 0x1128A, 0x1128D,
	0x1128F, 0x1129D, 0x1129F, 0x112A8, 0x112B0, 0x112DE, 0x11305, 0x1130C,
	0x1130F, 0x11310, 0x11313, 0x11328, 0x1132A, 0x11330, 0x11332, 0x11333,
	0x11335, 0x11339, 0x1133D, 0x1133D, 0x11350, 0x11350, 0x1135D, 0x11361,
	0x11400, 0x11434, 0x11447, 0x1144A, 0x1145F, 0x1145F, 0x11480, 0x114AF,
	0x114C4, 0x114C5, 0x114C7, 0x114C7, 0x11580, 0x115AE, 0x115D8, 0x115DB,
	0x11600, 0x1162F, 0x11644, 0x11644, 0x11680, 0x116AA, 0x116B8, 0x116B8,
	0x11700, 0x1171A, 0x11800, 0x1182B, 0x118FF, 0x118FF, 0x119A0, 0x119A7,
	0x119AA, 0x119D0, 0x119E1, 0x119E1, 0x119E3, 0x119E3, 0x11A00, 0x11A00,
	0x11A0B, 0x11A32, 0x11A3A, 0x11A3A, 0x11A50, 0x11A50, 0x11A5C, 0x11A89,
	0x11A9D, 0x11A9D, 0x11AC0, 0x11AF8, 0x11C00, 0x11C08, 0x11C0A, 0x11C2E,
	0x11C40, 0x11C40, 0x11C72, 0x11C8F, 0x11D00, 0x11D06, 0x11D08, 0x11D09,
	0x11D0B, 0x11D30, 0x11D46, 0x11D46, 0x11D60, 0x11D65, 0x11D67, 0x11D68,
	0x11D6A, 0x11D89, 0x11D98, 0x11D98, 0x11EE0, 0x11EF2, 0x12000, 0x12399,
	0x12480, 0x12543, 0x13000, 0x1342E, 0x14400, 0x14646, 0x16800, 0x16A38,
	0x16A40, 0x16A5E, 0x16AD0, 0x16AED, 0x16B00, 0x16B2F, 0x16B63, 0x16B77,
	0x16B7D, 0x16B8F, 0x16F00, 0x16F4A, 0x16F50, 0x16F50, 0x17000, 0x187F7,
	0x18800, 0x18AF2, 0x1B000, 0x1B11E, 0x1B150, 0x1B152, 0x1B164, 0x1B167,
	0x1B170, 0x1B2FB, 0x1BC00, 0x1BC6A, 0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88,
	0x1BC90, 0x1BC99, 0x1E100, 0x1E12C, 0x1E14E, 0x1E14E, 0x1E2C0, 0x1E2EB,
	0x1E800, 0x1E8C4, 0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22,
	0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37,
	0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47,
	0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52,
	0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B,
	0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64,
	0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C,
	0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3,
	0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB, 0x20000, 0x2A6D6, 0x2A700, 0x2B734,
	0x2B740, 0x2B81D, 0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0, 0x2F800, 0x2FA1D,
	//  #14 (2516+491): gc=Mark:M:Combining_Mark
	//  Mc:168 + Me:5 + Mn:318
	//  #15 (2516+168): gc=Spacing_Mark:Mc
	0x0903, 0x0903, 0x093B, 0x093B, 0x093E, 0x0940, 0x0949, 0x094C,
	0x094E, 0x094F, 0x0982, 0x0983, 0x09BE, 0x09C0, 0x09C7, 0x09C8,
	0x09CB, 0x09CC, 0x09D7, 0x09D7, 0x0A03, 0x0A03, 0x0A3E, 0x0A40,
	0x0A83, 0x0A83, 0x0ABE, 0x0AC0, 0x0AC9, 0x0AC9, 0x0ACB, 0x0ACC,
	0x0B02, 0x0B03, 0x0B3E, 0x0B3E, 0x0B40, 0x0B40, 0x0B47, 0x0B48,
	0x0B4B, 0x0B4C, 0x0B57, 0x0B57, 0x0BBE, 0x0BBF, 0x0BC1, 0x0BC2,
	0x0BC6, 0x0BC8, 0x0BCA, 0x0BCC, 0x0BD7, 0x0BD7, 0x0C01, 0x0C03,
	0x0C41, 0x0C44, 0x0C82, 0x0C83, 0x0CBE, 0x0CBE, 0x0CC0, 0x0CC4,
	0x0CC7, 0x0CC8, 0x0CCA, 0x0CCB, 0x0CD5, 0x0CD6, 0x0D02, 0x0D03,
	0x0D3E, 0x0D40, 0x0D46, 0x0D48, 0x0D4A, 0x0D4C, 0x0D57, 0x0D57,
	0x0D82, 0x0D83, 0x0DCF, 0x0DD1, 0x0DD8, 0x0DDF, 0x0DF2, 0x0DF3,
	0x0F3E, 0x0F3F, 0x0F7F, 0x0F7F, 0x102B, 0x102C, 0x1031, 0x1031,
	0x1038, 0x1038, 0x103B, 0x103C, 0x1056, 0x1057, 0x1062, 0x1064,
	0x1067, 0x106D, 0x1083, 0x1084, 0x1087, 0x108C, 0x108F, 0x108F,
	0x109A, 0x109C, 0x17B6, 0x17B6, 0x17BE, 0x17C5, 0x17C7, 0x17C8,
	0x1923, 0x1926, 0x1929, 0x192B, 0x1930, 0x1931, 0x1933, 0x1938,
	0x1A19, 0x1A1A, 0x1A55, 0x1A55, 0x1A57, 0x1A57, 0x1A61, 0x1A61,
	0x1A63, 0x1A64, 0x1A6D, 0x1A72, 0x1B04, 0x1B04, 0x1B35, 0x1B35,
	0x1B3B, 0x1B3B, 0x1B3D, 0x1B41, 0x1B43, 0x1B44, 0x1B82, 0x1B82,
	0x1BA1, 0x1BA1, 0x1BA6, 0x1BA7, 0x1BAA, 0x1BAA, 0x1BE7, 0x1BE7,
	0x1BEA, 0x1BEC, 0x1BEE, 0x1BEE, 0x1BF2, 0x1BF3, 0x1C24, 0x1C2B,
	0x1C34, 0x1C35, 0x1CE1, 0x1CE1, 0x1CF7, 0x1CF7, 0x302E, 0x302F,
	0xA823, 0xA824, 0xA827, 0xA827, 0xA880, 0xA881, 0xA8B4, 0xA8C3,
	0xA952, 0xA953, 0xA983, 0xA983, 0xA9B4, 0xA9B5, 0xA9BA, 0xA9BB,
	0xA9BE, 0xA9C0, 0xAA2F, 0xAA30, 0xAA33, 0xAA34, 0xAA4D, 0xAA4D,
	0xAA7B, 0xAA7B, 0xAA7D, 0xAA7D, 0xAAEB, 0xAAEB, 0xAAEE, 0xAAEF,
	0xAAF5, 0xAAF5, 0xABE3, 0xABE4, 0xABE6, 0xABE7, 0xABE9, 0xABEA,
	0xABEC, 0xABEC, 0x11000, 0x11000, 0x11002, 0x11002, 0x11082, 0x11082,
	0x110B0, 0x110B2, 0x110B7, 0x110B8, 0x1112C, 0x1112C, 0x11145, 0x11146,
	0x11182, 0x11182, 0x111B3, 0x111B5, 0x111BF, 0x111C0, 0x1122C, 0x1122E,
	0x11232, 0x11233, 0x11235, 0x11235, 0x112E0, 0x112E2, 0x11302, 0x11303,
	0x1133E, 0x1133F, 0x11341, 0x11344, 0x11347, 0x11348, 0x1134B, 0x1134D,
	0x11357, 0x11357, 0x11362, 0x11363, 0x11435, 0x11437, 0x11440, 0x11441,
	0x11445, 0x11445, 0x114B0, 0x114B2, 0x114B9, 0x114B9, 0x114BB, 0x114BE,
	0x114C1, 0x114C1, 0x115AF, 0x115B1, 0x115B8, 0x115BB, 0x115BE, 0x115BE,
	0x11630, 0x11632, 0x1163B, 0x1163C, 0x1163E, 0x1163E, 0x116AC, 0x116AC,
	0x116AE, 0x116AF, 0x116B6, 0x116B6, 0x11720, 0x11721, 0x11726, 0x11726,
	0x1182C, 0x1182E, 0x11838, 0x11838, 0x119D1, 0x119D3, 0x119DC, 0x119DF,
	0x119E4, 0x119E4, 0x11A39, 0x11A39, 0x11A57, 0x11A58, 0x11A97, 0x11A97,
	0x11C2F, 0x11C2F, 0x11C3E, 0x11C3E, 0x11CA9, 0x11CA9, 0x11CB1, 0x11CB1,
	0x11CB4, 0x11CB4, 0x11D8A, 0x11D8E, 0x11D93, 0x11D94, 0x11D96, 0x11D96,
	0x11EF5, 0x11EF6, 0x16F51, 0x16F87, 0x1D165, 0x1D166, 0x1D16D, 0x1D172,
	//  #16 (2684+5): gc=Enclosing_Mark:Me
	0x0488, 0x0489, 0x1ABE, 0x1ABE, 0x20DD, 0x20E0, 0x20E2, 0x20E4,
	0xA670, 0xA672,
	//  #17 (2689+318): gc=Nonspacing_Mark:Mn
	0x0300, 0x036F, 0x0483, 0x0487, 0x0591, 0x05BD, 0x05BF, 0x05BF,
	0x05C1, 0x05C2, 0x05C4, 0x05C5, 0x05C7, 0x05C7, 0x0610, 0x061A,
	0x064B, 0x065F, 0x0670, 0x0670, 0x06D6, 0x06DC, 0x06DF, 0x06E4,
	0x06E7, 0x06E8, 0x06EA, 0x06ED, 0x0711, 0x0711, 0x0730, 0x074A,
	0x07A6, 0x07B0, 0x07EB, 0x07F3, 0x07FD, 0x07FD, 0x0816, 0x0819,
	0x081B, 0x0823, 0x0825, 0x0827, 0x0829, 0x082D, 0x0859, 0x085B,
	0x08D3, 0x08E1, 0x08E3, 0x0902, 0x093A, 0x093A, 0x093C, 0x093C,
	0x0941, 0x0948, 0x094D, 0x094D, 0x0951, 0x0957, 0x0962, 0x0963,
	0x0981, 0x0981, 0x09BC, 0x09BC, 0x09C1, 0x09C4, 0x09CD, 0x09CD,
	0x09E2, 0x09E3, 0x09FE, 0x09FE, 0x0A01, 0x0A02, 0x0A3C, 0x0A3C,
	0x0A41, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4D, 0x0A51, 0x0A51,
	0x0A70, 0x0A71, 0x0A75, 0x0A75, 0x0A81, 0x0A82, 0x0ABC, 0x0ABC,
	0x0AC1, 0x0AC5, 0x0AC7, 0x0AC8, 0x0ACD, 0x0ACD, 0x0AE2, 0x0AE3,
	0x0AFA, 0x0AFF, 0x0B01, 0x0B01, 0x0B3C, 0x0B3C, 0x0B3F, 0x0B3F,
	0x0B41, 0x0B44, 0x0B4D, 0x0B4D, 0x0B56, 0x0B56, 0x0B62, 0x0B63,
	0x0B82, 0x0B82, 0x0BC0, 0x0BC0, 0x0BCD, 0x0BCD, 0x0C00, 0x0C00,
	0x0C04, 0x0C04, 0x0C3E, 0x0C40, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D,
	0x0C55, 0x0C56, 0x0C62, 0x0C63, 0x0C81, 0x0C81, 0x0CBC, 0x0CBC,
	0x0CBF, 0x0CBF, 0x0CC6, 0x0CC6, 0x0CCC, 0x0CCD, 0x0CE2, 0x0CE3,
	0x0D00, 0x0D01, 0x0D3B, 0x0D3C, 0x0D41, 0x0D44, 0x0D4D, 0x0D4D,
	0x0D62, 0x0D63, 0x0DCA, 0x0DCA, 0x0DD2, 0x0DD4, 0x0DD6, 0x0DD6,
	0x0E31, 0x0E31, 0x0E34, 0x0E3A, 0x0E47, 0x0E4E, 0x0EB1, 0x0EB1,
	0x0EB4, 0x0EBC, 0x0EC8, 0x0ECD, 0x0F18, 0x0F19, 0x0F35, 0x0F35,
	0x0F37, 0x0F37, 0x0F39, 0x0F39, 0x0F71, 0x0F7E, 0x0F80, 0x0F84,
	0x0F86, 0x0F87, 0x0F8D, 0x0F97, 0x0F99, 0x0FBC, 0x0FC6, 0x0FC6,
	0x102D, 0x1030, 0x1032, 0x1037, 0x1039, 0x103A, 0x103D, 0x103E,
	0x1058, 0x1059, 0x105E, 0x1060, 0x1071, 0x1074, 0x1082, 0x1082,
	0x1085, 0x1086, 0x108D, 0x108D, 0x109D, 0x109D, 0x135D, 0x135F,
	0x1712, 0x1714, 0x1732, 0x1734, 0x1752, 0x1753, 0x1772, 0x1773,
	0x17B4, 0x17B5, 0x17B7, 0x17BD, 0x17C6, 0x17C6, 0x17C9, 0x17D3,
	0x17DD, 0x17DD, 0x180B, 0x180D, 0x1885, 0x1886, 0x18A9, 0x18A9,
	0x1920, 0x1922, 0x1927, 0x1928, 0x1932, 0x1932, 0x1939, 0x193B,
	0x1A17, 0x1A18, 0x1A1B, 0x1A1B, 0x1A56, 0x1A56, 0x1A58, 0x1A5E,
	0x1A60, 0x1A60, 0x1A62, 0x1A62, 0x1A65, 0x1A6C, 0x1A73, 0x1A7C,
	0x1A7F, 0x1A7F, 0x1AB0, 0x1ABD, 0x1B00, 0x1B03, 0x1B34, 0x1B34,
	0x1B36, 0x1B3A, 0x1B3C, 0x1B3C, 0x1B42, 0x1B42, 0x1B6B, 0x1B73,
	0x1B80, 0x1B81, 0x1BA2, 0x1BA5, 0x1BA8, 0x1BA9, 0x1BAB, 0x1BAD,
	0x1BE6, 0x1BE6, 0x1BE8, 0x1BE9, 0x1BED, 0x1BED, 0x1BEF, 0x1BF1,
	0x1C2C, 0x1C33, 0x1C36, 0x1C37, 0x1CD0, 0x1CD2, 0x1CD4, 0x1CE0,
	0x1CE2, 0x1CE8, 0x1CED, 0x1CED, 0x1CF4, 0x1CF4, 0x1CF8, 0x1CF9,
	0x1DC0, 0x1DF9, 0x1DFB, 0x1DFF, 0x20D0, 0x20DC, 0x20E1, 0x20E1,
	0x20E5, 0x20F0, 0x2CEF, 0x2CF1, 0x2D7F, 0x2D7F, 0x2DE0, 0x2DFF,
	0x302A, 0x302D, 0x3099, 0x309A, 0xA66F, 0xA66F, 0xA674, 0xA67D,
	0xA69E, 0xA69F, 0xA6F0, 0xA6F1, 0xA802, 0xA802, 0xA806, 0xA806,
	0xA80B, 0xA80B, 0xA825, 0xA826, 0xA8C4, 0xA8C5, 0xA8E0, 0xA8F1,
	0xA8FF, 0xA8FF, 0xA926, 0xA92D, 0xA947, 0xA951, 0xA980, 0xA982,
	0xA9B3, 0xA9B3, 0xA9B6, 0xA9B9, 0xA9BC, 0xA9BD, 0xA9E5, 0xA9E5,
	0xAA29, 0xAA2E, 0xAA31, 0xAA32, 0xAA35, 0xAA36, 0xAA43, 0xAA43,
	0xAA4C, 0xAA4C, 0xAA7C, 0xAA7C, 0xAAB0, 0xAAB0, 0xAAB2, 0xAAB4,
	0xAAB7, 0xAAB8, 0xAABE, 0xAABF, 0xAAC1, 0xAAC1, 0xAAEC, 0xAAED,
	0xAAF6, 0xAAF6, 0xABE5, 0xABE5, 0xABE8, 0xABE8, 0xABED, 0xABED,
	0xFB1E, 0xFB1E, 0xFE00, 0xFE0F, 0xFE20, 0xFE2F, 0x101FD, 0x101FD,
	0x102E0, 0x102E0, 0x10376, 0x1037A, 0x10A01, 0x10A03, 0x10A05, 0x10A06,
	0x10A0C, 0x10A0F, 0x10A38, 0x10A3A, 0x10A3F, 0x10A3F, 0x10AE5, 0x10AE6,
	0x10D24, 0x10D27, 0x10F46, 0x10F50, 0x11001, 0x11001, 0x11038, 0x11046,
	0x1107F, 0x11081, 0x110B3, 0x110B6, 0x110B9, 0x110BA, 0x11100, 0x11102,
	0x11127, 0x1112B, 0x1112D, 0x11134, 0x11173, 0x11173, 0x11180, 0x11181,
	0x111B6, 0x111BE, 0x111C9, 0x111CC, 0x1122F, 0x11231, 0x11234, 0x11234,
	0x11236, 0x11237, 0x1123E, 0x1123E, 0x112DF, 0x112DF, 0x112E3, 0x112EA,
	0x11300, 0x11301, 0x1133B, 0x1133C, 0x11340, 0x11340, 0x11366, 0x1136C,
	0x11370, 0x11374, 0x11438, 0x1143F, 0x11442, 0x11444, 0x11446, 0x11446,
	0x1145E, 0x1145E, 0x114B3, 0x114B8, 0x114BA, 0x114BA, 0x114BF, 0x114C0,
	0x114C2, 0x114C3, 0x115B2, 0x115B5, 0x115BC, 0x115BD, 0x115BF, 0x115C0,
	0x115DC, 0x115DD, 0x11633, 0x1163A, 0x1163D, 0x1163D, 0x1163F, 0x11640,
	0x116AB, 0x116AB, 0x116AD, 0x116AD, 0x116B0, 0x116B5, 0x116B7, 0x116B7,
	0x1171D, 0x1171F, 0x11722, 0x11725, 0x11727, 0x1172B, 0x1182F, 0x11837,
	0x11839, 0x1183A, 0x119D4, 0x119D7, 0x119DA, 0x119DB, 0x119E0, 0x119E0,
	0x11A01, 0x11A0A, 0x11A33, 0x11A38, 0x11A3B, 0x11A3E, 0x11A47, 0x11A47,
	0x11A51, 0x11A56, 0x11A59, 0x11A5B, 0x11A8A, 0x11A96, 0x11A98, 0x11A99,
	0x11C30, 0x11C36, 0x11C38, 0x11C3D, 0x11C3F, 0x11C3F, 0x11C92, 0x11CA7,
	0x11CAA, 0x11CB0, 0x11CB2, 0x11CB3, 0x11CB5, 0x11CB6, 0x11D31, 0x11D36,
	0x11D3A, 0x11D3A, 0x11D3C, 0x11D3D, 0x11D3F, 0x11D45, 0x11D47, 0x11D47,
	0x11D90, 0x11D91, 0x11D95, 0x11D95, 0x11D97, 0x11D97, 0x11EF3, 0x11EF4,
	0x16AF0, 0x16AF4, 0x16B30, 0x16B36, 0x16F4F, 0x16F4F, 0x16F8F, 0x16F92,
	0x1BC9D, 0x1BC9E, 0x1D167, 0x1D169, 0x1D17B, 0x1D182, 0x1D185, 0x1D18B,
	0x1D1AA, 0x1D1AD, 0x1D242, 0x1D244, 0x1DA00, 0x1DA36, 0x1DA3B, 0x1DA6C,
	0x1DA75, 0x1DA75, 0x1DA84, 0x1DA84, 0x1DA9B, 0x1DA9F, 0x1DAA1, 0x1DAAF,
	0x1E000, 0x1E006, 0x1E008, 0x1E018, 0x1E01B, 0x1E021, 0x1E023, 0x1E024,
	0x1E026, 0x1E02A, 0x1E130, 0x1E136, 0x1E2EC, 0x1E2EF, 0x1E8D0, 0x1E8D6,
	0x1E944, 0x1E94A, 0xE0100, 0xE01EF,
	//  #18 (3007+141): gc=Number:N
	//  Nd:59 + Nl:12 + No:70
	//  #19 (3007+59): gc=Decimal_Number:Nd:digit
	0x0030, 0x0039, 0x0660, 0x0669, 0x06F0, 0x06F9, 0x07C0, 0x07C9,
	0x0966, 0x096F, 0x09E6, 0x09EF, 0x0A66, 0x0A6F, 0x0AE6, 0x0AEF,
	0x0B66, 0x0B6F, 0x0BE6, 0x0BEF, 0x0C66, 0x0C6F, 0x0CE6, 0x0CEF,
	0x0D66, 0x0D6F, 0x0DE6, 0x0DEF, 0x0E50, 0x0E59, 0x0ED0, 0x0ED9,
	0x0F20, 0x0F29, 0x1040, 0x1049, 0x1090, 0x1099, 0x17E0, 0x17E9,
	0x1810, 0x1819, 0x1946, 0x194F, 0x19D0, 0x19D9, 0x1A80, 0x1A89,
	0x1A90, 0x1A99, 0x1B50, 0x1B59, 0x1BB0, 0x1BB9, 0x1C40, 0x1C49,
	0x1C50, 0x1C59, 0xA620, 0xA629, 0xA8D0, 0xA8D9, 0xA900, 0xA909,
	0xA9D0, 0xA9D9, 0xA9F0, 0xA9F9, 0xAA50, 0xAA59, 0xABF0, 0xABF9,
	0xFF10, 0xFF19, 0x104A0, 0x104A9, 0x10D30, 0x10D39, 0x11066, 0x1106F,
	0x110F0, 0x110F9, 0x11136, 0x1113F, 0x111D0, 0x111D9, 0x112F0, 0x112F9,
	0x11450, 0x11459, 0x114D0, 0x114D9, 0x11650, 0x11659, 0x116C0, 0x116C9,
	0x11730, 0x11739, 0x118E0, 0x118E9, 0x11C50, 0x11C59, 0x11D50, 0x11D59,
	0x11DA0, 0x11DA9, 0x16A60, 0x16A69, 0x16B50, 0x16B59, 0x1D7CE, 0x1D7FF,
	0x1E140, 0x1E149, 0x1E2F0, 0x1E2F9, 0x1E950, 0x1E959,
	//  #20 (3066+12): gc=Letter_Number:Nl
	0x16EE, 0x16F0, 0x2160, 0x2182, 0x2185, 0x2188, 0x3007, 0x3007,
	0x3021, 0x3029, 0x3038, 0x303A, 0xA6E6, 0xA6EF, 0x10140, 0x10174,
	0x10341, 0x10341, 0x1034A, 0x1034A, 0x103D1, 0x103D5, 0x12400, 0x1246E,
	//  #21 (3078+70): gc=Other_Number:No
	0x00B2, 0x00B3, 0x00B9, 0x00B9, 0x00BC, 0x00BE, 0x09F4, 0x09F9,
	0x0B72, 0x0B77, 0x0BF0, 0x0BF2, 0x0C78, 0x0C7E, 0x0D58, 0x0D5E,
	0x0D70, 0x0D78, 0x0F2A, 0x0F33, 0x1369, 0x137C, 0x17F0, 0x17F9,
	0x19DA, 0x19DA, 0x2070, 0x2070, 0x2074, 0x2079, 0x2080, 0x2089,
	0x2150, 0x215F, 0x2189, 0x2189, 0x2460, 0x249B, 0x24EA, 0x24FF,
	0x2776, 0x2793, 0x2CFD, 0x2CFD, 0x3192, 0x3195, 0x3220, 0x3229,
	0x3248, 0x324F, 0x3251, 0x325F, 0x3280, 0x3289, 0x32B1, 0x32BF,
	0xA830, 0xA835, 0x10107, 0x10133, 0x10175, 0x10178, 0x1018A, 0x1018B,
	0x102E1, 0x102FB, 0x10320, 0x10323, 0x10858, 0x1085F, 0x10879, 0x1087F,
	0x108A7, 0x108AF, 0x108FB, 0x108FF, 0x10916, 0x1091B, 0x109BC, 0x109BD,
	0x109C0, 0x109CF, 0x109D2, 0x109FF, 0x10A40, 0x10A48, 0x10A7D, 0x10A7E,
	0x10A9D, 0x10A9F, 0x10AEB, 0x10AEF, 0x10B58, 0x10B5F, 0x10B78, 0x10B7F,
	0x10BA9, 0x10BAF, 0x10CFA, 0x10CFF, 0x10E60, 0x10E7E, 0x10F1D, 0x10F26,
	0x10F51, 0x10F54, 0x11052, 0x11065, 0x111E1, 0x111F4, 0x1173A, 0x1173B,
	0x118EA, 0x118F2, 0x11C5A, 0x11C6C, 0x11FC0, 0x11FD4, 0x16B5B, 0x16B61,
	0x16E80, 0x16E96, 0x1D2E0, 0x1D2F3, 0x1D360, 0x1D378, 0x1E8C7, 0x1E8CF,
	0x1EC71, 0x1ECAB, 0x1ECAD, 0x1ECAF, 0x1ECB1, 0x1ECB4, 0x1ED01, 0x1ED2D,
	0x1ED2F, 0x1ED3D, 0x1F100, 0x1F10C,
	//  #22 (3148+370): gc=Punctuation:P:punct
	//  Pc:6 + Pd:17 + Pe:72 + Pf:10 + Pi:11 + Po:179 + Ps:75
	//  #23 (3148+6): gc=Connector_Punctuation:Pc
	0x005F, 0x005F, 0x203F, 0x2040, 0x2054, 0x2054, 0xFE33, 0xFE34,
	0xFE4D, 0xFE4F, 0xFF3F, 0xFF3F,
	//  #24 (3154+17): gc=Dash_Punctuation:Pd
	0x002D, 0x002D, 0x058A, 0x058A, 0x05BE, 0x05BE, 0x1400, 0x1400,
	0x1806, 0x1806, 0x2010, 0x2015, 0x2E17, 0x2E17, 0x2E1A, 0x2E1A,
	0x2E3A, 0x2E3B, 0x2E40, 0x2E40, 0x301C, 0x301C, 0x3030, 0x3030,
	0x30A0, 0x30A0, 0xFE31, 0xFE32, 0xFE58, 0xFE58, 0xFE63, 0xFE63,
	0xFF0D, 0xFF0D,
	//  #25 (3171+72): gc=Close_Punctuation:Pe
	0x0029, 0x0029, 0x005D, 0x005D, 0x007D, 0x007D, 0x0F3B, 0x0F3B,
	0x0F3D, 0x0F3D, 0x169C, 0x169C, 0x2046, 0x2046, 0x207E, 0x207E,
	0x208E, 0x208E, 0x2309, 0x2309, 0x230B, 0x230B, 0x232A, 0x232A,
	0x2769, 0x2769, 0x276B, 0x276B, 0x276D, 0x276D, 0x276F, 0x276F,
	0x2771, 0x2771, 0x2773, 0x2773, 0x2775, 0x2775, 0x27C6, 0x27C6,
	0x27E7, 0x27E7, 0x27E9, 0x27E9, 0x27EB, 0x27EB, 0x27ED, 0x27ED,
	0x27EF, 0x27EF, 0x2984, 0x2984, 0x2986, 0x2986, 0x2988, 0x2988,
	0x298A, 0x298A, 0x298C, 0x298C, 0x298E, 0x298E, 0x2990, 0x2990,
	0x2992, 0x2992, 0x2994, 0x2994, 0x2996, 0x2996, 0x2998, 0x2998,
	0x29D9, 0x29D9, 0x29DB, 0x29DB, 0x29FD, 0x29FD, 0x2E23, 0x2E23,
	0x2E25, 0x2E25, 0x2E27, 0x2E27, 0x2E29, 0x2E29, 0x3009, 0x3009,
	0x300B, 0x300B, 0x300D, 0x300D, 0x300F, 0x300F, 0x3011, 0x3011,
	0x3015, 0x3015, 0x3017, 0x3017, 0x3019, 0x3019, 0x301B, 0x301B,
	0x301E, 0x301F, 0xFD3E, 0xFD3E, 0xFE18, 0xFE18, 0xFE36, 0xFE36,
	0xFE38, 0xFE38, 0xFE3A, 0xFE3A, 0xFE3C, 0xFE3C, 0xFE3E, 0xFE3E,
	0xFE40, 0xFE40, 0xFE42, 0xFE42, 0xFE44, 0xFE44, 0xFE48, 0xFE48,
	0xFE5A, 0xFE5A, 0xFE5C, 0xFE5C, 0xFE5E, 0xFE5E, 0xFF09, 0xFF09,
	0xFF3D, 0xFF3D, 0xFF5D, 0xFF5D, 0xFF60, 0xFF60, 0xFF63, 0xFF63,
	//  #26 (3243+10): gc=Final_Punctuation:Pf
	0x00BB, 0x00BB, 0x2019, 0x2019, 0x201D, 0x201D, 0x203A, 0x203A,
	0x2E03, 0x2E03, 0x2E05, 0x2E05, 0x2E0A, 0x2E0A, 0x2E0D, 0x2E0D,
	0x2E1D, 0x2E1D, 0x2E21, 0x2E21,
	//  #27 (3253+11): gc=Initial_Punctuation:Pi
	0x00AB, 0x00AB, 0x2018, 0x2018, 0x201B, 0x201C, 0x201F, 0x201F,
	0x2039, 0x2039, 0x2E02, 0x2E02, 0x2E04, 0x2E04, 0x2E09, 0x2E09,
	0x2E0C, 0x2E0C, 0x2E1C, 0x2E1C, 0x2E20, 0x2E20,
	//  #28 (3264+179): gc=Other_Punctuation:Po
	0x0021, 0x0023, 0x0025, 0x0027, 0x002A, 0x002A, 0x002C, 0x002C,
	0x002E, 0x002F, 0x003A, 0x003B, 0x003F, 0x0040, 0x005C, 0x005C,
	0x00A1, 0x00A1, 0x00A7, 0x00A7, 0x00B6, 0x00B7, 0x00BF, 0x00BF,
	0x037E, 0x037E, 0x0387, 0x0387, 0x055A, 0x055F, 0x0589, 0x0589,
	0x05C0, 0x05C0, 0x05C3, 0x05C3, 0x05C6, 0x05C6, 0x05F3, 0x05F4,
	0x0609, 0x060A, 0x060C, 0x060D, 0x061B, 0x061B, 0x061E, 0x061F,
	0x066A, 0x066D, 0x06D4, 0x06D4, 0x0700, 0x070D, 0x07F7, 0x07F9,
	0x0830, 0x083E, 0x085E, 0x085E, 0x0964, 0x0965, 0x0970, 0x0970,
	0x09FD, 0x09FD, 0x0A76, 0x0A76, 0x0AF0, 0x0AF0, 0x0C77, 0x0C77,
	0x0C84, 0x0C84, 0x0DF4, 0x0DF4, 0x0E4F, 0x0E4F, 0x0E5A, 0x0E5B,
	0x0F04, 0x0F12, 0x0F14, 0x0F14, 0x0F85, 0x0F85, 0x0FD0, 0x0FD4,
	0x0FD9, 0x0FDA, 0x104A, 0x104F, 0x10FB, 0x10FB, 0x1360, 0x1368,
	0x166E, 0x166E, 0x16EB, 0x16ED, 0x1735, 0x1736, 0x17D4, 0x17D6,
	0x17D8, 0x17DA, 0x1800, 0x1805, 0x1807, 0x180A, 0x1944, 0x1945,
	0x1A1E, 0x1A1F, 0x1AA0, 0x1AA6, 0x1AA8, 0x1AAD, 0x1B5A, 0x1B60,
	0x1BFC, 0x1BFF, 0x1C3B, 0x1C3F, 0x1C7E, 0x1C7F, 0x1CC0, 0x1CC7,
	0x1CD3, 0x1CD3, 0x2016, 0x2017, 0x2020, 0x2027, 0x2030, 0x2038,
	0x203B, 0x203E, 0x2041, 0x2043, 0x2047, 0x2051, 0x2053, 0x2053,
	0x2055, 0x205E, 0x2CF9, 0x2CFC, 0x2CFE, 0x2CFF, 0x2D70, 0x2D70,
	0x2E00, 0x2E01, 0x2E06, 0x2E08, 0x2E0B, 0x2E0B, 0x2E0E, 0x2E16,
	0x2E18, 0x2E19, 0x2E1B, 0x2E1B, 0x2E1E, 0x2E1F, 0x2E2A, 0x2E2E,
	0x2E30, 0x2E39, 0x2E3C, 0x2E3F, 0x2E41, 0x2E41, 0x2E43, 0x2E4F,
	0x3001, 0x3003, 0x303D, 0x303D, 0x30FB, 0x30FB, 0xA4FE, 0xA4FF,
	0xA60D, 0xA60F, 0xA673, 0xA673, 0xA67E, 0xA67E, 0xA6F2, 0xA6F7,
	0xA874, 0xA877, 0xA8CE, 0xA8CF, 0xA8F8, 0xA8FA, 0xA8FC, 0xA8FC,
	0xA92E, 0xA92F, 0xA95F, 0xA95F, 0xA9C1, 0xA9CD, 0xA9DE, 0xA9DF,
	0xAA5C, 0xAA5F, 0xAADE, 0xAADF, 0xAAF0, 0xAAF1, 0xABEB, 0xABEB,
	0xFE10, 0xFE16, 0xFE19, 0xFE19, 0xFE30, 0xFE30, 0xFE45, 0xFE46,
	0xFE49, 0xFE4C, 0xFE50, 0xFE52, 0xFE54, 0xFE57, 0xFE5F, 0xFE61,
	0xFE68, 0xFE68, 0xFE6A, 0xFE6B, 0xFF01, 0xFF03, 0xFF05, 0xFF07,
	0xFF0A, 0xFF0A, 0xFF0C, 0xFF0C, 0xFF0E, 0xFF0F, 0xFF1A, 0xFF1B,
	0xFF1F, 0xFF20, 0xFF3C, 0xFF3C, 0xFF61, 0xFF61, 0xFF64, 0xFF65,
	0x10100, 0x10102, 0x1039F, 0x1039F, 0x103D0, 0x103D0, 0x1056F, 0x1056F,
	0x10857, 0x10857, 0x1091F, 0x1091F, 0x1093F, 0x1093F, 0x10A50, 0x10A58,
	0x10A7F, 0x10A7F, 0x10AF0, 0x10AF6, 0x10B39, 0x10B3F, 0x10B99, 0x10B9C,
	0x10F55, 0x10F59, 0x11047, 0x1104D, 0x110BB, 0x110BC, 0x110BE, 0x110C1,
	0x11140, 0x11143, 0x11174, 0x11175, 0x111C5, 0x111C8, 0x111CD, 0x111CD,
	0x111DB, 0x111DB, 0x111DD, 0x111DF, 0x11238, 0x1123D, 0x112A9, 0x112A9,
	0x1144B, 0x1144F, 0x1145B, 0x1145B, 0x1145D, 0x1145D, 0x114C6, 0x114C6,
	0x115C1, 0x115D7, 0x11641, 0x11643, 0x11660, 0x1166C, 0x1173C, 0x1173E,
	0x1183B, 0x1183B, 0x119E2, 0x119E2, 0x11A3F, 0x11A46, 0x11A9A, 0x11A9C,
	0x11A9E, 0x11AA2, 0x11C41, 0x11C45, 0x11C70, 0x11C71, 0x11EF7, 0x11EF8,
	0x11FFF, 0x11FFF, 0x12470, 0x12474, 0x16A6E, 0x16A6F, 0x16AF5, 0x16AF5,
	0x16B37, 0x16B3B, 0x16B44, 0x16B44, 0x16E97, 0x16E9A, 0x16FE2, 0x16FE2,
	0x1BC9F, 0x1BC9F, 0x1DA87, 0x1DA8B, 0x1E95E, 0x1E95F,
	//  #29 (3443+75): gc=Open_Punctuation:Ps
	0x0028, 0x0028, 0x005B, 0x005B, 0x007B, 0x007B, 0x0F3A, 0x0F3A,
	0x0F3C, 0x0F3C, 0x169B, 0x169B, 0x201A, 0x201A, 0x201E, 0x201E,
	0x2045, 0x2045, 0x207D, 0x207D, 0x208D, 0x208D, 0x2308, 0x2308,
	0x230A, 0x230A, 0x2329, 0x2329, 0x2768, 0x2768, 0x276A, 0x276A,
	0x276C, 0x276C, 0x276E, 0x276E, 0x2770, 0x2770, 0x2772, 0x2772,
	0x2774, 0x2774, 0x27C5, 0x27C5, 0x27E6, 0x27E6, 0x27E8, 0x27E8,
	0x27EA, 0x27EA, 0x27EC, 0x27EC, 0x27EE, 0x27EE, 0x2983, 0x2983,
	0x2985, 0x2985, 0x2987, 0x2987, 0x2989, 0x2989, 0x298B, 0x298B,
	0x298D, 0x298D, 0x298F, 0x298F, 0x2991, 0x2991, 0x2993, 0x2993,
	0x2995, 0x2995, 0x2997, 0x2997, 0x29D8, 0x29D8, 0x29DA, 0x29DA,
	0x29FC, 0x29FC, 0x2E22, 0x2E22, 0x2E24, 0x2E24, 0x2E26, 0x2E26,
	0x2E28, 0x2E28, 0x2E42, 0x2E42, 0x3008, 0x3008, 0x300A, 0x300A,
	0x300C, 0x300C, 0x300E, 0x300E, 0x3010, 0x3010, 0x3014, 0x3014,
	0x3016, 0x3016, 0x3018, 0x3018, 0x301A, 0x301A, 0x301D, 0x301D,
	0xFD3F, 0xFD3F, 0xFE17, 0xFE17, 0xFE35, 0xFE35, 0xFE37, 0xFE37,
	0xFE39, 0xFE39, 0xFE3B, 0xFE3B, 0xFE3D, 0xFE3D, 0xFE3F, 0xFE3F,
	0xFE41, 0xFE41, 0xFE43, 0xFE43, 0xFE47, 0xFE47, 0xFE59, 0xFE59,
	0xFE5B, 0xFE5B, 0xFE5D, 0xFE5D, 0xFF08, 0xFF08, 0xFF3B, 0xFF3B,
	0xFF5B, 0xFF5B, 0xFF5F, 0xFF5F, 0xFF62, 0xFF62,
	//  #30 (3518+294): gc=Symbol:S
	//  Sc:21 + Sk:29 + Sm:64 + So:180
	//  #31 (3518+21): gc=Currency_Symbol:Sc
	0x0024, 0x0024, 0x00A2, 0x00A5, 0x058F, 0x058F, 0x060B, 0x060B,
	0x07FE, 0x07FF, 0x09F2, 0x09F3, 0x09FB, 0x09FB, 0x0AF1, 0x0AF1,
	0x0BF9, 0x0BF9, 0x0E3F, 0x0E3F, 0x17DB, 0x17DB, 0x20A0, 0x20BF,
	0xA838, 0xA838, 0xFDFC, 0xFDFC, 0xFE69, 0xFE69, 0xFF04, 0xFF04,
	0xFFE0, 0xFFE1, 0xFFE5, 0xFFE6, 0x11FDD, 0x11FE0, 0x1E2FF, 0x1E2FF,
	0x1ECB0, 0x1ECB0,
	//  #32 (3539+29): gc=Modifier_Symbol:Sk
	0x005E, 0x005E, 0x0060, 0x0060, 0x00A8, 0x00A8, 0x00AF, 0x00AF,
	0x00B4, 0x00B4, 0x00B8, 0x00B8, 0x02C2, 0x02C5, 0x02D2, 0x02DF,
	0x02E5, 0x02EB, 0x02ED, 0x02ED, 0x02EF, 0x02FF, 0x0375, 0x0375,
	0x0384, 0x0385, 0x1FBD, 0x1FBD, 0x1FBF, 0x1FC1, 0x1FCD, 0x1FCF,
	0x1FDD, 0x1FDF, 0x1FED, 0x1FEF, 0x1FFD, 0x1FFE, 0x309B, 0x309C,
	0xA700, 0xA716, 0xA720, 0xA721, 0xA789, 0xA78A, 0xAB5B, 0xAB5B,
	0xFBB2, 0xFBC1, 0xFF3E, 0xFF3E, 0xFF40, 0xFF40, 0xFFE3, 0xFFE3,
	0x1F3FB, 0x1F3FF,
	//  #33 (3568+64): gc=Math_Symbol:Sm
	0x002B, 0x002B, 0x003C, 0x003E, 0x007C, 0x007C, 0x007E, 0x007E,
	0x00AC, 0x00AC, 0x00B1, 0x00B1, 0x00D7, 0x00D7, 0x00F7, 0x00F7,
	0x03F6, 0x03F6, 0x0606, 0x0608, 0x2044, 0x2044, 0x2052, 0x2052,
	0x207A, 0x207C, 0x208A, 0x208C, 0x2118, 0x2118, 0x2140, 0x2144,
	0x214B, 0x214B, 0x2190, 0x2194, 0x219A, 0x219B, 0x21A0, 0x21A0,
	0x21A3, 0x21A3, 0x21A6, 0x21A6, 0x21AE, 0x21AE, 0x21CE, 0x21CF,
	0x21D2, 0x21D2, 0x21D4, 0x21D4, 0x21F4, 0x22FF, 0x2320, 0x2321,
	0x237C, 0x237C, 0x239B, 0x23B3, 0x23DC, 0x23E1, 0x25B7, 0x25B7,
	0x25C1, 0x25C1, 0x25F8, 0x25FF, 0x266F, 0x266F, 0x27C0, 0x27C4,
	0x27C7, 0x27E5, 0x27F0, 0x27FF, 0x2900, 0x2982, 0x2999, 0x29D7,
	0x29DC, 0x29FB, 0x29FE, 0x2AFF, 0x2B30, 0x2B44, 0x2B47, 0x2B4C,
	0xFB29, 0xFB29, 0xFE62, 0xFE62, 0xFE64, 0xFE66, 0xFF0B, 0xFF0B,
	0xFF1C, 0xFF1E, 0xFF5C, 0xFF5C, 0xFF5E, 0xFF5E, 0xFFE2, 0xFFE2,
	0xFFE9, 0xFFEC, 0x1D6C1, 0x1D6C1, 0x1D6DB, 0x1D6DB, 0x1D6FB, 0x1D6FB,
	0x1D715, 0x1D715, 0x1D735, 0x1D735, 0x1D74F, 0x1D74F, 0x1D76F, 0x1D76F,
	0x1D789, 0x1D789, 0x1D7A9, 0x1D7A9, 0x1D7C3, 0x1D7C3, 0x1EEF0, 0x1EEF1,
	//  #34 (3632+180): gc=Other_Symbol:So
	0x00A6, 0x00A6, 0x00A9, 0x00A9, 0x00AE, 0x00AE, 0x00B0, 0x00B0,
	0x0482, 0x0482, 0x058D, 0x058E, 0x060E, 0x060F, 0x06DE, 0x06DE,
	0x06E9, 0x06E9, 0x06FD, 0x06FE, 0x07F6, 0x07F6, 0x09FA, 0x09FA,
	0x0B70, 0x0B70, 0x0BF3, 0x0BF8, 0x0BFA, 0x0BFA, 0x0C7F, 0x0C7F,
	0x0D4F, 0x0D4F, 0x0D79, 0x0D79, 0x0F01, 0x0F03, 0x0F13, 0x0F13,
	0x0F15, 0x0F17, 0x0F1A, 0x0F1F, 0x0F34, 0x0F34, 0x0F36, 0x0F36,
	0x0F38, 0x0F38, 0x0FBE, 0x0FC5, 0x0FC7, 0x0FCC, 0x0FCE, 0x0FCF,
	0x0FD5, 0x0FD8, 0x109E, 0x109F, 0x1390, 0x1399, 0x166D, 0x166D,
	0x1940, 0x1940, 0x19DE, 0x19FF, 0x1B61, 0x1B6A, 0x1B74, 0x1B7C,
	0x2100, 0x2101, 0x2103, 0x2106, 0x2108, 0x2109, 0x2114, 0x2114,
	0x2116, 0x2117, 0x211E, 0x2123, 0x2125, 0x2125, 0x2127, 0x2127,
	0x2129, 0x2129, 0x212E, 0x212E, 0x213A, 0x213B, 0x214A, 0x214A,
	0x214C, 0x214D, 0x214F, 0x214F, 0x218A, 0x218B, 0x2195, 0x2199,
	0x219C, 0x219F, 0x21A1, 0x21A2, 0x21A4, 0x21A5, 0x21A7, 0x21AD,
	0x21AF, 0x21CD, 0x21D0, 0x21D1, 0x21D3, 0x21D3, 0x21D5, 0x21F3,
	0x2300, 0x2307, 0x230C, 0x231F, 0x2322, 0x2328, 0x232B, 0x237B,
	0x237D, 0x239A, 0x23B4, 0x23DB, 0x23E2, 0x2426, 0x2440, 0x244A,
	0x249C, 0x24E9, 0x2500, 0x25B6, 0x25B8, 0x25C0, 0x25C2, 0x25F7,
	0x2600, 0x266E, 0x2670, 0x2767, 0x2794, 0x27BF, 0x2800, 0x28FF,
	0x2B00, 0x2B2F, 0x2B45, 0x2B46, 0x2B4D, 0x2B73, 0x2B76, 0x2B95,
	0x2B98, 0x2BFF, 0x2CE5, 0x2CEA, 0x2E80, 0x2E99, 0x2E9B, 0x2EF3,
	0x2F00, 0x2FD5, 0x2FF0, 0x2FFB, 0x3004, 0x3004, 0x3012, 0x3013,
	0x3020, 0x3020, 0x3036, 0x3037, 0x303E, 0x303F, 0x3190, 0x3191,
	0x3196, 0x319F, 0x31C0, 0x31E3, 0x3200, 0x321E, 0x322A, 0x3247,
	0x3250, 0x3250, 0x3260, 0x327F, 0x328A, 0x32B0, 0x32C0, 0x33FF,
	0x4DC0, 0x4DFF, 0xA490, 0xA4C6, 0xA828, 0xA82B, 0xA836, 0xA837,
	0xA839, 0xA839, 0xAA77, 0xAA79, 0xFDFD, 0xFDFD, 0xFFE4, 0xFFE4,
	0xFFE8, 0xFFE8, 0xFFED, 0xFFEE, 0xFFFC, 0xFFFD, 0x10137, 0x1013F,
	0x10179, 0x10189, 0x1018C, 0x1018E, 0x10190, 0x1019B, 0x101A0, 0x101A0,
	0x101D0, 0x101FC, 0x10877, 0x10878, 0x10AC8, 0x10AC8, 0x1173F, 0x1173F,
	0x11FD5, 0x11FDC, 0x11FE1, 0x11FF1, 0x16B3C, 0x16B3F, 0x16B45, 0x16B45,
	0x1BC9C, 0x1BC9C, 0x1D000, 0x1D0F5, 0x1D100, 0x1D126, 0x1D129, 0x1D164,
	0x1D16A, 0x1D16C, 0x1D183, 0x1D184, 0x1D18C, 0x1D1A9, 0x1D1AE, 0x1D1E8,
	0x1D200, 0x1D241, 0x1D245, 0x1D245, 0x1D300, 0x1D356, 0x1D800, 0x1D9FF,
	0x1DA37, 0x1DA3A, 0x1DA6D, 0x1DA74, 0x1DA76, 0x1DA83, 0x1DA85, 0x1DA86,
	0x1E14F, 0x1E14F, 0x1ECAC, 0x1ECAC, 0x1ED2E, 0x1ED2E, 0x1F000, 0x1F02B,
	0x1F030, 0x1F093, 0x1F0A0, 0x1F0AE, 0x1F0B1, 0x1F0BF, 0x1F0C1, 0x1F0CF,
	0x1F0D1, 0x1F0F5, 0x1F110, 0x1F16C, 0x1F170, 0x1F1AC, 0x1F1E6, 0x1F202,
	0x1F210, 0x1F23B, 0x1F240, 0x1F248, 0x1F250, 0x1F251, 0x1F260, 0x1F265,
	0x1F300, 0x1F3FA, 0x1F400, 0x1F6D5, 0x1F6E0, 0x1F6EC, 0x1F6F0, 0x1F6FA,
	0x1F700, 0x1F773, 0x1F780, 0x1F7D8, 0x1F7E0, 0x1F7EB, 0x1F800, 0x1F80B,
	0x1F810, 0x1F847, 0x1F850, 0x1F859, 0x1F860, 0x1F887, 0x1F890, 0x1F8AD,
	0x1F900, 0x1F90B, 0x1F90D, 0x1F971, 0x1F973, 0x1F976, 0x1F97A, 0x1F9A2,
	0x1F9A5, 0x1F9AA, 0x1F9AE, 0x1F9CA, 0x1F9CD, 0x1FA53, 0x1FA60, 0x1FA6D,
	0x1FA70, 0x1FA73, 0x1FA78, 0x1FA7A, 0x1FA80, 0x1FA82, 0x1FA90, 0x1FA95,
	//  #35 (3812+9): gc=Separator:Z
	//  Zl:1 + Zp:1 + Zs:7
	//  #36 (3812+1): gc=Line_Separator:Zl
	0x2028, 0x2028,
	//  #37 (3813+1): gc=Paragraph_Separator:Zp
	0x2029, 0x2029,
	//  #38 (3814+7): gc=Space_Separator:Zs
	0x0020, 0x0020, 0x00A0, 0x00A0, 0x1680, 0x1680, 0x2000, 0x200A,
	0x202F, 0x202F, 0x205F, 0x205F, 0x3000, 0x3000,
	//  #39 (3821+1): bp=ASCII
	0x0000, 0x007F,
	//  #40 (3822+3): bp=ASCII_Hex_Digit:AHex
	0x0030, 0x0039, 0x0041, 0x0046, 0x0061, 0x0066,
	//  #41 (3825+679): bp=Alphabetic:Alpha
	0x0041, 0x005A, 0x0061, 0x007A, 0x00AA, 0x00AA, 0x00B5, 0x00B5,
	0x00BA, 0x00BA, 0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x02C1,
	0x02C6, 0x02D1, 0x02E0, 0x02E4, 0x02EC, 0x02EC, 0x02EE, 0x02EE,
	0x0345, 0x0345, 0x0370, 0x0374, 0x0376, 0x0377, 0x037A, 0x037D,
	0x037F, 0x037F, 0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C,
	0x038E, 0x03A1, 0x03A3, 0x03F5, 0x03F7, 0x0481, 0x048A, 0x052F,
	0x0531, 0x0556, 0x0559, 0x0559, 0x0560, 0x0588, 0x05B0, 0x05BD,
	0x05BF, 0x05BF, 0x05C1, 0x05C2, 0x05C4, 0x05C5, 0x05C7, 0x05C7,
	0x05D0, 0x05EA, 0x05EF, 0x05F2, 0x0610, 0x061A, 0x0620, 0x0657,
	0x0659, 0x065F, 0x066E, 0x06D3, 0x06D5, 0x06DC, 0x06E1, 0x06E8,
	0x06ED, 0x06EF, 0x06FA, 0x06FC, 0x06FF, 0x06FF, 0x0710, 0x073F,
	0x074D, 0x07B1, 0x07CA, 0x07EA, 0x07F4, 0x07F5, 0x07FA, 0x07FA,
	0x0800, 0x0817, 0x081A, 0x082C, 0x0840, 0x0858, 0x0860, 0x086A,
	0x08A0, 0x08B4, 0x08B6, 0x08BD, 0x08D4, 0x08DF, 0x08E3, 0x08E9,
	0x08F0, 0x093B, 0x093D, 0x094C, 0x094E, 0x0950, 0x0955, 0x0963,
	0x0971, 0x0983, 0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8,
	0x09AA, 0x09B0, 0x09B2, 0x09B2, 0x09B6, 0x09B9, 0x09BD, 0x09C4,
	0x09C7, 0x09C8, 0x09CB, 0x09CC, 0x09CE, 0x09CE, 0x09D7, 0x09D7,
	0x09DC, 0x09DD, 0x09DF, 0x09E3, 0x09F0, 0x09F1, 0x09FC, 0x09FC,
	0x0A01, 0x0A03, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10, 0x0A13, 0x0A28,
	0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36, 0x0A38, 0x0A39,
	0x0A3E, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4C, 0x0A51, 0x0A51,
	0x0A59, 0x0A5C, 0x0A5E, 0x0A5E, 0x0A70, 0x0A75, 0x0A81, 0x0A83,
	0x0A85, 0x0A8D, 0x0A8F, 0x0A91, 0x0A93, 0x0AA8, 0x0AAA, 0x0AB0,
	0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9, 0x0ABD, 0x0AC5, 0x0AC7, 0x0AC9,
	0x0ACB, 0x0ACC, 0x0AD0, 0x0AD0, 0x0AE0, 0x0AE3, 0x0AF9, 0x0AFC,
	0x0B01, 0x0B03, 0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28,
	0x0B2A, 0x0B30, 0x0B32, 0x0B33, 0x0B35, 0x0B39, 0x0B3D, 0x0B44,
	0x0B47, 0x0B48, 0x0B4B, 0x0B4C, 0x0B56, 0x0B57, 0x0B5C, 0x0B5D,
	0x0B5F, 0x0B63, 0x0B71, 0x0B71, 0x0B82, 0x0B83, 0x0B85, 0x0B8A,
	0x0B8E, 0x0B90, 0x0B92, 0x0B95, 0x0B99, 0x0B9A, 0x0B9C, 0x0B9C,
	0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9,
	0x0BBE, 0x0BC2, 0x0BC6, 0x0BC8, 0x0BCA, 0x0BCC, 0x0BD0, 0x0BD0,
	0x0BD7, 0x0BD7, 0x0C00, 0x0C03, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10,
	0x0C12, 0x0C28, 0x0C2A, 0x0C39, 0x0C3D, 0x0C44, 0x0C46, 0x0C48,
	0x0C4A, 0x0C4C, 0x0C55, 0x0C56, 0x0C58, 0x0C5A, 0x0C60, 0x0C63,
	0x0C80, 0x0C83, 0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8,
	0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBD, 0x0CC4, 0x0CC6, 0x0CC8,
	0x0CCA, 0x0CCC, 0x0CD5, 0x0CD6, 0x0CDE, 0x0CDE, 0x0CE0, 0x0CE3,
	0x0CF1, 0x0CF2, 0x0D00, 0x0D03, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10,
	0x0D12, 0x0D3A, 0x0D3D, 0x0D44, 0x0D46, 0x0D48, 0x0D4A, 0x0D4C,
	0x0D4E, 0x0D4E, 0x0D54, 0x0D57, 0x0D5F, 0x0D63, 0x0D7A, 0x0D7F,
	0x0D82, 0x0D83, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1, 0x0DB3, 0x0DBB,
	0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0DCF, 0x0DD4, 0x0DD6, 0x0DD6,
	0x0DD8, 0x0DDF, 0x0DF2, 0x0DF3, 0x0E01, 0x0E3A, 0x0E40, 0x0E46,
	0x0E4D, 0x0E4D, 0x0E81, 0x0E82, 0x0E84, 0x0E84, 0x0E86, 0x0E8A,
	0x0E8C, 0x0EA3, 0x0EA5, 0x0EA5, 0x0EA7, 0x0EB9, 0x0EBB, 0x0EBD,
	0x0EC0, 0x0EC4, 0x0EC6, 0x0EC6, 0x0ECD, 0x0ECD, 0x0EDC, 0x0EDF,
	0x0F00, 0x0F00, 0x0F40, 0x0F47, 0x0F49, 0x0F6C, 0x0F71, 0x0F81,
	0x0F88, 0x0F97, 0x0F99, 0x0FBC, 0x1000, 0x1036, 0x1038, 0x1038,
	0x103B, 0x103F, 0x1050, 0x108F, 0x109A, 0x109D, 0x10A0, 0x10C5,
	0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x10D0, 0x10FA, 0x10FC, 0x1248,
	0x124A, 0x124D, 0x1250, 0x1256, 0x1258, 0x1258, 0x125A, 0x125D,
	0x1260, 0x1288, 0x128A, 0x128D, 0x1290, 0x12B0, 0x12B2, 0x12B5,
	0x12B8, 0x12BE, 0x12C0, 0x12C0, 0x12C2, 0x12C5, 0x12C8, 0x12D6,
	0x12D8, 0x1310, 0x1312, 0x1315, 0x1318, 0x135A, 0x1380, 0x138F,
	0x13A0, 0x13F5, 0x13F8, 0x13FD, 0x1401, 0x166C, 0x166F, 0x167F,
	0x1681, 0x169A, 0x16A0, 0x16EA, 0x16EE, 0x16F8, 0x1700, 0x170C,
	0x170E, 0x1713, 0x1720, 0x1733, 0x1740, 0x1753, 0x1760, 0x176C,
	0x176E, 0x1770, 0x1772, 0x1773, 0x1780, 0x17B3, 0x17B6, 0x17C8,
	0x17D7, 0x17D7, 0x17DC, 0x17DC, 0x1820, 0x1878, 0x1880, 0x18AA,
	0x18B0, 0x18F5, 0x1900, 0x191E, 0x1920, 0x192B, 0x1930, 0x1938,
	0x1950, 0x196D, 0x1970, 0x1974, 0x1980, 0x19AB, 0x19B0, 0x19C9,
	0x1A00, 0x1A1B, 0x1A20, 0x1A5E, 0x1A61, 0x1A74, 0x1AA7, 0x1AA7,
	0x1B00, 0x1B33, 0x1B35, 0x1B43, 0x1B45, 0x1B4B, 0x1B80, 0x1BA9,
	0x1BAC, 0x1BAF, 0x1BBA, 0x1BE5, 0x1BE7, 0x1BF1, 0x1C00, 0x1C36,
	0x1C4D, 0x1C4F, 0x1C5A, 0x1C7D, 0x1C80, 0x1C88, 0x1C90, 0x1CBA,
	0x1CBD, 0x1CBF, 0x1CE9, 0x1CEC, 0x1CEE, 0x1CF3, 0x1CF5, 0x1CF6,
	0x1CFA, 0x1CFA, 0x1D00, 0x1DBF, 0x1DE7, 0x1DF4, 0x1E00, 0x1F15,
	0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57,
	0x1F59, 0x1F59, 0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D,
	0x1F80, 0x1FB4, 0x1FB6, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4,
	0x1FC6, 0x1FCC, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC,
	0x1FF2, 0x1FF4, 0x1FF6, 0x1FFC, 0x2071, 0x2071, 0x207F, 0x207F,
	0x2090, 0x209C, 0x2102, 0x2102, 0x2107, 0x2107, 0x210A, 0x2113,
	0x2115, 0x2115, 0x2119, 0x211D, 0x2124, 0x2124, 0x2126, 0x2126,
	0x2128, 0x2128, 0x212A, 0x212D, 0x212F, 0x2139, 0x213C, 0x213F,
	0x2145, 0x2149, 0x214E, 0x214E, 0x2160, 0x2188, 0x24B6, 0x24E9,
	0x2C00, 0x2C2E, 0x2C30, 0x2C5E, 0x2C60, 0x2CE4, 0x2CEB, 0x2CEE,
	0x2CF2, 0x2CF3, 0x2D00, 0x2D25, 0x2D27, 0x2D27, 0x2D2D, 0x2D2D,
	0x2D30, 0x2D67, 0x2D6F, 0x2D6F, 0x2D80, 0x2D96, 0x2DA0, 0x2DA6,
	0x2DA8, 0x2DAE, 0x2DB0, 0x2DB6, 0x2DB8, 0x2DBE, 0x2DC0, 0x2DC6,
	0x2DC8, 0x2DCE, 0x2DD0, 0x2DD6, 0x2DD8, 0x2DDE, 0x2DE0, 0x2DFF,
	0x2E2F, 0x2E2F, 0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035,
	0x3038, 0x303C, 0x3041, 0x3096, 0x309D, 0x309F, 0x30A1, 0x30FA,
	0x30FC, 0x30FF, 0x3105, 0x312F, 0x3131, 0x318E, 0x31A0, 0x31BA,
	0x31F0, 0x31FF, 0x3400, 0x4DB5, 0x4E00, 0x9FEF, 0xA000, 0xA48C,
	0xA4D0, 0xA4FD, 0xA500, 0xA60C, 0xA610, 0xA61F, 0xA62A, 0xA62B,
	0xA640, 0xA66E, 0xA674, 0xA67B, 0xA67F, 0xA6EF, 0xA717, 0xA71F,
	0xA722, 0xA788, 0xA78B, 0xA7BF, 0xA7C2, 0xA7C6, 0xA7F7, 0xA805,
	0xA807, 0xA827, 0xA840, 0xA873, 0xA880, 0xA8C3, 0xA8C5, 0xA8C5,
	0xA8F2, 0xA8F7, 0xA8FB, 0xA8FB, 0xA8FD, 0xA8FF, 0xA90A, 0xA92A,
	0xA930, 0xA952, 0xA960, 0xA97C, 0xA980, 0xA9B2, 0xA9B4, 0xA9BF,
	0xA9CF, 0xA9CF, 0xA9E0, 0xA9EF, 0xA9FA, 0xA9FE, 0xAA00, 0xAA36,
	0xAA40, 0xAA4D, 0xAA60, 0xAA76, 0xAA7A, 0xAABE, 0xAAC0, 0xAAC0,
	0xAAC2, 0xAAC2, 0xAADB, 0xAADD, 0xAAE0, 0xAAEF, 0xAAF2, 0xAAF5,
	0xAB01, 0xAB06, 0xAB09, 0xAB0E, 0xAB11, 0xAB16, 0xAB20, 0xAB26,
	0xAB28, 0xAB2E, 0xAB30, 0xAB5A, 0xAB5C, 0xAB67, 0xAB70, 0xABEA,
	0xAC00, 0xD7A3, 0xD7B0, 0xD7C6, 0xD7CB, 0xD7FB, 0xF900, 0xFA6D,
	0xFA70, 0xFAD9, 0xFB00, 0xFB06, 0xFB13, 0xFB17, 0xFB1D, 0xFB28,
	0xFB2A, 0xFB36, 0xFB38, 0xFB3C, 0xFB3E, 0xFB3E, 0xFB40, 0xFB41,
	0xFB43, 0xFB44, 0xFB46, 0xFBB1, 0xFBD3, 0xFD3D, 0xFD50, 0xFD8F,
	0xFD92, 0xFDC7, 0xFDF0, 0xFDFB, 0xFE70, 0xFE74, 0xFE76, 0xFEFC,
	0xFF21, 0xFF3A, 0xFF41, 0xFF5A, 0xFF66, 0xFFBE, 0xFFC2, 0xFFC7,
	0xFFCA, 0xFFCF, 0xFFD2, 0xFFD7, 0xFFDA, 0xFFDC, 0x10000, 0x1000B,
	0x1000D, 0x10026, 0x10028, 0x1003A, 0x1003C, 0x1003D, 0x1003F, 0x1004D,
	0x10050, 0x1005D, 0x10080, 0x100FA, 0x10140, 0x10174, 0x10280, 0x1029C,
	0x102A0, 0x102D0, 0x10300, 0x1031F, 0x1032D, 0x1034A, 0x10350, 0x1037A,
	0x10380, 0x1039D, 0x103A0, 0x103C3, 0x103C8, 0x103CF, 0x103D1, 0x103D5,
	0x10400, 0x1049D, 0x104B0, 0x104D3, 0x104D8, 0x104FB, 0x10500, 0x10527,
	0x10530, 0x10563, 0x10600, 0x10736, 0x10740, 0x10755, 0x10760, 0x10767,
	0x10800, 0x10805, 0x10808, 0x10808, 0x1080A, 0x10835, 0x10837, 0x10838,
	0x1083C, 0x1083C, 0x1083F, 0x10855, 0x10860, 0x10876, 0x10880, 0x1089E,
	0x108E0, 0x108F2, 0x108F4, 0x108F5, 0x10900, 0x10915, 0x10920, 0x10939,
	0x10980, 0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A03, 0x10A05, 0x10A06,
	0x10A0C, 0x10A13, 0x10A15, 0x10A17, 0x10A19, 0x10A35, 0x10A60, 0x10A7C,
	0x10A80, 0x10A9C, 0x10AC0, 0x10AC7, 0x10AC9, 0x10AE4, 0x10B00, 0x10B35,
	0x10B40, 0x10B55, 0x10B60, 0x10B72, 0x10B80, 0x10B91, 0x10C00, 0x10C48,
	0x10C80, 0x10CB2, 0x10CC0, 0x10CF2, 0x10D00, 0x10D27, 0x10F00, 0x10F1C,
	0x10F27, 0x10F27, 0x10F30, 0x10F45, 0x10FE0, 0x10FF6, 0x11000, 0x11045,
	0x11082, 0x110B8, 0x110D0, 0x110E8, 0x11100, 0x11132, 0x11144, 0x11146,
	0x11150, 0x11172, 0x11176, 0x11176, 0x11180, 0x111BF, 0x111C1, 0x111C4,
	0x111DA, 0x111DA, 0x111DC, 0x111DC, 0x11200, 0x11211, 0x11213, 0x11234,
	0x11237, 0x11237, 0x1123E, 0x1123E, 0x11280, 0x11286, 0x11288, 0x11288,
	0x1128A, 0x1128D, 0x1128F, 0x1129D, 0x1129F, 0x112A8, 0x112B0, 0x112E8,
	0x11300, 0x11303, 0x11305, 0x1130C, 0x1130F, 0x11310, 0x11313, 0x11328,
	0x1132A, 0x11330, 0x11332, 0x11333, 0x11335, 0x11339, 0x1133D, 0x11344,
	0x11347, 0x11348, 0x1134B, 0x1134C, 0x11350, 0x11350, 0x11357, 0x11357,
	0x1135D, 0x11363, 0x11400, 0x11441, 0x11443, 0x11445, 0x11447, 0x1144A,
	0x1145F, 0x1145F, 0x11480, 0x114C1, 0x114C4, 0x114C5, 0x114C7, 0x114C7,
	0x11580, 0x115B5, 0x115B8, 0x115BE, 0x115D8, 0x115DD, 0x11600, 0x1163E,
	0x11640, 0x11640, 0x11644, 0x11644, 0x11680, 0x116B5, 0x116B8, 0x116B8,
	0x11700, 0x1171A, 0x1171D, 0x1172A, 0x11800, 0x11838, 0x118A0, 0x118DF,
	0x118FF, 0x118FF, 0x119A0, 0x119A7, 0x119AA, 0x119D7, 0x119DA, 0x119DF,
	0x119E1, 0x119E1, 0x119E3, 0x119E4, 0x11A00, 0x11A32, 0x11A35, 0x11A3E,
	0x11A50, 0x11A97, 0x11A9D, 0x11A9D, 0x11AC0, 0x11AF8, 0x11C00, 0x11C08,
	0x11C0A, 0x11C36, 0x11C38, 0x11C3E, 0x11C40, 0x11C40, 0x11C72, 0x11C8F,
	0x11C92, 0x11CA7, 0x11CA9, 0x11CB6, 0x11D00, 0x11D06, 0x11D08, 0x11D09,
	0x11D0B, 0x11D36, 0x11D3A, 0x11D3A, 0x11D3C, 0x11D3D, 0x11D3F, 0x11D41,
	0x11D43, 0x11D43, 0x11D46, 0x11D47, 0x11D60, 0x11D65, 0x11D67, 0x11D68,
	0x11D6A, 0x11D8E, 0x11D90, 0x11D91, 0x11D93, 0x11D96, 0x11D98, 0x11D98,
	0x11EE0, 0x11EF6, 0x12000, 0x12399, 0x12400, 0x1246E, 0x12480, 0x12543,
	0x13000, 0x1342E, 0x14400, 0x14646, 0x16800, 0x16A38, 0x16A40, 0x16A5E,
	0x16AD0, 0x16AED, 0x16B00, 0x16B2F, 0x16B40, 0x16B43, 0x16B63, 0x16B77,
	0x16B7D, 0x16B8F, 0x16E40, 0x16E7F, 0x16F00, 0x16F4A, 0x16F4F, 0x16F87,
	0x16F8F, 0x16F9F, 0x16FE0, 0x16FE1, 0x16FE3, 0x16FE3, 0x17000, 0x187F7,
	0x18800, 0x18AF2, 0x1B000, 0x1B11E, 0x1B150, 0x1B152, 0x1B164, 0x1B167,
	0x1B170, 0x1B2FB, 0x1BC00, 0x1BC6A, 0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88,
	0x1BC90, 0x1BC99, 0x1BC9E, 0x1BC9E, 0x1D400, 0x1D454, 0x1D456, 0x1D49C,
	0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC,
	0x1D4AE, 0x1D4B9, 0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505,
	0x1D507, 0x1D50A, 0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539,
	0x1D53B, 0x1D53E, 0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550,
	0x1D552, 0x1D6A5, 0x1D6A8, 0x1D6C0, 0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6FA,
	0x1D6FC, 0x1D714, 0x1D716, 0x1D734, 0x1D736, 0x1D74E, 0x1D750, 0x1D76E,
	0x1D770, 0x1D788, 0x1D78A, 0x1D7A8, 0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7CB,
	0x1E000, 0x1E006, 0x1E008, 0x1E018, 0x1E01B, 0x1E021, 0x1E023, 0x1E024,
	0x1E026, 0x1E02A, 0x1E100, 0x1E12C, 0x1E137, 0x1E13D, 0x1E14E, 0x1E14E,
	0x1E2C0, 0x1E2EB, 0x1E800, 0x1E8C4, 0x1E900, 0x1E943, 0x1E947, 0x1E947,
	0x1E94B, 0x1E94B, 0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22,
	0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37,
	0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47,
	0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52,
	0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B,
	0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64,
	0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C,
	0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3,
	0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB, 0x1F130, 0x1F149, 0x1F150, 0x1F169,
	0x1F170, 0x1F189, 0x20000, 0x2A6D6, 0x2A700, 0x2B734, 0x2B740, 0x2B81D,
	0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0, 0x2F800, 0x2FA1D,
	//  #42 (4504+1): bp=Any
	0x0000, 0x10FFFF,
	//  #43 (4505+0): bp=Assigned
	
	//  #44 (4505+4): bp=Bidi_Control:Bidi_C
	0x061C, 0x061C, 0x200E, 0x200F, 0x202A, 0x202E, 0x2066, 0x2069,
	//  #45 (4509+113): bp=Bidi_Mirrored:Bidi_M
	0x0028, 0x0029, 0x003C, 0x003C, 0x003E, 0x003E, 0x005B, 0x005B,
	0x005D, 0x005D, 0x007B, 0x007B, 0x007D, 0x007D, 0x00AB, 0x00AB,
	0x00BB, 0x00BB, 0x0F3A, 0x0F3D, 0x169B, 0x169C, 0x2039, 0x203A,
	0x2045, 0x2046, 0x207D, 0x207E, 0x208D, 0x208E, 0x2140, 0x2140,
	0x2201, 0x2204, 0x2208, 0x220D, 0x2211, 0x2211, 0x2215, 0x2216,
	0x221A, 0x221D, 0x221F, 0x2222, 0x2224, 0x2224, 0x2226, 0x2226,
	0x222B, 0x2233, 0x2239, 0x2239, 0x223B, 0x224C, 0x2252, 0x2255,
	0x225F, 0x2260, 0x2262, 0x2262, 0x2264, 0x226B, 0x226E, 0x228C,
	0x228F, 0x2292, 0x2298, 0x2298, 0x22A2, 0x22A3, 0x22A6, 0x22B8,
	0x22BE, 0x22BF, 0x22C9, 0x22CD, 0x22D0, 0x22D1, 0x22D6, 0x22ED,
	0x22F0, 0x22FF, 0x2308, 0x230B, 0x2320, 0x2321, 0x2329, 0x232A,
	0x2768, 0x2775, 0x27C0, 0x27C0, 0x27C3, 0x27C6, 0x27C8, 0x27C9,
	0x27CB, 0x27CD, 0x27D3, 0x27D6, 0x27DC, 0x27DE, 0x27E2, 0x27EF,
	0x2983, 0x2998, 0x299B, 0x29A0, 0x29A2, 0x29AF, 0x29B8, 0x29B8,
	0x29C0, 0x29C5, 0x29C9, 0x29C9, 0x29CE, 0x29D2, 0x29D4, 0x29D5,
	0x29D8, 0x29DC, 0x29E1, 0x29E1, 0x29E3, 0x29E5, 0x29E8, 0x29E9,
	0x29F4, 0x29F9, 0x29FC, 0x29FD, 0x2A0A, 0x2A1C, 0x2A1E, 0x2A21,
	0x2A24, 0x2A24, 0x2A26, 0x2A26, 0x2A29, 0x2A29, 0x2A2B, 0x2A2E,
	0x2A34, 0x2A35, 0x2A3C, 0x2A3E, 0x2A57, 0x2A58, 0x2A64, 0x2A65,
	0x2A6A, 0x2A6D, 0x2A6F, 0x2A70, 0x2A73, 0x2A74, 0x2A79, 0x2AA3,
	0x2AA6, 0x2AAD, 0x2AAF, 0x2AD6, 0x2ADC, 0x2ADC, 0x2ADE, 0x2ADE,
	0x2AE2, 0x2AE6, 0x2AEC, 0x2AEE, 0x2AF3, 0x2AF3, 0x2AF7, 0x2AFB,
	0x2AFD, 0x2AFD, 0x2BFE, 0x2BFE, 0x2E02, 0x2E05, 0x2E09, 0x2E0A,
	0x2E0C, 0x2E0D, 0x2E1C, 0x2E1D, 0x2E20, 0x2E29, 0x3008, 0x3011,
	0x3014, 0x301B, 0xFE59, 0xFE5E, 0xFE64, 0xFE65, 0xFF08, 0xFF09,
	0xFF1C, 0xFF1C, 0xFF1E, 0xFF1E, 0xFF3B, 0xFF3B, 0xFF3D, 0xFF3D,
	0xFF5B, 0xFF5B, 0xFF5D, 0xFF5D, 0xFF5F, 0xFF60, 0xFF62, 0xFF63,
	0x1D6DB, 0x1D6DB, 0x1D715, 0x1D715, 0x1D74F, 0x1D74F, 0x1D789, 0x1D789,
	0x1D7C3, 0x1D7C3,
	//  #46 (4622+401): bp=Case_Ignorable:CI
	0x0027, 0x0027, 0x002E, 0x002E, 0x003A, 0x003A, 0x005E, 0x005E,
	0x0060, 0x0060, 0x00A8, 0x00A8, 0x00AD, 0x00AD, 0x00AF, 0x00AF,
	0x00B4, 0x00B4, 0x00B7, 0x00B8, 0x02B0, 0x036F, 0x0374, 0x0375,
	0x037A, 0x037A, 0x0384, 0x0385, 0x0387, 0x0387, 0x0483, 0x0489,
	0x0559, 0x0559, 0x0591, 0x05BD, 0x05BF, 0x05BF, 0x05C1, 0x05C2,
	0x05C4, 0x05C5, 0x05C7, 0x05C7, 0x05F4, 0x05F4, 0x0600, 0x0605,
	0x0610, 0x061A, 0x061C, 0x061C, 0x0640, 0x0640, 0x064B, 0x065F,
	0x0670, 0x0670, 0x06D6, 0x06DD, 0x06DF, 0x06E8, 0x06EA, 0x06ED,
	0x070F, 0x070F, 0x0711, 0x0711, 0x0730, 0x074A, 0x07A6, 0x07B0,
	0x07EB, 0x07F5, 0x07FA, 0x07FA, 0x07FD, 0x07FD, 0x0816, 0x082D,
	0x0859, 0x085B, 0x08D3, 0x0902, 0x093A, 0x093A, 0x093C, 0x093C,
	0x0941, 0x0948, 0x094D, 0x094D, 0x0951, 0x0957, 0x0962, 0x0963,
	0x0971, 0x0971, 0x0981, 0x0981, 0x09BC, 0x09BC, 0x09C1, 0x09C4,
	0x09CD, 0x09CD, 0x09E2, 0x09E3, 0x09FE, 0x09FE, 0x0A01, 0x0A02,
	0x0A3C, 0x0A3C, 0x0A41, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4D,
	0x0A51, 0x0A51, 0x0A70, 0x0A71, 0x0A75, 0x0A75, 0x0A81, 0x0A82,
	0x0ABC, 0x0ABC, 0x0AC1, 0x0AC5, 0x0AC7, 0x0AC8, 0x0ACD, 0x0ACD,
	0x0AE2, 0x0AE3, 0x0AFA, 0x0AFF, 0x0B01, 0x0B01, 0x0B3C, 0x0B3C,
	0x0B3F, 0x0B3F, 0x0B41, 0x0B44, 0x0B4D, 0x0B4D, 0x0B56, 0x0B56,
	0x0B62, 0x0B63, 0x0B82, 0x0B82, 0x0BC0, 0x0BC0, 0x0BCD, 0x0BCD,
	0x0C00, 0x0C00, 0x0C04, 0x0C04, 0x0C3E, 0x0C40, 0x0C46, 0x0C48,
	0x0C4A, 0x0C4D, 0x0C55, 0x0C56, 0x0C62, 0x0C63, 0x0C81, 0x0C81,
	0x0CBC, 0x0CBC, 0x0CBF, 0x0CBF, 0x0CC6, 0x0CC6, 0x0CCC, 0x0CCD,
	0x0CE2, 0x0CE3, 0x0D00, 0x0D01, 0x0D3B, 0x0D3C, 0x0D41, 0x0D44,
	0x0D4D, 0x0D4D, 0x0D62, 0x0D63, 0x0DCA, 0x0DCA, 0x0DD2, 0x0DD4,
	0x0DD6, 0x0DD6, 0x0E31, 0x0E31, 0x0E34, 0x0E3A, 0x0E46, 0x0E4E,
	0x0EB1, 0x0EB1, 0x0EB4, 0x0EBC, 0x0EC6, 0x0EC6, 0x0EC8, 0x0ECD,
	0x0F18, 0x0F19, 0x0F35, 0x0F35, 0x0F37, 0x0F37, 0x0F39, 0x0F39,
	0x0F71, 0x0F7E, 0x0F80, 0x0F84, 0x0F86, 0x0F87, 0x0F8D, 0x0F97,
	0x0F99, 0x0FBC, 0x0FC6, 0x0FC6, 0x102D, 0x1030, 0x1032, 0x1037,
	0x1039, 0x103A, 0x103D, 0x103E, 0x1058, 0x1059, 0x105E, 0x1060,
	0x1071, 0x1074, 0x1082, 0x1082, 0x1085, 0x1086, 0x108D, 0x108D,
	0x109D, 0x109D, 0x10FC, 0x10FC, 0x135D, 0x135F, 0x1712, 0x1714,
	0x1732, 0x1734, 0x1752, 0x1753, 0x1772, 0x1773, 0x17B4, 0x17B5,
	0x17B7, 0x17BD, 0x17C6, 0x17C6, 0x17C9, 0x17D3, 0x17D7, 0x17D7,
	0x17DD, 0x17DD, 0x180B, 0x180E, 0x1843, 0x1843, 0x1885, 0x1886,
	0x18A9, 0x18A9, 0x1920, 0x1922, 0x1927, 0x1928, 0x1932, 0x1932,
	0x1939, 0x193B, 0x1A17, 0x1A18, 0x1A1B, 0x1A1B, 0x1A56, 0x1A56,
	0x1A58, 0x1A5E, 0x1A60, 0x1A60, 0x1A62, 0x1A62, 0x1A65, 0x1A6C,
	0x1A73, 0x1A7C, 0x1A7F, 0x1A7F, 0x1AA7, 0x1AA7, 0x1AB0, 0x1ABE,
	0x1B00, 0x1B03, 0x1B34, 0x1B34, 0x1B36, 0x1B3A, 0x1B3C, 0x1B3C,
	0x1B42, 0x1B42, 0x1B6B, 0x1B73, 0x1B80, 0x1B81, 0x1BA2, 0x1BA5,
	0x1BA8, 0x1BA9, 0x1BAB, 0x1BAD, 0x1BE6, 0x1BE6, 0x1BE8, 0x1BE9,
	0x1BED, 0x1BED, 0x1BEF, 0x1BF1, 0x1C2C, 0x1C33, 0x1C36, 0x1C37,
	0x1C78, 0x1C7D, 0x1CD0, 0x1CD2, 0x1CD4, 0x1CE0, 0x1CE2, 0x1CE8,
	0x1CED, 0x1CED, 0x1CF4, 0x1CF4, 0x1CF8, 0x1CF9, 0x1D2C, 0x1D6A,
	0x1D78, 0x1D78, 0x1D9B, 0x1DF9, 0x1DFB, 0x1DFF, 0x1FBD, 0x1FBD,
	0x1FBF, 0x1FC1, 0x1FCD, 0x1FCF, 0x1FDD, 0x1FDF, 0x1FED, 0x1FEF,
	0x1FFD, 0x1FFE, 0x200B, 0x200F, 0x2018, 0x2019, 0x2024, 0x2024,
	0x2027, 0x2027, 0x202A, 0x202E, 0x2060, 0x2064, 0x2066, 0x206F,
	0x2071, 0x2071, 0x207F, 0x207F, 0x2090, 0x209C, 0x20D0, 0x20F0,
	0x2C7C, 0x2C7D, 0x2CEF, 0x2CF1, 0x2D6F, 0x2D6F, 0x2D7F, 0x2D7F,
	0x2DE0, 0x2DFF, 0x2E2F, 0x2E2F, 0x3005, 0x3005, 0x302A, 0x302D,
	0x3031, 0x3035, 0x303B, 0x303B, 0x3099, 0x309E, 0x30FC, 0x30FE,
	0xA015, 0xA015, 0xA4F8, 0xA4FD, 0xA60C, 0xA60C, 0xA66F, 0xA672,
	0xA674, 0xA67D, 0xA67F, 0xA67F, 0xA69C, 0xA69F, 0xA6F0, 0xA6F1,
	0xA700, 0xA721, 0xA770, 0xA770, 0xA788, 0xA78A, 0xA7F8, 0xA7F9,
	0xA802, 0xA802, 0xA806, 0xA806, 0xA80B, 0xA80B, 0xA825, 0xA826,
	0xA8C4, 0xA8C5, 0xA8E0, 0xA8F1, 0xA8FF, 0xA8FF, 0xA926, 0xA92D,
	0xA947, 0xA951, 0xA980, 0xA982, 0xA9B3, 0xA9B3, 0xA9B6, 0xA9B9,
	0xA9BC, 0xA9BD, 0xA9CF, 0xA9CF, 0xA9E5, 0xA9E6, 0xAA29, 0xAA2E,
	0xAA31, 0xAA32, 0xAA35, 0xAA36, 0xAA43, 0xAA43, 0xAA4C, 0xAA4C,
	0xAA70, 0xAA70, 0xAA7C, 0xAA7C, 0xAAB0, 0xAAB0, 0xAAB2, 0xAAB4,
	0xAAB7, 0xAAB8, 0xAABE, 0xAABF, 0xAAC1, 0xAAC1, 0xAADD, 0xAADD,
	0xAAEC, 0xAAED, 0xAAF3, 0xAAF4, 0xAAF6, 0xAAF6, 0xAB5B, 0xAB5F,
	0xABE5, 0xABE5, 0xABE8, 0xABE8, 0xABED, 0xABED, 0xFB1E, 0xFB1E,
	0xFBB2, 0xFBC1, 0xFE00, 0xFE0F, 0xFE13, 0xFE13, 0xFE20, 0xFE2F,
	0xFE52, 0xFE52, 0xFE55, 0xFE55, 0xFEFF, 0xFEFF, 0xFF07, 0xFF07,
	0xFF0E, 0xFF0E, 0xFF1A, 0xFF1A, 0xFF3E, 0xFF3E, 0xFF40, 0xFF40,
	0xFF70, 0xFF70, 0xFF9E, 0xFF9F, 0xFFE3, 0xFFE3, 0xFFF9, 0xFFFB,
	0x101FD, 0x101FD, 0x102E0, 0x102E0, 0x10376, 0x1037A, 0x10A01, 0x10A03,
	0x10A05, 0x10A06, 0x10A0C, 0x10A0F, 0x10A38, 0x10A3A, 0x10A3F, 0x10A3F,
	0x10AE5, 0x10AE6, 0x10D24, 0x10D27, 0x10F46, 0x10F50, 0x11001, 0x11001,
	0x11038, 0x11046, 0x1107F, 0x11081, 0x110B3, 0x110B6, 0x110B9, 0x110BA,
	0x110BD, 0x110BD, 0x110CD, 0x110CD, 0x11100, 0x11102, 0x11127, 0x1112B,
	0x1112D, 0x11134, 0x11173, 0x11173, 0x11180, 0x11181, 0x111B6, 0x111BE,
	0x111C9, 0x111CC, 0x1122F, 0x11231, 0x11234, 0x11234, 0x11236, 0x11237,
	0x1123E, 0x1123E, 0x112DF, 0x112DF, 0x112E3, 0x112EA, 0x11300, 0x11301,
	0x1133B, 0x1133C, 0x11340, 0x11340, 0x11366, 0x1136C, 0x11370, 0x11374,
	0x11438, 0x1143F, 0x11442, 0x11444, 0x11446, 0x11446, 0x1145E, 0x1145E,
	0x114B3, 0x114B8, 0x114BA, 0x114BA, 0x114BF, 0x114C0, 0x114C2, 0x114C3,
	0x115B2, 0x115B5, 0x115BC, 0x115BD, 0x115BF, 0x115C0, 0x115DC, 0x115DD,
	0x11633, 0x1163A, 0x1163D, 0x1163D, 0x1163F, 0x11640, 0x116AB, 0x116AB,
	0x116AD, 0x116AD, 0x116B0, 0x116B5, 0x116B7, 0x116B7, 0x1171D, 0x1171F,
	0x11722, 0x11725, 0x11727, 0x1172B, 0x1182F, 0x11837, 0x11839, 0x1183A,
	0x119D4, 0x119D7, 0x119DA, 0x119DB, 0x119E0, 0x119E0, 0x11A01, 0x11A0A,
	0x11A33, 0x11A38, 0x11A3B, 0x11A3E, 0x11A47, 0x11A47, 0x11A51, 0x11A56,
	0x11A59, 0x11A5B, 0x11A8A, 0x11A96, 0x11A98, 0x11A99, 0x11C30, 0x11C36,
	0x11C38, 0x11C3D, 0x11C3F, 0x11C3F, 0x11C92, 0x11CA7, 0x11CAA, 0x11CB0,
	0x11CB2, 0x11CB3, 0x11CB5, 0x11CB6, 0x11D31, 0x11D36, 0x11D3A, 0x11D3A,
	0x11D3C, 0x11D3D, 0x11D3F, 0x11D45, 0x11D47, 0x11D47, 0x11D90, 0x11D91,
	0x11D95, 0x11D95, 0x11D97, 0x11D97, 0x11EF3, 0x11EF4, 0x13430, 0x13438,
	0x16AF0, 0x16AF4, 0x16B30, 0x16B36, 0x16B40, 0x16B43, 0x16F4F, 0x16F4F,
	0x16F8F, 0x16F9F, 0x16FE0, 0x16FE1, 0x16FE3, 0x16FE3, 0x1BC9D, 0x1BC9E,
	0x1BCA0, 0x1BCA3, 0x1D167, 0x1D169, 0x1D173, 0x1D182, 0x1D185, 0x1D18B,
	0x1D1AA, 0x1D1AD, 0x1D242, 0x1D244, 0x1DA00, 0x1DA36, 0x1DA3B, 0x1DA6C,
	0x1DA75, 0x1DA75, 0x1DA84, 0x1DA84, 0x1DA9B, 0x1DA9F, 0x1DAA1, 0x1DAAF,
	0x1E000, 0x1E006, 0x1E008, 0x1E018, 0x1E01B, 0x1E021, 0x1E023, 0x1E024,
	0x1E026, 0x1E02A, 0x1E130, 0x1E13D, 0x1E2EC, 0x1E2EF, 0x1E8D0, 0x1E8D6,
	0x1E944, 0x1E94B, 0x1F3FB, 0x1F3FF, 0xE0001, 0xE0001, 0xE0020, 0xE007F,
	0xE0100, 0xE01EF,
	//  #47 (5023+140): bp=Cased
	0x0041, 0x005A, 0x0061, 0x007A, 0x00AA, 0x00AA, 0x00B5, 0x00B5,
	0x00BA, 0x00BA, 0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x01BA,
	0x01BC, 0x01BF, 0x01C4, 0x0293, 0x0295, 0x02B8, 0x02C0, 0x02C1,
	0x02E0, 0x02E4, 0x0345, 0x0345, 0x0370, 0x0373, 0x0376, 0x0377,
	0x037A, 0x037D, 0x037F, 0x037F, 0x0386, 0x0386, 0x0388, 0x038A,
	0x038C, 0x038C, 0x038E, 0x03A1, 0x03A3, 0x03F5, 0x03F7, 0x0481,
	0x048A, 0x052F, 0x0531, 0x0556, 0x0560, 0x0588, 0x10A0, 0x10C5,
	0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x10D0, 0x10FA, 0x10FD, 0x10FF,
	0x13A0, 0x13F5, 0x13F8, 0x13FD, 0x1C80, 0x1C88, 0x1C90, 0x1CBA,
	0x1CBD, 0x1CBF, 0x1D00, 0x1DBF, 0x1E00, 0x1F15, 0x1F18, 0x1F1D,
	0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57, 0x1F59, 0x1F59,
	0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4,
	0x1FB6, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC,
	0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4,
	0x1FF6, 0x1FFC, 0x2071, 0x2071, 0x207F, 0x207F, 0x2090, 0x209C,
	0x2102, 0x2102, 0x2107, 0x2107, 0x210A, 0x2113, 0x2115, 0x2115,
	0x2119, 0x211D, 0x2124, 0x2124, 0x2126, 0x2126, 0x2128, 0x2128,
	0x212A, 0x212D, 0x212F, 0x2134, 0x2139, 0x2139, 0x213C, 0x213F,
	0x2145, 0x2149, 0x214E, 0x214E, 0x2160, 0x217F, 0x2183, 0x2184,
	0x24B6, 0x24E9, 0x2C00, 0x2C2E, 0x2C30, 0x2C5E, 0x2C60, 0x2CE4,
	0x2CEB, 0x2CEE, 0x2CF2, 0x2CF3, 0x2D00, 0x2D25, 0x2D27, 0x2D27,
	0x2D2D, 0x2D2D, 0xA640, 0xA66D, 0xA680, 0xA69D, 0xA722, 0xA787,
	0xA78B, 0xA78E, 0xA790, 0xA7BF, 0xA7C2, 0xA7C6, 0xA7F8, 0xA7FA,
	0xAB30, 0xAB5A, 0xAB5C, 0xAB67, 0xAB70, 0xABBF, 0xFB00, 0xFB06,
	0xFB13, 0xFB17, 0xFF21, 0xFF3A, 0xFF41, 0xFF5A, 0x10400, 0x1044F,
	0x104B0, 0x104D3, 0x104D8, 0x104FB, 0x10C80, 0x10CB2, 0x10CC0, 0x10CF2,
	0x118A0, 0x118DF, 0x16E40, 0x16E7F, 0x1D400, 0x1D454, 0x1D456, 0x1D49C,
	0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC,
	0x1D4AE, 0x1D4B9, 0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505,
	0x1D507, 0x1D50A, 0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539,
	0x1D53B, 0x1D53E, 0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550,
	0x1D552, 0x1D6A5, 0x1D6A8, 0x1D6C0, 0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6FA,
	0x1D6FC, 0x1D714, 0x1D716, 0x1D734, 0x1D736, 0x1D74E, 0x1D750, 0x1D76E,
	0x1D770, 0x1D788, 0x1D78A, 0x1D7A8, 0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7CB,
	0x1E900, 0x1E943, 0x1F130, 0x1F149, 0x1F150, 0x1F169, 0x1F170, 0x1F189,
	//  #48 (5163+612): bp=Changes_When_Casefolded:CWCF
	0x0041, 0x005A, 0x00B5, 0x00B5, 0x00C0, 0x00D6, 0x00D8, 0x00DF,
	0x0100, 0x0100, 0x0102, 0x0102, 0x0104, 0x0104, 0x0106, 0x0106,
	0x0108, 0x0108, 0x010A, 0x010A, 0x010C, 0x010C, 0x010E, 0x010E,
	0x0110, 0x0110, 0x0112, 0x0112, 0x0114, 0x0114, 0x0116, 0x0116,
	0x0118, 0x0118, 0x011A, 0x011A, 0x011C, 0x011C, 0x011E, 0x011E,
	0x0120, 0x0120, 0x0122, 0x0122, 0x0124, 0x0124, 0x0126, 0x0126,
	0x0128, 0x0128, 0x012A, 0x012A, 0x012C, 0x012C, 0x012E, 0x012E,
	0x0130, 0x0130, 0x0132, 0x0132, 0x0134, 0x0134, 0x0136, 0x0136,
	0x0139, 0x0139, 0x013B, 0x013B, 0x013D, 0x013D, 0x013F, 0x013F,
	0x0141, 0x0141, 0x0143, 0x0143, 0x0145, 0x0145, 0x0147, 0x0147,
	0x0149, 0x014A, 0x014C, 0x014C, 0x014E, 0x014E, 0x0150, 0x0150,
	0x0152, 0x0152, 0x0154, 0x0154, 0x0156, 0x0156, 0x0158, 0x0158,
	0x015A, 0x015A, 0x015C, 0x015C, 0x015E, 0x015E, 0x0160, 0x0160,
	0x0162, 0x0162, 0x0164, 0x0164, 0x0166, 0x0166, 0x0168, 0x0168,
	0x016A, 0x016A, 0x016C, 0x016C, 0x016E, 0x016E, 0x0170, 0x0170,
	0x0172, 0x0172, 0x0174, 0x0174, 0x0176, 0x0176, 0x0178, 0x0179,
	0x017B, 0x017B, 0x017D, 0x017D, 0x017F, 0x017F, 0x0181, 0x0182,
	0x0184, 0x0184, 0x0186, 0x0187, 0x0189, 0x018B, 0x018E, 0x0191,
	0x0193, 0x0194, 0x0196, 0x0198, 0x019C, 0x019D, 0x019F, 0x01A0,
	0x01A2, 0x01A2, 0x01A4, 0x01A4, 0x01A6, 0x01A7, 0x01A9, 0x01A9,
	0x01AC, 0x01AC, 0x01AE, 0x01AF, 0x01B1, 0x01B3, 0x01B5, 0x01B5,
	0x01B7, 0x01B8, 0x01BC, 0x01BC, 0x01C4, 0x01C5, 0x01C7, 0x01C8,
	0x01CA, 0x01CB, 0x01CD, 0x01CD, 0x01CF, 0x01CF, 0x01D1, 0x01D1,
	0x01D3, 0x01D3, 0x01D5, 0x01D5, 0x01D7, 0x01D7, 0x01D9, 0x01D9,
	0x01DB, 0x01DB, 0x01DE, 0x01DE, 0x01E0, 0x01E0, 0x01E2, 0x01E2,
	0x01E4, 0x01E4, 0x01E6, 0x01E6, 0x01E8, 0x01E8, 0x01EA, 0x01EA,
	0x01EC, 0x01EC, 0x01EE, 0x01EE, 0x01F1, 0x01F2, 0x01F4, 0x01F4,
	0x01F6, 0x01F8, 0x01FA, 0x01FA, 0x01FC, 0x01FC, 0x01FE, 0x01FE,
	0x0200, 0x0200, 0x0202, 0x0202, 0x0204, 0x0204, 0x0206, 0x0206,
	0x0208, 0x0208, 0x020A, 0x020A, 0x020C, 0x020C, 0x020E, 0x020E,
	0x0210, 0x0210, 0x0212, 0x0212, 0x0214, 0x0214, 0x0216, 0x0216,
	0x0218, 0x0218, 0x021A, 0x021A, 0x021C, 0x021C, 0x021E, 0x021E,
	0x0220, 0x0220, 0x0222, 0x0222, 0x0224, 0x0224, 0x0226, 0x0226,
	0x0228, 0x0228, 0x022A, 0x022A, 0x022C, 0x022C, 0x022E, 0x022E,
	0x0230, 0x0230, 0x0232, 0x0232, 0x023A, 0x023B, 0x023D, 0x023E,
	0x0241, 0x0241, 0x0243, 0x0246, 0x0248, 0x0248, 0x024A, 0x024A,
	0x024C, 0x024C, 0x024E, 0x024E, 0x0345, 0x0345, 0x0370, 0x0370,
	0x0372, 0x0372, 0x0376, 0x0376, 0x037F, 0x037F, 0x0386, 0x0386,
	0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x038F, 0x0391, 0x03A1,
	0x03A3, 0x03AB, 0x03C2, 0x03C2, 0x03CF, 0x03D1, 0x03D5, 0x03D6,
	0x03D8, 0x03D8, 0x03DA, 0x03DA, 0x03DC, 0x03DC, 0x03DE, 0x03DE,
	0x03E0, 0x03E0, 0x03E2, 0x03E2, 0x03E4, 0x03E4, 0x03E6, 0x03E6,
	0x03E8, 0x03E8, 0x03EA, 0x03EA, 0x03EC, 0x03EC, 0x03EE, 0x03EE,
	0x03F0, 0x03F1, 0x03F4, 0x03F5, 0x03F7, 0x03F7, 0x03F9, 0x03FA,
	0x03FD, 0x042F, 0x0460, 0x0460, 0x0462, 0x0462, 0x0464, 0x0464,
	0x0466, 0x0466, 0x0468, 0x0468, 0x046A, 0x046A, 0x046C, 0x046C,
	0x046E, 0x046E, 0x0470, 0x0470, 0x0472, 0x0472, 0x0474, 0x0474,
	0x0476, 0x0476, 0x0478, 0x0478, 0x047A, 0x047A, 0x047C, 0x047C,
	0x047E, 0x047E, 0x0480, 0x0480, 0x048A, 0x048A, 0x048C, 0x048C,
	0x048E, 0x048E, 0x0490, 0x0490, 0x0492, 0x0492, 0x0494, 0x0494,
	0x0496, 0x0496, 0x0498, 0x0498, 0x049A, 0x049A, 0x049C, 0x049C,
	0x049E, 0x049E, 0x04A0, 0x04A0, 0x04A2, 0x04A2, 0x04A4, 0x04A4,
	0x04A6, 0x04A6, 0x04A8, 0x04A8, 0x04AA, 0x04AA, 0x04AC, 0x04AC,
	0x04AE, 0x04AE, 0x04B0, 0x04B0, 0x04B2, 0x04B2, 0x04B4, 0x04B4,
	0x04B6, 0x04B6, 0x04B8, 0x04B8, 0x04BA, 0x04BA, 0x04BC, 0x04BC,
	0x04BE, 0x04BE, 0x04C0, 0x04C1, 0x04C3, 0x04C3, 0x04C5, 0x04C5,
	0x04C7, 0x04C7, 0x04C9, 0x04C9, 0x04CB, 0x04CB, 0x04CD, 0x04CD,
	0x04D0, 0x04D0, 0x04D2, 0x04D2, 0x04D4, 0x04D4, 0x04D6, 0x04D6,
	0x04D8, 0x04D8, 0x04DA, 0x04DA, 0x04DC, 0x04DC, 0x04DE, 0x04DE,
	0x04E0, 0x04E0, 0x04E2, 0x04E2, 0x04E4, 0x04E4, 0x04E6, 0x04E6,
	0x04E8, 0x04E8, 0x04EA, 0x04EA, 0x04EC, 0x04EC, 0x04EE, 0x04EE,
	0x04F0, 0x04F0, 0x04F2, 0x04F2, 0x04F4, 0x04F4, 0x04F6, 0x04F6,
	0x04F8, 0x04F8, 0x04FA, 0x04FA, 0x04FC, 0x04FC, 0x04FE, 0x04FE,
	0x0500, 0x0500, 0x0502, 0x0502, 0x0504, 0x0504, 0x0506, 0x0506,
	0x0508, 0x0508, 0x050A, 0x050A, 0x050C, 0x050C, 0x050E, 0x050E,
	0x0510, 0x0510, 0x0512, 0x0512, 0x0514, 0x0514, 0x0516, 0x0516,
	0x0518, 0x0518, 0x051A, 0x051A, 0x051C, 0x051C, 0x051E, 0x051E,
	0x0520, 0x0520, 0x0522, 0x0522, 0x0524, 0x0524, 0x0526, 0x0526,
	0x0528, 0x0528, 0x052A, 0x052A, 0x052C, 0x052C, 0x052E, 0x052E,
	0x0531, 0x0556, 0x0587, 0x0587, 0x10A0, 0x10C5, 0x10C7, 0x10C7,
	0x10CD, 0x10CD, 0x13F8, 0x13FD, 0x1C80, 0x1C88, 0x1C90, 0x1CBA,
	0x1CBD, 0x1CBF, 0x1E00, 0x1E00, 0x1E02, 0x1E02, 0x1E04, 0x1E04,
	0x1E06, 0x1E06, 0x1E08, 0x1E08, 0x1E0A, 0x1E0A, 0x1E0C, 0x1E0C,
	0x1E0E, 0x1E0E, 0x1E10, 0x1E10, 0x1E12, 0x1E12, 0x1E14, 0x1E14,
	0x1E16, 0x1E16, 0x1E18, 0x1E18, 0x1E1A, 0x1E1A, 0x1E1C, 0x1E1C,
	0x1E1E, 0x1E1E, 0x1E20, 0x1E20, 0x1E22, 0x1E22, 0x1E24, 0x1E24,
	0x1E26, 0x1E26, 0x1E28, 0x1E28, 0x1E2A, 0x1E2A, 0x1E2C, 0x1E2C,
	0x1E2E, 0x1E2E, 0x1E30, 0x1E30, 0x1E32, 0x1E32, 0x1E34, 0x1E34,
	0x1E36, 0x1E36, 0x1E38, 0x1E38, 0x1E3A, 0x1E3A, 0x1E3C, 0x1E3C,
	0x1E3E, 0x1E3E, 0x1E40, 0x1E40, 0x1E42, 0x1E42, 0x1E44, 0x1E44,
	0x1E46, 0x1E46, 0x1E48, 0x1E48, 0x1E4A, 0x1E4A, 0x1E4C, 0x1E4C,
	0x1E4E, 0x1E4E, 0x1E50, 0x1E50, 0x1E52, 0x1E52, 0x1E54, 0x1E54,
	0x1E56, 0x1E56, 0x1E58, 0x1E58, 0x1E5A, 0x1E5A, 0x1E5C, 0x1E5C,
	0x1E5E, 0x1E5E, 0x1E60, 0x1E60, 0x1E62, 0x1E62, 0x1E64, 0x1E64,
	0x1E66, 0x1E66, 0x1E68, 0x1E68, 0x1E6A, 0x1E6A, 0x1E6C, 0x1E6C,
	0x1E6E, 0x1E6E, 0x1E70, 0x1E70, 0x1E72, 0x1E72, 0x1E74, 0x1E74,
	0x1E76, 0x1E76, 0x1E78, 0x1E78, 0x1E7A, 0x1E7A, 0x1E7C, 0x1E7C,
	0x1E7E, 0x1E7E, 0x1E80, 0x1E80, 0x1E82, 0x1E82, 0x1E84, 0x1E84,
	0x1E86, 0x1E86, 0x1E88, 0x1E88, 0x1E8A, 0x1E8A, 0x1E8C, 0x1E8C,
	0x1E8E, 0x1E8E, 0x1E90, 0x1E90, 0x1E92, 0x1E92, 0x1E94, 0x1E94,
	0x1E9A, 0x1E9B, 0x1E9E, 0x1E9E, 0x1EA0, 0x1EA0, 0x1EA2, 0x1EA2,
	0x1EA4, 0x1EA4, 0x1EA6, 0x1EA6, 0x1EA8, 0x1EA8, 0x1EAA, 0x1EAA,
	0x1EAC, 0x1EAC, 0x1EAE, 0x1EAE, 0x1EB0, 0x1EB0, 0x1EB2, 0x1EB2,
	0x1EB4, 0x1EB4, 0x1EB6, 0x1EB6, 0x1EB8, 0x1EB8, 0x1EBA, 0x1EBA,
	0x1EBC, 0x1EBC, 0x1EBE, 0x1EBE, 0x1EC0, 0x1EC0, 0x1EC2, 0x1EC2,
	0x1EC4, 0x1EC4, 0x1EC6, 0x1EC6, 0x1EC8, 0x1EC8, 0x1ECA, 0x1ECA,
	0x1ECC, 0x1ECC, 0x1ECE, 0x1ECE, 0x1ED0, 0x1ED0, 0x1ED2, 0x1ED2,
	0x1ED4, 0x1ED4, 0x1ED6, 0x1ED6, 0x1ED8, 0x1ED8, 0x1EDA, 0x1EDA,
	0x1EDC, 0x1EDC, 0x1EDE, 0x1EDE, 0x1EE0, 0x1EE0, 0x1EE2, 0x1EE2,
	0x1EE4, 0x1EE4, 0x1EE6, 0x1EE6, 0x1EE8, 0x1EE8, 0x1EEA, 0x1EEA,
	0x1EEC, 0x1EEC, 0x1EEE, 0x1EEE, 0x1EF0, 0x1EF0, 0x1EF2, 0x1EF2,
	0x1EF4, 0x1EF4, 0x1EF6, 0x1EF6, 0x1EF8, 0x1EF8, 0x1EFA, 0x1EFA,
	0x1EFC, 0x1EFC, 0x1EFE, 0x1EFE, 0x1F08, 0x1F0F, 0x1F18, 0x1F1D,
	0x1F28, 0x1F2F, 0x1F38, 0x1F3F, 0x1F48, 0x1F4D, 0x1F59, 0x1F59,
	0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F5F, 0x1F68, 0x1F6F,
	0x1F80, 0x1FAF, 0x1FB2, 0x1FB4, 0x1FB7, 0x1FBC, 0x1FC2, 0x1FC4,
	0x1FC7, 0x1FCC, 0x1FD8, 0x1FDB, 0x1FE8, 0x1FEC, 0x1FF2, 0x1FF4,
	0x1FF7, 0x1FFC, 0x2126, 0x2126, 0x212A, 0x212B, 0x2132, 0x2132,
	0x2160, 0x216F, 0x2183, 0x2183, 0x24B6, 0x24CF, 0x2C00, 0x2C2E,
	0x2C60, 0x2C60, 0x2C62, 0x2C64, 0x2C67, 0x2C67, 0x2C69, 0x2C69,
	0x2C6B, 0x2C6B, 0x2C6D, 0x2C70, 0x2C72, 0x2C72, 0x2C75, 0x2C75,
	0x2C7E, 0x2C80, 0x2C82, 0x2C82, 0x2C84, 0x2C84, 0x2C86, 0x2C86,
	0x2C88, 0x2C88, 0x2C8A, 0x2C8A, 0x2C8C, 0x2C8C, 0x2C8E, 0x2C8E,
	0x2C90, 0x2C90, 0x2C92, 0x2C92, 0x2C94, 0x2C94, 0x2C96, 0x2C96,
	0x2C98, 0x2C98, 0x2C9A, 0x2C9A, 0x2C9C, 0x2C9C, 0x2C9E, 0x2C9E,
	0x2CA0, 0x2CA0, 0x2CA2, 0x2CA2, 0x2CA4, 0x2CA4, 0x2CA6, 0x2CA6,
	0x2CA8, 0x2CA8, 0x2CAA, 0x2CAA, 0x2CAC, 0x2CAC, 0x2CAE, 0x2CAE,
	0x2CB0, 0x2CB0, 0x2CB2, 0x2CB2, 0x2CB4, 0x2CB4, 0x2CB6, 0x2CB6,
	0x2CB8, 0x2CB8, 0x2CBA, 0x2CBA, 0x2CBC, 0x2CBC, 0x2CBE, 0x2CBE,
	0x2CC0, 0x2CC0, 0x2CC2, 0x2CC2, 0x2CC4, 0x2CC4, 0x2CC6, 0x2CC6,
	0x2CC8, 0x2CC8, 0x2CCA, 0x2CCA, 0x2CCC, 0x2CCC, 0x2CCE, 0x2CCE,
	0x2CD0, 0x2CD0, 0x2CD2, 0x2CD2, 0x2CD4, 0x2CD4, 0x2CD6, 0x2CD6,
	0x2CD8, 0x2CD8, 0x2CDA, 0x2CDA, 0x2CDC, 0x2CDC, 0x2CDE, 0x2CDE,
	0x2CE0, 0x2CE0, 0x2CE2, 0x2CE2, 0x2CEB, 0x2CEB, 0x2CED, 0x2CED,
	0x2CF2, 0x2CF2, 0xA640, 0xA640, 0xA642, 0xA642, 0xA644, 0xA644,
	0xA646, 0xA646, 0xA648, 0xA648, 0xA64A, 0xA64A, 0xA64C, 0xA64C,
	0xA64E, 0xA64E, 0xA650, 0xA650, 0xA652, 0xA652, 0xA654, 0xA654,
	0xA656, 0xA656, 0xA658, 0xA658, 0xA65A, 0xA65A, 0xA65C, 0xA65C,
	0xA65E, 0xA65E, 0xA660, 0xA660, 0xA662, 0xA662, 0xA664, 0xA664,
	0xA666, 0xA666, 0xA668, 0xA668, 0xA66A, 0xA66A, 0xA66C, 0xA66C,
	0xA680, 0xA680, 0xA682, 0xA682, 0xA684, 0xA684, 0xA686, 0xA686,
	0xA688, 0xA688, 0xA68A, 0xA68A, 0xA68C, 0xA68C, 0xA68E, 0xA68E,
	0xA690, 0xA690, 0xA692, 0xA692, 0xA694, 0xA694, 0xA696, 0xA696,
	0xA698, 0xA698, 0xA69A, 0xA69A, 0xA722, 0xA722, 0xA724, 0xA724,
	0xA726, 0xA726, 0xA728, 0xA728, 0xA72A, 0xA72A, 0xA72C, 0xA72C,
	0xA72E, 0xA72E, 0xA732, 0xA732, 0xA734, 0xA734, 0xA736, 0xA736,
	0xA738, 0xA738, 0xA73A, 0xA73A, 0xA73C, 0xA73C, 0xA73E, 0xA73E,
	0xA740, 0xA740, 0xA742, 0xA742, 0xA744, 0xA744, 0xA746, 0xA746,
	0xA748, 0xA748, 0xA74A, 0xA74A, 0xA74C, 0xA74C, 0xA74E, 0xA74E,
	0xA750, 0xA750, 0xA752, 0xA752, 0xA754, 0xA754, 0xA756, 0xA756,
	0xA758, 0xA758, 0xA75A, 0xA75A, 0xA75C, 0xA75C, 0xA75E, 0xA75E,
	0xA760, 0xA760, 0xA762, 0xA762, 0xA764, 0xA764, 0xA766, 0xA766,
	0xA768, 0xA768, 0xA76A, 0xA76A, 0xA76C, 0xA76C, 0xA76E, 0xA76E,
	0xA779, 0xA779, 0xA77B, 0xA77B, 0xA77D, 0xA77E, 0xA780, 0xA780,
	0xA782, 0xA782, 0xA784, 0xA784, 0xA786, 0xA786, 0xA78B, 0xA78B,
	0xA78D, 0xA78D, 0xA790, 0xA790, 0xA792, 0xA792, 0xA796, 0xA796,
	0xA798, 0xA798, 0xA79A, 0xA79A, 0xA79C, 0xA79C, 0xA79E, 0xA79E,
	0xA7A0, 0xA7A0, 0xA7A2, 0xA7A2, 0xA7A4, 0xA7A4, 0xA7A6, 0xA7A6,
	0xA7A8, 0xA7A8, 0xA7AA, 0xA7AE, 0xA7B0, 0xA7B4, 0xA7B6, 0xA7B6,
	0xA7B8, 0xA7B8, 0xA7BA, 0xA7BA, 0xA7BC, 0xA7BC, 0xA7BE, 0xA7BE,
	0xA7C2, 0xA7C2, 0xA7C4, 0xA7C6, 0xAB70, 0xABBF, 0xFB00, 0xFB06,
	0xFB13, 0xFB17, 0xFF21, 0xFF3A, 0x10400, 0x10427, 0x104B0, 0x104D3,
	0x10C80, 0x10CB2, 0x118A0, 0x118BF, 0x16E40, 0x16E5F, 0x1E900, 0x1E921,
	//  #49 (5775+123): bp=Changes_When_Casemapped:CWCM
	0x0041, 0x005A, 0x0061, 0x007A, 0x00B5, 0x00B5, 0x00C0, 0x00D6,
	0x00D8, 0x00F6, 0x00F8, 0x0137, 0x0139, 0x018C, 0x018E, 0x019A,
	0x019C, 0x01A9, 0x01AC, 0x01B9, 0x01BC, 0x01BD, 0x01BF, 0x01BF,
	0x01C4, 0x0220, 0x0222, 0x0233, 0x023A, 0x0254, 0x0256, 0x0257,
	0x0259, 0x0259, 0x025B, 0x025C, 0x0260, 0x0261, 0x0263, 0x0263,
	0x0265, 0x0266, 0x0268, 0x026C, 0x026F, 0x026F, 0x0271, 0x0272,
	0x0275, 0x0275, 0x027D, 0x027D, 0x0280, 0x0280, 0x0282, 0x0283,
	0x0287, 0x028C, 0x0292, 0x0292, 0x029D, 0x029E, 0x0345, 0x0345,
	0x0370, 0x0373, 0x0376, 0x0377, 0x037B, 0x037D, 0x037F, 0x037F,
	0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x03A1,
	0x03A3, 0x03D1, 0x03D5, 0x03F5, 0x03F7, 0x03FB, 0x03FD, 0x0481,
	0x048A, 0x052F, 0x0531, 0x0556, 0x0561, 0x0587, 0x10A0, 0x10C5,
	0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x10D0, 0x10FA, 0x10FD, 0x10FF,
	0x13A0, 0x13F5, 0x13F8, 0x13FD, 0x1C80, 0x1C88, 0x1C90, 0x1CBA,
	0x1CBD, 0x1CBF, 0x1D79, 0x1D79, 0x1D7D, 0x1D7D, 0x1D8E, 0x1D8E,
	0x1E00, 0x1E9B, 0x1E9E, 0x1E9E, 0x1EA0, 0x1F15, 0x1F18, 0x1F1D,
	0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57, 0x1F59, 0x1F59,
	0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4,
	0x1FB6, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC,
	0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4,
	0x1FF6, 0x1FFC, 0x2126, 0x2126, 0x212A, 0x212B, 0x2132, 0x2132,
	0x214E, 0x214E, 0x2160, 0x217F, 0x2183, 0x2184, 0x24B6, 0x24E9,
	0x2C00, 0x2C2E, 0x2C30, 0x2C5E, 0x2C60, 0x2C70, 0x2C72, 0x2C73,
	0x2C75, 0x2C76, 0x2C7E, 0x2CE3, 0x2CEB, 0x2CEE, 0x2CF2, 0x2CF3,
	0x2D00, 0x2D25, 0x2D27, 0x2D27, 0x2D2D, 0x2D2D, 0xA640, 0xA66D,
	0xA680, 0xA69B, 0xA722, 0xA72F, 0xA732, 0xA76F, 0xA779, 0xA787,
	0xA78B, 0xA78D, 0xA790, 0xA794, 0xA796, 0xA7AE, 0xA7B0, 0xA7BF,
	0xA7C2, 0xA7C6, 0xAB53, 0xAB53, 0xAB70, 0xABBF, 0xFB00, 0xFB06,
	0xFB13, 0xFB17, 0xFF21, 0xFF3A, 0xFF41, 0xFF5A, 0x10400, 0x1044F,
	0x104B0, 0x104D3, 0x104D8, 0x104FB, 0x10C80, 0x10CB2, 0x10CC0, 0x10CF2,
	0x118A0, 0x118DF, 0x16E40, 0x16E7F, 0x1E900, 0x1E943,
	//  #50 (5898+599): bp=Changes_When_Lowercased:CWL
	0x0041, 0x005A, 0x00C0, 0x00D6, 0x00D8, 0x00DE, 0x0100, 0x0100,
	0x0102, 0x0102, 0x0104, 0x0104, 0x0106, 0x0106, 0x0108, 0x0108,
	0x010A, 0x010A, 0x010C, 0x010C, 0x010E, 0x010E, 0x0110, 0x0110,
	0x0112, 0x0112, 0x0114, 0x0114, 0x0116, 0x0116, 0x0118, 0x0118,
	0x011A, 0x011A, 0x011C, 0x011C, 0x011E, 0x011E, 0x0120, 0x0120,
	0x0122, 0x0122, 0x0124, 0x0124, 0x0126, 0x0126, 0x0128, 0x0128,
	0x012A, 0x012A, 0x012C, 0x012C, 0x012E, 0x012E, 0x0130, 0x0130,
	0x0132, 0x0132, 0x0134, 0x0134, 0x0136, 0x0136, 0x0139, 0x0139,
	0x013B, 0x013B, 0x013D, 0x013D, 0x013F, 0x013F, 0x0141, 0x0141,
	0x0143, 0x0143, 0x0145, 0x0145, 0x0147, 0x0147, 0x014A, 0x014A,
	0x014C, 0x014C, 0x014E, 0x014E, 0x0150, 0x0150, 0x0152, 0x0152,
	0x0154, 0x0154, 0x0156, 0x0156, 0x0158, 0x0158, 0x015A, 0x015A,
	0x015C, 0x015C, 0x015E, 0x015E, 0x0160, 0x0160, 0x0162, 0x0162,
	0x0164, 0x0164, 0x0166, 0x0166, 0x0168, 0x0168, 0x016A, 0x016A,
	0x016C, 0x016C, 0x016E, 0x016E, 0x0170, 0x0170, 0x0172, 0x0172,
	0x0174, 0x0174, 0x0176, 0x0176, 0x0178, 0x0179, 0x017B, 0x017B,
	0x017D, 0x017D, 0x0181, 0x0182, 0x0184, 0x0184, 0x0186, 0x0187,
	0x0189, 0x018B, 0x018E, 0x0191, 0x0193, 0x0194, 0x0196, 0x0198,
	0x019C, 0x019D, 0x019F, 0x01A0, 0x01A2, 0x01A2, 0x01A4, 0x01A4,
	0x01A6, 0x01A7, 0x01A9, 0x01A9, 0x01AC, 0x01AC, 0x01AE, 0x01AF,
	0x01B1, 0x01B3, 0x01B5, 0x01B5, 0x01B7, 0x01B8, 0x01BC, 0x01BC,
	0x01C4, 0x01C5, 0x01C7, 0x01C8, 0x01CA, 0x01CB, 0x01CD, 0x01CD,
	0x01CF, 0x01CF, 0x01D1, 0x01D1, 0x01D3, 0x01D3, 0x01D5, 0x01D5,
	0x01D7, 0x01D7, 0x01D9, 0x01D9, 0x01DB, 0x01DB, 0x01DE, 0x01DE,
	0x01E0, 0x01E0, 0x01E2, 0x01E2, 0x01E4, 0x01E4, 0x01E6, 0x01E6,
	0x01E8, 0x01E8, 0x01EA, 0x01EA, 0x01EC, 0x01EC, 0x01EE, 0x01EE,
	0x01F1, 0x01F2, 0x01F4, 0x01F4, 0x01F6, 0x01F8, 0x01FA, 0x01FA,
	0x01FC, 0x01FC, 0x01FE, 0x01FE, 0x0200, 0x0200, 0x0202, 0x0202,
	0x0204, 0x0204, 0x0206, 0x0206, 0x0208, 0x0208, 0x020A, 0x020A,
	0x020C, 0x020C, 0x020E, 0x020E, 0x0210, 0x0210, 0x0212, 0x0212,
	0x0214, 0x0214, 0x0216, 0x0216, 0x0218, 0x0218, 0x021A, 0x021A,
	0x021C, 0x021C, 0x021E, 0x021E, 0x0220, 0x0220, 0x0222, 0x0222,
	0x0224, 0x0224, 0x0226, 0x0226, 0x0228, 0x0228, 0x022A, 0x022A,
	0x022C, 0x022C, 0x022E, 0x022E, 0x0230, 0x0230, 0x0232, 0x0232,
	0x023A, 0x023B, 0x023D, 0x023E, 0x0241, 0x0241, 0x0243, 0x0246,
	0x0248, 0x0248, 0x024A, 0x024A, 0x024C, 0x024C, 0x024E, 0x024E,
	0x0370, 0x0370, 0x0372, 0x0372, 0x0376, 0x0376, 0x037F, 0x037F,
	0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x038F,
	0x0391, 0x03A1, 0x03A3, 0x03AB, 0x03CF, 0x03CF, 0x03D8, 0x03D8,
	0x03DA, 0x03DA, 0x03DC, 0x03DC, 0x03DE, 0x03DE, 0x03E0, 0x03E0,
	0x03E2, 0x03E2, 0x03E4, 0x03E4, 0x03E6, 0x03E6, 0x03E8, 0x03E8,
	0x03EA, 0x03EA, 0x03EC, 0x03EC, 0x03EE, 0x03EE, 0x03F4, 0x03F4,
	0x03F7, 0x03F7, 0x03F9, 0x03FA, 0x03FD, 0x042F, 0x0460, 0x0460,
	0x0462, 0x0462, 0x0464, 0x0464, 0x0466, 0x0466, 0x0468, 0x0468,
	0x046A, 0x046A, 0x046C, 0x046C, 0x046E, 0x046E, 0x0470, 0x0470,
	0x0472, 0x0472, 0x0474, 0x0474, 0x0476, 0x0476, 0x0478, 0x0478,
	0x047A, 0x047A, 0x047C, 0x047C, 0x047E, 0x047E, 0x0480, 0x0480,
	0x048A, 0x048A, 0x048C, 0x048C, 0x048E, 0x048E, 0x0490, 0x0490,
	0x0492, 0x0492, 0x0494, 0x0494, 0x0496, 0x0496, 0x0498, 0x0498,
	0x049A, 0x049A, 0x049C, 0x049C, 0x049E, 0x049E, 0x04A0, 0x04A0,
	0x04A2, 0x04A2, 0x04A4, 0x04A4, 0x04A6, 0x04A6, 0x04A8, 0x04A8,
	0x04AA, 0x04AA, 0x04AC, 0x04AC, 0x04AE, 0x04AE, 0x04B0, 0x04B0,
	0x04B2, 0x04B2, 0x04B4, 0x04B4, 0x04B6, 0x04B6, 0x04B8, 0x04B8,
	0x04BA, 0x04BA, 0x04BC, 0x04BC, 0x04BE, 0x04BE, 0x04C0, 0x04C1,
	0x04C3, 0x04C3, 0x04C5, 0x04C5, 0x04C7, 0x04C7, 0x04C9, 0x04C9,
	0x04CB, 0x04CB, 0x04CD, 0x04CD, 0x04D0, 0x04D0, 0x04D2, 0x04D2,
	0x04D4, 0x04D4, 0x04D6, 0x04D6, 0x04D8, 0x04D8, 0x04DA, 0x04DA,
	0x04DC, 0x04DC, 0x04DE, 0x04DE, 0x04E0, 0x04E0, 0x04E2, 0x04E2,
	0x04E4, 0x04E4, 0x04E6, 0x04E6, 0x04E8, 0x04E8, 0x04EA, 0x04EA,
	0x04EC, 0x04EC, 0x04EE, 0x04EE, 0x04F0, 0x04F0, 0x04F2, 0x04F2,
	0x04F4, 0x04F4, 0x04F6, 0x04F6, 0x04F8, 0x04F8, 0x04FA, 0x04FA,
	0x04FC, 0x04FC, 0x04FE, 0x04FE, 0x0500, 0x0500, 0x0502, 0x0502,
	0x0504, 0x0504, 0x0506, 0x0506, 0x0508, 0x0508, 0x050A, 0x050A,
	0x050C, 0x050C, 0x050E, 0x050E, 0x0510, 0x0510, 0x0512, 0x0512,
	0x0514, 0x0514, 0x0516, 0x0516, 0x0518, 0x0518, 0x051A, 0x051A,
	0x051C, 0x051C, 0x051E, 0x051E, 0x0520, 0x0520, 0x0522, 0x0522,
	0x0524, 0x0524, 0x0526, 0x0526, 0x0528, 0x0528, 0x052A, 0x052A,
	0x052C, 0x052C, 0x052E, 0x052E, 0x0531, 0x0556, 0x10A0, 0x10C5,
	0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x13A0, 0x13F5, 0x1C90, 0x1CBA,
	0x1CBD, 0x1CBF, 0x1E00, 0x1E00, 0x1E02, 0x1E02, 0x1E04, 0x1E04,
	0x1E06, 0x1E06, 0x1E08, 0x1E08, 0x1E0A, 0x1E0A, 0x1E0C, 0x1E0C,
	0x1E0E, 0x1E0E, 0x1E10, 0x1E10, 0x1E12, 0x1E12, 0x1E14, 0x1E14,
	0x1E16, 0x1E16, 0x1E18, 0x1E18, 0x1E1A, 0x1E1A, 0x1E1C, 0x1E1C,
	0x1E1E, 0x1E1E, 0x1E20, 0x1E20, 0x1E22, 0x1E22, 0x1E24, 0x1E24,
	0x1E26, 0x1E26, 0x1E28, 0x1E28, 0x1E2A, 0x1E2A, 0x1E2C, 0x1E2C,
	0x1E2E, 0x1E2E, 0x1E30, 0x1E30, 0x1E32, 0x1E32, 0x1E34, 0x1E34,
	0x1E36, 0x1E36, 0x1E38, 0x1E38, 0x1E3A, 0x1E3A, 0x1E3C, 0x1E3C,
	0x1E3E, 0x1E3E, 0x1E40, 0x1E40, 0x1E42, 0x1E42, 0x1E44, 0x1E44,
	0x1E46, 0x1E46, 0x1E48, 0x1E48, 0x1E4A, 0x1E4A, 0x1E4C, 0x1E4C,
	0x1E4E, 0x1E4E, 0x1E50, 0x1E50, 0x1E52, 0x1E52, 0x1E54, 0x1E54,
	0x1E56, 0x1E56, 0x1E58, 0x1E58, 0x1E5A, 0x1E5A, 0x1E5C, 0x1E5C,
	0x1E5E, 0x1E5E, 0x1E60, 0x1E60, 0x1E62, 0x1E62, 0x1E64, 0x1E64,
	0x1E66, 0x1E66, 0x1E68, 0x1E68, 0x1E6A, 0x1E6A, 0x1E6C, 0x1E6C,
	0x1E6E, 0x1E6E, 0x1E70, 0x1E70, 0x1E72, 0x1E72, 0x1E74, 0x1E74,
	0x1E76, 0x1E76, 0x1E78, 0x1E78, 0x1E7A, 0x1E7A, 0x1E7C, 0x1E7C,
	0x1E7E, 0x1E7E, 0x1E80, 0x1E80, 0x1E82, 0x1E82, 0x1E84, 0x1E84,
	0x1E86, 0x1E86, 0x1E88, 0x1E88, 0x1E8A, 0x1E8A, 0x1E8C, 0x1E8C,
	0x1E8E, 0x1E8E, 0x1E90, 0x1E90, 0x1E92, 0x1E92, 0x1E94, 0x1E94,
	0x1E9E, 0x1E9E, 0x1EA0, 0x1EA0, 0x1EA2, 0x1EA2, 0x1EA4, 0x1EA4,
	0x1EA6, 0x1EA6, 0x1EA8, 0x1EA8, 0x1EAA, 0x1EAA, 0x1EAC, 0x1EAC,
	0x1EAE, 0x1EAE, 0x1EB0, 0x1EB0, 0x1EB2, 0x1EB2, 0x1EB4, 0x1EB4,
	0x1EB6, 0x1EB6, 0x1EB8, 0x1EB8, 0x1EBA, 0x1EBA, 0x1EBC, 0x1EBC,
	0x1EBE, 0x1EBE, 0x1EC0, 0x1EC0, 0x1EC2, 0x1EC2, 0x1EC4, 0x1EC4,
	0x1EC6, 0x1EC6, 0x1EC8, 0x1EC8, 0x1ECA, 0x1ECA, 0x1ECC, 0x1ECC,
	0x1ECE, 0x1ECE, 0x1ED0, 0x1ED0, 0x1ED2, 0x1ED2, 0x1ED4, 0x1ED4,
	0x1ED6, 0x1ED6, 0x1ED8, 0x1ED8, 0x1EDA, 0x1EDA, 0x1EDC, 0x1EDC,
	0x1EDE, 0x1EDE, 0x1EE0, 0x1EE0, 0x1EE2, 0x1EE2, 0x1EE4, 0x1EE4,
	0x1EE6, 0x1EE6, 0x1EE8, 0x1EE8, 0x1EEA, 0x1EEA, 0x1EEC, 0x1EEC,
	0x1EEE, 0x1EEE, 0x1EF0, 0x1EF0, 0x1EF2, 0x1EF2, 0x1EF4, 0x1EF4,
	0x1EF6, 0x1EF6, 0x1EF8, 0x1EF8, 0x1EFA, 0x1EFA, 0x1EFC, 0x1EFC,
	0x1EFE, 0x1EFE, 0x1F08, 0x1F0F, 0x1F18, 0x1F1D, 0x1F28, 0x1F2F,
	0x1F38, 0x1F3F, 0x1F48, 0x1F4D, 0x1F59, 0x1F59, 0x1F5B, 0x1F5B,
	0x1F5D, 0x1F5D, 0x1F5F, 0x1F5F, 0x1F68, 0x1F6F, 0x1F88, 0x1F8F,
	0x1F98, 0x1F9F, 0x1FA8, 0x1FAF, 0x1FB8, 0x1FBC, 0x1FC8, 0x1FCC,
	0x1FD8, 0x1FDB, 0x1FE8, 0x1FEC, 0x1FF8, 0x1FFC, 0x2126, 0x2126,
	0x212A, 0x212B, 0x2132, 0x2132, 0x2160, 0x216F, 0x2183, 0x2183,
	0x24B6, 0x24CF, 0x2C00, 0x2C2E, 0x2C60, 0x2C60, 0x2C62, 0x2C64,
	0x2C67, 0x2C67, 0x2C69, 0x2C69, 0x2C6B, 0x2C6B, 0x2C6D, 0x2C70,
	0x2C72, 0x2C72, 0x2C75, 0x2C75, 0x2C7E, 0x2C80, 0x2C82, 0x2C82,
	0x2C84, 0x2C84, 0x2C86, 0x2C86, 0x2C88, 0x2C88, 0x2C8A, 0x2C8A,
	0x2C8C, 0x2C8C, 0x2C8E, 0x2C8E, 0x2C90, 0x2C90, 0x2C92, 0x2C92,
	0x2C94, 0x2C94, 0x2C96, 0x2C96, 0x2C98, 0x2C98, 0x2C9A, 0x2C9A,
	0x2C9C, 0x2C9C, 0x2C9E, 0x2C9E, 0x2CA0, 0x2CA0, 0x2CA2, 0x2CA2,
	0x2CA4, 0x2CA4, 0x2CA6, 0x2CA6, 0x2CA8, 0x2CA8, 0x2CAA, 0x2CAA,
	0x2CAC, 0x2CAC, 0x2CAE, 0x2CAE, 0x2CB0, 0x2CB0, 0x2CB2, 0x2CB2,
	0x2CB4, 0x2CB4, 0x2CB6, 0x2CB6, 0x2CB8, 0x2CB8, 0x2CBA, 0x2CBA,
	0x2CBC, 0x2CBC, 0x2CBE, 0x2CBE, 0x2CC0, 0x2CC0, 0x2CC2, 0x2CC2,
	0x2CC4, 0x2CC4, 0x2CC6, 0x2CC6, 0x2CC8, 0x2CC8, 0x2CCA, 0x2CCA,
	0x2CCC, 0x2CCC, 0x2CCE, 0x2CCE, 0x2CD0, 0x2CD0, 0x2CD2, 0x2CD2,
	0x2CD4, 0x2CD4, 0x2CD6, 0x2CD6, 0x2CD8, 0x2CD8, 0x2CDA, 0x2CDA,
	0x2CDC, 0x2CDC, 0x2CDE, 0x2CDE, 0x2CE0, 0x2CE0, 0x2CE2, 0x2CE2,
	0x2CEB, 0x2CEB, 0x2CED, 0x2CED, 0x2CF2, 0x2CF2, 0xA640, 0xA640,
	0xA642, 0xA642, 0xA644, 0xA644, 0xA646, 0xA646, 0xA648, 0xA648,
	0xA64A, 0xA64A, 0xA64C, 0xA64C, 0xA64E, 0xA64E, 0xA650, 0xA650,
	0xA652, 0xA652, 0xA654, 0xA654, 0xA656, 0xA656, 0xA658, 0xA658,
	0xA65A, 0xA65A, 0xA65C, 0xA65C, 0xA65E, 0xA65E, 0xA660, 0xA660,
	0xA662, 0xA662, 0xA664, 0xA664, 0xA666, 0xA666, 0xA668, 0xA668,
	0xA66A, 0xA66A, 0xA66C, 0xA66C, 0xA680, 0xA680, 0xA682, 0xA682,
	0xA684, 0xA684, 0xA686, 0xA686, 0xA688, 0xA688, 0xA68A, 0xA68A,
	0xA68C, 0xA68C, 0xA68E, 0xA68E, 0xA690, 0xA690, 0xA692, 0xA692,
	0xA694, 0xA694, 0xA696, 0xA696, 0xA698, 0xA698, 0xA69A, 0xA69A,
	0xA722, 0xA722, 0xA724, 0xA724, 0xA726, 0xA726, 0xA728, 0xA728,
	0xA72A, 0xA72A, 0xA72C, 0xA72C, 0xA72E, 0xA72E, 0xA732, 0xA732,
	0xA734, 0xA734, 0xA736, 0xA736, 0xA738, 0xA738, 0xA73A, 0xA73A,
	0xA73C, 0xA73C, 0xA73E, 0xA73E, 0xA740, 0xA740, 0xA742, 0xA742,
	0xA744, 0xA744, 0xA746, 0xA746, 0xA748, 0xA748, 0xA74A, 0xA74A,
	0xA74C, 0xA74C, 0xA74E, 0xA74E, 0xA750, 0xA750, 0xA752, 0xA752,
	0xA754, 0xA754, 0xA756, 0xA756, 0xA758, 0xA758, 0xA75A, 0xA75A,
	0xA75C, 0xA75C, 0xA75E, 0xA75E, 0xA760, 0xA760, 0xA762, 0xA762,
	0xA764, 0xA764, 0xA766, 0xA766, 0xA768, 0xA768, 0xA76A, 0xA76A,
	0xA76C, 0xA76C, 0xA76E, 0xA76E, 0xA779, 0xA779, 0xA77B, 0xA77B,
	0xA77D, 0xA77E, 0xA780, 0xA780, 0xA782, 0xA782, 0xA784, 0xA784,
	0xA786, 0xA786, 0xA78B, 0xA78B, 0xA78D, 0xA78D, 0xA790, 0xA790,
	0xA792, 0xA792, 0xA796, 0xA796, 0xA798, 0xA798, 0xA79A, 0xA79A,
	0xA79C, 0xA79C, 0xA79E, 0xA79E, 0xA7A0, 0xA7A0, 0xA7A2, 0xA7A2,
	0xA7A4, 0xA7A4, 0xA7A6, 0xA7A6, 0xA7A8, 0xA7A8, 0xA7AA, 0xA7AE,
	0xA7B0, 0xA7B4, 0xA7B6, 0xA7B6, 0xA7B8, 0xA7B8, 0xA7BA, 0xA7BA,
	0xA7BC, 0xA7BC, 0xA7BE, 0xA7BE, 0xA7C2, 0xA7C2, 0xA7C4, 0xA7C6,
	0xFF21, 0xFF3A, 0x10400, 0x10427, 0x104B0, 0x104D3, 0x10C80, 0x10CB2,
	0x118A0, 0x118BF, 0x16E40, 0x16E5F, 0x1E900, 0x1E921,
	//  #51 (6497+823): bp=Changes_When_NFKC_Casefolded:CWKCF
	0x0041, 0x005A, 0x00A0, 0x00A0, 0x00A8, 0x00A8, 0x00AA, 0x00AA,
	0x00AD, 0x00AD, 0x00AF, 0x00AF, 0x00B2, 0x00B5, 0x00B8, 0x00BA,
	0x00BC, 0x00BE, 0x00C0, 0x00D6, 0x00D8, 0x00DF, 0x0100, 0x0100,
	0x0102, 0x0102, 0x0104, 0x0104, 0x0106, 0x0106, 0x0108, 0x0108,
	0x010A, 0x010A, 0x010C, 0x010C, 0x010E, 0x010E, 0x0110, 0x0110,
	0x0112, 0x0112, 0x0114, 0x0114, 0x0116, 0x0116, 0x0118, 0x0118,
	0x011A, 0x011A, 0x011C, 0x011C, 0x011E, 0x011E, 0x0120, 0x0120,
	0x0122, 0x0122, 0x0124, 0x0124, 0x0126, 0x0126, 0x0128, 0x0128,
	0x012A, 0x012A, 0x012C, 0x012C, 0x012E, 0x012E, 0x0130, 0x0130,
	0x0132, 0x0134, 0x0136, 0x0136, 0x0139, 0x0139, 0x013B, 0x013B,
	0x013D, 0x013D, 0x013F, 0x0141, 0x0143, 0x0143, 0x0145, 0x0145,
	0x0147, 0x0147, 0x0149, 0x014A, 0x014C, 0x014C, 0x014E, 0x014E,
	0x0150, 0x0150, 0x0152, 0x0152, 0x0154, 0x0154, 0x0156, 0x0156,
	0x0158, 0x0158, 0x015A, 0x015A, 0x015C, 0x015C, 0x015E, 0x015E,
	0x0160, 0x0160, 0x0162, 0x0162, 0x0164, 0x0164, 0x0166, 0x0166,
	0x0168, 0x0168, 0x016A, 0x016A, 0x016C, 0x016C, 0x016E, 0x016E,
	0x0170, 0x0170, 0x0172, 0x0172, 0x0174, 0x0174, 0x0176, 0x0176,
	0x0178, 0x0179, 0x017B, 0x017B, 0x017D, 0x017D, 0x017F, 0x017F,
	0x0181, 0x0182, 0x0184, 0x0184, 0x0186, 0x0187, 0x0189, 0x018B,
	0x018E, 0x0191, 0x0193, 0x0194, 0x0196, 0x0198, 0x019C, 0x019D,
	0x019F, 0x01A0, 0x01A2, 0x01A2, 0x01A4, 0x01A4, 0x01A6, 0x01A7,
	0x01A9, 0x01A9, 0x01AC, 0x01AC, 0x01AE, 0x01AF, 0x01B1, 0x01B3,
	0x01B5, 0x01B5, 0x01B7, 0x01B8, 0x01BC, 0x01BC, 0x01C4, 0x01CD,
	0x01CF, 0x01CF, 0x01D1, 0x01D1, 0x01D3, 0x01D3, 0x01D5, 0x01D5,
	0x01D7, 0x01D7, 0x01D9, 0x01D9, 0x01DB, 0x01DB, 0x01DE, 0x01DE,
	0x01E0, 0x01E0, 0x01E2, 0x01E2, 0x01E4, 0x01E4, 0x01E6, 0x01E6,
	0x01E8, 0x01E8, 0x01EA, 0x01EA, 0x01EC, 0x01EC, 0x01EE, 0x01EE,
	0x01F1, 0x01F4, 0x01F6, 0x01F8, 0x01FA, 0x01FA, 0x01FC, 0x01FC,
	0x01FE, 0x01FE, 0x0200, 0x0200, 0x0202, 0x0202, 0x0204, 0x0204,
	0x0206, 0x0206, 0x0208, 0x0208, 0x020A, 0x020A, 0x020C, 0x020C,
	0x020E, 0x020E, 0x0210, 0x0210, 0x0212, 0x0212, 0x0214, 0x0214,
	0x0216, 0x0216, 0x0218, 0x0218, 0x021A, 0x021A, 0x021C, 0x021C,
	0x021E, 0x021E, 0x0220, 0x0220, 0x0222, 0x0222, 0x0224, 0x0224,
	0x0226, 0x0226, 0x0228, 0x0228, 0x022A, 0x022A, 0x022C, 0x022C,
	0x022E, 0x022E, 0x0230, 0x0230, 0x0232, 0x0232, 0x023A, 0x023B,
	0x023D, 0x023E, 0x0241, 0x0241, 0x0243, 0x0246, 0x0248, 0x0248,
	0x024A, 0x024A, 0x024C, 0x024C, 0x024E, 0x024E, 0x02B0, 0x02B8,
	0x02D8, 0x02DD, 0x02E0, 0x02E4, 0x0340, 0x0341, 0x0343, 0x0345,
	0x034F, 0x034F, 0x0370, 0x0370, 0x0372, 0x0372, 0x0374, 0x0374,
	0x0376, 0x0376, 0x037A, 0x037A, 0x037E, 0x037F, 0x0384, 0x038A,
	0x038C, 0x038C, 0x038E, 0x038F, 0x0391, 0x03A1, 0x03A3, 0x03AB,
	0x03C2, 0x03C2, 0x03CF, 0x03D6, 0x03D8, 0x03D8, 0x03DA, 0x03DA,
	0x03DC, 0x03DC, 0x03DE, 0x03DE, 0x03E0, 0x03E0, 0x03E2, 0x03E2,
	0x03E4, 0x03E4, 0x03E6, 0x03E6, 0x03E8, 0x03E8, 0x03EA, 0x03EA,
	0x03EC, 0x03EC, 0x03EE, 0x03EE, 0x03F0, 0x03F2, 0x03F4, 0x03F5,
	0x03F7, 0x03F7, 0x03F9, 0x03FA, 0x03FD, 0x042F, 0x0460, 0x0460,
	0x0462, 0x0462, 0x0464, 0x0464, 0x0466, 0x0466, 0x0468, 0x0468,
	0x046A, 0x046A, 0x046C, 0x046C, 0x046E, 0x046E, 0x0470, 0x0470,
	0x0472, 0x0472, 0x0474, 0x0474, 0x0476, 0x0476, 0x0478, 0x0478,
	0x047A, 0x047A, 0x047C, 0x047C, 0x047E, 0x047E, 0x0480, 0x0480,
	0x048A, 0x048A, 0x048C, 0x048C, 0x048E, 0x048E, 0x0490, 0x0490,
	0x0492, 0x0492, 0x0494, 0x0494, 0x0496, 0x0496, 0x0498, 0x0498,
	0x049A, 0x049A, 0x049C, 0x049C, 0x049E, 0x049E, 0x04A0, 0x04A0,
	0x04A2, 0x04A2, 0x04A4, 0x04A4, 0x04A6, 0x04A6, 0x04A8, 0x04A8,
	0x04AA, 0x04AA, 0x04AC, 0x04AC, 0x04AE, 0x04AE, 0x04B0, 0x04B0,
	0x04B2, 0x04B2, 0x04B4, 0x04B4, 0x04B6, 0x04B6, 0x04B8, 0x04B8,
	0x04BA, 0x04BA, 0x04BC, 0x04BC, 0x04BE, 0x04BE, 0x04C0, 0x04C1,
	0x04C3, 0x04C3, 0x04C5, 0x04C5, 0x04C7, 0x04C7, 0x04C9, 0x04C9,
	0x04CB, 0x04CB, 0x04CD, 0x04CD, 0x04D0, 0x04D0, 0x04D2, 0x04D2,
	0x04D4, 0x04D4, 0x04D6, 0x04D6, 0x04D8, 0x04D8, 0x04DA, 0x04DA,
	0x04DC, 0x04DC, 0x04DE, 0x04DE, 0x04E0, 0x04E0, 0x04E2, 0x04E2,
	0x04E4, 0x04E4, 0x04E6, 0x04E6, 0x04E8, 0x04E8, 0x04EA, 0x04EA,
	0x04EC, 0x04EC, 0x04EE, 0x04EE, 0x04F0, 0x04F0, 0x04F2, 0x04F2,
	0x04F4, 0x04F4, 0x04F6, 0x04F6, 0x04F8, 0x04F8, 0x04FA, 0x04FA,
	0x04FC, 0x04FC, 0x04FE, 0x04FE, 0x0500, 0x0500, 0x0502, 0x0502,
	0x0504, 0x0504, 0x0506, 0x0506, 0x0508, 0x0508, 0x050A, 0x050A,
	0x050C, 0x050C, 0x050E, 0x050E, 0x0510, 0x0510, 0x0512, 0x0512,
	0x0514, 0x0514, 0x0516, 0x0516, 0x0518, 0x0518, 0x051A, 0x051A,
	0x051C, 0x051C, 0x051E, 0x051E, 0x0520, 0x0520, 0x0522, 0x0522,
	0x0524, 0x0524, 0x0526, 0x0526, 0x0528, 0x0528, 0x052A, 0x052A,
	0x052C, 0x052C, 0x052E, 0x052E, 0x0531, 0x0556, 0x0587, 0x0587,
	0x061C, 0x061C, 0x0675, 0x0678, 0x0958, 0x095F, 0x09DC, 0x09DD,
	0x09DF, 0x09DF, 0x0A33, 0x0A33, 0x0A36, 0x0A36, 0x0A59, 0x0A5B,
	0x0A5E, 0x0A5E, 0x0B5C, 0x0B5D, 0x0E33, 0x0E33, 0x0EB3, 0x0EB3,
	0x0EDC, 0x0EDD, 0x0F0C, 0x0F0C, 0x0F43, 0x0F43, 0x0F4D, 0x0F4D,
	0x0F52, 0x0F52, 0x0F57, 0x0F57, 0x0F5C, 0x0F5C, 0x0F69, 0x0F69,
	0x0F73, 0x0F73, 0x0F75, 0x0F79, 0x0F81, 0x0F81, 0x0F93, 0x0F93,
	0x0F9D, 0x0F9D, 0x0FA2, 0x0FA2, 0x0FA7, 0x0FA7, 0x0FAC, 0x0FAC,
	0x0FB9, 0x0FB9, 0x10A0, 0x10C5, 0x10C7, 0x10C7, 0x10CD, 0x10CD,
	0x10FC, 0x10FC, 0x115F, 0x1160, 0x13F8, 0x13FD, 0x17B4, 0x17B5,
	0x180B, 0x180E, 0x1C80, 0x1C88, 0x1C90, 0x1CBA, 0x1CBD, 0x1CBF,
	0x1D2C, 0x1D2E, 0x1D30, 0x1D3A, 0x1D3C, 0x1D4D, 0x1D4F, 0x1D6A,
	0x1D78, 0x1D78, 0x1D9B, 0x1DBF, 0x1E00, 0x1E00, 0x1E02, 0x1E02,
	0x1E04, 0x1E04, 0x1E06, 0x1E06, 0x1E08, 0x1E08, 0x1E0A, 0x1E0A,
	0x1E0C, 0x1E0C, 0x1E0E, 0x1E0E, 0x1E10, 0x1E10, 0x1E12, 0x1E12,
	0x1E14, 0x1E14, 0x1E16, 0x1E16, 0x1E18, 0x1E18, 0x1E1A, 0x1E1A,
	0x1E1C, 0x1E1C, 0x1E1E, 0x1E1E, 0x1E20, 0x1E20, 0x1E22, 0x1E22,
	0x1E24, 0x1E24, 0x1E26, 0x1E26, 0x1E28, 0x1E28, 0x1E2A, 0x1E2A,
	0x1E2C, 0x1E2C, 0x1E2E, 0x1E2E, 0x1E30, 0x1E30, 0x1E32, 0x1E32,
	0x1E34, 0x1E34, 0x1E36, 0x1E36, 0x1E38, 0x1E38, 0x1E3A, 0x1E3A,
	0x1E3C, 0x1E3C, 0x1E3E, 0x1E3E, 0x1E40, 0x1E40, 0x1E42, 0x1E42,
	0x1E44, 0x1E44, 0x1E46, 0x1E46, 0x1E48, 0x1E48, 0x1E4A, 0x1E4A,
	0x1E4C, 0x1E4C, 0x1E4E, 0x1E4E, 0x1E50, 0x1E50, 0x1E52, 0x1E52,
	0x1E54, 0x1E54, 0x1E56, 0x1E56, 0x1E58, 0x1E58, 0x1E5A, 0x1E5A,
	0x1E5C, 0x1E5C, 0x1E5E, 0x1E5E, 0x1E60, 0x1E60, 0x1E62, 0x1E62,
	0x1E64, 0x1E64, 0x1E66, 0x1E66, 0x1E68, 0x1E68, 0x1E6A, 0x1E6A,
	0x1E6C, 0x1E6C, 0x1E6E, 0x1E6E, 0x1E70, 0x1E70, 0x1E72, 0x1E72,
	0x1E74, 0x1E74, 0x1E76, 0x1E76, 0x1E78, 0x1E78, 0x1E7A, 0x1E7A,
	0x1E7C, 0x1E7C, 0x1E7E, 0x1E7E, 0x1E80, 0x1E80, 0x1E82, 0x1E82,
	0x1E84, 0x1E84, 0x1E86, 0x1E86, 0x1E88, 0x1E88, 0x1E8A, 0x1E8A,
	0x1E8C, 0x1E8C, 0x1E8E, 0x1E8E, 0x1E90, 0x1E90, 0x1E92, 0x1E92,
	0x1E94, 0x1E94, 0x1E9A, 0x1E9B, 0x1E9E, 0x1E9E, 0x1EA0, 0x1EA0,
	0x1EA2, 0x1EA2, 0x1EA4, 0x1EA4, 0x1EA6, 0x1EA6, 0x1EA8, 0x1EA8,
	0x1EAA, 0x1EAA, 0x1EAC, 0x1EAC, 0x1EAE, 0x1EAE, 0x1EB0, 0x1EB0,
	0x1EB2, 0x1EB2, 0x1EB4, 0x1EB4, 0x1EB6, 0x1EB6, 0x1EB8, 0x1EB8,
	0x1EBA, 0x1EBA, 0x1EBC, 0x1EBC, 0x1EBE, 0x1EBE, 0x1EC0, 0x1EC0,
	0x1EC2, 0x1EC2, 0x1EC4, 0x1EC4, 0x1EC6, 0x1EC6, 0x1EC8, 0x1EC8,
	0x1ECA, 0x1ECA, 0x1ECC, 0x1ECC, 0x1ECE, 0x1ECE, 0x1ED0, 0x1ED0,
	0x1ED2, 0x1ED2, 0x1ED4, 0x1ED4, 0x1ED6, 0x1ED6, 0x1ED8, 0x1ED8,
	0x1EDA, 0x1EDA, 0x1EDC, 0x1EDC, 0x1EDE, 0x1EDE, 0x1EE0, 0x1EE0,
	0x1EE2, 0x1EE2, 0x1EE4, 0x1EE4, 0x1EE6, 0x1EE6, 0x1EE8, 0x1EE8,
	0x1EEA, 0x1EEA, 0x1EEC, 0x1EEC, 0x1EEE, 0x1EEE, 0x1EF0, 0x1EF0,
	0x1EF2, 0x1EF2, 0x1EF4, 0x1EF4, 0x1EF6, 0x1EF6, 0x1EF8, 0x1EF8,
	0x1EFA, 0x1EFA, 0x1EFC, 0x1EFC, 0x1EFE, 0x1EFE, 0x1F08, 0x1F0F,
	0x1F18, 0x1F1D, 0x1F28, 0x1F2F, 0x1F38, 0x1F3F, 0x1F48, 0x1F4D,
	0x1F59, 0x1F59, 0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F5F,
	0x1F68, 0x1F6F, 0x1F71, 0x1F71, 0x1F73, 0x1F73, 0x1F75, 0x1F75,
	0x1F77, 0x1F77, 0x1F79, 0x1F79, 0x1F7B, 0x1F7B, 0x1F7D, 0x1F7D,
	0x1F80, 0x1FAF, 0x1FB2, 0x1FB4, 0x1FB7, 0x1FC4, 0x1FC7, 0x1FCF,
	0x1FD3, 0x1FD3, 0x1FD8, 0x1FDB, 0x1FDD, 0x1FDF, 0x1FE3, 0x1FE3,
	0x1FE8, 0x1FEF, 0x1FF2, 0x1FF4, 0x1FF7, 0x1FFE, 0x2000, 0x200F,
	0x2011, 0x2011, 0x2017, 0x2017, 0x2024, 0x2026, 0x202A, 0x202F,
	0x2033, 0x2034, 0x2036, 0x2037, 0x203C, 0x203C, 0x203E, 0x203E,
	0x2047, 0x2049, 0x2057, 0x2057, 0x205F, 0x2071, 0x2074, 0x208E,
	0x2090, 0x209C, 0x20A8, 0x20A8, 0x2100, 0x2103, 0x2105, 0x2107,
	0x2109, 0x2113, 0x2115, 0x2116, 0x2119, 0x211D, 0x2120, 0x2122,
	0x2124, 0x2124, 0x2126, 0x2126, 0x2128, 0x2128, 0x212A, 0x212D,
	0x212F, 0x2139, 0x213B, 0x2140, 0x2145, 0x2149, 0x2150, 0x217F,
	0x2183, 0x2183, 0x2189, 0x2189, 0x222C, 0x222D, 0x222F, 0x2230,
	0x2329, 0x232A, 0x2460, 0x24EA, 0x2A0C, 0x2A0C, 0x2A74, 0x2A76,
	0x2ADC, 0x2ADC, 0x2C00, 0x2C2E, 0x2C60, 0x2C60, 0x2C62, 0x2C64,
	0x2C67, 0x2C67, 0x2C69, 0x2C69, 0x2C6B, 0x2C6B, 0x2C6D, 0x2C70,
	0x2C72, 0x2C72, 0x2C75, 0x2C75, 0x2C7C, 0x2C80, 0x2C82, 0x2C82,
	0x2C84, 0x2C84, 0x2C86, 0x2C86, 0x2C88, 0x2C88, 0x2C8A, 0x2C8A,
	0x2C8C, 0x2C8C, 0x2C8E, 0x2C8E, 0x2C90, 0x2C90, 0x2C92, 0x2C92,
	0x2C94, 0x2C94, 0x2C96, 0x2C96, 0x2C98, 0x2C98, 0x2C9A, 0x2C9A,
	0x2C9C, 0x2C9C, 0x2C9E, 0x2C9E, 0x2CA0, 0x2CA0, 0x2CA2, 0x2CA2,
	0x2CA4, 0x2CA4, 0x2CA6, 0x2CA6, 0x2CA8, 0x2CA8, 0x2CAA, 0x2CAA,
	0x2CAC, 0x2CAC, 0x2CAE, 0x2CAE, 0x2CB0, 0x2CB0, 0x2CB2, 0x2CB2,
	0x2CB4, 0x2CB4, 0x2CB6, 0x2CB6, 0x2CB8, 0x2CB8, 0x2CBA, 0x2CBA,
	0x2CBC, 0x2CBC, 0x2CBE, 0x2CBE, 0x2CC0, 0x2CC0, 0x2CC2, 0x2CC2,
	0x2CC4, 0x2CC4, 0x2CC6, 0x2CC6, 0x2CC8, 0x2CC8, 0x2CCA, 0x2CCA,
	0x2CCC, 0x2CCC, 0x2CCE, 0x2CCE, 0x2CD0, 0x2CD0, 0x2CD2, 0x2CD2,
	0x2CD4, 0x2CD4, 0x2CD6, 0x2CD6, 0x2CD8, 0x2CD8, 0x2CDA, 0x2CDA,
	0x2CDC, 0x2CDC, 0x2CDE, 0x2CDE, 0x2CE0, 0x2CE0, 0x2CE2, 0x2CE2,
	0x2CEB, 0x2CEB, 0x2CED, 0x2CED, 0x2CF2, 0x2CF2, 0x2D6F, 0x2D6F,
	0x2E9F, 0x2E9F, 0x2EF3, 0x2EF3, 0x2F00, 0x2FD5, 0x3000, 0x3000,
	0x3036, 0x3036, 0x3038, 0x303A, 0x309B, 0x309C, 0x309F, 0x309F,
	0x30FF, 0x30FF, 0x3131, 0x318E, 0x3192, 0x319F, 0x3200, 0x321E,
	0x3220, 0x3247, 0x3250, 0x327E, 0x3280, 0x33FF, 0xA640, 0xA640,
	0xA642, 0xA642, 0xA644, 0xA644, 0xA646, 0xA646, 0xA648, 0xA648,
	0xA64A, 0xA64A, 0xA64C, 0xA64C, 0xA64E, 0xA64E, 0xA650, 0xA650,
	0xA652, 0xA652, 0xA654, 0xA654, 0xA656, 0xA656, 0xA658, 0xA658,
	0xA65A, 0xA65A, 0xA65C, 0xA65C, 0xA65E, 0xA65E, 0xA660, 0xA660,
	0xA662, 0xA662, 0xA664, 0xA664, 0xA666, 0xA666, 0xA668, 0xA668,
	0xA66A, 0xA66A, 0xA66C, 0xA66C, 0xA680, 0xA680, 0xA682, 0xA682,
	0xA684, 0xA684, 0xA686, 0xA686, 0xA688, 0xA688, 0xA68A, 0xA68A,
	0xA68C, 0xA68C, 0xA68E, 0xA68E, 0xA690, 0xA690, 0xA692, 0xA692,
	0xA694, 0xA694, 0xA696, 0xA696, 0xA698, 0xA698, 0xA69A, 0xA69A,
	0xA69C, 0xA69D, 0xA722, 0xA722, 0xA724, 0xA724, 0xA726, 0xA726,
	0xA728, 0xA728, 0xA72A, 0xA72A, 0xA72C, 0xA72C, 0xA72E, 0xA72E,
	0xA732, 0xA732, 0xA734, 0xA734, 0xA736, 0xA736, 0xA738, 0xA738,
	0xA73A, 0xA73A, 0xA73C, 0xA73C, 0xA73E, 0xA73E, 0xA740, 0xA740,
	0xA742, 0xA742, 0xA744, 0xA744, 0xA746, 0xA746, 0xA748, 0xA748,
	0xA74A, 0xA74A, 0xA74C, 0xA74C, 0xA74E, 0xA74E, 0xA750, 0xA750,
	0xA752, 0xA752, 0xA754, 0xA754, 0xA756, 0xA756, 0xA758, 0xA758,
	0xA75A, 0xA75A, 0xA75C, 0xA75C, 0xA75E, 0xA75E, 0xA760, 0xA760,
	0xA762, 0xA762, 0xA764, 0xA764, 0xA766, 0xA766, 0xA768, 0xA768,
	0xA76A, 0xA76A, 0xA76C, 0xA76C, 0xA76E, 0xA76E, 0xA770, 0xA770,
	0xA779, 0xA779, 0xA77B, 0xA77B, 0xA77D, 0xA77E, 0xA780, 0xA780,
	0xA782, 0xA782, 0xA784, 0xA784, 0xA786, 0xA786, 0xA78B, 0xA78B,
	0xA78D, 0xA78D, 0xA790, 0xA790, 0xA792, 0xA792, 0xA796, 0xA796,
	0xA798, 0xA798, 0xA79A, 0xA79A, 0xA79C, 0xA79C, 0xA79E, 0xA79E,
	0xA7A0, 0xA7A0, 0xA7A2, 0xA7A2, 0xA7A4, 0xA7A4, 0xA7A6, 0xA7A6,
	0xA7A8, 0xA7A8, 0xA7AA, 0xA7AE, 0xA7B0, 0xA7B4, 0xA7B6, 0xA7B6,
	0xA7B8, 0xA7B8, 0xA7BA, 0xA7BA, 0xA7BC, 0xA7BC, 0xA7BE, 0xA7BE,
	0xA7C2, 0xA7C2, 0xA7C4, 0xA7C6, 0xA7F8, 0xA7F9, 0xAB5C, 0xAB5F,
	0xAB70, 0xABBF, 0xF900, 0xFA0D, 0xFA10, 0xFA10, 0xFA12, 0xFA12,
	0xFA15, 0xFA1E, 0xFA20, 0xFA20, 0xFA22, 0xFA22, 0xFA25, 0xFA26,
	0xFA2A, 0xFA6D, 0xFA70, 0xFAD9, 0xFB00, 0xFB06, 0xFB13, 0xFB17,
	0xFB1D, 0xFB1D, 0xFB1F, 0xFB36, 0xFB38, 0xFB3C, 0xFB3E, 0xFB3E,
	0xFB40, 0xFB41, 0xFB43, 0xFB44, 0xFB46, 0xFBB1, 0xFBD3, 0xFD3D,
	0xFD50, 0xFD8F, 0xFD92, 0xFDC7, 0xFDF0, 0xFDFC, 0xFE00, 0xFE19,
	0xFE30, 0xFE44, 0xFE47, 0xFE52, 0xFE54, 0xFE66, 0xFE68, 0xFE6B,
	0xFE70, 0xFE72, 0xFE74, 0xFE74, 0xFE76, 0xFEFC, 0xFEFF, 0xFEFF,
	0xFF01, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF, 0xFFD2, 0xFFD7,
	0xFFDA, 0xFFDC, 0xFFE0, 0xFFE6, 0xFFE8, 0xFFEE, 0xFFF0, 0xFFF8,
	0x10400, 0x10427, 0x104B0, 0x104D3, 0x10C80, 0x10CB2, 0x118A0, 0x118BF,
	0x16E40, 0x16E5F, 0x1BCA0, 0x1BCA3, 0x1D15E, 0x1D164, 0x1D173, 0x1D17A,
	0x1D1BB, 0x1D1C0, 0x1D400, 0x1D454, 0x1D456, 0x1D49C, 0x1D49E, 0x1D49F,
	0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B9,
	0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505, 0x1D507, 0x1D50A,
	0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539, 0x1D53B, 0x1D53E,
	0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550, 0x1D552, 0x1D6A5,
	0x1D6A8, 0x1D7CB, 0x1D7CE, 0x1D7FF, 0x1E900, 0x1E921, 0x1EE00, 0x1EE03,
	0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22, 0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27,
	0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37, 0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B,
	0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47, 0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B,
	0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57,
	0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B, 0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F,
	0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64, 0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72,
	0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C, 0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89,
	0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3, 0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB,
	0x1F100, 0x1F10A, 0x1F110, 0x1F12E, 0x1F130, 0x1F14F, 0x1F16A, 0x1F16C,
	0x1F190, 0x1F190, 0x1F200, 0x1F202, 0x1F210, 0x1F23B, 0x1F240, 0x1F248,
	0x1F250, 0x1F251, 0x2F800, 0x2FA1D, 0xE0000, 0xE0FFF,
	//  #52 (7320+615): bp=Changes_When_Titlecased:CWT
	0x0061, 0x007A, 0x00B5, 0x00B5, 0x00DF, 0x00F6, 0x00F8, 0x00FF,
	0x0101, 0x0101, 0x0103, 0x0103, 0x0105, 0x0105, 0x0107, 0x0107,
	0x0109, 0x0109, 0x010B, 0x010B, 0x010D, 0x010D, 0x010F, 0x010F,
	0x0111, 0x0111, 0x0113, 0x0113, 0x0115, 0x0115, 0x0117, 0x0117,
	0x0119, 0x0119, 0x011B, 0x011B, 0x011D, 0x011D, 0x011F, 0x011F,
	0x0121, 0x0121, 0x0123, 0x0123, 0x0125, 0x0125, 0x0127, 0x0127,
	0x0129, 0x0129, 0x012B, 0x012B, 0x012D, 0x012D, 0x012F, 0x012F,
	0x0131, 0x0131, 0x0133, 0x0133, 0x0135, 0x0135, 0x0137, 0x0137,
	0x013A, 0x013A, 0x013C, 0x013C, 0x013E, 0x013E, 0x0140, 0x0140,
	0x0142, 0x0142, 0x0144, 0x0144, 0x0146, 0x0146, 0x0148, 0x0149,
	0x014B, 0x014B, 0x014D, 0x014D, 0x014F, 0x014F, 0x0151, 0x0151,
	0x0153, 0x0153, 0x0155, 0x0155, 0x0157, 0x0157, 0x0159, 0x0159,
	0x015B, 0x015B, 0x015D, 0x015D, 0x015F, 0x015F, 0x0161, 0x0161,
	0x0163, 0x0163, 0x0165, 0x0165, 0x0167, 0x0167, 0x0169, 0x0169,
	0x016B, 0x016B, 0x016D, 0x016D, 0x016F, 0x016F, 0x0171, 0x0171,
	0x0173, 0x0173, 0x0175, 0x0175, 0x0177, 0x0177, 0x017A, 0x017A,
	0x017C, 0x017C, 0x017E, 0x0180, 0x0183, 0x0183, 0x0185, 0x0185,
	0x0188, 0x0188, 0x018C, 0x018C, 0x0192, 0x0192, 0x0195, 0x0195,
	0x0199, 0x019A, 0x019E, 0x019E, 0x01A1, 0x01A1, 0x01A3, 0x01A3,
	0x01A5, 0x01A5, 0x01A8, 0x01A8, 0x01AD, 0x01AD, 0x01B0, 0x01B0,
	0x01B4, 0x01B4, 0x01B6, 0x01B6, 0x01B9, 0x01B9, 0x01BD, 0x01BD,
	0x01BF, 0x01BF, 0x01C4, 0x01C4, 0x01C6, 0x01C7, 0x01C9, 0x01CA,
	0x01CC, 0x01CC, 0x01CE, 0x01CE, 0x01D0, 0x01D0, 0x01D2, 0x01D2,
	0x01D4, 0x01D4, 0x01D6, 0x01D6, 0x01D8, 0x01D8, 0x01DA, 0x01DA,
	0x01DC, 0x01DD, 0x01DF, 0x01DF, 0x01E1, 0x01E1, 0x01E3, 0x01E3,
	0x01E5, 0x01E5, 0x01E7, 0x01E7, 0x01E9, 0x01E9, 0x01EB, 0x01EB,
	0x01ED, 0x01ED, 0x01EF, 0x01F1, 0x01F3, 0x01F3, 0x01F5, 0x01F5,
	0x01F9, 0x01F9, 0x01FB, 0x01FB, 0x01FD, 0x01FD, 0x01FF, 0x01FF,
	0x0201, 0x0201, 0x0203, 0x0203, 0x0205, 0x0205, 0x0207, 0x0207,
	0x0209, 0x0209, 0x020B, 0x020B, 0x020D, 0x020D, 0x020F, 0x020F,
	0x0211, 0x0211, 0x0213, 0x0213, 0x0215, 0x0215, 0x0217, 0x0217,
	0x0219, 0x0219, 0x021B, 0x021B, 0x021D, 0x021D, 0x021F, 0x021F,
	0x0223, 0x0223, 0x0225, 0x0225, 0x0227, 0x0227, 0x0229, 0x0229,
	0x022B, 0x022B, 0x022D, 0x022D, 0x022F, 0x022F, 0x0231, 0x0231,
	0x0233, 0x0233, 0x023C, 0x023C, 0x023F, 0x0240, 0x0242, 0x0242,
	0x0247, 0x0247, 0x0249, 0x0249, 0x024B, 0x024B, 0x024D, 0x024D,
	0x024F, 0x0254, 0x0256, 0x0257, 0x0259, 0x0259, 0x025B, 0x025C,
	0x0260, 0x0261, 0x0263, 0x0263, 0x0265, 0x0266, 0x0268, 0x026C,
	0x026F, 0x026F, 0x0271, 0x0272, 0x0275, 0x0275, 0x027D, 0x027D,
	0x0280, 0x0280, 0x0282, 0x0283, 0x0287, 0x028C, 0x0292, 0x0292,
	0x029D, 0x029E, 0x0345, 0x0345, 0x0371, 0x0371, 0x0373, 0x0373,
	0x0377, 0x0377, 0x037B, 0x037D, 0x0390, 0x0390, 0x03AC, 0x03CE,
	0x03D0, 0x03D1, 0x03D5, 0x03D7, 0x03D9, 0x03D9, 0x03DB, 0x03DB,
	0x03DD, 0x03DD, 0x03DF, 0x03DF, 0x03E1, 0x03E1, 0x03E3, 0x03E3,
	0x03E5, 0x03E5, 0x03E7, 0x03E7, 0x03E9, 0x03E9, 0x03EB, 0x03EB,
	0x03ED, 0x03ED, 0x03EF, 0x03F3, 0x03F5, 0x03F5, 0x03F8, 0x03F8,
	0x03FB, 0x03FB, 0x0430, 0x045F, 0x0461, 0x0461, 0x0463, 0x0463,
	0x0465, 0x0465, 0x0467, 0x0467, 0x0469, 0x0469, 0x046B, 0x046B,
	0x046D, 0x046D, 0x046F, 0x046F, 0x0471, 0x0471, 0x0473, 0x0473,
	0x0475, 0x0475, 0x0477, 0x0477, 0x0479, 0x0479, 0x047B, 0x047B,
	0x047D, 0x047D, 0x047F, 0x047F, 0x0481, 0x0481, 0x048B, 0x048B,
	0x048D, 0x048D, 0x048F, 0x048F, 0x0491, 0x0491, 0x0493, 0x0493,
	0x0495, 0x0495, 0x0497, 0x0497, 0x0499, 0x0499, 0x049B, 0x049B,
	0x049D, 0x049D, 0x049F, 0x049F, 0x04A1, 0x04A1, 0x04A3, 0x04A3,
	0x04A5, 0x04A5, 0x04A7, 0x04A7, 0x04A9, 0x04A9, 0x04AB, 0x04AB,
	0x04AD, 0x04AD, 0x04AF, 0x04AF, 0x04B1, 0x04B1, 0x04B3, 0x04B3,
	0x04B5, 0x04B5, 0x04B7, 0x04B7, 0x04B9, 0x04B9, 0x04BB, 0x04BB,
	0x04BD, 0x04BD, 0x04BF, 0x04BF, 0x04C2, 0x04C2, 0x04C4, 0x04C4,
	0x04C6, 0x04C6, 0x04C8, 0x04C8, 0x04CA, 0x04CA, 0x04CC, 0x04CC,
	0x04CE, 0x04CF, 0x04D1, 0x04D1, 0x04D3, 0x04D3, 0x04D5, 0x04D5,
	0x04D7, 0x04D7, 0x04D9, 0x04D9, 0x04DB, 0x04DB, 0x04DD, 0x04DD,
	0x04DF, 0x04DF, 0x04E1, 0x04E1, 0x04E3, 0x04E3, 0x04E5, 0x04E5,
	0x04E7, 0x04E7, 0x04E9, 0x04E9, 0x04EB, 0x04EB, 0x04ED, 0x04ED,
	0x04EF, 0x04EF, 0x04F1, 0x04F1, 0x04F3, 0x04F3, 0x04F5, 0x04F5,
	0x04F7, 0x04F7, 0x04F9, 0x04F9, 0x04FB, 0x04FB, 0x04FD, 0x04FD,
	0x04FF, 0x04FF, 0x0501, 0x0501, 0x0503, 0x0503, 0x0505, 0x0505,
	0x0507, 0x0507, 0x0509, 0x0509, 0x050B, 0x050B, 0x050D, 0x050D,
	0x050F, 0x050F, 0x0511, 0x0511, 0x0513, 0x0513, 0x0515, 0x0515,
	0x0517, 0x0517, 0x0519, 0x0519, 0x051B, 0x051B, 0x051D, 0x051D,
	0x051F, 0x051F, 0x0521, 0x0521, 0x0523, 0x0523, 0x0525, 0x0525,
	0x0527, 0x0527, 0x0529, 0x0529, 0x052B, 0x052B, 0x052D, 0x052D,
	0x052F, 0x052F, 0x0561, 0x0587, 0x13F8, 0x13FD, 0x1C80, 0x1C88,
	0x1D79, 0x1D79, 0x1D7D, 0x1D7D, 0x1D8E, 0x1D8E, 0x1E01, 0x1E01,
	0x1E03, 0x1E03, 0x1E05, 0x1E05, 0x1E07, 0x1E07, 0x1E09, 0x1E09,
	0x1E0B, 0x1E0B, 0x1E0D, 0x1E0D, 0x1E0F, 0x1E0F, 0x1E11, 0x1E11,
	0x1E13, 0x1E13, 0x1E15, 0x1E15, 0x1E17, 0x1E17, 0x1E19, 0x1E19,
	0x1E1B, 0x1E1B, 0x1E1D, 0x1E1D, 0x1E1F, 0x1E1F, 0x1E21, 0x1E21,
	0x1E23, 0x1E23, 0x1E25, 0x1E25, 0x1E27, 0x1E27, 0x1E29, 0x1E29,
	0x1E2B, 0x1E2B, 0x1E2D, 0x1E2D, 0x1E2F, 0x1E2F, 0x1E31, 0x1E31,
	0x1E33, 0x1E33, 0x1E35, 0x1E35, 0x1E37, 0x1E37, 0x1E39, 0x1E39,
	0x1E3B, 0x1E3B, 0x1E3D, 0x1E3D, 0x1E3F, 0x1E3F, 0x1E41, 0x1E41,
	0x1E43, 0x1E43, 0x1E45, 0x1E45, 0x1E47, 0x1E47, 0x1E49, 0x1E49,
	0x1E4B, 0x1E4B, 0x1E4D, 0x1E4D, 0x1E4F, 0x1E4F, 0x1E51, 0x1E51,
	0x1E53, 0x1E53, 0x1E55, 0x1E55, 0x1E57, 0x1E57, 0x1E59, 0x1E59,
	0x1E5B, 0x1E5B, 0x1E5D, 0x1E5D, 0x1E5F, 0x1E5F, 0x1E61, 0x1E61,
	0x1E63, 0x1E63, 0x1E65, 0x1E65, 0x1E67, 0x1E67, 0x1E69, 0x1E69,
	0x1E6B, 0x1E6B, 0x1E6D, 0x1E6D, 0x1E6F, 0x1E6F, 0x1E71, 0x1E71,
	0x1E73, 0x1E73, 0x1E75, 0x1E75, 0x1E77, 0x1E77, 0x1E79, 0x1E79,
	0x1E7B, 0x1E7B, 0x1E7D, 0x1E7D, 0x1E7F, 0x1E7F, 0x1E81, 0x1E81,
	0x1E83, 0x1E83, 0x1E85, 0x1E85, 0x1E87, 0x1E87, 0x1E89, 0x1E89,
	0x1E8B, 0x1E8B, 0x1E8D, 0x1E8D, 0x1E8F, 0x1E8F, 0x1E91, 0x1E91,
	0x1E93, 0x1E93, 0x1E95, 0x1E9B, 0x1EA1, 0x1EA1, 0x1EA3, 0x1EA3,
	0x1EA5, 0x1EA5, 0x1EA7, 0x1EA7, 0x1EA9, 0x1EA9, 0x1EAB, 0x1EAB,
	0x1EAD, 0x1EAD, 0x1EAF, 0x1EAF, 0x1EB1, 0x1EB1, 0x1EB3, 0x1EB3,
	0x1EB5, 0x1EB5, 0x1EB7, 0x1EB7, 0x1EB9, 0x1EB9, 0x1EBB, 0x1EBB,
	0x1EBD, 0x1EBD, 0x1EBF, 0x1EBF, 0x1EC1, 0x1EC1, 0x1EC3, 0x1EC3,
	0x1EC5, 0x1EC5, 0x1EC7, 0x1EC7, 0x1EC9, 0x1EC9, 0x1ECB, 0x1ECB,
	0x1ECD, 0x1ECD, 0x1ECF, 0x1ECF, 0x1ED1, 0x1ED1, 0x1ED3, 0x1ED3,
	0x1ED5, 0x1ED5, 0x1ED7, 0x1ED7, 0x1ED9, 0x1ED9, 0x1EDB, 0x1EDB,
	0x1EDD, 0x1EDD, 0x1EDF, 0x1EDF, 0x1EE1, 0x1EE1, 0x1EE3, 0x1EE3,
	0x1EE5, 0x1EE5, 0x1EE7, 0x1EE7, 0x1EE9, 0x1EE9, 0x1EEB, 0x1EEB,
	0x1EED, 0x1EED, 0x1EEF, 0x1EEF, 0x1EF1, 0x1EF1, 0x1EF3, 0x1EF3,
	0x1EF5, 0x1EF5, 0x1EF7, 0x1EF7, 0x1EF9, 0x1EF9, 0x1EFB, 0x1EFB,
	0x1EFD, 0x1EFD, 0x1EFF, 0x1F07, 0x1F10, 0x1F15, 0x1F20, 0x1F27,
	0x1F30, 0x1F37, 0x1F40, 0x1F45, 0x1F50, 0x1F57, 0x1F60, 0x1F67,
	0x1F70, 0x1F7D, 0x1F80, 0x1F87, 0x1F90, 0x1F97, 0x1FA0, 0x1FA7,
	0x1FB0, 0x1FB4, 0x1FB6, 0x1FB7, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4,
	0x1FC6, 0x1FC7, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FD7, 0x1FE0, 0x1FE7,
	0x1FF2, 0x1FF4, 0x1FF6, 0x1FF7, 0x214E, 0x214E, 0x2170, 0x217F,
	0x2184, 0x2184, 0x24D0, 0x24E9, 0x2C30, 0x2C5E, 0x2C61, 0x2C61,
	0x2C65, 0x2C66, 0x2C68, 0x2C68, 0x2C6A, 0x2C6A, 0x2C6C, 0x2C6C,
	0x2C73, 0x2C73, 0x2C76, 0x2C76, 0x2C81, 0x2C81, 0x2C83, 0x2C83,
	0x2C85, 0x2C85, 0x2C87, 0x2C87, 0x2C89, 0x2C89, 0x2C8B, 0x2C8B,
	0x2C8D, 0x2C8D, 0x2C8F, 0x2C8F, 0x2C91, 0x2C91, 0x2C93, 0x2C93,
	0x2C95, 0x2C95, 0x2C97, 0x2C97, 0x2C99, 0x2C99, 0x2C9B, 0x2C9B,
	0x2C9D, 0x2C9D, 0x2C9F, 0x2C9F, 0x2CA1, 0x2CA1, 0x2CA3, 0x2CA3,
	0x2CA5, 0x2CA5, 0x2CA7, 0x2CA7, 0x2CA9, 0x2CA9, 0x2CAB, 0x2CAB,
	0x2CAD, 0x2CAD, 0x2CAF, 0x2CAF, 0x2CB1, 0x2CB1, 0x2CB3, 0x2CB3,
	0x2CB5, 0x2CB5, 0x2CB7, 0x2CB7, 0x2CB9, 0x2CB9, 0x2CBB, 0x2CBB,
	0x2CBD, 0x2CBD, 0x2CBF, 0x2CBF, 0x2CC1, 0x2CC1, 0x2CC3, 0x2CC3,
	0x2CC5, 0x2CC5, 0x2CC7, 0x2CC7, 0x2CC9, 0x2CC9, 0x2CCB, 0x2CCB,
	0x2CCD, 0x2CCD, 0x2CCF, 0x2CCF, 0x2CD1, 0x2CD1, 0x2CD3, 0x2CD3,
	0x2CD5, 0x2CD5, 0x2CD7, 0x2CD7, 0x2CD9, 0x2CD9, 0x2CDB, 0x2CDB,
	0x2CDD, 0x2CDD, 0x2CDF, 0x2CDF, 0x2CE1, 0x2CE1, 0x2CE3, 0x2CE3,
	0x2CEC, 0x2CEC, 0x2CEE, 0x2CEE, 0x2CF3, 0x2CF3, 0x2D00, 0x2D25,
	0x2D27, 0x2D27, 0x2D2D, 0x2D2D, 0xA641, 0xA641, 0xA643, 0xA643,
	0xA645, 0xA645, 0xA647, 0xA647, 0xA649, 0xA649, 0xA64B, 0xA64B,
	0xA64D, 0xA64D, 0xA64F, 0xA64F, 0xA651, 0xA651, 0xA653, 0xA653,
	0xA655, 0xA655, 0xA657, 0xA657, 0xA659, 0xA659, 0xA65B, 0xA65B,
	0xA65D, 0xA65D, 0xA65F, 0xA65F, 0xA661, 0xA661, 0xA663, 0xA663,
	0xA665, 0xA665, 0xA667, 0xA667, 0xA669, 0xA669, 0xA66B, 0xA66B,
	0xA66D, 0xA66D, 0xA681, 0xA681, 0xA683, 0xA683, 0xA685, 0xA685,
	0xA687, 0xA687, 0xA689, 0xA689, 0xA68B, 0xA68B, 0xA68D, 0xA68D,
	0xA68F, 0xA68F, 0xA691, 0xA691, 0xA693, 0xA693, 0xA695, 0xA695,
	0xA697, 0xA697, 0xA699, 0xA699, 0xA69B, 0xA69B, 0xA723, 0xA723,
	0xA725, 0xA725, 0xA727, 0xA727, 0xA729, 0xA729, 0xA72B, 0xA72B,
	0xA72D, 0xA72D, 0xA72F, 0xA72F, 0xA733, 0xA733, 0xA735, 0xA735,
	0xA737, 0xA737, 0xA739, 0xA739, 0xA73B, 0xA73B, 0xA73D, 0xA73D,
	0xA73F, 0xA73F, 0xA741, 0xA741, 0xA743, 0xA743, 0xA745, 0xA745,
	0xA747, 0xA747, 0xA749, 0xA749, 0xA74B, 0xA74B, 0xA74D, 0xA74D,
	0xA74F, 0xA74F, 0xA751, 0xA751, 0xA753, 0xA753, 0xA755, 0xA755,
	0xA757, 0xA757, 0xA759, 0xA759, 0xA75B, 0xA75B, 0xA75D, 0xA75D,
	0xA75F, 0xA75F, 0xA761, 0xA761, 0xA763, 0xA763, 0xA765, 0xA765,
	0xA767, 0xA767, 0xA769, 0xA769, 0xA76B, 0xA76B, 0xA76D, 0xA76D,
	0xA76F, 0xA76F, 0xA77A, 0xA77A, 0xA77C, 0xA77C, 0xA77F, 0xA77F,
	0xA781, 0xA781, 0xA783, 0xA783, 0xA785, 0xA785, 0xA787, 0xA787,
	0xA78C, 0xA78C, 0xA791, 0xA791, 0xA793, 0xA794, 0xA797, 0xA797,
	0xA799, 0xA799, 0xA79B, 0xA79B, 0xA79D, 0xA79D, 0xA79F, 0xA79F,
	0xA7A1, 0xA7A1, 0xA7A3, 0xA7A3, 0xA7A5, 0xA7A5, 0xA7A7, 0xA7A7,
	0xA7A9, 0xA7A9, 0xA7B5, 0xA7B5, 0xA7B7, 0xA7B7, 0xA7B9, 0xA7B9,
	0xA7BB, 0xA7BB, 0xA7BD, 0xA7BD, 0xA7BF, 0xA7BF, 0xA7C3, 0xA7C3,
	0xAB53, 0xAB53, 0xAB70, 0xABBF, 0xFB00, 0xFB06, 0xFB13, 0xFB17,
	0xFF41, 0xFF5A, 0x10428, 0x1044F, 0x104D8, 0x104FB, 0x10CC0, 0x10CF2,
	0x118C0, 0x118DF, 0x16E60, 0x16E7F, 0x1E922, 0x1E943,
	//  #53 (7935+616): bp=Changes_When_Uppercased:CWU
	0x0061, 0x007A, 0x00B5, 0x00B5, 0x00DF, 0x00F6, 0x00F8, 0x00FF,
	0x0101, 0x0101, 0x0103, 0x0103, 0x0105, 0x0105, 0x0107, 0x0107,
	0x0109, 0x0109, 0x010B, 0x010B, 0x010D, 0x010D, 0x010F, 0x010F,
	0x0111, 0x0111, 0x0113, 0x0113, 0x0115, 0x0115, 0x0117, 0x0117,
	0x0119, 0x0119, 0x011B, 0x011B, 0x011D, 0x011D, 0x011F, 0x011F,
	0x0121, 0x0121, 0x0123, 0x0123, 0x0125, 0x0125, 0x0127, 0x0127,
	0x0129, 0x0129, 0x012B, 0x012B, 0x012D, 0x012D, 0x012F, 0x012F,
	0x0131, 0x0131, 0x0133, 0x0133, 0x0135, 0x0135, 0x0137, 0x0137,
	0x013A, 0x013A, 0x013C, 0x013C, 0x013E, 0x013E, 0x0140, 0x0140,
	0x0142, 0x0142, 0x0144, 0x0144, 0x0146, 0x0146, 0x0148, 0x0149,
	0x014B, 0x014B, 0x014D, 0x014D, 0x014F, 0x014F, 0x0151, 0x0151,
	0x0153, 0x0153, 0x0155, 0x0155, 0x0157, 0x0157, 0x0159, 0x0159,
	0x015B, 0x015B, 0x015D, 0x015D, 0x015F, 0x015F, 0x0161, 0x0161,
	0x0163, 0x0163, 0x0165, 0x0165, 0x0167, 0x0167, 0x0169, 0x0169,
	0x016B, 0x016B, 0x016D, 0x016D, 0x016F, 0x016F, 0x0171, 0x0171,
	0x0173, 0x0173, 0x0175, 0x0175, 0x0177, 0x0177, 0x017A, 0x017A,
	0x017C, 0x017C, 0x017E, 0x0180, 0x0183, 0x0183, 0x0185, 0x0185,
	0x0188, 0x0188, 0x018C, 0x018C, 0x0192, 0x0192, 0x0195, 0x0195,
	0x0199, 0x019A, 0x019E, 0x019E, 0x01A1, 0x01A1, 0x01A3, 0x01A3,
	0x01A5, 0x01A5, 0x01A8, 0x01A8, 0x01AD, 0x01AD, 0x01B0, 0x01B0,
	0x01B4, 0x01B4, 0x01B6, 0x01B6, 0x01B9, 0x01B9, 0x01BD, 0x01BD,
	0x01BF, 0x01BF, 0x01C5, 0x01C6, 0x01C8, 0x01C9, 0x01CB, 0x01CC,
	0x01CE, 0x01CE, 0x01D0, 0x01D0, 0x01D2, 0x01D2, 0x01D4, 0x01D4,
	0x01D6, 0x01D6, 0x01D8, 0x01D8, 0x01DA, 0x01DA, 0x01DC, 0x01DD,
	0x01DF, 0x01DF, 0x01E1, 0x01E1, 0x01E3, 0x01E3, 0x01E5, 0x01E5,
	0x01E7, 0x01E7, 0x01E9, 0x01E9, 0x01EB, 0x01EB, 0x01ED, 0x01ED,
	0x01EF, 0x01F0, 0x01F2, 0x01F3, 0x01F5, 0x01F5, 0x01F9, 0x01F9,
	0x01FB, 0x01FB, 0x01FD, 0x01FD, 0x01FF, 0x01FF, 0x0201, 0x0201,
	0x0203, 0x0203, 0x0205, 0x0205, 0x0207, 0x0207, 0x0209, 0x0209,
	0x020B, 0x020B, 0x020D, 0x020D, 0x020F, 0x020F, 0x0211, 0x0211,
	0x0213, 0x0213, 0x0215, 0x0215, 0x0217, 0x0217, 0x0219, 0x0219,
	0x021B, 0x021B, 0x021D, 0x021D, 0x021F, 0x021F, 0x0223, 0x0223,
	0x0225, 0x0225, 0x0227, 0x0227, 0x0229, 0x0229, 0x022B, 0x022B,
	0x022D, 0x022D, 0x022F, 0x022F, 0x0231, 0x0231, 0x0233, 0x0233,
	0x023C, 0x023C, 0x023F, 0x0240, 0x0242, 0x0242, 0x0247, 0x0247,
	0x0249, 0x0249, 0x024B, 0x024B, 0x024D, 0x024D, 0x024F, 0x0254,
	0x0256, 0x0257, 0x0259, 0x0259, 0x025B, 0x025C, 0x0260, 0x0261,
	0x0263, 0x0263, 0x0265, 0x0266, 0x0268, 0x026C, 0x026F, 0x026F,
	0x0271, 0x0272, 0x0275, 0x0275, 0x027D, 0x027D, 0x0280, 0x0280,
	0x0282, 0x0283, 0x0287, 0x028C, 0x0292, 0x0292, 0x029D, 0x029E,
	0x0345, 0x0345, 0x0371, 0x0371, 0x0373, 0x0373, 0x0377, 0x0377,
	0x037B, 0x037D, 0x0390, 0x0390, 0x03AC, 0x03CE, 0x03D0, 0x03D1,
	0x03D5, 0x03D7, 0x03D9, 0x03D9, 0x03DB, 0x03DB, 0x03DD, 0x03DD,
	0x03DF, 0x03DF, 0x03E1, 0x03E1, 0x03E3, 0x03E3, 0x03E5, 0x03E5,
	0x03E7, 0x03E7, 0x03E9, 0x03E9, 0x03EB, 0x03EB, 0x03ED, 0x03ED,
	0x03EF, 0x03F3, 0x03F5, 0x03F5, 0x03F8, 0x03F8, 0x03FB, 0x03FB,
	0x0430, 0x045F, 0x0461, 0x0461, 0x0463, 0x0463, 0x0465, 0x0465,
	0x0467, 0x0467, 0x0469, 0x0469, 0x046B, 0x046B, 0x046D, 0x046D,
	0x046F, 0x046F, 0x0471, 0x0471, 0x0473, 0x0473, 0x0475, 0x0475,
	0x0477, 0x0477, 0x0479, 0x0479, 0x047B, 0x047B, 0x047D, 0x047D,
	0x047F, 0x047F, 0x0481, 0x0481, 0x048B, 0x048B, 0x048D, 0x048D,
	0x048F, 0x048F, 0x0491, 0x0491, 0x0493, 0x0493, 0x0495, 0x0495,
	0x0497, 0x0497, 0x0499, 0x0499, 0x049B, 0x049B, 0x049D, 0x049D,
	0x049F, 0x049F, 0x04A1, 0x04A1, 0x04A3, 0x04A3, 0x04A5, 0x04A5,
	0x04A7, 0x04A7, 0x04A9, 0x04A9, 0x04AB, 0x04AB, 0x04AD, 0x04AD,
	0x04AF, 0x04AF, 0x04B1, 0x04B1, 0x04B3, 0x04B3, 0x04B5, 0x04B5,
	0x04B7, 0x04B7, 0x04B9, 0x04B9, 0x04BB, 0x04BB, 0x04BD, 0x04BD,
	0x04BF, 0x04BF, 0x04C2, 0x04C2, 0x04C4, 0x04C4, 0x04C6, 0x04C6,
	0x04C8, 0x04C8, 0x04CA, 0x04CA, 0x04CC, 0x04CC, 0x04CE, 0x04CF,
	0x04D1, 0x04D1, 0x04D3, 0x04D3, 0x04D5, 0x04D5, 0x04D7, 0x04D7,
	0x04D9, 0x04D9, 0x04DB, 0x04DB, 0x04DD, 0x04DD, 0x04DF, 0x04DF,
	0x04E1, 0x04E1, 0x04E3, 0x04E3, 0x04E5, 0x04E5, 0x04E7, 0x04E7,
	0x04E9, 0x04E9, 0x04EB, 0x04EB, 0x04ED, 0x04ED, 0x04EF, 0x04EF,
	0x04F1, 0x04F1, 0x04F3, 0x04F3, 0x04F5, 0x04F5, 0x04F7, 0x04F7,
	0x04F9, 0x04F9, 0x04FB, 0x04FB, 0x04FD, 0x04FD, 0x04FF, 0x04FF,
	0x0501, 0x0501, 0x0503, 0x0503, 0x0505, 0x0505, 0x0507, 0x0507,
	0x0509, 0x0509, 0x050B, 0x050B, 0x050D, 0x050D, 0x050F, 0x050F,
	0x0511, 0x0511, 0x0513, 0x0513, 0x0515, 0x0515, 0x0517, 0x0517,
	0x0519, 0x0519, 0x051B, 0x051B, 0x051D, 0x051D, 0x051F, 0x051F,
	0x0521, 0x0521, 0x0523, 0x0523, 0x0525, 0x0525, 0x0527, 0x0527,
	0x0529, 0x0529, 0x052B, 0x052B, 0x052D, 0x052D, 0x052F, 0x052F,
	0x0561, 0x0587, 0x10D0, 0x10FA, 0x10FD, 0x10FF, 0x13F8, 0x13FD,
	0x1C80, 0x1C88, 0x1D79, 0x1D79, 0x1D7D, 0x1D7D, 0x1D8E, 0x1D8E,
	0x1E01, 0x1E01, 0x1E03, 0x1E03, 0x1E05, 0x1E05, 0x1E07, 0x1E07,
	0x1E09, 0x1E09, 0x1E0B, 0x1E0B, 0x1E0D, 0x1E0D, 0x1E0F, 0x1E0F,
	0x1E11, 0x1E11, 0x1E13, 0x1E13, 0x1E15, 0x1E15, 0x1E17, 0x1E17,
	0x1E19, 0x1E19, 0x1E1B, 0x1E1B, 0x1E1D, 0x1E1D, 0x1E1F, 0x1E1F,
	0x1E21, 0x1E21, 0x1E23, 0x1E23, 0x1E25, 0x1E25, 0x1E27, 0x1E27,
	0x1E29, 0x1E29, 0x1E2B, 0x1E2B, 0x1E2D, 0x1E2D, 0x1E2F, 0x1E2F,
	0x1E31, 0x1E31, 0x1E33, 0x1E33, 0x1E35, 0x1E35, 0x1E37, 0x1E37,
	0x1E39, 0x1E39, 0x1E3B, 0x1E3B, 0x1E3D, 0x1E3D, 0x1E3F, 0x1E3F,
	0x1E41, 0x1E41, 0x1E43, 0x1E43, 0x1E45, 0x1E45, 0x1E47, 0x1E47,
	0x1E49, 0x1E49, 0x1E4B, 0x1E4B, 0x1E4D, 0x1E4D, 0x1E4F, 0x1E4F,
	0x1E51, 0x1E51, 0x1E53, 0x1E53, 0x1E55, 0x1E55, 0x1E57, 0x1E57,
	0x1E59, 0x1E59, 0x1E5B, 0x1E5B, 0x1E5D, 0x1E5D, 0x1E5F, 0x1E5F,
	0x1E61, 0x1E61, 0x1E63, 0x1E63, 0x1E65, 0x1E65, 0x1E67, 0x1E67,
	0x1E69, 0x1E69, 0x1E6B, 0x1E6B, 0x1E6D, 0x1E6D, 0x1E6F, 0x1E6F,
	0x1E71, 0x1E71, 0x1E73, 0x1E73, 0x1E75, 0x1E75, 0x1E77, 0x1E77,
	0x1E79, 0x1E79, 0x1E7B, 0x1E7B, 0x1E7D, 0x1E7D, 0x1E7F, 0x1E7F,
	0x1E81, 0x1E81, 0x1E83, 0x1E83, 0x1E85, 0x1E85, 0x1E87, 0x1E87,
	0x1E89, 0x1E89, 0x1E8B, 0x1E8B, 0x1E8D, 0x1E8D, 0x1E8F, 0x1E8F,
	0x1E91, 0x1E91, 0x1E93, 0x1E93, 0x1E95, 0x1E9B, 0x1EA1, 0x1EA1,
	0x1EA3, 0x1EA3, 0x1EA5, 0x1EA5, 0x1EA7, 0x1EA7, 0x1EA9, 0x1EA9,
	0x1EAB, 0x1EAB, 0x1EAD, 0x1EAD, 0x1EAF, 0x1EAF, 0x1EB1, 0x1EB1,
	0x1EB3, 0x1EB3, 0x1EB5, 0x1EB5, 0x1EB7, 0x1EB7, 0x1EB9, 0x1EB9,
	0x1EBB, 0x1EBB, 0x1EBD, 0x1EBD, 0x1EBF, 0x1EBF, 0x1EC1, 0x1EC1,
	0x1EC3, 0x1EC3, 0x1EC5, 0x1EC5, 0x1EC7, 0x1EC7, 0x1EC9, 0x1EC9,
	0x1ECB, 0x1ECB, 0x1ECD, 0x1ECD, 0x1ECF, 0x1ECF, 0x1ED1, 0x1ED1,
	0x1ED3, 0x1ED3, 0x1ED5, 0x1ED5, 0x1ED7, 0x1ED7, 0x1ED9, 0x1ED9,
	0x1EDB, 0x1EDB, 0x1EDD, 0x1EDD, 0x1EDF, 0x1EDF, 0x1EE1, 0x1EE1,
	0x1EE3, 0x1EE3, 0x1EE5, 0x1EE5, 0x1EE7, 0x1EE7, 0x1EE9, 0x1EE9,
	0x1EEB, 0x1EEB, 0x1EED, 0x1EED, 0x1EEF, 0x1EEF, 0x1EF1, 0x1EF1,
	0x1EF3, 0x1EF3, 0x1EF5, 0x1EF5, 0x1EF7, 0x1EF7, 0x1EF9, 0x1EF9,
	0x1EFB, 0x1EFB, 0x1EFD, 0x1EFD, 0x1EFF, 0x1F07, 0x1F10, 0x1F15,
	0x1F20, 0x1F27, 0x1F30, 0x1F37, 0x1F40, 0x1F45, 0x1F50, 0x1F57,
	0x1F60, 0x1F67, 0x1F70, 0x1F7D, 0x1F80, 0x1FB4, 0x1FB6, 0x1FB7,
	0x1FBC, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FC7,
	0x1FCC, 0x1FCC, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FD7, 0x1FE0, 0x1FE7,
	0x1FF2, 0x1FF4, 0x1FF6, 0x1FF7, 0x1FFC, 0x1FFC, 0x214E, 0x214E,
	0x2170, 0x217F, 0x2184, 0x2184, 0x24D0, 0x24E9, 0x2C30, 0x2C5E,
	0x2C61, 0x2C61, 0x2C65, 0x2C66, 0x2C68, 0x2C68, 0x2C6A, 0x2C6A,
	0x2C6C, 0x2C6C, 0x2C73, 0x2C73, 0x2C76, 0x2C76, 0x2C81, 0x2C81,
	0x2C83, 0x2C83, 0x2C85, 0x2C85, 0x2C87, 0x2C87, 0x2C89, 0x2C89,
	0x2C8B, 0x2C8B, 0x2C8D, 0x2C8D, 0x2C8F, 0x2C8F, 0x2C91, 0x2C91,
	0x2C93, 0x2C93, 0x2C95, 0x2C95, 0x2C97, 0x2C97, 0x2C99, 0x2C99,
	0x2C9B, 0x2C9B, 0x2C9D, 0x2C9D, 0x2C9F, 0x2C9F, 0x2CA1, 0x2CA1,
	0x2CA3, 0x2CA3, 0x2CA5, 0x2CA5, 0x2CA7, 0x2CA7, 0x2CA9, 0x2CA9,
	0x2CAB, 0x2CAB, 0x2CAD, 0x2CAD, 0x2CAF, 0x2CAF, 0x2CB1, 0x2CB1,
	0x2CB3, 0x2CB3, 0x2CB5, 0x2CB5, 0x2CB7, 0x2CB7, 0x2CB9, 0x2CB9,
	0x2CBB, 0x2CBB, 0x2CBD, 0x2CBD, 0x2CBF, 0x2CBF, 0x2CC1, 0x2CC1,
	0x2CC3, 0x2CC3, 0x2CC5, 0x2CC5, 0x2CC7, 0x2CC7, 0x2CC9, 0x2CC9,
	0x2CCB, 0x2CCB, 0x2CCD, 0x2CCD, 0x2CCF, 0x2CCF, 0x2CD1, 0x2CD1,
	0x2CD3, 0x2CD3, 0x2CD5, 0x2CD5, 0x2CD7, 0x2CD7, 0x2CD9, 0x2CD9,
	0x2CDB, 0x2CDB, 0x2CDD, 0x2CDD, 0x2CDF, 0x2CDF, 0x2CE1, 0x2CE1,
	0x2CE3, 0x2CE3, 0x2CEC, 0x2CEC, 0x2CEE, 0x2CEE, 0x2CF3, 0x2CF3,
	0x2D00, 0x2D25, 0x2D27, 0x2D27, 0x2D2D, 0x2D2D, 0xA641, 0xA641,
	0xA643, 0xA643, 0xA645, 0xA645, 0xA647, 0xA647, 0xA649, 0xA649,
	0xA64B, 0xA64B, 0xA64D, 0xA64D, 0xA64F, 0xA64F, 0xA651, 0xA651,
	0xA653, 0xA653, 0xA655, 0xA655, 0xA657, 0xA657, 0xA659, 0xA659,
	0xA65B, 0xA65B, 0xA65D, 0xA65D, 0xA65F, 0xA65F, 0xA661, 0xA661,
	0xA663, 0xA663, 0xA665, 0xA665, 0xA667, 0xA667, 0xA669, 0xA669,
	0xA66B, 0xA66B, 0xA66D, 0xA66D, 0xA681, 0xA681, 0xA683, 0xA683,
	0xA685, 0xA685, 0xA687, 0xA687, 0xA689, 0xA689, 0xA68B, 0xA68B,
	0xA68D, 0xA68D, 0xA68F, 0xA68F, 0xA691, 0xA691, 0xA693, 0xA693,
	0xA695, 0xA695, 0xA697, 0xA697, 0xA699, 0xA699, 0xA69B, 0xA69B,
	0xA723, 0xA723, 0xA725, 0xA725, 0xA727, 0xA727, 0xA729, 0xA729,
	0xA72B, 0xA72B, 0xA72D, 0xA72D, 0xA72F, 0xA72F, 0xA733, 0xA733,
	0xA735, 0xA735, 0xA737, 0xA737, 0xA739, 0xA739, 0xA73B, 0xA73B,
	0xA73D, 0xA73D, 0xA73F, 0xA73F, 0xA741, 0xA741, 0xA743, 0xA743,
	0xA745, 0xA745, 0xA747, 0xA747, 0xA749, 0xA749, 0xA74B, 0xA74B,
	0xA74D, 0xA74D, 0xA74F, 0xA74F, 0xA751, 0xA751, 0xA753, 0xA753,
	0xA755, 0xA755, 0xA757, 0xA757, 0xA759, 0xA759, 0xA75B, 0xA75B,
	0xA75D, 0xA75D, 0xA75F, 0xA75F, 0xA761, 0xA761, 0xA763, 0xA763,
	0xA765, 0xA765, 0xA767, 0xA767, 0xA769, 0xA769, 0xA76B, 0xA76B,
	0xA76D, 0xA76D, 0xA76F, 0xA76F, 0xA77A, 0xA77A, 0xA77C, 0xA77C,
	0xA77F, 0xA77F, 0xA781, 0xA781, 0xA783, 0xA783, 0xA785, 0xA785,
	0xA787, 0xA787, 0xA78C, 0xA78C, 0xA791, 0xA791, 0xA793, 0xA794,
	0xA797, 0xA797, 0xA799, 0xA799, 0xA79B, 0xA79B, 0xA79D, 0xA79D,
	0xA79F, 0xA79F, 0xA7A1, 0xA7A1, 0xA7A3, 0xA7A3, 0xA7A5, 0xA7A5,
	0xA7A7, 0xA7A7, 0xA7A9, 0xA7A9, 0xA7B5, 0xA7B5, 0xA7B7, 0xA7B7,
	0xA7B9, 0xA7B9, 0xA7BB, 0xA7BB, 0xA7BD, 0xA7BD, 0xA7BF, 0xA7BF,
	0xA7C3, 0xA7C3, 0xAB53, 0xAB53, 0xAB70, 0xABBF, 0xFB00, 0xFB06,
	0xFB13, 0xFB17, 0xFF41, 0xFF5A, 0x10428, 0x1044F, 0x104D8, 0x104FB,
	0x10CC0, 0x10CF2, 0x118C0, 0x118DF, 0x16E60, 0x16E7F, 0x1E922, 0x1E943,
	//  #54 (8551+21): bp=Dash
	0x002D, 0x002D, 0x058A, 0x058A, 0x05BE, 0x05BE, 0x1400, 0x1400,
	0x1806, 0x1806, 0x2010, 0x2015, 0x2053, 0x2053, 0x207B, 0x207B,
	0x208B, 0x208B, 0x2212, 0x2212, 0x2E17, 0x2E17, 0x2E1A, 0x2E1A,
	0x2E3A, 0x2E3B, 0x2E40, 0x2E40, 0x301C, 0x301C, 0x3030, 0x3030,
	0x30A0, 0x30A0, 0xFE31, 0xFE32, 0xFE58, 0xFE58, 0xFE63, 0xFE63,
	0xFF0D, 0xFF0D,
	//  #55 (8572+17): bp=Default_Ignorable_Code_Point:DI
	0x00AD, 0x00AD, 0x034F, 0x034F, 0x061C, 0x061C, 0x115F, 0x1160,
	0x17B4, 0x17B5, 0x180B, 0x180E, 0x200B, 0x200F, 0x202A, 0x202E,
	0x2060, 0x206F, 0x3164, 0x3164, 0xFE00, 0xFE0F, 0xFEFF, 0xFEFF,
	0xFFA0, 0xFFA0, 0xFFF0, 0xFFF8, 0x1BCA0, 0x1BCA3, 0x1D173, 0x1D17A,
	0xE0000, 0xE0FFF,
	//  #56 (8589+8): bp=Deprecated:Dep
	0x0149, 0x0149, 0x0673, 0x0673, 0x0F77, 0x0F77, 0x0F79, 0x0F79,
	0x17A3, 0x17A4, 0x206A, 0x206F, 0x2329, 0x232A, 0xE0001, 0xE0001,
	//  #57 (8597+171): bp=Diacritic:Dia
	0x005E, 0x005E, 0x0060, 0x0060, 0x00A8, 0x00A8, 0x00AF, 0x00AF,
	0x00B4, 0x00B4, 0x00B7, 0x00B8, 0x02B0, 0x034E, 0x0350, 0x0357,
	0x035D, 0x0362, 0x0374, 0x0375, 0x037A, 0x037A, 0x0384, 0x0385,
	0x0483, 0x0487, 0x0559, 0x0559, 0x0591, 0x05A1, 0x05A3, 0x05BD,
	0x05BF, 0x05BF, 0x05C1, 0x05C2, 0x05C4, 0x05C4, 0x064B, 0x0652,
	0x0657, 0x0658, 0x06DF, 0x06E0, 0x06E5, 0x06E6, 0x06EA, 0x06EC,
	0x0730, 0x074A, 0x07A6, 0x07B0, 0x07EB, 0x07F5, 0x0818, 0x0819,
	0x08E3, 0x08FE, 0x093C, 0x093C, 0x094D, 0x094D, 0x0951, 0x0954,
	0x0971, 0x0971, 0x09BC, 0x09BC, 0x09CD, 0x09CD, 0x0A3C, 0x0A3C,
	0x0A4D, 0x0A4D, 0x0ABC, 0x0ABC, 0x0ACD, 0x0ACD, 0x0AFD, 0x0AFF,
	0x0B3C, 0x0B3C, 0x0B4D, 0x0B4D, 0x0BCD, 0x0BCD, 0x0C4D, 0x0C4D,
	0x0CBC, 0x0CBC, 0x0CCD, 0x0CCD, 0x0D3B, 0x0D3C, 0x0D4D, 0x0D4D,
	0x0DCA, 0x0DCA, 0x0E47, 0x0E4C, 0x0E4E, 0x0E4E, 0x0EBA, 0x0EBA,
	0x0EC8, 0x0ECC, 0x0F18, 0x0F19, 0x0F35, 0x0F35, 0x0F37, 0x0F37,
	0x0F39, 0x0F39, 0x0F3E, 0x0F3F, 0x0F82, 0x0F84, 0x0F86, 0x0F87,
	0x0FC6, 0x0FC6, 0x1037, 0x1037, 0x1039, 0x103A, 0x1063, 0x1064,
	0x1069, 0x106D, 0x1087, 0x108D, 0x108F, 0x108F, 0x109A, 0x109B,
	0x135D, 0x135F, 0x17C9, 0x17D3, 0x17DD, 0x17DD, 0x1939, 0x193B,
	0x1A75, 0x1A7C, 0x1A7F, 0x1A7F, 0x1AB0, 0x1ABD, 0x1B34, 0x1B34,
	0x1B44, 0x1B44, 0x1B6B, 0x1B73, 0x1BAA, 0x1BAB, 0x1C36, 0x1C37,
	0x1C78, 0x1C7D, 0x1CD0, 0x1CE8, 0x1CED, 0x1CED, 0x1CF4, 0x1CF4,
	0x1CF7, 0x1CF9, 0x1D2C, 0x1D6A, 0x1DC4, 0x1DCF, 0x1DF5, 0x1DF9,
	0x1DFD, 0x1DFF, 0x1FBD, 0x1FBD, 0x1FBF, 0x1FC1, 0x1FCD, 0x1FCF,
	0x1FDD, 0x1FDF, 0x1FED, 0x1FEF, 0x1FFD, 0x1FFE, 0x2CEF, 0x2CF1,
	0x2E2F, 0x2E2F, 0x302A, 0x302F, 0x3099, 0x309C, 0x30FC, 0x30FC,
	0xA66F, 0xA66F, 0xA67C, 0xA67D, 0xA67F, 0xA67F, 0xA69C, 0xA69D,
	0xA6F0, 0xA6F1, 0xA700, 0xA721, 0xA788, 0xA78A, 0xA7F8, 0xA7F9,
	0xA8C4, 0xA8C4, 0xA8E0, 0xA8F1, 0xA92B, 0xA92E, 0xA953, 0xA953,
	0xA9B3, 0xA9B3, 0xA9C0, 0xA9C0, 0xA9E5, 0xA9E5, 0xAA7B, 0xAA7D,
	0xAABF, 0xAAC2, 0xAAF6, 0xAAF6, 0xAB5B, 0xAB5F, 0xABEC, 0xABED,
	0xFB1E, 0xFB1E, 0xFE20, 0xFE2F, 0xFF3E, 0xFF3E, 0xFF40, 0xFF40,
	0xFF70, 0xFF70, 0xFF9E, 0xFF9F, 0xFFE3, 0xFFE3, 0x102E0, 0x102E0,
	0x10AE5, 0x10AE6, 0x10D22, 0x10D27, 0x10F46, 0x10F50, 0x110B9, 0x110BA,
	0x11133, 0x11134, 0x11173, 0x11173, 0x111C0, 0x111C0, 0x111CA, 0x111CC,
	0x11235, 0x11236, 0x112E9, 0x112EA, 0x1133C, 0x1133C, 0x1134D, 0x1134D,
	0x11366, 0x1136C, 0x11370, 0x11374, 0x11442, 0x11442, 0x11446, 0x11446,
	0x114C2, 0x114C3, 0x115BF, 0x115C0, 0x1163F, 0x1163F, 0x116B6, 0x116B7,
	0x1172B, 0x1172B, 0x11839, 0x1183A, 0x119E0, 0x119E0, 0x11A34, 0x11A34,
	0x11A47, 0x11A47, 0x11A99, 0x11A99, 0x11C3F, 0x11C3F, 0x11D42, 0x11D42,
	0x11D44, 0x11D45, 0x11D97, 0x11D97, 0x16AF0, 0x16AF4, 0x16B30, 0x16B36,
	0x16F8F, 0x16F9F, 0x1D167, 0x1D169, 0x1D16D, 0x1D172, 0x1D17B, 0x1D182,
	0x1D185, 0x1D18B, 0x1D1AA, 0x1D1AD, 0x1E130, 0x1E136, 0x1E2EC, 0x1E2EF,
	0x1E8D0, 0x1E8D6, 0x1E944, 0x1E946, 0x1E948, 0x1E94A,
	//  #58 (8768+151): bp=Emoji
	0x0023, 0x0023, 0x002A, 0x002A, 0x0030, 0x0039, 0x00A9, 0x00A9,
	0x00AE, 0x00AE, 0x203C, 0x203C, 0x2049, 0x2049, 0x2122, 0x2122,
	0x2139, 0x2139, 0x2194, 0x2199, 0x21A9, 0x21AA, 0x231A, 0x231B,
	0x2328, 0x2328, 0x23CF, 0x23CF, 0x23E9, 0x23F3, 0x23F8, 0x23FA,
	0x24C2, 0x24C2, 0x25AA, 0x25AB, 0x25B6, 0x25B6, 0x25C0, 0x25C0,
	0x25FB, 0x25FE, 0x2600, 0x2604, 0x260E, 0x260E, 0x2611, 0x2611,
	0x2614, 0x2615, 0x2618, 0x2618, 0x261D, 0x261D, 0x2620, 0x2620,
	0x2622, 0x2623, 0x2626, 0x2626, 0x262A, 0x262A, 0x262E, 0x262F,
	0x2638, 0x263A, 0x2640, 0x2640, 0x2642, 0x2642, 0x2648, 0x2653,
	0x265F, 0x2660, 0x2663, 0x2663, 0x2665, 0x2666, 0x2668, 0x2668,
	0x267B, 0x267B, 0x267E, 0x267F, 0x2692, 0x2697, 0x2699, 0x2699,
	0x269B, 0x269C, 0x26A0, 0x26A1, 0x26AA, 0x26AB, 0x26B0, 0x26B1,
	0x26BD, 0x26BE, 0x26C4, 0x26C5, 0x26C8, 0x26C8, 0x26CE, 0x26CF,
	0x26D1, 0x26D1, 0x26D3, 0x26D4, 0x26E9, 0x26EA, 0x26F0, 0x26F5,
	0x26F7, 0x26FA, 0x26FD, 0x26FD, 0x2702, 0x2702, 0x2705, 0x2705,
	0x2708, 0x270D, 0x270F, 0x270F, 0x2712, 0x2712, 0x2714, 0x2714,
	0x2716, 0x2716, 0x271D, 0x271D, 0x2721, 0x2721, 0x2728, 0x2728,
	0x2733, 0x2734, 0x2744, 0x2744, 0x2747, 0x2747, 0x274C, 0x274C,
	0x274E, 0x274E, 0x2753, 0x2755, 0x2757, 0x2757, 0x2763, 0x2764,
	0x2795, 0x2797, 0x27A1, 0x27A1, 0x27B0, 0x27B0, 0x27BF, 0x27BF,
	0x2934, 0x2935, 0x2B05, 0x2B07, 0x2B1B, 0x2B1C, 0x2B50, 0x2B50,
	0x2B55, 0x2B55, 0x3030, 0x3030, 0x303D, 0x303D, 0x3297, 0x3297,
	0x3299, 0x3299, 0x1F004, 0x1F004, 0x1F0CF, 0x1F0CF, 0x1F170, 0x1F171,
	0x1F17E, 0x1F17F, 0x1F18E, 0x1F18E, 0x1F191, 0x1F19A, 0x1F1E6, 0x1F1FF,
	0x1F201, 0x1F202, 0x1F21A, 0x1F21A, 0x1F22F, 0x1F22F, 0x1F232, 0x1F23A,
	0x1F250, 0x1F251, 0x1F300, 0x1F321, 0x1F324, 0x1F393, 0x1F396, 0x1F397,
	0x1F399, 0x1F39B, 0x1F39E, 0x1F3F0, 0x1F3F3, 0x1F3F5, 0x1F3F7, 0x1F4FD,
	0x1F4FF, 0x1F53D, 0x1F549, 0x1F54E, 0x1F550, 0x1F567, 0x1F56F, 0x1F570,
	0x1F573, 0x1F57A, 0x1F587, 0x1F587, 0x1F58A, 0x1F58D, 0x1F590, 0x1F590,
	0x1F595, 0x1F596, 0x1F5A4, 0x1F5A5, 0x1F5A8, 0x1F5A8, 0x1F5B1, 0x1F5B2,
	0x1F5BC, 0x1F5BC, 0x1F5C2, 0x1F5C4, 0x1F5D1, 0x1F5D3, 0x1F5DC, 0x1F5DE,
	0x1F5E1, 0x1F5E1, 0x1F5E3, 0x1F5E3, 0x1F5E8, 0x1F5E8, 0x1F5EF, 0x1F5EF,
	0x1F5F3, 0x1F5F3, 0x1F5FA, 0x1F64F, 0x1F680, 0x1F6C5, 0x1F6CB, 0x1F6D2,
	0x1F6D5, 0x1F6D5, 0x1F6E0, 0x1F6E5, 0x1F6E9, 0x1F6E9, 0x1F6EB, 0x1F6EC,
	0x1F6F0, 0x1F6F0, 0x1F6F3, 0x1F6FA, 0x1F7E0, 0x1F7EB, 0x1F90D, 0x1F93A,
	0x1F93C, 0x1F945, 0x1F947, 0x1F971, 0x1F973, 0x1F976, 0x1F97A, 0x1F9A2,
	0x1F9A5, 0x1F9AA, 0x1F9AE, 0x1F9CA, 0x1F9CD, 0x1F9FF, 0x1FA70, 0x1FA73,
	0x1FA78, 0x1FA7A, 0x1FA80, 0x1FA82, 0x1FA90, 0x1FA95,
	//  #59 (8919+10): bp=Emoji_Component
	0x0023, 0x0023, 0x002A, 0x002A, 0x0030, 0x0039, 0x200D, 0x200D,
	0x20E3, 0x20E3, 0xFE0F, 0xFE0F, 0x1F1E6, 0x1F1FF, 0x1F3FB, 0x1F3FF,
	0x1F9B0, 0x1F9B3, 0xE0020, 0xE007F,
	//  #60 (8929+1): bp=Emoji_Modifier
	0x1F3FB, 0x1F3FF,
	//  #61 (8930+36): bp=Emoji_Modifier_Base
	0x261D, 0x261D, 0x26F9, 0x26F9, 0x270A, 0x270D, 0x1F385, 0x1F385,
	0x1F3C2, 0x1F3C4, 0x1F3C7, 0x1F3C7, 0x1F3CA, 0x1F3CC, 0x1F442, 0x1F443,
	0x1F446, 0x1F450, 0x1F466, 0x1F478, 0x1F47C, 0x1F47C, 0x1F481, 0x1F483,
	0x1F485, 0x1F487, 0x1F48F, 0x1F48F, 0x1F491, 0x1F491, 0x1F4AA, 0x1F4AA,
	0x1F574, 0x1F575, 0x1F57A, 0x1F57A, 0x1F590, 0x1F590, 0x1F595, 0x1F596,
	0x1F645, 0x1F647, 0x1F64B, 0x1F64F, 0x1F6A3, 0x1F6A3, 0x1F6B4, 0x1F6B6,
	0x1F6C0, 0x1F6C0, 0x1F6CC, 0x1F6CC, 0x1F90F, 0x1F90F, 0x1F918, 0x1F91F,
	0x1F926, 0x1F926, 0x1F930, 0x1F939, 0x1F93C, 0x1F93E, 0x1F9B5, 0x1F9B6,
	0x1F9B8, 0x1F9B9, 0x1F9BB, 0x1F9BB, 0x1F9CD, 0x1F9CF, 0x1F9D1, 0x1F9DD,
	//  #62 (8966+81): bp=Emoji_Presentation
	0x231A, 0x231B, 0x23E9, 0x23EC, 0x23F0, 0x23F0, 0x23F3, 0x23F3,
	0x25FD, 0x25FE, 0x2614, 0x2615, 0x2648, 0x2653, 0x267F, 0x267F,
	0x2693, 0x2693, 0x26A1, 0x26A1, 0x26AA, 0x26AB, 0x26BD, 0x26BE,
	0x26C4, 0x26C5, 0x26CE, 0x26CE, 0x26D4, 0x26D4, 0x26EA, 0x26EA,
	0x26F2, 0x26F3, 0x26F5, 0x26F5, 0x26FA, 0x26FA, 0x26FD, 0x26FD,
	0x2705, 0x2705, 0x270A, 0x270B, 0x2728, 0x2728, 0x274C, 0x274C,
	0x274E, 0x274E, 0x2753, 0x2755, 0x2757, 0x2757, 0x2795, 0x2797,
	0x27B0, 0x27B0, 0x27BF, 0x27BF, 0x2B1B, 0x2B1C, 0x2B50, 0x2B50,
	0x2B55, 0x2B55, 0x1F004, 0x1F004, 0x1F0CF, 0x1F0CF, 0x1F18E, 0x1F18E,
	0x1F191, 0x1F19A, 0x1F1E6, 0x1F1FF, 0x1F201, 0x1F201, 0x1F21A, 0x1F21A,
	0x1F22F, 0x1F22F, 0x1F232, 0x1F236, 0x1F238, 0x1F23A, 0x1F250, 0x1F251,
	0x1F300, 0x1F320, 0x1F32D, 0x1F335, 0x1F337, 0x1F37C, 0x1F37E, 0x1F393,
	0x1F3A0, 0x1F3CA, 0x1F3CF, 0x1F3D3, 0x1F3E0, 0x1F3F0, 0x1F3F4, 0x1F3F4,
	0x1F3F8, 0x1F43E, 0x1F440, 0x1F440, 0x1F442, 0x1F4FC, 0x1F4FF, 0x1F53D,
	0x1F54B, 0x1F54E, 0x1F550, 0x1F567, 0x1F57A, 0x1F57A, 0x1F595, 0x1F596,
	0x1F5A4, 0x1F5A4, 0x1F5FB, 0x1F64F, 0x1F680, 0x1F6C5, 0x1F6CC, 0x1F6CC,
	0x1F6D0, 0x1F6D2, 0x1F6D5, 0x1F6D5, 0x1F6EB, 0x1F6EC, 0x1F6F4, 0x1F6FA,
	0x1F7E0, 0x1F7EB, 0x1F90D, 0x1F93A, 0x1F93C, 0x1F945, 0x1F947, 0x1F971,
	0x1F973, 0x1F976, 0x1F97A, 0x1F9A2, 0x1F9A5, 0x1F9AA, 0x1F9AE, 0x1F9CA,
	0x1F9CD, 0x1F9FF, 0x1FA70, 0x1FA73, 0x1FA78, 0x1FA7A, 0x1FA80, 0x1FA82,
	0x1FA90, 0x1FA95,
	//  #63 (9047+31): bp=Extender:Ext
	0x00B7, 0x00B7, 0x02D0, 0x02D1, 0x0640, 0x0640, 0x07FA, 0x07FA,
	0x0E46, 0x0E46, 0x0EC6, 0x0EC6, 0x180A, 0x180A, 0x1843, 0x1843,
	0x1AA7, 0x1AA7, 0x1C36, 0x1C36, 0x1C7B, 0x1C7B, 0x3005, 0x3005,
	0x3031, 0x3035, 0x309D, 0x309E, 0x30FC, 0x30FE, 0xA015, 0xA015,
	0xA60C, 0xA60C, 0xA9CF, 0xA9CF, 0xA9E6, 0xA9E6, 0xAA70, 0xAA70,
	0xAADD, 0xAADD, 0xAAF3, 0xAAF4, 0xFF70, 0xFF70, 0x1135D, 0x1135D,
	0x115C6, 0x115C8, 0x11A98, 0x11A98, 0x16B42, 0x16B43, 0x16FE0, 0x16FE1,
	0x16FE3, 0x16FE3, 0x1E13C, 0x1E13D, 0x1E944, 0x1E946,
	//  #64 (9078+819): bp=Grapheme_Base:Gr_Base
	0x0020, 0x007E, 0x00A0, 0x00AC, 0x00AE, 0x02FF, 0x0370, 0x0377,
	0x037A, 0x037F, 0x0384, 0x038A, 0x038C, 0x038C, 0x038E, 0x03A1,
	0x03A3, 0x0482, 0x048A, 0x052F, 0x0531, 0x0556, 0x0559, 0x058A,
	0x058D, 0x058F, 0x05BE, 0x05BE, 0x05C0, 0x05C0, 0x05C3, 0x05C3,
	0x05C6, 0x05C6, 0x05D0, 0x05EA, 0x05EF, 0x05F4, 0x0606, 0x060F,
	0x061B, 0x061B, 0x061E, 0x064A, 0x0660, 0x066F, 0x0671, 0x06D5,
	0x06DE, 0x06DE, 0x06E5, 0x06E6, 0x06E9, 0x06E9, 0x06EE, 0x070D,
	0x0710, 0x0710, 0x0712, 0x072F, 0x074D, 0x07A5, 0x07B1, 0x07B1,
	0x07C0, 0x07EA, 0x07F4, 0x07FA, 0x07FE, 0x0815, 0x081A, 0x081A,
	0x0824, 0x0824, 0x0828, 0x0828, 0x0830, 0x083E, 0x0840, 0x0858,
	0x085E, 0x085E, 0x0860, 0x086A, 0x08A0, 0x08B4, 0x08B6, 0x08BD,
	0x0903, 0x0939, 0x093B, 0x093B, 0x093D, 0x0940, 0x0949, 0x094C,
	0x094E, 0x0950, 0x0958, 0x0961, 0x0964, 0x0980, 0x0982, 0x0983,
	0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8, 0x09AA, 0x09B0,
	0x09B2, 0x09B2, 0x09B6, 0x09B9, 0x09BD, 0x09BD, 0x09BF, 0x09C0,
	0x09C7, 0x09C8, 0x09CB, 0x09CC, 0x09CE, 0x09CE, 0x09DC, 0x09DD,
	0x09DF, 0x09E1, 0x09E6, 0x09FD, 0x0A03, 0x0A03, 0x0A05, 0x0A0A,
	0x0A0F, 0x0A10, 0x0A13, 0x0A28, 0x0A2A, 0x0A30, 0x0A32, 0x0A33,
	0x0A35, 0x0A36, 0x0A38, 0x0A39, 0x0A3E, 0x0A40, 0x0A59, 0x0A5C,
	0x0A5E, 0x0A5E, 0x0A66, 0x0A6F, 0x0A72, 0x0A74, 0x0A76, 0x0A76,
	0x0A83, 0x0A83, 0x0A85, 0x0A8D, 0x0A8F, 0x0A91, 0x0A93, 0x0AA8,
	0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9, 0x0ABD, 0x0AC0,
	0x0AC9, 0x0AC9, 0x0ACB, 0x0ACC, 0x0AD0, 0x0AD0, 0x0AE0, 0x0AE1,
	0x0AE6, 0x0AF1, 0x0AF9, 0x0AF9, 0x0B02, 0x0B03, 0x0B05, 0x0B0C,
	0x0B0F, 0x0B10, 0x0B13, 0x0B28, 0x0B2A, 0x0B30, 0x0B32, 0x0B33,
	0x0B35, 0x0B39, 0x0B3D, 0x0B3D, 0x0B40, 0x0B40, 0x0B47, 0x0B48,
	0x0B4B, 0x0B4C, 0x0B5C, 0x0B5D, 0x0B5F, 0x0B61, 0x0B66, 0x0B77,
	0x0B83, 0x0B83, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90, 0x0B92, 0x0B95,
	0x0B99, 0x0B9A, 0x0B9C, 0x0B9C, 0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4,
	0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9, 0x0BBF, 0x0BBF, 0x0BC1, 0x0BC2,
	0x0BC6, 0x0BC8, 0x0BCA, 0x0BCC, 0x0BD0, 0x0BD0, 0x0BE6, 0x0BFA,
	0x0C01, 0x0C03, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10, 0x0C12, 0x0C28,
	0x0C2A, 0x0C39, 0x0C3D, 0x0C3D, 0x0C41, 0x0C44, 0x0C58, 0x0C5A,
	0x0C60, 0x0C61, 0x0C66, 0x0C6F, 0x0C77, 0x0C80, 0x0C82, 0x0C8C,
	0x0C8E, 0x0C90, 0x0C92, 0x0CA8, 0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9,
	0x0CBD, 0x0CBE, 0x0CC0, 0x0CC1, 0x0CC3, 0x0CC4, 0x0CC7, 0x0CC8,
	0x0CCA, 0x0CCB, 0x0CDE, 0x0CDE, 0x0CE0, 0x0CE1, 0x0CE6, 0x0CEF,
	0x0CF1, 0x0CF2, 0x0D02, 0x0D03, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10,
	0x0D12, 0x0D3A, 0x0D3D, 0x0D3D, 0x0D3F, 0x0D40, 0x0D46, 0x0D48,
	0x0D4A, 0x0D4C, 0x0D4E, 0x0D4F, 0x0D54, 0x0D56, 0x0D58, 0x0D61,
	0x0D66, 0x0D7F, 0x0D82, 0x0D83, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1,
	0x0DB3, 0x0DBB, 0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0DD0, 0x0DD1,
	0x0DD8, 0x0DDE, 0x0DE6, 0x0DEF, 0x0DF2, 0x0DF4, 0x0E01, 0x0E30,
	0x0E32, 0x0E33, 0x0E3F, 0x0E46, 0x0E4F, 0x0E5B, 0x0E81, 0x0E82,
	0x0E84, 0x0E84, 0x0E86, 0x0E8A, 0x0E8C, 0x0EA3, 0x0EA5, 0x0EA5,
	0x0EA7, 0x0EB0, 0x0EB2, 0x0EB3, 0x0EBD, 0x0EBD, 0x0EC0, 0x0EC4,
	0x0EC6, 0x0EC6, 0x0ED0, 0x0ED9, 0x0EDC, 0x0EDF, 0x0F00, 0x0F17,
	0x0F1A, 0x0F34, 0x0F36, 0x0F36, 0x0F38, 0x0F38, 0x0F3A, 0x0F47,
	0x0F49, 0x0F6C, 0x0F7F, 0x0F7F, 0x0F85, 0x0F85, 0x0F88, 0x0F8C,
	0x0FBE, 0x0FC5, 0x0FC7, 0x0FCC, 0x0FCE, 0x0FDA, 0x1000, 0x102C,
	0x1031, 0x1031, 0x1038, 0x1038, 0x103B, 0x103C, 0x103F, 0x1057,
	0x105A, 0x105D, 0x1061, 0x1070, 0x1075, 0x1081, 0x1083, 0x1084,
	0x1087, 0x108C, 0x108E, 0x109C, 0x109E, 0x10C5, 0x10C7, 0x10C7,
	0x10CD, 0x10CD, 0x10D0, 0x1248, 0x124A, 0x124D, 0x1250, 0x1256,
	0x1258, 0x1258, 0x125A, 0x125D, 0x1260, 0x1288, 0x128A, 0x128D,
	0x1290, 0x12B0, 0x12B2, 0x12B5, 0x12B8, 0x12BE, 0x12C0, 0x12C0,
	0x12C2, 0x12C5, 0x12C8, 0x12D6, 0x12D8, 0x1310, 0x1312, 0x1315,
	0x1318, 0x135A, 0x1360, 0x137C, 0x1380, 0x1399, 0x13A0, 0x13F5,
	0x13F8, 0x13FD, 0x1400, 0x169C, 0x16A0, 0x16F8, 0x1700, 0x170C,
	0x170E, 0x1711, 0x1720, 0x1731, 0x1735, 0x1736, 0x1740, 0x1751,
	0x1760, 0x176C, 0x176E, 0x1770, 0x1780, 0x17B3, 0x17B6, 0x17B6,
	0x17BE, 0x17C5, 0x17C7, 0x17C8, 0x17D4, 0x17DC, 0x17E0, 0x17E9,
	0x17F0, 0x17F9, 0x1800, 0x180A, 0x1810, 0x1819, 0x1820, 0x1878,
	0x1880, 0x1884, 0x1887, 0x18A8, 0x18AA, 0x18AA, 0x18B0, 0x18F5,
	0x1900, 0x191E, 0x1923, 0x1926, 0x1929, 0x192B, 0x1930, 0x1931,
	0x1933, 0x1938, 0x1940, 0x1940, 0x1944, 0x196D, 0x1970, 0x1974,
	0x1980, 0x19AB, 0x19B0, 0x19C9, 0x19D0, 0x19DA, 0x19DE, 0x1A16,
	0x1A19, 0x1A1A, 0x1A1E, 0x1A55, 0x1A57, 0x1A57, 0x1A61, 0x1A61,
	0x1A63, 0x1A64, 0x1A6D, 0x1A72, 0x1A80, 0x1A89, 0x1A90, 0x1A99,
	0x1AA0, 0x1AAD, 0x1B04, 0x1B33, 0x1B3B, 0x1B3B, 0x1B3D, 0x1B41,
	0x1B43, 0x1B4B, 0x1B50, 0x1B6A, 0x1B74, 0x1B7C, 0x1B82, 0x1BA1,
	0x1BA6, 0x1BA7, 0x1BAA, 0x1BAA, 0x1BAE, 0x1BE5, 0x1BE7, 0x1BE7,
	0x1BEA, 0x1BEC, 0x1BEE, 0x1BEE, 0x1BF2, 0x1BF3, 0x1BFC, 0x1C2B,
	0x1C34, 0x1C35, 0x1C3B, 0x1C49, 0x1C4D, 0x1C88, 0x1C90, 0x1CBA,
	0x1CBD, 0x1CC7, 0x1CD3, 0x1CD3, 0x1CE1, 0x1CE1, 0x1CE9, 0x1CEC,
	0x1CEE, 0x1CF3, 0x1CF5, 0x1CF7, 0x1CFA, 0x1CFA, 0x1D00, 0x1DBF,
	0x1E00, 0x1F15, 0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D,
	0x1F50, 0x1F57, 0x1F59, 0x1F59, 0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D,
	0x1F5F, 0x1F7D, 0x1F80, 0x1FB4, 0x1FB6, 0x1FC4, 0x1FC6, 0x1FD3,
	0x1FD6, 0x1FDB, 0x1FDD, 0x1FEF, 0x1FF2, 0x1FF4, 0x1FF6, 0x1FFE,
	0x2000, 0x200A, 0x2010, 0x2027, 0x202F, 0x205F, 0x2070, 0x2071,
	0x2074, 0x208E, 0x2090, 0x209C, 0x20A0, 0x20BF, 0x2100, 0x218B,
	0x2190, 0x2426, 0x2440, 0x244A, 0x2460, 0x2B73, 0x2B76, 0x2B95,
	0x2B98, 0x2C2E, 0x2C30, 0x2C5E, 0x2C60, 0x2CEE, 0x2CF2, 0x2CF3,
	0x2CF9, 0x2D25, 0x2D27, 0x2D27, 0x2D2D, 0x2D2D, 0x2D30, 0x2D67,
	0x2D6F, 0x2D70, 0x2D80, 0x2D96, 0x2DA0, 0x2DA6, 0x2DA8, 0x2DAE,
	0x2DB0, 0x2DB6, 0x2DB8, 0x2DBE, 0x2DC0, 0x2DC6, 0x2DC8, 0x2DCE,
	0x2DD0, 0x2DD6, 0x2DD8, 0x2DDE, 0x2E00, 0x2E4F, 0x2E80, 0x2E99,
	0x2E9B, 0x2EF3, 0x2F00, 0x2FD5, 0x2FF0, 0x2FFB, 0x3000, 0x3029,
	0x3030, 0x303F, 0x3041, 0x3096, 0x309B, 0x30FF, 0x3105, 0x312F,
	0x3131, 0x318E, 0x3190, 0x31BA, 0x31C0, 0x31E3, 0x31F0, 0x321E,
	0x3220, 0x4DB5, 0x4DC0, 0x9FEF, 0xA000, 0xA48C, 0xA490, 0xA4C6,
	0xA4D0, 0xA62B, 0xA640, 0xA66E, 0xA673, 0xA673, 0xA67E, 0xA69D,
	0xA6A0, 0xA6EF, 0xA6F2, 0xA6F7, 0xA700, 0xA7BF, 0xA7C2, 0xA7C6,
	0xA7F7, 0xA801, 0xA803, 0xA805, 0xA807, 0xA80A, 0xA80C, 0xA824,
	0xA827, 0xA82B, 0xA830, 0xA839, 0xA840, 0xA877, 0xA880, 0xA8C3,
	0xA8CE, 0xA8D9, 0xA8F2, 0xA8FE, 0xA900, 0xA925, 0xA92E, 0xA946,
	0xA952, 0xA953, 0xA95F, 0xA97C, 0xA983, 0xA9B2, 0xA9B4, 0xA9B5,
	0xA9BA, 0xA9BB, 0xA9BE, 0xA9CD, 0xA9CF, 0xA9D9, 0xA9DE, 0xA9E4,
	0xA9E6, 0xA9FE, 0xAA00, 0xAA28, 0xAA2F, 0xAA30, 0xAA33, 0xAA34,
	0xAA40, 0xAA42, 0xAA44, 0xAA4B, 0xAA4D, 0xAA4D, 0xAA50, 0xAA59,
	0xAA5C, 0xAA7B, 0xAA7D, 0xAAAF, 0xAAB1, 0xAAB1, 0xAAB5, 0xAAB6,
	0xAAB9, 0xAABD, 0xAAC0, 0xAAC0, 0xAAC2, 0xAAC2, 0xAADB, 0xAAEB,
	0xAAEE, 0xAAF5, 0xAB01, 0xAB06, 0xAB09, 0xAB0E, 0xAB11, 0xAB16,
	0xAB20, 0xAB26, 0xAB28, 0xAB2E, 0xAB30, 0xAB67, 0xAB70, 0xABE4,
	0xABE6, 0xABE7, 0xABE9, 0xABEC, 0xABF0, 0xABF9, 0xAC00, 0xD7A3,
	0xD7B0, 0xD7C6, 0xD7CB, 0xD7FB, 0xF900, 0xFA6D, 0xFA70, 0xFAD9,
	0xFB00, 0xFB06, 0xFB13, 0xFB17, 0xFB1D, 0xFB1D, 0xFB1F, 0xFB36,
	0xFB38, 0xFB3C, 0xFB3E, 0xFB3E, 0xFB40, 0xFB41, 0xFB43, 0xFB44,
	0xFB46, 0xFBC1, 0xFBD3, 0xFD3F, 0xFD50, 0xFD8F, 0xFD92, 0xFDC7,
	0xFDF0, 0xFDFD, 0xFE10, 0xFE19, 0xFE30, 0xFE52, 0xFE54, 0xFE66,
	0xFE68, 0xFE6B, 0xFE70, 0xFE74, 0xFE76, 0xFEFC, 0xFF01, 0xFF9D,
	0xFFA0, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF, 0xFFD2, 0xFFD7,
	0xFFDA, 0xFFDC, 0xFFE0, 0xFFE6, 0xFFE8, 0xFFEE, 0xFFFC, 0xFFFD,
	0x10000, 0x1000B, 0x1000D, 0x10026, 0x10028, 0x1003A, 0x1003C, 0x1003D,
	0x1003F, 0x1004D, 0x10050, 0x1005D, 0x10080, 0x100FA, 0x10100, 0x10102,
	0x10107, 0x10133, 0x10137, 0x1018E, 0x10190, 0x1019B, 0x101A0, 0x101A0,
	0x101D0, 0x101FC, 0x10280, 0x1029C, 0x102A0, 0x102D0, 0x102E1, 0x102FB,
	0x10300, 0x10323, 0x1032D, 0x1034A, 0x10350, 0x10375, 0x10380, 0x1039D,
	0x1039F, 0x103C3, 0x103C8, 0x103D5, 0x10400, 0x1049D, 0x104A0, 0x104A9,
	0x104B0, 0x104D3, 0x104D8, 0x104FB, 0x10500, 0x10527, 0x10530, 0x10563,
	0x1056F, 0x1056F, 0x10600, 0x10736, 0x10740, 0x10755, 0x10760, 0x10767,
	0x10800, 0x10805, 0x10808, 0x10808, 0x1080A, 0x10835, 0x10837, 0x10838,
	0x1083C, 0x1083C, 0x1083F, 0x10855, 0x10857, 0x1089E, 0x108A7, 0x108AF,
	0x108E0, 0x108F2, 0x108F4, 0x108F5, 0x108FB, 0x1091B, 0x1091F, 0x10939,
	0x1093F, 0x1093F, 0x10980, 0x109B7, 0x109BC, 0x109CF, 0x109D2, 0x10A00,
	0x10A10, 0x10A13, 0x10A15, 0x10A17, 0x10A19, 0x10A35, 0x10A40, 0x10A48,
	0x10A50, 0x10A58, 0x10A60, 0x10A9F, 0x10AC0, 0x10AE4, 0x10AEB, 0x10AF6,
	0x10B00, 0x10B35, 0x10B39, 0x10B55, 0x10B58, 0x10B72, 0x10B78, 0x10B91,
	0x10B99, 0x10B9C, 0x10BA9, 0x10BAF, 0x10C00, 0x10C48, 0x10C80, 0x10CB2,
	0x10CC0, 0x10CF2, 0x10CFA, 0x10D23, 0x10D30, 0x10D39, 0x10E60, 0x10E7E,
	0x10F00, 0x10F27, 0x10F30, 0x10F45, 0x10F51, 0x10F59, 0x10FE0, 0x10FF6,
	0x11000, 0x11000, 0x11002, 0x11037, 0x11047, 0x1104D, 0x11052, 0x1106F,
	0x11082, 0x110B2, 0x110B7, 0x110B8, 0x110BB, 0x110BC, 0x110BE, 0x110C1,
	0x110D0, 0x110E8, 0x110F0, 0x110F9, 0x11103, 0x11126, 0x1112C, 0x1112C,
	0x11136, 0x11146, 0x11150, 0x11172, 0x11174, 0x11176, 0x11182, 0x111B5,
	0x111BF, 0x111C8, 0x111CD, 0x111CD, 0x111D0, 0x111DF, 0x111E1, 0x111F4,
	0x11200, 0x11211, 0x11213, 0x1122E, 0x11232, 0x11233, 0x11235, 0x11235,
	0x11238, 0x1123D, 0x11280, 0x11286, 0x11288, 0x11288, 0x1128A, 0x1128D,
	0x1128F, 0x1129D, 0x1129F, 0x112A9, 0x112B0, 0x112DE, 0x112E0, 0x112E2,
	0x112F0, 0x112F9, 0x11302, 0x11303, 0x11305, 0x1130C, 0x1130F, 0x11310,
	0x11313, 0x11328, 0x1132A, 0x11330, 0x11332, 0x11333, 0x11335, 0x11339,
	0x1133D, 0x1133D, 0x1133F, 0x1133F, 0x11341, 0x11344, 0x11347, 0x11348,
	0x1134B, 0x1134D, 0x11350, 0x11350, 0x1135D, 0x11363, 0x11400, 0x11437,
	0x11440, 0x11441, 0x11445, 0x11445, 0x11447, 0x11459, 0x1145B, 0x1145B,
	0x1145D, 0x1145D, 0x1145F, 0x1145F, 0x11480, 0x114AF, 0x114B1, 0x114B2,
	0x114B9, 0x114B9, 0x114BB, 0x114BC, 0x114BE, 0x114BE, 0x114C1, 0x114C1,
	0x114C4, 0x114C7, 0x114D0, 0x114D9, 0x11580, 0x115AE, 0x115B0, 0x115B1,
	0x115B8, 0x115BB, 0x115BE, 0x115BE, 0x115C1, 0x115DB, 0x11600, 0x11632,
	0x1163B, 0x1163C, 0x1163E, 0x1163E, 0x11641, 0x11644, 0x11650, 0x11659,
	0x11660, 0x1166C, 0x11680, 0x116AA, 0x116AC, 0x116AC, 0x116AE, 0x116AF,
	0x116B6, 0x116B6, 0x116B8, 0x116B8, 0x116C0, 0x116C9, 0x11700, 0x1171A,
	0x11720, 0x11721, 0x11726, 0x11726, 0x11730, 0x1173F, 0x11800, 0x1182E,
	0x11838, 0x11838, 0x1183B, 0x1183B, 0x118A0, 0x118F2, 0x118FF, 0x118FF,
	0x119A0, 0x119A7, 0x119AA, 0x119D3, 0x119DC, 0x119DF, 0x119E1, 0x119E4,
	0x11A00, 0x11A00, 0x11A0B, 0x11A32, 0x11A39, 0x11A3A, 0x11A3F, 0x11A46,
	0x11A50, 0x11A50, 0x11A57, 0x11A58, 0x11A5C, 0x11A89, 0x11A97, 0x11A97,
	0x11A9A, 0x11AA2, 0x11AC0, 0x11AF8, 0x11C00, 0x11C08, 0x11C0A, 0x11C2F,
	0x11C3E, 0x11C3E, 0x11C40, 0x11C45, 0x11C50, 0x11C6C, 0x11C70, 0x11C8F,
	0x11CA9, 0x11CA9, 0x11CB1, 0x11CB1, 0x11CB4, 0x11CB4, 0x11D00, 0x11D06,
	0x11D08, 0x11D09, 0x11D0B, 0x11D30, 0x11D46, 0x11D46, 0x11D50, 0x11D59,
	0x11D60, 0x11D65, 0x11D67, 0x11D68, 0x11D6A, 0x11D8E, 0x11D93, 0x11D94,
	0x11D96, 0x11D96, 0x11D98, 0x11D98, 0x11DA0, 0x11DA9, 0x11EE0, 0x11EF2,
	0x11EF5, 0x11EF8, 0x11FC0, 0x11FF1, 0x11FFF, 0x12399, 0x12400, 0x1246E,
	0x12470, 0x12474, 0x12480, 0x12543, 0x13000, 0x1342E, 0x14400, 0x14646,
	0x16800, 0x16A38, 0x16A40, 0x16A5E, 0x16A60, 0x16A69, 0x16A6E, 0x16A6F,
	0x16AD0, 0x16AED, 0x16AF5, 0x16AF5, 0x16B00, 0x16B2F, 0x16B37, 0x16B45,
	0x16B50, 0x16B59, 0x16B5B, 0x16B61, 0x16B63, 0x16B77, 0x16B7D, 0x16B8F,
	0x16E40, 0x16E9A, 0x16F00, 0x16F4A, 0x16F50, 0x16F87, 0x16F93, 0x16F9F,
	0x16FE0, 0x16FE3, 0x17000, 0x187F7, 0x18800, 0x18AF2, 0x1B000, 0x1B11E,
	0x1B150, 0x1B152, 0x1B164, 0x1B167, 0x1B170, 0x1B2FB, 0x1BC00, 0x1BC6A,
	0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88, 0x1BC90, 0x1BC99, 0x1BC9C, 0x1BC9C,
	0x1BC9F, 0x1BC9F, 0x1D000, 0x1D0F5, 0x1D100, 0x1D126, 0x1D129, 0x1D164,
	0x1D166, 0x1D166, 0x1D16A, 0x1D16D, 0x1D183, 0x1D184, 0x1D18C, 0x1D1A9,
	0x1D1AE, 0x1D1E8, 0x1D200, 0x1D241, 0x1D245, 0x1D245, 0x1D2E0, 0x1D2F3,
	0x1D300, 0x1D356, 0x1D360, 0x1D378, 0x1D400, 0x1D454, 0x1D456, 0x1D49C,
	0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC,
	0x1D4AE, 0x1D4B9, 0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505,
	0x1D507, 0x1D50A, 0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539,
	0x1D53B, 0x1D53E, 0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550,
	0x1D552, 0x1D6A5, 0x1D6A8, 0x1D7CB, 0x1D7CE, 0x1D9FF, 0x1DA37, 0x1DA3A,
	0x1DA6D, 0x1DA74, 0x1DA76, 0x1DA83, 0x1DA85, 0x1DA8B, 0x1E100, 0x1E12C,
	0x1E137, 0x1E13D, 0x1E140, 0x1E149, 0x1E14E, 0x1E14F, 0x1E2C0, 0x1E2EB,
	0x1E2F0, 0x1E2F9, 0x1E2FF, 0x1E2FF, 0x1E800, 0x1E8C4, 0x1E8C7, 0x1E8CF,
	0x1E900, 0x1E943, 0x1E94B, 0x1E94B, 0x1E950, 0x1E959, 0x1E95E, 0x1E95F,
	0x1EC71, 0x1ECB4, 0x1ED01, 0x1ED3D, 0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F,
	0x1EE21, 0x1EE22, 0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32,
	0x1EE34, 0x1EE37, 0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42,
	0x1EE47, 0x1EE47, 0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F,
	0x1EE51, 0x1EE52, 0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59,
	0x1EE5B, 0x1EE5B, 0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62,
	0x1EE64, 0x1EE64, 0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77,
	0x1EE79, 0x1EE7C, 0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B,
	0x1EEA1, 0x1EEA3, 0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB, 0x1EEF0, 0x1EEF1,
	0x1F000, 0x1F02B, 0x1F030, 0x1F093, 0x1F0A0, 0x1F0AE, 0x1F0B1, 0x1F0BF,
	0x1F0C1, 0x1F0CF, 0x1F0D1, 0x1F0F5, 0x1F100, 0x1F10C, 0x1F110, 0x1F16C,
	0x1F170, 0x1F1AC, 0x1F1E6, 0x1F202, 0x1F210, 0x1F23B, 0x1F240, 0x1F248,
	0x1F250, 0x1F251, 0x1F260, 0x1F265, 0x1F300, 0x1F6D5, 0x1F6E0, 0x1F6EC,
	0x1F6F0, 0x1F6FA, 0x1F700, 0x1F773, 0x1F780, 0x1F7D8, 0x1F7E0, 0x1F7EB,
	0x1F800, 0x1F80B, 0x1F810, 0x1F847, 0x1F850, 0x1F859, 0x1F860, 0x1F887,
	0x1F890, 0x1F8AD, 0x1F900, 0x1F90B, 0x1F90D, 0x1F971, 0x1F973, 0x1F976,
	0x1F97A, 0x1F9A2, 0x1F9A5, 0x1F9AA, 0x1F9AE, 0x1F9CA, 0x1F9CD, 0x1FA53,
	0x1FA60, 0x1FA6D, 0x1FA70, 0x1FA73, 0x1FA78, 0x1FA7A, 0x1FA80, 0x1FA82,
	0x1FA90, 0x1FA95, 0x20000, 0x2A6D6, 0x2A700, 0x2B734, 0x2B740, 0x2B81D,
	0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0, 0x2F800, 0x2FA1D,
	//  #65 (9897+335): bp=Grapheme_Extend:Gr_Ext
	0x0300, 0x036F, 0x0483, 0x0489, 0x0591, 0x05BD, 0x05BF, 0x05BF,
	0x05C1, 0x05C2, 0x05C4, 0x05C5, 0x05C7, 0x05C7, 0x0610, 0x061A,
	0x064B, 0x065F, 0x0670, 0x0670, 0x06D6, 0x06DC, 0x06DF, 0x06E4,
	0x06E7, 0x06E8, 0x06EA, 0x06ED, 0x0711, 0x0711, 0x0730, 0x074A,
	0x07A6, 0x07B0, 0x07EB, 0x07F3, 0x07FD, 0x07FD, 0x0816, 0x0819,
	0x081B, 0x0823, 0x0825, 0x0827, 0x0829, 0x082D, 0x0859, 0x085B,
	0x08D3, 0x08E1, 0x08E3, 0x0902, 0x093A, 0x093A, 0x093C, 0x093C,
	0x0941, 0x0948, 0x094D, 0x094D, 0x0951, 0x0957, 0x0962, 0x0963,
	0x0981, 0x0981, 0x09BC, 0x09BC, 0x09BE, 0x09BE, 0x09C1, 0x09C4,
	0x09CD, 0x09CD, 0x09D7, 0x09D7, 0x09E2, 0x09E3, 0x09FE, 0x09FE,
	0x0A01, 0x0A02, 0x0A3C, 0x0A3C, 0x0A41, 0x0A42, 0x0A47, 0x0A48,
	0x0A4B, 0x0A4D, 0x0A51, 0x0A51, 0x0A70, 0x0A71, 0x0A75, 0x0A75,
	0x0A81, 0x0A82, 0x0ABC, 0x0ABC, 0x0AC1, 0x0AC5, 0x0AC7, 0x0AC8,
	0x0ACD, 0x0ACD, 0x0AE2, 0x0AE3, 0x0AFA, 0x0AFF, 0x0B01, 0x0B01,
	0x0B3C, 0x0B3C, 0x0B3E, 0x0B3F, 0x0B41, 0x0B44, 0x0B4D, 0x0B4D,
	0x0B56, 0x0B57, 0x0B62, 0x0B63, 0x0B82, 0x0B82, 0x0BBE, 0x0BBE,
	0x0BC0, 0x0BC0, 0x0BCD, 0x0BCD, 0x0BD7, 0x0BD7, 0x0C00, 0x0C00,
	0x0C04, 0x0C04, 0x0C3E, 0x0C40, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D,
	0x0C55, 0x0C56, 0x0C62, 0x0C63, 0x0C81, 0x0C81, 0x0CBC, 0x0CBC,
	0x0CBF, 0x0CBF, 0x0CC2, 0x0CC2, 0x0CC6, 0x0CC6, 0x0CCC, 0x0CCD,
	0x0CD5, 0x0CD6, 0x0CE2, 0x0CE3, 0x0D00, 0x0D01, 0x0D3B, 0x0D3C,
	0x0D3E, 0x0D3E, 0x0D41, 0x0D44, 0x0D4D, 0x0D4D, 0x0D57, 0x0D57,
	0x0D62, 0x0D63, 0x0DCA, 0x0DCA, 0x0DCF, 0x0DCF, 0x0DD2, 0x0DD4,
	0x0DD6, 0x0DD6, 0x0DDF, 0x0DDF, 0x0E31, 0x0E31, 0x0E34, 0x0E3A,
	0x0E47, 0x0E4E, 0x0EB1, 0x0EB1, 0x0EB4, 0x0EBC, 0x0EC8, 0x0ECD,
	0x0F18, 0x0F19, 0x0F35, 0x0F35, 0x0F37, 0x0F37, 0x0F39, 0x0F39,
	0x0F71, 0x0F7E, 0x0F80, 0x0F84, 0x0F86, 0x0F87, 0x0F8D, 0x0F97,
	0x0F99, 0x0FBC, 0x0FC6, 0x0FC6, 0x102D, 0x1030, 0x1032, 0x1037,
	0x1039, 0x103A, 0x103D, 0x103E, 0x1058, 0x1059, 0x105E, 0x1060,
	0x1071, 0x1074, 0x1082, 0x1082, 0x1085, 0x1086, 0x108D, 0x108D,
	0x109D, 0x109D, 0x135D, 0x135F, 0x1712, 0x1714, 0x1732, 0x1734,
	0x1752, 0x1753, 0x1772, 0x1773, 0x17B4, 0x17B5, 0x17B7, 0x17BD,
	0x17C6, 0x17C6, 0x17C9, 0x17D3, 0x17DD, 0x17DD, 0x180B, 0x180D,
	0x1885, 0x1886, 0x18A9, 0x18A9, 0x1920, 0x1922, 0x1927, 0x1928,
	0x1932, 0x1932, 0x1939, 0x193B, 0x1A17, 0x1A18, 0x1A1B, 0x1A1B,
	0x1A56, 0x1A56, 0x1A58, 0x1A5E, 0x1A60, 0x1A60, 0x1A62, 0x1A62,
	0x1A65, 0x1A6C, 0x1A73, 0x1A7C, 0x1A7F, 0x1A7F, 0x1AB0, 0x1ABE,
	0x1B00, 0x1B03, 0x1B34, 0x1B3A, 0x1B3C, 0x1B3C, 0x1B42, 0x1B42,
	0x1B6B, 0x1B73, 0x1B80, 0x1B81, 0x1BA2, 0x1BA5, 0x1BA8, 0x1BA9,
	0x1BAB, 0x1BAD, 0x1BE6, 0x1BE6, 0x1BE8, 0x1BE9, 0x1BED, 0x1BED,
	0x1BEF, 0x1BF1, 0x1C2C, 0x1C33, 0x1C36, 0x1C37, 0x1CD0, 0x1CD2,
	0x1CD4, 0x1CE0, 0x1CE2, 0x1CE8, 0x1CED, 0x1CED, 0x1CF4, 0x1CF4,
	0x1CF8, 0x1CF9, 0x1DC0, 0x1DF9, 0x1DFB, 0x1DFF, 0x200C, 0x200C,
	0x20D0, 0x20F0, 0x2CEF, 0x2CF1, 0x2D7F, 0x2D7F, 0x2DE0, 0x2DFF,
	0x302A, 0x302F, 0x3099, 0x309A, 0xA66F, 0xA672, 0xA674, 0xA67D,
	0xA69E, 0xA69F, 0xA6F0, 0xA6F1, 0xA802, 0xA802, 0xA806, 0xA806,
	0xA80B, 0xA80B, 0xA825, 0xA826, 0xA8C4, 0xA8C5, 0xA8E0, 0xA8F1,
	0xA8FF, 0xA8FF, 0xA926, 0xA92D, 0xA947, 0xA951, 0xA980, 0xA982,
	0xA9B3, 0xA9B3, 0xA9B6, 0xA9B9, 0xA9BC, 0xA9BD, 0xA9E5, 0xA9E5,
	0xAA29, 0xAA2E, 0xAA31, 0xAA32, 0xAA35, 0xAA36, 0xAA43, 0xAA43,
	0xAA4C, 0xAA4C, 0xAA7C, 0xAA7C, 0xAAB0, 0xAAB0, 0xAAB2, 0xAAB4,
	0xAAB7, 0xAAB8, 0xAABE, 0xAABF, 0xAAC1, 0xAAC1, 0xAAEC, 0xAAED,
	0xAAF6, 0xAAF6, 0xABE5, 0xABE5, 0xABE8, 0xABE8, 0xABED, 0xABED,
	0xFB1E, 0xFB1E, 0xFE00, 0xFE0F, 0xFE20, 0xFE2F, 0xFF9E, 0xFF9F,
	0x101FD, 0x101FD, 0x102E0, 0x102E0, 0x10376, 0x1037A, 0x10A01, 0x10A03,
	0x10A05, 0x10A06, 0x10A0C, 0x10A0F, 0x10A38, 0x10A3A, 0x10A3F, 0x10A3F,
	0x10AE5, 0x10AE6, 0x10D24, 0x10D27, 0x10F46, 0x10F50, 0x11001, 0x11001,
	0x11038, 0x11046, 0x1107F, 0x11081, 0x110B3, 0x110B6, 0x110B9, 0x110BA,
	0x11100, 0x11102, 0x11127, 0x1112B, 0x1112D, 0x11134, 0x11173, 0x11173,
	0x11180, 0x11181, 0x111B6, 0x111BE, 0x111C9, 0x111CC, 0x1122F, 0x11231,
	0x11234, 0x11234, 0x11236, 0x11237, 0x1123E, 0x1123E, 0x112DF, 0x112DF,
	0x112E3, 0x112EA, 0x11300, 0x11301, 0x1133B, 0x1133C, 0x1133E, 0x1133E,
	0x11340, 0x11340, 0x11357, 0x11357, 0x11366, 0x1136C, 0x11370, 0x11374,
	0x11438, 0x1143F, 0x11442, 0x11444, 0x11446, 0x11446, 0x1145E, 0x1145E,
	0x114B0, 0x114B0, 0x114B3, 0x114B8, 0x114BA, 0x114BA, 0x114BD, 0x114BD,
	0x114BF, 0x114C0, 0x114C2, 0x114C3, 0x115AF, 0x115AF, 0x115B2, 0x115B5,
	0x115BC, 0x115BD, 0x115BF, 0x115C0, 0x115DC, 0x115DD, 0x11633, 0x1163A,
	0x1163D, 0x1163D, 0x1163F, 0x11640, 0x116AB, 0x116AB, 0x116AD, 0x116AD,
	0x116B0, 0x116B5, 0x116B7, 0x116B7, 0x1171D, 0x1171F, 0x11722, 0x11725,
	0x11727, 0x1172B, 0x1182F, 0x11837, 0x11839, 0x1183A, 0x119D4, 0x119D7,
	0x119DA, 0x119DB, 0x119E0, 0x119E0, 0x11A01, 0x11A0A, 0x11A33, 0x11A38,
	0x11A3B, 0x11A3E, 0x11A47, 0x11A47, 0x11A51, 0x11A56, 0x11A59, 0x11A5B,
	0x11A8A, 0x11A96, 0x11A98, 0x11A99, 0x11C30, 0x11C36, 0x11C38, 0x11C3D,
	0x11C3F, 0x11C3F, 0x11C92, 0x11CA7, 0x11CAA, 0x11CB0, 0x11CB2, 0x11CB3,
	0x11CB5, 0x11CB6, 0x11D31, 0x11D36, 0x11D3A, 0x11D3A, 0x11D3C, 0x11D3D,
	0x11D3F, 0x11D45, 0x11D47, 0x11D47, 0x11D90, 0x11D91, 0x11D95, 0x11D95,
	0x11D97, 0x11D97, 0x11EF3, 0x11EF4, 0x16AF0, 0x16AF4, 0x16B30, 0x16B36,
	0x16F4F, 0x16F4F, 0x16F8F, 0x16F92, 0x1BC9D, 0x1BC9E, 0x1D165, 0x1D165,
	0x1D167, 0x1D169, 0x1D16E, 0x1D172, 0x1D17B, 0x1D182, 0x1D185, 0x1D18B,
	0x1D1AA, 0x1D1AD, 0x1D242, 0x1D244, 0x1DA00, 0x1DA36, 0x1DA3B, 0x1DA6C,
	0x1DA75, 0x1DA75, 0x1DA84, 0x1DA84, 0x1DA9B, 0x1DA9F, 0x1DAA1, 0x1DAAF,
	0x1E000, 0x1E006, 0x1E008, 0x1E018, 0x1E01B, 0x1E021, 0x1E023, 0x1E024,
	0x1E026, 0x1E02A, 0x1E130, 0x1E136, 0x1E2EC, 0x1E2EF, 0x1E8D0, 0x1E8D6,
	0x1E944, 0x1E94A, 0xE0020, 0xE007F, 0xE0100, 0xE01EF,
	//  #66 (10232+6): bp=Hex_Digit:Hex
	0x0030, 0x0039, 0x0041, 0x0046, 0x0061, 0x0066, 0xFF10, 0xFF19,
	0xFF21, 0xFF26, 0xFF41, 0xFF46,
	//  #67 (10238+2): bp=IDS_Binary_Operator:IDSB
	0x2FF0, 0x2FF1, 0x2FF4, 0x2FFB,
	//  #68 (10240+1): bp=IDS_Trinary_Operator:IDST
	0x2FF2, 0x2FF3,
	//  #69 (10241+713): bp=ID_Continue:IDC
	0x0030, 0x0039, 0x0041, 0x005A, 0x005F, 0x005F, 0x0061, 0x007A,
	0x00AA, 0x00AA, 0x00B5, 0x00B5, 0x00B7, 0x00B7, 0x00BA, 0x00BA,
	0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x02C1, 0x02C6, 0x02D1,
	0x02E0, 0x02E4, 0x02EC, 0x02EC, 0x02EE, 0x02EE, 0x0300, 0x0374,
	0x0376, 0x0377, 0x037A, 0x037D, 0x037F, 0x037F, 0x0386, 0x038A,
	0x038C, 0x038C, 0x038E, 0x03A1, 0x03A3, 0x03F5, 0x03F7, 0x0481,
	0x0483, 0x0487, 0x048A, 0x052F, 0x0531, 0x0556, 0x0559, 0x0559,
	0x0560, 0x0588, 0x0591, 0x05BD, 0x05BF, 0x05BF, 0x05C1, 0x05C2,
	0x05C4, 0x05C5, 0x05C7, 0x05C7, 0x05D0, 0x05EA, 0x05EF, 0x05F2,
	0x0610, 0x061A, 0x0620, 0x0669, 0x066E, 0x06D3, 0x06D5, 0x06DC,
	0x06DF, 0x06E8, 0x06EA, 0x06FC, 0x06FF, 0x06FF, 0x0710, 0x074A,
	0x074D, 0x07B1, 0x07C0, 0x07F5, 0x07FA, 0x07FA, 0x07FD, 0x07FD,
	0x0800, 0x082D, 0x0840, 0x085B, 0x0860, 0x086A, 0x08A0, 0x08B4,
	0x08B6, 0x08BD, 0x08D3, 0x08E1, 0x08E3, 0x0963, 0x0966, 0x096F,
	0x0971, 0x0983, 0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8,
	0x09AA, 0x09B0, 0x09B2, 0x09B2, 0x09B6, 0x09B9, 0x09BC, 0x09C4,
	0x09C7, 0x09C8, 0x09CB, 0x09CE, 0x09D7, 0x09D7, 0x09DC, 0x09DD,
	0x09DF, 0x09E3, 0x09E6, 0x09F1, 0x09FC, 0x09FC, 0x09FE, 0x09FE,
	0x0A01, 0x0A03, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10, 0x0A13, 0x0A28,
	0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36, 0x0A38, 0x0A39,
	0x0A3C, 0x0A3C, 0x0A3E, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4D,
	0x0A51, 0x0A51, 0x0A59, 0x0A5C, 0x0A5E, 0x0A5E, 0x0A66, 0x0A75,
	0x0A81, 0x0A83, 0x0A85, 0x0A8D, 0x0A8F, 0x0A91, 0x0A93, 0x0AA8,
	0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9, 0x0ABC, 0x0AC5,
	0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD, 0x0AD0, 0x0AD0, 0x0AE0, 0x0AE3,
	0x0AE6, 0x0AEF, 0x0AF9, 0x0AFF, 0x0B01, 0x0B03, 0x0B05, 0x0B0C,
	0x0B0F, 0x0B10, 0x0B13, 0x0B28, 0x0B2A, 0x0B30, 0x0B32, 0x0B33,
	0x0B35, 0x0B39, 0x0B3C, 0x0B44, 0x0B47, 0x0B48, 0x0B4B, 0x0B4D,
	0x0B56, 0x0B57, 0x0B5C, 0x0B5D, 0x0B5F, 0x0B63, 0x0B66, 0x0B6F,
	0x0B71, 0x0B71, 0x0B82, 0x0B83, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90,
	0x0B92, 0x0B95, 0x0B99, 0x0B9A, 0x0B9C, 0x0B9C, 0x0B9E, 0x0B9F,
	0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9, 0x0BBE, 0x0BC2,
	0x0BC6, 0x0BC8, 0x0BCA, 0x0BCD, 0x0BD0, 0x0BD0, 0x0BD7, 0x0BD7,
	0x0BE6, 0x0BEF, 0x0C00, 0x0C0C, 0x0C0E, 0x0C10, 0x0C12, 0x0C28,
	0x0C2A, 0x0C39, 0x0C3D, 0x0C44, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D,
	0x0C55, 0x0C56, 0x0C58, 0x0C5A, 0x0C60, 0x0C63, 0x0C66, 0x0C6F,
	0x0C80, 0x0C83, 0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8,
	0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBC, 0x0CC4, 0x0CC6, 0x0CC8,
	0x0CCA, 0x0CCD, 0x0CD5, 0x0CD6, 0x0CDE, 0x0CDE, 0x0CE0, 0x0CE3,
	0x0CE6, 0x0CEF, 0x0CF1, 0x0CF2, 0x0D00, 0x0D03, 0x0D05, 0x0D0C,
	0x0D0E, 0x0D10, 0x0D12, 0x0D44, 0x0D46, 0x0D48, 0x0D4A, 0x0D4E,
	0x0D54, 0x0D57, 0x0D5F, 0x0D63, 0x0D66, 0x0D6F, 0x0D7A, 0x0D7F,
	0x0D82, 0x0D83, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1, 0x0DB3, 0x0DBB,
	0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0DCA, 0x0DCA, 0x0DCF, 0x0DD4,
	0x0DD6, 0x0DD6, 0x0DD8, 0x0DDF, 0x0DE6, 0x0DEF, 0x0DF2, 0x0DF3,
	0x0E01, 0x0E3A, 0x0E40, 0x0E4E, 0x0E50, 0x0E59, 0x0E81, 0x0E82,
	0x0E84, 0x0E84, 0x0E86, 0x0E8A, 0x0E8C, 0x0EA3, 0x0EA5, 0x0EA5,
	0x0EA7, 0x0EBD, 0x0EC0, 0x0EC4, 0x0EC6, 0x0EC6, 0x0EC8, 0x0ECD,
	0x0ED0, 0x0ED9, 0x0EDC, 0x0EDF, 0x0F00, 0x0F00, 0x0F18, 0x0F19,
	0x0F20, 0x0F29, 0x0F35, 0x0F35, 0x0F37, 0x0F37, 0x0F39, 0x0F39,
	0x0F3E, 0x0F47, 0x0F49, 0x0F6C, 0x0F71, 0x0F84, 0x0F86, 0x0F97,
	0x0F99, 0x0FBC, 0x0FC6, 0x0FC6, 0x1000, 0x1049, 0x1050, 0x109D,
	0x10A0, 0x10C5, 0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x10D0, 0x10FA,
	0x10FC, 0x1248, 0x124A, 0x124D, 0x1250, 0x1256, 0x1258, 0x1258,
	0x125A, 0x125D, 0x1260, 0x1288, 0x128A, 0x128D, 0x1290, 0x12B0,
	0x12B2, 0x12B5, 0x12B8, 0x12BE, 0x12C0, 0x12C0, 0x12C2, 0x12C5,
	0x12C8, 0x12D6, 0x12D8, 0x1310, 0x1312, 0x1315, 0x1318, 0x135A,
	0x135D, 0x135F, 0x1369, 0x1371, 0x1380, 0x138F, 0x13A0, 0x13F5,
	0x13F8, 0x13FD, 0x1401, 0x166C, 0x166F, 0x167F, 0x1681, 0x169A,
	0x16A0, 0x16EA, 0x16EE, 0x16F8, 0x1700, 0x170C, 0x170E, 0x1714,
	0x1720, 0x1734, 0x1740, 0x1753, 0x1760, 0x176C, 0x176E, 0x1770,
	0x1772, 0x1773, 0x1780, 0x17D3, 0x17D7, 0x17D7, 0x17DC, 0x17DD,
	0x17E0, 0x17E9, 0x180B, 0x180D, 0x1810, 0x1819, 0x1820, 0x1878,
	0x1880, 0x18AA, 0x18B0, 0x18F5, 0x1900, 0x191E, 0x1920, 0x192B,
	0x1930, 0x193B, 0x1946, 0x196D, 0x1970, 0x1974, 0x1980, 0x19AB,
	0x19B0, 0x19C9, 0x19D0, 0x19DA, 0x1A00, 0x1A1B, 0x1A20, 0x1A5E,
	0x1A60, 0x1A7C, 0x1A7F, 0x1A89, 0x1A90, 0x1A99, 0x1AA7, 0x1AA7,
	0x1AB0, 0x1ABD, 0x1B00, 0x1B4B, 0x1B50, 0x1B59, 0x1B6B, 0x1B73,
	0x1B80, 0x1BF3, 0x1C00, 0x1C37, 0x1C40, 0x1C49, 0x1C4D, 0x1C7D,
	0x1C80, 0x1C88, 0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x1CD0, 0x1CD2,
	0x1CD4, 0x1CFA, 0x1D00, 0x1DF9, 0x1DFB, 0x1F15, 0x1F18, 0x1F1D,
	0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57, 0x1F59, 0x1F59,
	0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4,
	0x1FB6, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC,
	0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4,
	0x1FF6, 0x1FFC, 0x203F, 0x2040, 0x2054, 0x2054, 0x2071, 0x2071,
	0x207F, 0x207F, 0x2090, 0x209C, 0x20D0, 0x20DC, 0x20E1, 0x20E1,
	0x20E5, 0x20F0, 0x2102, 0x2102, 0x2107, 0x2107, 0x210A, 0x2113,
	0x2115, 0x2115, 0x2118, 0x211D, 0x2124, 0x2124, 0x2126, 0x2126,
	0x2128, 0x2128, 0x212A, 0x2139, 0x213C, 0x213F, 0x2145, 0x2149,
	0x214E, 0x214E, 0x2160, 0x2188, 0x2C00, 0x2C2E, 0x2C30, 0x2C5E,
	0x2C60, 0x2CE4, 0x2CEB, 0x2CF3, 0x2D00, 0x2D25, 0x2D27, 0x2D27,
	0x2D2D, 0x2D2D, 0x2D30, 0x2D67, 0x2D6F, 0x2D6F, 0x2D7F, 0x2D96,
	0x2DA0, 0x2DA6, 0x2DA8, 0x2DAE, 0x2DB0, 0x2DB6, 0x2DB8, 0x2DBE,
	0x2DC0, 0x2DC6, 0x2DC8, 0x2DCE, 0x2DD0, 0x2DD6, 0x2DD8, 0x2DDE,
	0x2DE0, 0x2DFF, 0x3005, 0x3007, 0x3021, 0x302F, 0x3031, 0x3035,
	0x3038, 0x303C, 0x3041, 0x3096, 0x3099, 0x309F, 0x30A1, 0x30FA,
	0x30FC, 0x30FF, 0x3105, 0x312F, 0x3131, 0x318E, 0x31A0, 0x31BA,
	0x31F0, 0x31FF, 0x3400, 0x4DB5, 0x4E00, 0x9FEF, 0xA000, 0xA48C,
	0xA4D0, 0xA4FD, 0xA500, 0xA60C, 0xA610, 0xA62B, 0xA640, 0xA66F,
	0xA674, 0xA67D, 0xA67F, 0xA6F1, 0xA717, 0xA71F, 0xA722, 0xA788,
	0xA78B, 0xA7BF, 0xA7C2, 0xA7C6, 0xA7F7, 0xA827, 0xA840, 0xA873,
	0xA880, 0xA8C5, 0xA8D0, 0xA8D9, 0xA8E0, 0xA8F7, 0xA8FB, 0xA8FB,
	0xA8FD, 0xA92D, 0xA930, 0xA953, 0xA960, 0xA97C, 0xA980, 0xA9C0,
	0xA9CF, 0xA9D9, 0xA9E0, 0xA9FE, 0xAA00, 0xAA36, 0xAA40, 0xAA4D,
	0xAA50, 0xAA59, 0xAA60, 0xAA76, 0xAA7A, 0xAAC2, 0xAADB, 0xAADD,
	0xAAE0, 0xAAEF, 0xAAF2, 0xAAF6, 0xAB01, 0xAB06, 0xAB09, 0xAB0E,
	0xAB11, 0xAB16, 0xAB20, 0xAB26, 0xAB28, 0xAB2E, 0xAB30, 0xAB5A,
	0xAB5C, 0xAB67, 0xAB70, 0xABEA, 0xABEC, 0xABED, 0xABF0, 0xABF9,
	0xAC00, 0xD7A3, 0xD7B0, 0xD7C6, 0xD7CB, 0xD7FB, 0xF900, 0xFA6D,
	0xFA70, 0xFAD9, 0xFB00, 0xFB06, 0xFB13, 0xFB17, 0xFB1D, 0xFB28,
	0xFB2A, 0xFB36, 0xFB38, 0xFB3C, 0xFB3E, 0xFB3E, 0xFB40, 0xFB41,
	0xFB43, 0xFB44, 0xFB46, 0xFBB1, 0xFBD3, 0xFD3D, 0xFD50, 0xFD8F,
	0xFD92, 0xFDC7, 0xFDF0, 0xFDFB, 0xFE00, 0xFE0F, 0xFE20, 0xFE2F,
	0xFE33, 0xFE34, 0xFE4D, 0xFE4F, 0xFE70, 0xFE74, 0xFE76, 0xFEFC,
	0xFF10, 0xFF19, 0xFF21, 0xFF3A, 0xFF3F, 0xFF3F, 0xFF41, 0xFF5A,
	0xFF66, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF, 0xFFD2, 0xFFD7,
	0xFFDA, 0xFFDC, 0x10000, 0x1000B, 0x1000D, 0x10026, 0x10028, 0x1003A,
	0x1003C, 0x1003D, 0x1003F, 0x1004D, 0x10050, 0x1005D, 0x10080, 0x100FA,
	0x10140, 0x10174, 0x101FD, 0x101FD, 0x10280, 0x1029C, 0x102A0, 0x102D0,
	0x102E0, 0x102E0, 0x10300, 0x1031F, 0x1032D, 0x1034A, 0x10350, 0x1037A,
	0x10380, 0x1039D, 0x103A0, 0x103C3, 0x103C8, 0x103CF, 0x103D1, 0x103D5,
	0x10400, 0x1049D, 0x104A0, 0x104A9, 0x104B0, 0x104D3, 0x104D8, 0x104FB,
	0x10500, 0x10527, 0x10530, 0x10563, 0x10600, 0x10736, 0x10740, 0x10755,
	0x10760, 0x10767, 0x10800, 0x10805, 0x10808, 0x10808, 0x1080A, 0x10835,
	0x10837, 0x10838, 0x1083C, 0x1083C, 0x1083F, 0x10855, 0x10860, 0x10876,
	0x10880, 0x1089E, 0x108E0, 0x108F2, 0x108F4, 0x108F5, 0x10900, 0x10915,
	0x10920, 0x10939, 0x10980, 0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A03,
	0x10A05, 0x10A06, 0x10A0C, 0x10A13, 0x10A15, 0x10A17, 0x10A19, 0x10A35,
	0x10A38, 0x10A3A, 0x10A3F, 0x10A3F, 0x10A60, 0x10A7C, 0x10A80, 0x10A9C,
	0x10AC0, 0x10AC7, 0x10AC9, 0x10AE6, 0x10B00, 0x10B35, 0x10B40, 0x10B55,
	0x10B60, 0x10B72, 0x10B80, 0x10B91, 0x10C00, 0x10C48, 0x10C80, 0x10CB2,
	0x10CC0, 0x10CF2, 0x10D00, 0x10D27, 0x10D30, 0x10D39, 0x10F00, 0x10F1C,
	0x10F27, 0x10F27, 0x10F30, 0x10F50, 0x10FE0, 0x10FF6, 0x11000, 0x11046,
	0x11066, 0x1106F, 0x1107F, 0x110BA, 0x110D0, 0x110E8, 0x110F0, 0x110F9,
	0x11100, 0x11134, 0x11136, 0x1113F, 0x11144, 0x11146, 0x11150, 0x11173,
	0x11176, 0x11176, 0x11180, 0x111C4, 0x111C9, 0x111CC, 0x111D0, 0x111DA,
	0x111DC, 0x111DC, 0x11200, 0x11211, 0x11213, 0x11237, 0x1123E, 0x1123E,
	0x11280, 0x11286, 0x11288, 0x11288, 0x1128A, 0x1128D, 0x1128F, 0x1129D,
	0x1129F, 0x112A8, 0x112B0, 0x112EA, 0x112F0, 0x112F9, 0x11300, 0x11303,
	0x11305, 0x1130C, 0x1130F, 0x11310, 0x11313, 0x11328, 0x1132A, 0x11330,
	0x11332, 0x11333, 0x11335, 0x11339, 0x1133B, 0x11344, 0x11347, 0x11348,
	0x1134B, 0x1134D, 0x11350, 0x11350, 0x11357, 0x11357, 0x1135D, 0x11363,
	0x11366, 0x1136C, 0x11370, 0x11374, 0x11400, 0x1144A, 0x11450, 0x11459,
	0x1145E, 0x1145F, 0x11480, 0x114C5, 0x114C7, 0x114C7, 0x114D0, 0x114D9,
	0x11580, 0x115B5, 0x115B8, 0x115C0, 0x115D8, 0x115DD, 0x11600, 0x11640,
	0x11644, 0x11644, 0x11650, 0x11659, 0x11680, 0x116B8, 0x116C0, 0x116C9,
	0x11700, 0x1171A, 0x1171D, 0x1172B, 0x11730, 0x11739, 0x11800, 0x1183A,
	0x118A0, 0x118E9, 0x118FF, 0x118FF, 0x119A0, 0x119A7, 0x119AA, 0x119D7,
	0x119DA, 0x119E1, 0x119E3, 0x119E4, 0x11A00, 0x11A3E, 0x11A47, 0x11A47,
	0x11A50, 0x11A99, 0x11A9D, 0x11A9D, 0x11AC0, 0x11AF8, 0x11C00, 0x11C08,
	0x11C0A, 0x11C36, 0x11C38, 0x11C40, 0x11C50, 0x11C59, 0x11C72, 0x11C8F,
	0x11C92, 0x11CA7, 0x11CA9, 0x11CB6, 0x11D00, 0x11D06, 0x11D08, 0x11D09,
	0x11D0B, 0x11D36, 0x11D3A, 0x11D3A, 0x11D3C, 0x11D3D, 0x11D3F, 0x11D47,
	0x11D50, 0x11D59, 0x11D60, 0x11D65, 0x11D67, 0x11D68, 0x11D6A, 0x11D8E,
	0x11D90, 0x11D91, 0x11D93, 0x11D98, 0x11DA0, 0x11DA9, 0x11EE0, 0x11EF6,
	0x12000, 0x12399, 0x12400, 0x1246E, 0x12480, 0x12543, 0x13000, 0x1342E,
	0x14400, 0x14646, 0x16800, 0x16A38, 0x16A40, 0x16A5E, 0x16A60, 0x16A69,
	0x16AD0, 0x16AED, 0x16AF0, 0x16AF4, 0x16B00, 0x16B36, 0x16B40, 0x16B43,
	0x16B50, 0x16B59, 0x16B63, 0x16B77, 0x16B7D, 0x16B8F, 0x16E40, 0x16E7F,
	0x16F00, 0x16F4A, 0x16F4F, 0x16F87, 0x16F8F, 0x16F9F, 0x16FE0, 0x16FE1,
	0x16FE3, 0x16FE3, 0x17000, 0x187F7, 0x18800, 0x18AF2, 0x1B000, 0x1B11E,
	0x1B150, 0x1B152, 0x1B164, 0x1B167, 0x1B170, 0x1B2FB, 0x1BC00, 0x1BC6A,
	0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88, 0x1BC90, 0x1BC99, 0x1BC9D, 0x1BC9E,
	0x1D165, 0x1D169, 0x1D16D, 0x1D172, 0x1D17B, 0x1D182, 0x1D185, 0x1D18B,
	0x1D1AA, 0x1D1AD, 0x1D242, 0x1D244, 0x1D400, 0x1D454, 0x1D456, 0x1D49C,
	0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC,
	0x1D4AE, 0x1D4B9, 0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505,
	0x1D507, 0x1D50A, 0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539,
	0x1D53B, 0x1D53E, 0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550,
	0x1D552, 0x1D6A5, 0x1D6A8, 0x1D6C0, 0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6FA,
	0x1D6FC, 0x1D714, 0x1D716, 0x1D734, 0x1D736, 0x1D74E, 0x1D750, 0x1D76E,
	0x1D770, 0x1D788, 0x1D78A, 0x1D7A8, 0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7CB,
	0x1D7CE, 0x1D7FF, 0x1DA00, 0x1DA36, 0x1DA3B, 0x1DA6C, 0x1DA75, 0x1DA75,
	0x1DA84, 0x1DA84, 0x1DA9B, 0x1DA9F, 0x1DAA1, 0x1DAAF, 0x1E000, 0x1E006,
	0x1E008, 0x1E018, 0x1E01B, 0x1E021, 0x1E023, 0x1E024, 0x1E026, 0x1E02A,
	0x1E100, 0x1E12C, 0x1E130, 0x1E13D, 0x1E140, 0x1E149, 0x1E14E, 0x1E14E,
	0x1E2C0, 0x1E2F9, 0x1E800, 0x1E8C4, 0x1E8D0, 0x1E8D6, 0x1E900, 0x1E94B,
	0x1E950, 0x1E959, 0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22,
	0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37,
	0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47,
	0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52,
	0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B,
	0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64,
	0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C,
	0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3,
	0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB, 0x20000, 0x2A6D6, 0x2A700, 0x2B734,
	0x2B740, 0x2B81D, 0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0, 0x2F800, 0x2FA1D,
	0xE0100, 0xE01EF,
	//  #70 (10954+609): bp=ID_Start:IDS
	0x0041, 0x005A, 0x0061, 0x007A, 0x00AA, 0x00AA, 0x00B5, 0x00B5,
	0x00BA, 0x00BA, 0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x02C1,
	0x02C6, 0x02D1, 0x02E0, 0x02E4, 0x02EC, 0x02EC, 0x02EE, 0x02EE,
	0x0370, 0x0374, 0x0376, 0x0377, 0x037A, 0x037D, 0x037F, 0x037F,
	0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x03A1,
	0x03A3, 0x03F5, 0x03F7, 0x0481, 0x048A, 0x052F, 0x0531, 0x0556,
	0x0559, 0x0559, 0x0560, 0x0588, 0x05D0, 0x05EA, 0x05EF, 0x05F2,
	0x0620, 0x064A, 0x066E, 0x066F, 0x0671, 0x06D3, 0x06D5, 0x06D5,
	0x06E5, 0x06E6, 0x06EE, 0x06EF, 0x06FA, 0x06FC, 0x06FF, 0x06FF,
	0x0710, 0x0710, 0x0712, 0x072F, 0x074D, 0x07A5, 0x07B1, 0x07B1,
	0x07CA, 0x07EA, 0x07F4, 0x07F5, 0x07FA, 0x07FA, 0x0800, 0x0815,
	0x081A, 0x081A, 0x0824, 0x0824, 0x0828, 0x0828, 0x0840, 0x0858,
	0x0860, 0x086A, 0x08A0, 0x08B4, 0x08B6, 0x08BD, 0x0904, 0x0939,
	0x093D, 0x093D, 0x0950, 0x0950, 0x0958, 0x0961, 0x0971, 0x0980,
	0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8, 0x09AA, 0x09B0,
	0x09B2, 0x09B2, 0x09B6, 0x09B9, 0x09BD, 0x09BD, 0x09CE, 0x09CE,
	0x09DC, 0x09DD, 0x09DF, 0x09E1, 0x09F0, 0x09F1, 0x09FC, 0x09FC,
	0x0A05, 0x0A0A, 0x0A0F, 0x0A10, 0x0A13, 0x0A28, 0x0A2A, 0x0A30,
	0x0A32, 0x0A33, 0x0A35, 0x0A36, 0x0A38, 0x0A39, 0x0A59, 0x0A5C,
	0x0A5E, 0x0A5E, 0x0A72, 0x0A74, 0x0A85, 0x0A8D, 0x0A8F, 0x0A91,
	0x0A93, 0x0AA8, 0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9,
	0x0ABD, 0x0ABD, 0x0AD0, 0x0AD0, 0x0AE0, 0x0AE1, 0x0AF9, 0x0AF9,
	0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28, 0x0B2A, 0x0B30,
	0x0B32, 0x0B33, 0x0B35, 0x0B39, 0x0B3D, 0x0B3D, 0x0B5C, 0x0B5D,
	0x0B5F, 0x0B61, 0x0B71, 0x0B71, 0x0B83, 0x0B83, 0x0B85, 0x0B8A,
	0x0B8E, 0x0B90, 0x0B92, 0x0B95, 0x0B99, 0x0B9A, 0x0B9C, 0x0B9C,
	0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9,
	0x0BD0, 0x0BD0, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10, 0x0C12, 0x0C28,
	0x0C2A, 0x0C39, 0x0C3D, 0x0C3D, 0x0C58, 0x0C5A, 0x0C60, 0x0C61,
	0x0C80, 0x0C80, 0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8,
	0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBD, 0x0CBD, 0x0CDE, 0x0CDE,
	0x0CE0, 0x0CE1, 0x0CF1, 0x0CF2, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10,
	0x0D12, 0x0D3A, 0x0D3D, 0x0D3D, 0x0D4E, 0x0D4E, 0x0D54, 0x0D56,
	0x0D5F, 0x0D61, 0x0D7A, 0x0D7F, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1,
	0x0DB3, 0x0DBB, 0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0E01, 0x0E30,
	0x0E32, 0x0E33, 0x0E40, 0x0E46, 0x0E81, 0x0E82, 0x0E84, 0x0E84,
	0x0E86, 0x0E8A, 0x0E8C, 0x0EA3, 0x0EA5, 0x0EA5, 0x0EA7, 0x0EB0,
	0x0EB2, 0x0EB3, 0x0EBD, 0x0EBD, 0x0EC0, 0x0EC4, 0x0EC6, 0x0EC6,
	0x0EDC, 0x0EDF, 0x0F00, 0x0F00, 0x0F40, 0x0F47, 0x0F49, 0x0F6C,
	0x0F88, 0x0F8C, 0x1000, 0x102A, 0x103F, 0x103F, 0x1050, 0x1055,
	0x105A, 0x105D, 0x1061, 0x1061, 0x1065, 0x1066, 0x106E, 0x1070,
	0x1075, 0x1081, 0x108E, 0x108E, 0x10A0, 0x10C5, 0x10C7, 0x10C7,
	0x10CD, 0x10CD, 0x10D0, 0x10FA, 0x10FC, 0x1248, 0x124A, 0x124D,
	0x1250, 0x1256, 0x1258, 0x1258, 0x125A, 0x125D, 0x1260, 0x1288,
	0x128A, 0x128D, 0x1290, 0x12B0, 0x12B2, 0x12B5, 0x12B8, 0x12BE,
	0x12C0, 0x12C0, 0x12C2, 0x12C5, 0x12C8, 0x12D6, 0x12D8, 0x1310,
	0x1312, 0x1315, 0x1318, 0x135A, 0x1380, 0x138F, 0x13A0, 0x13F5,
	0x13F8, 0x13FD, 0x1401, 0x166C, 0x166F, 0x167F, 0x1681, 0x169A,
	0x16A0, 0x16EA, 0x16EE, 0x16F8, 0x1700, 0x170C, 0x170E, 0x1711,
	0x1720, 0x1731, 0x1740, 0x1751, 0x1760, 0x176C, 0x176E, 0x1770,
	0x1780, 0x17B3, 0x17D7, 0x17D7, 0x17DC, 0x17DC, 0x1820, 0x1878,
	0x1880, 0x18A8, 0x18AA, 0x18AA, 0x18B0, 0x18F5, 0x1900, 0x191E,
	0x1950, 0x196D, 0x1970, 0x1974, 0x1980, 0x19AB, 0x19B0, 0x19C9,
	0x1A00, 0x1A16, 0x1A20, 0x1A54, 0x1AA7, 0x1AA7, 0x1B05, 0x1B33,
	0x1B45, 0x1B4B, 0x1B83, 0x1BA0, 0x1BAE, 0x1BAF, 0x1BBA, 0x1BE5,
	0x1C00, 0x1C23, 0x1C4D, 0x1C4F, 0x1C5A, 0x1C7D, 0x1C80, 0x1C88,
	0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x1CE9, 0x1CEC, 0x1CEE, 0x1CF3,
	0x1CF5, 0x1CF6, 0x1CFA, 0x1CFA, 0x1D00, 0x1DBF, 0x1E00, 0x1F15,
	0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57,
	0x1F59, 0x1F59, 0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D,
	0x1F80, 0x1FB4, 0x1FB6, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4,
	0x1FC6, 0x1FCC, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC,
	0x1FF2, 0x1FF4, 0x1FF6, 0x1FFC, 0x2071, 0x2071, 0x207F, 0x207F,
	0x2090, 0x209C, 0x2102, 0x2102, 0x2107, 0x2107, 0x210A, 0x2113,
	0x2115, 0x2115, 0x2118, 0x211D, 0x2124, 0x2124, 0x2126, 0x2126,
	0x2128, 0x2128, 0x212A, 0x2139, 0x213C, 0x213F, 0x2145, 0x2149,
	0x214E, 0x214E, 0x2160, 0x2188, 0x2C00, 0x2C2E, 0x2C30, 0x2C5E,
	0x2C60, 0x2CE4, 0x2CEB, 0x2CEE, 0x2CF2, 0x2CF3, 0x2D00, 0x2D25,
	0x2D27, 0x2D27, 0x2D2D, 0x2D2D, 0x2D30, 0x2D67, 0x2D6F, 0x2D6F,
	0x2D80, 0x2D96, 0x2DA0, 0x2DA6, 0x2DA8, 0x2DAE, 0x2DB0, 0x2DB6,
	0x2DB8, 0x2DBE, 0x2DC0, 0x2DC6, 0x2DC8, 0x2DCE, 0x2DD0, 0x2DD6,
	0x2DD8, 0x2DDE, 0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035,
	0x3038, 0x303C, 0x3041, 0x3096, 0x309B, 0x309F, 0x30A1, 0x30FA,
	0x30FC, 0x30FF, 0x3105, 0x312F, 0x3131, 0x318E, 0x31A0, 0x31BA,
	0x31F0, 0x31FF, 0x3400, 0x4DB5, 0x4E00, 0x9FEF, 0xA000, 0xA48C,
	0xA4D0, 0xA4FD, 0xA500, 0xA60C, 0xA610, 0xA61F, 0xA62A, 0xA62B,
	0xA640, 0xA66E, 0xA67F, 0xA69D, 0xA6A0, 0xA6EF, 0xA717, 0xA71F,
	0xA722, 0xA788, 0xA78B, 0xA7BF, 0xA7C2, 0xA7C6, 0xA7F7, 0xA801,
	0xA803, 0xA805, 0xA807, 0xA80A, 0xA80C, 0xA822, 0xA840, 0xA873,
	0xA882, 0xA8B3, 0xA8F2, 0xA8F7, 0xA8FB, 0xA8FB, 0xA8FD, 0xA8FE,
	0xA90A, 0xA925, 0xA930, 0xA946, 0xA960, 0xA97C, 0xA984, 0xA9B2,
	0xA9CF, 0xA9CF, 0xA9E0, 0xA9E4, 0xA9E6, 0xA9EF, 0xA9FA, 0xA9FE,
	0xAA00, 0xAA28, 0xAA40, 0xAA42, 0xAA44, 0xAA4B, 0xAA60, 0xAA76,
	0xAA7A, 0xAA7A, 0xAA7E, 0xAAAF, 0xAAB1, 0xAAB1, 0xAAB5, 0xAAB6,
	0xAAB9, 0xAABD, 0xAAC0, 0xAAC0, 0xAAC2, 0xAAC2, 0xAADB, 0xAADD,
	0xAAE0, 0xAAEA, 0xAAF2, 0xAAF4, 0xAB01, 0xAB06, 0xAB09, 0xAB0E,
	0xAB11, 0xAB16, 0xAB20, 0xAB26, 0xAB28, 0xAB2E, 0xAB30, 0xAB5A,
	0xAB5C, 0xAB67, 0xAB70, 0xABE2, 0xAC00, 0xD7A3, 0xD7B0, 0xD7C6,
	0xD7CB, 0xD7FB, 0xF900, 0xFA6D, 0xFA70, 0xFAD9, 0xFB00, 0xFB06,
	0xFB13, 0xFB17, 0xFB1D, 0xFB1D, 0xFB1F, 0xFB28, 0xFB2A, 0xFB36,
	0xFB38, 0xFB3C, 0xFB3E, 0xFB3E, 0xFB40, 0xFB41, 0xFB43, 0xFB44,
	0xFB46, 0xFBB1, 0xFBD3, 0xFD3D, 0xFD50, 0xFD8F, 0xFD92, 0xFDC7,
	0xFDF0, 0xFDFB, 0xFE70, 0xFE74, 0xFE76, 0xFEFC, 0xFF21, 0xFF3A,
	0xFF41, 0xFF5A, 0xFF66, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF,
	0xFFD2, 0xFFD7, 0xFFDA, 0xFFDC, 0x10000, 0x1000B, 0x1000D, 0x10026,
	0x10028, 0x1003A, 0x1003C, 0x1003D, 0x1003F, 0x1004D, 0x10050, 0x1005D,
	0x10080, 0x100FA, 0x10140, 0x10174, 0x10280, 0x1029C, 0x102A0, 0x102D0,
	0x10300, 0x1031F, 0x1032D, 0x1034A, 0x10350, 0x10375, 0x10380, 0x1039D,
	0x103A0, 0x103C3, 0x103C8, 0x103CF, 0x103D1, 0x103D5, 0x10400, 0x1049D,
	0x104B0, 0x104D3, 0x104D8, 0x104FB, 0x10500, 0x10527, 0x10530, 0x10563,
	0x10600, 0x10736, 0x10740, 0x10755, 0x10760, 0x10767, 0x10800, 0x10805,
	0x10808, 0x10808, 0x1080A, 0x10835, 0x10837, 0x10838, 0x1083C, 0x1083C,
	0x1083F, 0x10855, 0x10860, 0x10876, 0x10880, 0x1089E, 0x108E0, 0x108F2,
	0x108F4, 0x108F5, 0x10900, 0x10915, 0x10920, 0x10939, 0x10980, 0x109B7,
	0x109BE, 0x109BF, 0x10A00, 0x10A00, 0x10A10, 0x10A13, 0x10A15, 0x10A17,
	0x10A19, 0x10A35, 0x10A60, 0x10A7C, 0x10A80, 0x10A9C, 0x10AC0, 0x10AC7,
	0x10AC9, 0x10AE4, 0x10B00, 0x10B35, 0x10B40, 0x10B55, 0x10B60, 0x10B72,
	0x10B80, 0x10B91, 0x10C00, 0x10C48, 0x10C80, 0x10CB2, 0x10CC0, 0x10CF2,
	0x10D00, 0x10D23, 0x10F00, 0x10F1C, 0x10F27, 0x10F27, 0x10F30, 0x10F45,
	0x10FE0, 0x10FF6, 0x11003, 0x11037, 0x11083, 0x110AF, 0x110D0, 0x110E8,
	0x11103, 0x11126, 0x11144, 0x11144, 0x11150, 0x11172, 0x11176, 0x11176,
	0x11183, 0x111B2, 0x111C1, 0x111C4, 0x111DA, 0x111DA, 0x111DC, 0x111DC,
	0x11200, 0x11211, 0x11213, 0x1122B, 0x11280, 0x11286, 0x11288, 0x11288,
	0x1128A, 0x1128D, 0x1128F, 0x1129D, 0x1129F, 0x112A8, 0x112B0, 0x112DE,
	0x11305, 0x1130C, 0x1130F, 0x11310, 0x11313, 0x11328, 0x1132A, 0x11330,
	0x11332, 0x11333, 0x11335, 0x11339, 0x1133D, 0x1133D, 0x11350, 0x11350,
	0x1135D, 0x11361, 0x11400, 0x11434, 0x11447, 0x1144A, 0x1145F, 0x1145F,
	0x11480, 0x114AF, 0x114C4, 0x114C5, 0x114C7, 0x114C7, 0x11580, 0x115AE,
	0x115D8, 0x115DB, 0x11600, 0x1162F, 0x11644, 0x11644, 0x11680, 0x116AA,
	0x116B8, 0x116B8, 0x11700, 0x1171A, 0x11800, 0x1182B, 0x118A0, 0x118DF,
	0x118FF, 0x118FF, 0x119A0, 0x119A7, 0x119AA, 0x119D0, 0x119E1, 0x119E1,
	0x119E3, 0x119E3, 0x11A00, 0x11A00, 0x11A0B, 0x11A32, 0x11A3A, 0x11A3A,
	0x11A50, 0x11A50, 0x11A5C, 0x11A89, 0x11A9D, 0x11A9D, 0x11AC0, 0x11AF8,
	0x11C00, 0x11C08, 0x11C0A, 0x11C2E, 0x11C40, 0x11C40, 0x11C72, 0x11C8F,
	0x11D00, 0x11D06, 0x11D08, 0x11D09, 0x11D0B, 0x11D30, 0x11D46, 0x11D46,
	0x11D60, 0x11D65, 0x11D67, 0x11D68, 0x11D6A, 0x11D89, 0x11D98, 0x11D98,
	0x11EE0, 0x11EF2, 0x12000, 0x12399, 0x12400, 0x1246E, 0x12480, 0x12543,
	0x13000, 0x1342E, 0x14400, 0x14646, 0x16800, 0x16A38, 0x16A40, 0x16A5E,
	0x16AD0, 0x16AED, 0x16B00, 0x16B2F, 0x16B40, 0x16B43, 0x16B63, 0x16B77,
	0x16B7D, 0x16B8F, 0x16E40, 0x16E7F, 0x16F00, 0x16F4A, 0x16F50, 0x16F50,
	0x16F93, 0x16F9F, 0x16FE0, 0x16FE1, 0x16FE3, 0x16FE3, 0x17000, 0x187F7,
	0x18800, 0x18AF2, 0x1B000, 0x1B11E, 0x1B150, 0x1B152, 0x1B164, 0x1B167,
	0x1B170, 0x1B2FB, 0x1BC00, 0x1BC6A, 0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88,
	0x1BC90, 0x1BC99, 0x1D400, 0x1D454, 0x1D456, 0x1D49C, 0x1D49E, 0x1D49F,
	0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B9,
	0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505, 0x1D507, 0x1D50A,
	0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539, 0x1D53B, 0x1D53E,
	0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550, 0x1D552, 0x1D6A5,
	0x1D6A8, 0x1D6C0, 0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6FA, 0x1D6FC, 0x1D714,
	0x1D716, 0x1D734, 0x1D736, 0x1D74E, 0x1D750, 0x1D76E, 0x1D770, 0x1D788,
	0x1D78A, 0x1D7A8, 0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7CB, 0x1E100, 0x1E12C,
	0x1E137, 0x1E13D, 0x1E14E, 0x1E14E, 0x1E2C0, 0x1E2EB, 0x1E800, 0x1E8C4,
	0x1E900, 0x1E943, 0x1E94B, 0x1E94B, 0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F,
	0x1EE21, 0x1EE22, 0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32,
	0x1EE34, 0x1EE37, 0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42,
	0x1EE47, 0x1EE47, 0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F,
	0x1EE51, 0x1EE52, 0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59,
	0x1EE5B, 0x1EE5B, 0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62,
	0x1EE64, 0x1EE64, 0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77,
	0x1EE79, 0x1EE7C, 0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B,
	0x1EEA1, 0x1EEA3, 0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB, 0x20000, 0x2A6D6,
	0x2A700, 0x2B734, 0x2B740, 0x2B81D, 0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0,
	0x2F800, 0x2FA1D,
	//  #71 (11563+16): bp=Ideographic:Ideo
	0x3006, 0x3007, 0x3021, 0x3029, 0x3038, 0x303A, 0x3400, 0x4DB5,
	0x4E00, 0x9FEF, 0xF900, 0xFA6D, 0xFA70, 0xFAD9, 0x17000, 0x187F7,
	0x18800, 0x18AF2, 0x1B170, 0x1B2FB, 0x20000, 0x2A6D6, 0x2A700, 0x2B734,
	0x2B740, 0x2B81D, 0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0, 0x2F800, 0x2FA1D,
	//  #72 (11579+1): bp=Join_Control:Join_C
	0x200C, 0x200D,
	//  #73 (11580+7): bp=Logical_Order_Exception:LOE
	0x0E40, 0x0E44, 0x0EC0, 0x0EC4, 0x19B5, 0x19B7, 0x19BA, 0x19BA,
	0xAAB5, 0xAAB6, 0xAAB9, 0xAAB9, 0xAABB, 0xAABC,
	//  #74 (11587+649): bp=Lowercase:Lower
	0x0061, 0x007A, 0x00AA, 0x00AA, 0x00B5, 0x00B5, 0x00BA, 0x00BA,
	0x00DF, 0x00F6, 0x00F8, 0x00FF, 0x0101, 0x0101, 0x0103, 0x0103,
	0x0105, 0x0105, 0x0107, 0x0107, 0x0109, 0x0109, 0x010B, 0x010B,
	0x010D, 0x010D, 0x010F, 0x010F, 0x0111, 0x0111, 0x0113, 0x0113,
	0x0115, 0x0115, 0x0117, 0x0117, 0x0119, 0x0119, 0x011B, 0x011B,
	0x011D, 0x011D, 0x011F, 0x011F, 0x0121, 0x0121, 0x0123, 0x0123,
	0x0125, 0x0125, 0x0127, 0x0127, 0x0129, 0x0129, 0x012B, 0x012B,
	0x012D, 0x012D, 0x012F, 0x012F, 0x0131, 0x0131, 0x0133, 0x0133,
	0x0135, 0x0135, 0x0137, 0x0138, 0x013A, 0x013A, 0x013C, 0x013C,
	0x013E, 0x013E, 0x0140, 0x0140, 0x0142, 0x0142, 0x0144, 0x0144,
	0x0146, 0x0146, 0x0148, 0x0149, 0x014B, 0x014B, 0x014D, 0x014D,
	0x014F, 0x014F, 0x0151, 0x0151, 0x0153, 0x0153, 0x0155, 0x0155,
	0x0157, 0x0157, 0x0159, 0x0159, 0x015B, 0x015B, 0x015D, 0x015D,
	0x015F, 0x015F, 0x0161, 0x0161, 0x0163, 0x0163, 0x0165, 0x0165,
	0x0167, 0x0167, 0x0169, 0x0169, 0x016B, 0x016B, 0x016D, 0x016D,
	0x016F, 0x016F, 0x0171, 0x0171, 0x0173, 0x0173, 0x0175, 0x0175,
	0x0177, 0x0177, 0x017A, 0x017A, 0x017C, 0x017C, 0x017E, 0x0180,
	0x0183, 0x0183, 0x0185, 0x0185, 0x0188, 0x0188, 0x018C, 0x018D,
	0x0192, 0x0192, 0x0195, 0x0195, 0x0199, 0x019B, 0x019E, 0x019E,
	0x01A1, 0x01A1, 0x01A3, 0x01A3, 0x01A5, 0x01A5, 0x01A8, 0x01A8,
	0x01AA, 0x01AB, 0x01AD, 0x01AD, 0x01B0, 0x01B0, 0x01B4, 0x01B4,
	0x01B6, 0x01B6, 0x01B9, 0x01BA, 0x01BD, 0x01BF, 0x01C6, 0x01C6,
	0x01C9, 0x01C9, 0x01CC, 0x01CC, 0x01CE, 0x01CE, 0x01D0, 0x01D0,
	0x01D2, 0x01D2, 0x01D4, 0x01D4, 0x01D6, 0x01D6, 0x01D8, 0x01D8,
	0x01DA, 0x01DA, 0x01DC, 0x01DD, 0x01DF, 0x01DF, 0x01E1, 0x01E1,
	0x01E3, 0x01E3, 0x01E5, 0x01E5, 0x01E7, 0x01E7, 0x01E9, 0x01E9,
	0x01EB, 0x01EB, 0x01ED, 0x01ED, 0x01EF, 0x01F0, 0x01F3, 0x01F3,
	0x01F5, 0x01F5, 0x01F9, 0x01F9, 0x01FB, 0x01FB, 0x01FD, 0x01FD,
	0x01FF, 0x01FF, 0x0201, 0x0201, 0x0203, 0x0203, 0x0205, 0x0205,
	0x0207, 0x0207, 0x0209, 0x0209, 0x020B, 0x020B, 0x020D, 0x020D,
	0x020F, 0x020F, 0x0211, 0x0211, 0x0213, 0x0213, 0x0215, 0x0215,
	0x0217, 0x0217, 0x0219, 0x0219, 0x021B, 0x021B, 0x021D, 0x021D,
	0x021F, 0x021F, 0x0221, 0x0221, 0x0223, 0x0223, 0x0225, 0x0225,
	0x0227, 0x0227, 0x0229, 0x0229, 0x022B, 0x022B, 0x022D, 0x022D,
	0x022F, 0x022F, 0x0231, 0x0231, 0x0233, 0x0239, 0x023C, 0x023C,
	0x023F, 0x0240, 0x0242, 0x0242, 0x0247, 0x0247, 0x0249, 0x0249,
	0x024B, 0x024B, 0x024D, 0x024D, 0x024F, 0x0293, 0x0295, 0x02B8,
	0x02C0, 0x02C1, 0x02E0, 0x02E4, 0x0345, 0x0345, 0x0371, 0x0371,
	0x0373, 0x0373, 0x0377, 0x0377, 0x037A, 0x037D, 0x0390, 0x0390,
	0x03AC, 0x03CE, 0x03D0, 0x03D1, 0x03D5, 0x03D7, 0x03D9, 0x03D9,
	0x03DB, 0x03DB, 0x03DD, 0x03DD, 0x03DF, 0x03DF, 0x03E1, 0x03E1,
	0x03E3, 0x03E3, 0x03E5, 0x03E5, 0x03E7, 0x03E7, 0x03E9, 0x03E9,
	0x03EB, 0x03EB, 0x03ED, 0x03ED, 0x03EF, 0x03F3, 0x03F5, 0x03F5,
	0x03F8, 0x03F8, 0x03FB, 0x03FC, 0x0430, 0x045F, 0x0461, 0x0461,
	0x0463, 0x0463, 0x0465, 0x0465, 0x0467, 0x0467, 0x0469, 0x0469,
	0x046B, 0x046B, 0x046D, 0x046D, 0x046F, 0x046F, 0x0471, 0x0471,
	0x0473, 0x0473, 0x0475, 0x0475, 0x0477, 0x0477, 0x0479, 0x0479,
	0x047B, 0x047B, 0x047D, 0x047D, 0x047F, 0x047F, 0x0481, 0x0481,
	0x048B, 0x048B, 0x048D, 0x048D, 0x048F, 0x048F, 0x0491, 0x0491,
	0x0493, 0x0493, 0x0495, 0x0495, 0x0497, 0x0497, 0x0499, 0x0499,
	0x049B, 0x049B, 0x049D, 0x049D, 0x049F, 0x049F, 0x04A1, 0x04A1,
	0x04A3, 0x04A3, 0x04A5, 0x04A5, 0x04A7, 0x04A7, 0x04A9, 0x04A9,
	0x04AB, 0x04AB, 0x04AD, 0x04AD, 0x04AF, 0x04AF, 0x04B1, 0x04B1,
	0x04B3, 0x04B3, 0x04B5, 0x04B5, 0x04B7, 0x04B7, 0x04B9, 0x04B9,
	0x04BB, 0x04BB, 0x04BD, 0x04BD, 0x04BF, 0x04BF, 0x04C2, 0x04C2,
	0x04C4, 0x04C4, 0x04C6, 0x04C6, 0x04C8, 0x04C8, 0x04CA, 0x04CA,
	0x04CC, 0x04CC, 0x04CE, 0x04CF, 0x04D1, 0x04D1, 0x04D3, 0x04D3,
	0x04D5, 0x04D5, 0x04D7, 0x04D7, 0x04D9, 0x04D9, 0x04DB, 0x04DB,
	0x04DD, 0x04DD, 0x04DF, 0x04DF, 0x04E1, 0x04E1, 0x04E3, 0x04E3,
	0x04E5, 0x04E5, 0x04E7, 0x04E7, 0x04E9, 0x04E9, 0x04EB, 0x04EB,
	0x04ED, 0x04ED, 0x04EF, 0x04EF, 0x04F1, 0x04F1, 0x04F3, 0x04F3,
	0x04F5, 0x04F5, 0x04F7, 0x04F7, 0x04F9, 0x04F9, 0x04FB, 0x04FB,
	0x04FD, 0x04FD, 0x04FF, 0x04FF, 0x0501, 0x0501, 0x0503, 0x0503,
	0x0505, 0x0505, 0x0507, 0x0507, 0x0509, 0x0509, 0x050B, 0x050B,
	0x050D, 0x050D, 0x050F, 0x050F, 0x0511, 0x0511, 0x0513, 0x0513,
	0x0515, 0x0515, 0x0517, 0x0517, 0x0519, 0x0519, 0x051B, 0x051B,
	0x051D, 0x051D, 0x051F, 0x051F, 0x0521, 0x0521, 0x0523, 0x0523,
	0x0525, 0x0525, 0x0527, 0x0527, 0x0529, 0x0529, 0x052B, 0x052B,
	0x052D, 0x052D, 0x052F, 0x052F, 0x0560, 0x0588, 0x10D0, 0x10FA,
	0x10FD, 0x10FF, 0x13F8, 0x13FD, 0x1C80, 0x1C88, 0x1D00, 0x1DBF,
	0x1E01, 0x1E01, 0x1E03, 0x1E03, 0x1E05, 0x1E05, 0x1E07, 0x1E07,
	0x1E09, 0x1E09, 0x1E0B, 0x1E0B, 0x1E0D, 0x1E0D, 0x1E0F, 0x1E0F,
	0x1E11, 0x1E11, 0x1E13, 0x1E13, 0x1E15, 0x1E15, 0x1E17, 0x1E17,
	0x1E19, 0x1E19, 0x1E1B, 0x1E1B, 0x1E1D, 0x1E1D, 0x1E1F, 0x1E1F,
	0x1E21, 0x1E21, 0x1E23, 0x1E23, 0x1E25, 0x1E25, 0x1E27, 0x1E27,
	0x1E29, 0x1E29, 0x1E2B, 0x1E2B, 0x1E2D, 0x1E2D, 0x1E2F, 0x1E2F,
	0x1E31, 0x1E31, 0x1E33, 0x1E33, 0x1E35, 0x1E35, 0x1E37, 0x1E37,
	0x1E39, 0x1E39, 0x1E3B, 0x1E3B, 0x1E3D, 0x1E3D, 0x1E3F, 0x1E3F,
	0x1E41, 0x1E41, 0x1E43, 0x1E43, 0x1E45, 0x1E45, 0x1E47, 0x1E47,
	0x1E49, 0x1E49, 0x1E4B, 0x1E4B, 0x1E4D, 0x1E4D, 0x1E4F, 0x1E4F,
	0x1E51, 0x1E51, 0x1E53, 0x1E53, 0x1E55, 0x1E55, 0x1E57, 0x1E57,
	0x1E59, 0x1E59, 0x1E5B, 0x1E5B, 0x1E5D, 0x1E5D, 0x1E5F, 0x1E5F,
	0x1E61, 0x1E61, 0x1E63, 0x1E63, 0x1E65, 0x1E65, 0x1E67, 0x1E67,
	0x1E69, 0x1E69, 0x1E6B, 0x1E6B, 0x1E6D, 0x1E6D, 0x1E6F, 0x1E6F,
	0x1E71, 0x1E71, 0x1E73, 0x1E73, 0x1E75, 0x1E75, 0x1E77, 0x1E77,
	0x1E79, 0x1E79, 0x1E7B, 0x1E7B, 0x1E7D, 0x1E7D, 0x1E7F, 0x1E7F,
	0x1E81, 0x1E81, 0x1E83, 0x1E83, 0x1E85, 0x1E85, 0x1E87, 0x1E87,
	0x1E89, 0x1E89, 0x1E8B, 0x1E8B, 0x1E8D, 0x1E8D, 0x1E8F, 0x1E8F,
	0x1E91, 0x1E91, 0x1E93, 0x1E93, 0x1E95, 0x1E9D, 0x1E9F, 0x1E9F,
	0x1EA1, 0x1EA1, 0x1EA3, 0x1EA3, 0x1EA5, 0x1EA5, 0x1EA7, 0x1EA7,
	0x1EA9, 0x1EA9, 0x1EAB, 0x1EAB, 0x1EAD, 0x1EAD, 0x1EAF, 0x1EAF,
	0x1EB1, 0x1EB1, 0x1EB3, 0x1EB3, 0x1EB5, 0x1EB5, 0x1EB7, 0x1EB7,
	0x1EB9, 0x1EB9, 0x1EBB, 0x1EBB, 0x1EBD, 0x1EBD, 0x1EBF, 0x1EBF,
	0x1EC1, 0x1EC1, 0x1EC3, 0x1EC3, 0x1EC5, 0x1EC5, 0x1EC7, 0x1EC7,
	0x1EC9, 0x1EC9, 0x1ECB, 0x1ECB, 0x1ECD, 0x1ECD, 0x1ECF, 0x1ECF,
	0x1ED1, 0x1ED1, 0x1ED3, 0x1ED3, 0x1ED5, 0x1ED5, 0x1ED7, 0x1ED7,
	0x1ED9, 0x1ED9, 0x1EDB, 0x1EDB, 0x1EDD, 0x1EDD, 0x1EDF, 0x1EDF,
	0x1EE1, 0x1EE1, 0x1EE3, 0x1EE3, 0x1EE5, 0x1EE5, 0x1EE7, 0x1EE7,
	0x1EE9, 0x1EE9, 0x1EEB, 0x1EEB, 0x1EED, 0x1EED, 0x1EEF, 0x1EEF,
	0x1EF1, 0x1EF1, 0x1EF3, 0x1EF3, 0x1EF5, 0x1EF5, 0x1EF7, 0x1EF7,
	0x1EF9, 0x1EF9, 0x1EFB, 0x1EFB, 0x1EFD, 0x1EFD, 0x1EFF, 0x1F07,
	0x1F10, 0x1F15, 0x1F20, 0x1F27, 0x1F30, 0x1F37, 0x1F40, 0x1F45,
	0x1F50, 0x1F57, 0x1F60, 0x1F67, 0x1F70, 0x1F7D, 0x1F80, 0x1F87,
	0x1F90, 0x1F97, 0x1FA0, 0x1FA7, 0x1FB0, 0x1FB4, 0x1FB6, 0x1FB7,
	0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FC7, 0x1FD0, 0x1FD3,
	0x1FD6, 0x1FD7, 0x1FE0, 0x1FE7, 0x1FF2, 0x1FF4, 0x1FF6, 0x1FF7,
	0x2071, 0x2071, 0x207F, 0x207F, 0x2090, 0x209C, 0x210A, 0x210A,
	0x210E, 0x210F, 0x2113, 0x2113, 0x212F, 0x212F, 0x2134, 0x2134,
	0x2139, 0x2139, 0x213C, 0x213D, 0x2146, 0x2149, 0x214E, 0x214E,
	0x2170, 0x217F, 0x2184, 0x2184, 0x24D0, 0x24E9, 0x2C30, 0x2C5E,
	0x2C61, 0x2C61, 0x2C65, 0x2C66, 0x2C68, 0x2C68, 0x2C6A, 0x2C6A,
	0x2C6C, 0x2C6C, 0x2C71, 0x2C71, 0x2C73, 0x2C74, 0x2C76, 0x2C7D,
	0x2C81, 0x2C81, 0x2C83, 0x2C83, 0x2C85, 0x2C85, 0x2C87, 0x2C87,
	0x2C89, 0x2C89, 0x2C8B, 0x2C8B, 0x2C8D, 0x2C8D, 0x2C8F, 0x2C8F,
	0x2C91, 0x2C91, 0x2C93, 0x2C93, 0x2C95, 0x2C95, 0x2C97, 0x2C97,
	0x2C99, 0x2C99, 0x2C9B, 0x2C9B, 0x2C9D, 0x2C9D, 0x2C9F, 0x2C9F,
	0x2CA1, 0x2CA1, 0x2CA3, 0x2CA3, 0x2CA5, 0x2CA5, 0x2CA7, 0x2CA7,
	0x2CA9, 0x2CA9, 0x2CAB, 0x2CAB, 0x2CAD, 0x2CAD, 0x2CAF, 0x2CAF,
	0x2CB1, 0x2CB1, 0x2CB3, 0x2CB3, 0x2CB5, 0x2CB5, 0x2CB7, 0x2CB7,
	0x2CB9, 0x2CB9, 0x2CBB, 0x2CBB, 0x2CBD, 0x2CBD, 0x2CBF, 0x2CBF,
	0x2CC1, 0x2CC1, 0x2CC3, 0x2CC3, 0x2CC5, 0x2CC5, 0x2CC7, 0x2CC7,
	0x2CC9, 0x2CC9, 0x2CCB, 0x2CCB, 0x2CCD, 0x2CCD, 0x2CCF, 0x2CCF,
	0x2CD1, 0x2CD1, 0x2CD3, 0x2CD3, 0x2CD5, 0x2CD5, 0x2CD7, 0x2CD7,
	0x2CD9, 0x2CD9, 0x2CDB, 0x2CDB, 0x2CDD, 0x2CDD, 0x2CDF, 0x2CDF,
	0x2CE1, 0x2CE1, 0x2CE3, 0x2CE4, 0x2CEC, 0x2CEC, 0x2CEE, 0x2CEE,
	0x2CF3, 0x2CF3, 0x2D00, 0x2D25, 0x2D27, 0x2D27, 0x2D2D, 0x2D2D,
	0xA641, 0xA641, 0xA643, 0xA643, 0xA645, 0xA645, 0xA647, 0xA647,
	0xA649, 0xA649, 0xA64B, 0xA64B, 0xA64D, 0xA64D, 0xA64F, 0xA64F,
	0xA651, 0xA651, 0xA653, 0xA653, 0xA655, 0xA655, 0xA657, 0xA657,
	0xA659, 0xA659, 0xA65B, 0xA65B, 0xA65D, 0xA65D, 0xA65F, 0xA65F,
	0xA661, 0xA661, 0xA663, 0xA663, 0xA665, 0xA665, 0xA667, 0xA667,
	0xA669, 0xA669, 0xA66B, 0xA66B, 0xA66D, 0xA66D, 0xA681, 0xA681,
	0xA683, 0xA683, 0xA685, 0xA685, 0xA687, 0xA687, 0xA689, 0xA689,
	0xA68B, 0xA68B, 0xA68D, 0xA68D, 0xA68F, 0xA68F, 0xA691, 0xA691,
	0xA693, 0xA693, 0xA695, 0xA695, 0xA697, 0xA697, 0xA699, 0xA699,
	0xA69B, 0xA69D, 0xA723, 0xA723, 0xA725, 0xA725, 0xA727, 0xA727,
	0xA729, 0xA729, 0xA72B, 0xA72B, 0xA72D, 0xA72D, 0xA72F, 0xA731,
	0xA733, 0xA733, 0xA735, 0xA735, 0xA737, 0xA737, 0xA739, 0xA739,
	0xA73B, 0xA73B, 0xA73D, 0xA73D, 0xA73F, 0xA73F, 0xA741, 0xA741,
	0xA743, 0xA743, 0xA745, 0xA745, 0xA747, 0xA747, 0xA749, 0xA749,
	0xA74B, 0xA74B, 0xA74D, 0xA74D, 0xA74F, 0xA74F, 0xA751, 0xA751,
	0xA753, 0xA753, 0xA755, 0xA755, 0xA757, 0xA757, 0xA759, 0xA759,
	0xA75B, 0xA75B, 0xA75D, 0xA75D, 0xA75F, 0xA75F, 0xA761, 0xA761,
	0xA763, 0xA763, 0xA765, 0xA765, 0xA767, 0xA767, 0xA769, 0xA769,
	0xA76B, 0xA76B, 0xA76D, 0xA76D, 0xA76F, 0xA778, 0xA77A, 0xA77A,
	0xA77C, 0xA77C, 0xA77F, 0xA77F, 0xA781, 0xA781, 0xA783, 0xA783,
	0xA785, 0xA785, 0xA787, 0xA787, 0xA78C, 0xA78C, 0xA78E, 0xA78E,
	0xA791, 0xA791, 0xA793, 0xA795, 0xA797, 0xA797, 0xA799, 0xA799,
	0xA79B, 0xA79B, 0xA79D, 0xA79D, 0xA79F, 0xA79F, 0xA7A1, 0xA7A1,
	0xA7A3, 0xA7A3, 0xA7A5, 0xA7A5, 0xA7A7, 0xA7A7, 0xA7A9, 0xA7A9,
	0xA7AF, 0xA7AF, 0xA7B5, 0xA7B5, 0xA7B7, 0xA7B7, 0xA7B9, 0xA7B9,
	0xA7BB, 0xA7BB, 0xA7BD, 0xA7BD, 0xA7BF, 0xA7BF, 0xA7C3, 0xA7C3,
	0xA7F8, 0xA7FA, 0xAB30, 0xAB5A, 0xAB5C, 0xAB67, 0xAB70, 0xABBF,
	0xFB00, 0xFB06, 0xFB13, 0xFB17, 0xFF41, 0xFF5A, 0x10428, 0x1044F,
	0x104D8, 0x104FB, 0x10CC0, 0x10CF2, 0x118C0, 0x118DF, 0x16E60, 0x16E7F,
	0x1D41A, 0x1D433, 0x1D44E, 0x1D454, 0x1D456, 0x1D467, 0x1D482, 0x1D49B,
	0x1D4B6, 0x1D4B9, 0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D4CF,
	0x1D4EA, 0x1D503, 0x1D51E, 0x1D537, 0x1D552, 0x1D56B, 0x1D586, 0x1D59F,
	0x1D5BA, 0x1D5D3, 0x1D5EE, 0x1D607, 0x1D622, 0x1D63B, 0x1D656, 0x1D66F,
	0x1D68A, 0x1D6A5, 0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6E1, 0x1D6FC, 0x1D714,
	0x1D716, 0x1D71B, 0x1D736, 0x1D74E, 0x1D750, 0x1D755, 0x1D770, 0x1D788,
	0x1D78A, 0x1D78F, 0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7C9, 0x1D7CB, 0x1D7CB,
	0x1E922, 0x1E943,
	//  #75 (12236+138): bp=Math
	0x002B, 0x002B, 0x003C, 0x003E, 0x005E, 0x005E, 0x007C, 0x007C,
	0x007E, 0x007E, 0x00AC, 0x00AC, 0x00B1, 0x00B1, 0x00D7, 0x00D7,
	0x00F7, 0x00F7, 0x03D0, 0x03D2, 0x03D5, 0x03D5, 0x03F0, 0x03F1,
	0x03F4, 0x03F6, 0x0606, 0x0608, 0x2016, 0x2016, 0x2032, 0x2034,
	0x2040, 0x2040, 0x2044, 0x2044, 0x2052, 0x2052, 0x2061, 0x2064,
	0x207A, 0x207E, 0x208A, 0x208E, 0x20D0, 0x20DC, 0x20E1, 0x20E1,
	0x20E5, 0x20E6, 0x20EB, 0x20EF, 0x2102, 0x2102, 0x2107, 0x2107,
	0x210A, 0x2113, 0x2115, 0x2115, 0x2118, 0x211D, 0x2124, 0x2124,
	0x2128, 0x2129, 0x212C, 0x212D, 0x212F, 0x2131, 0x2133, 0x2138,
	0x213C, 0x2149, 0x214B, 0x214B, 0x2190, 0x21A7, 0x21A9, 0x21AE,
	0x21B0, 0x21B1, 0x21B6, 0x21B7, 0x21BC, 0x21DB, 0x21DD, 0x21DD,
	0x21E4, 0x21E5, 0x21F4, 0x22FF, 0x2308, 0x230B, 0x2320, 0x2321,
	0x237C, 0x237C, 0x239B, 0x23B5, 0x23B7, 0x23B7, 0x23D0, 0x23D0,
	0x23DC, 0x23E2, 0x25A0, 0x25A1, 0x25AE, 0x25B7, 0x25BC, 0x25C1,
	0x25C6, 0x25C7, 0x25CA, 0x25CB, 0x25CF, 0x25D3, 0x25E2, 0x25E2,
	0x25E4, 0x25E4, 0x25E7, 0x25EC, 0x25F8, 0x25FF, 0x2605, 0x2606,
	0x2640, 0x2640, 0x2642, 0x2642, 0x2660, 0x2663, 0x266D, 0x266F,
	0x27C0, 0x27FF, 0x2900, 0x2AFF, 0x2B30, 0x2B44, 0x2B47, 0x2B4C,
	0xFB29, 0xFB29, 0xFE61, 0xFE66, 0xFE68, 0xFE68, 0xFF0B, 0xFF0B,
	0xFF1C, 0xFF1E, 0xFF3C, 0xFF3C, 0xFF3E, 0xFF3E, 0xFF5C, 0xFF5C,
	0xFF5E, 0xFF5E, 0xFFE2, 0xFFE2, 0xFFE9, 0xFFEC, 0x1D400, 0x1D454,
	0x1D456, 0x1D49C, 0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6,
	0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B9, 0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3,
	0x1D4C5, 0x1D505, 0x1D507, 0x1D50A, 0x1D50D, 0x1D514, 0x1D516, 0x1D51C,
	0x1D51E, 0x1D539, 0x1D53B, 0x1D53E, 0x1D540, 0x1D544, 0x1D546, 0x1D546,
	0x1D54A, 0x1D550, 0x1D552, 0x1D6A5, 0x1D6A8, 0x1D7CB, 0x1D7CE, 0x1D7FF,
	0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22, 0x1EE24, 0x1EE24,
	0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37, 0x1EE39, 0x1EE39,
	0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47, 0x1EE49, 0x1EE49,
	0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE54,
	0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B, 0x1EE5D, 0x1EE5D,
	0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64, 0x1EE67, 0x1EE6A,
	0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C, 0x1EE7E, 0x1EE7E,
	0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3, 0x1EEA5, 0x1EEA9,
	0x1EEAB, 0x1EEBB, 0x1EEF0, 0x1EEF1,
	//  #76 (12374+18): bp=Noncharacter_Code_Point:NChar
	0xFDD0, 0xFDEF, 0xFFFE, 0xFFFF, 0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF,
	0x3FFFE, 0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF, 0x6FFFE, 0x6FFFF,
	0x7FFFE, 0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE, 0x9FFFF, 0xAFFFE, 0xAFFFF,
	0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE, 0xDFFFF, 0xEFFFE, 0xEFFFF,
	0xFFFFE, 0xFFFFF, 0x10FFFE, 0x10FFFF,
	//  #77 (12392+28): bp=Pattern_Syntax:Pat_Syn
	0x0021, 0x002F, 0x003A, 0x0040, 0x005B, 0x005E, 0x0060, 0x0060,
	0x007B, 0x007E, 0x00A1, 0x00A7, 0x00A9, 0x00A9, 0x00AB, 0x00AC,
	0x00AE, 0x00AE, 0x00B0, 0x00B1, 0x00B6, 0x00B6, 0x00BB, 0x00BB,
	0x00BF, 0x00BF, 0x00D7, 0x00D7, 0x00F7, 0x00F7, 0x2010, 0x2027,
	0x2030, 0x203E, 0x2041, 0x2053, 0x2055, 0x205E, 0x2190, 0x245F,
	0x2500, 0x2775, 0x2794, 0x2BFF, 0x2E00, 0x2E7F, 0x3001, 0x3003,
	0x3008, 0x3020, 0x3030, 0x3030, 0xFD3E, 0xFD3F, 0xFE45, 0xFE46,
	//  #78 (12420+5): bp=Pattern_White_Space:Pat_WS
	0x0009, 0x000D, 0x0020, 0x0020, 0x0085, 0x0085, 0x200E, 0x200F,
	0x2028, 0x2029,
	//  #79 (12425+13): bp=Quotation_Mark:QMark
	0x0022, 0x0022, 0x0027, 0x0027, 0x00AB, 0x00AB, 0x00BB, 0x00BB,
	0x2018, 0x201F, 0x2039, 0x203A, 0x2E42, 0x2E42, 0x300C, 0x300F,
	0x301D, 0x301F, 0xFE41, 0xFE44, 0xFF02, 0xFF02, 0xFF07, 0xFF07,
	0xFF62, 0xFF63,
	//  #80 (12438+3): bp=Radical
	0x2E80, 0x2E99, 0x2E9B, 0x2EF3, 0x2F00, 0x2FD5,
	//  #81 (12441+1): bp=Regional_Indicator:RI
	0x1F1E6, 0x1F1FF,
	//  #82 (12442+74): bp=Sentence_Terminal:STerm
	0x0021, 0x0021, 0x002E, 0x002E, 0x003F, 0x003F, 0x0589, 0x0589,
	0x061E, 0x061F, 0x06D4, 0x06D4, 0x0700, 0x0702, 0x07F9, 0x07F9,
	0x0837, 0x0837, 0x0839, 0x0839, 0x083D, 0x083E, 0x0964, 0x0965,
	0x104A, 0x104B, 0x1362, 0x1362, 0x1367, 0x1368, 0x166E, 0x166E,
	0x1735, 0x1736, 0x1803, 0x1803, 0x1809, 0x1809, 0x1944, 0x1945,
	0x1AA8, 0x1AAB, 0x1B5A, 0x1B5B, 0x1B5E, 0x1B5F, 0x1C3B, 0x1C3C,
	0x1C7E, 0x1C7F, 0x203C, 0x203D, 0x2047, 0x2049, 0x2E2E, 0x2E2E,
	0x2E3C, 0x2E3C, 0x3002, 0x3002, 0xA4FF, 0xA4FF, 0xA60E, 0xA60F,
	0xA6F3, 0xA6F3, 0xA6F7, 0xA6F7, 0xA876, 0xA877, 0xA8CE, 0xA8CF,
	0xA92F, 0xA92F, 0xA9C8, 0xA9C9, 0xAA5D, 0xAA5F, 0xAAF0, 0xAAF1,
	0xABEB, 0xABEB, 0xFE52, 0xFE52, 0xFE56, 0xFE57, 0xFF01, 0xFF01,
	0xFF0E, 0xFF0E, 0xFF1F, 0xFF1F, 0xFF61, 0xFF61, 0x10A56, 0x10A57,
	0x10F55, 0x10F59, 0x11047, 0x11048, 0x110BE, 0x110C1, 0x11141, 0x11143,
	0x111C5, 0x111C6, 0x111CD, 0x111CD, 0x111DE, 0x111DF, 0x11238, 0x11239,
	0x1123B, 0x1123C, 0x112A9, 0x112A9, 0x1144B, 0x1144C, 0x115C2, 0x115C3,
	0x115C9, 0x115D7, 0x11641, 0x11642, 0x1173C, 0x1173E, 0x11A42, 0x11A43,
	0x11A9B, 0x11A9C, 0x11C41, 0x11C42, 0x11EF7, 0x11EF8, 0x16A6E, 0x16A6F,
	0x16AF5, 0x16AF5, 0x16B37, 0x16B38, 0x16B44, 0x16B44, 0x16E98, 0x16E98,
	0x1BC9F, 0x1BC9F, 0x1DA88, 0x1DA88,
	//  #83 (12516+31): bp=Soft_Dotted:SD
	0x0069, 0x006A, 0x012F, 0x012F, 0x0249, 0x0249, 0x0268, 0x0268,
	0x029D, 0x029D, 0x02B2, 0x02B2, 0x03F3, 0x03F3, 0x0456, 0x0456,
	0x0458, 0x0458, 0x1D62, 0x1D62, 0x1D96, 0x1D96, 0x1DA4, 0x1DA4,
	0x1DA8, 0x1DA8, 0x1E2D, 0x1E2D, 0x1ECB, 0x1ECB, 0x2071, 0x2071,
	0x2148, 0x2149, 0x2C7C, 0x2C7C, 0x1D422, 0x1D423, 0x1D456, 0x1D457,
	0x1D48A, 0x1D48B, 0x1D4BE, 0x1D4BF, 0x1D4F2, 0x1D4F3, 0x1D526, 0x1D527,
	0x1D55A, 0x1D55B, 0x1D58E, 0x1D58F, 0x1D5C2, 0x1D5C3, 0x1D5F6, 0x1D5F7,
	0x1D62A, 0x1D62B, 0x1D65E, 0x1D65F, 0x1D692, 0x1D693,
	//  #84 (12547+102): bp=Terminal_Punctuation:Term
	0x0021, 0x0021, 0x002C, 0x002C, 0x002E, 0x002E, 0x003A, 0x003B,
	0x003F, 0x003F, 0x037E, 0x037E, 0x0387, 0x0387, 0x0589, 0x0589,
	0x05C3, 0x05C3, 0x060C, 0x060C, 0x061B, 0x061B, 0x061E, 0x061F,
	0x06D4, 0x06D4, 0x0700, 0x070A, 0x070C, 0x070C, 0x07F8, 0x07F9,
	0x0830, 0x083E, 0x085E, 0x085E, 0x0964, 0x0965, 0x0E5A, 0x0E5B,
	0x0F08, 0x0F08, 0x0F0D, 0x0F12, 0x104A, 0x104B, 0x1361, 0x1368,
	0x166E, 0x166E, 0x16EB, 0x16ED, 0x1735, 0x1736, 0x17D4, 0x17D6,
	0x17DA, 0x17DA, 0x1802, 0x1805, 0x1808, 0x1809, 0x1944, 0x1945,
	0x1AA8, 0x1AAB, 0x1B5A, 0x1B5B, 0x1B5D, 0x1B5F, 0x1C3B, 0x1C3F,
	0x1C7E, 0x1C7F, 0x203C, 0x203D, 0x2047, 0x2049, 0x2E2E, 0x2E2E,
	0x2E3C, 0x2E3C, 0x2E41, 0x2E41, 0x2E4C, 0x2E4C, 0x2E4E, 0x2E4F,
	0x3001, 0x3002, 0xA4FE, 0xA4FF, 0xA60D, 0xA60F, 0xA6F3, 0xA6F7,
	0xA876, 0xA877, 0xA8CE, 0xA8CF, 0xA92F, 0xA92F, 0xA9C7, 0xA9C9,
	0xAA5D, 0xAA5F, 0xAADF, 0xAADF, 0xAAF0, 0xAAF1, 0xABEB, 0xABEB,
	0xFE50, 0xFE52, 0xFE54, 0xFE57, 0xFF01, 0xFF01, 0xFF0C, 0xFF0C,
	0xFF0E, 0xFF0E, 0xFF1A, 0xFF1B, 0xFF1F, 0xFF1F, 0xFF61, 0xFF61,
	0xFF64, 0xFF64, 0x1039F, 0x1039F, 0x103D0, 0x103D0, 0x10857, 0x10857,
	0x1091F, 0x1091F, 0x10A56, 0x10A57, 0x10AF0, 0x10AF5, 0x10B3A, 0x10B3F,
	0x10B99, 0x10B9C, 0x10F55, 0x10F59, 0x11047, 0x1104D, 0x110BE, 0x110C1,
	0x11141, 0x11143, 0x111C5, 0x111C6, 0x111CD, 0x111CD, 0x111DE, 0x111DF,
	0x11238, 0x1123C, 0x112A9, 0x112A9, 0x1144B, 0x1144D, 0x1145B, 0x1145B,
	0x115C2, 0x115C5, 0x115C9, 0x115D7, 0x11641, 0x11642, 0x1173C, 0x1173E,
	0x11A42, 0x11A43, 0x11A9B, 0x11A9C, 0x11AA1, 0x11AA2, 0x11C41, 0x11C43,
	0x11C71, 0x11C71, 0x11EF7, 0x11EF8, 0x12470, 0x12474, 0x16A6E, 0x16A6F,
	0x16AF5, 0x16AF5, 0x16B37, 0x16B39, 0x16B44, 0x16B44, 0x16E97, 0x16E98,
	0x1BC9F, 0x1BC9F, 0x1DA87, 0x1DA8A,
	//  #85 (12649+14): bp=Unified_Ideograph:UIdeo
	0x3400, 0x4DB5, 0x4E00, 0x9FEF, 0xFA0E, 0xFA0F, 0xFA11, 0xFA11,
	0xFA13, 0xFA14, 0xFA1F, 0xFA1F, 0xFA21, 0xFA21, 0xFA23, 0xFA24,
	0xFA27, 0xFA29, 0x20000, 0x2A6D6, 0x2A700, 0x2B734, 0x2B740, 0x2B81D,
	0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0,
	//  #86 (12663+641): bp=Uppercase:Upper
	0x0041, 0x005A, 0x00C0, 0x00D6, 0x00D8, 0x00DE, 0x0100, 0x0100,
	0x0102, 0x0102, 0x0104, 0x0104, 0x0106, 0x0106, 0x0108, 0x0108,
	0x010A, 0x010A, 0x010C, 0x010C, 0x010E, 0x010E, 0x0110, 0x0110,
	0x0112, 0x0112, 0x0114, 0x0114, 0x0116, 0x0116, 0x0118, 0x0118,
	0x011A, 0x011A, 0x011C, 0x011C, 0x011E, 0x011E, 0x0120, 0x0120,
	0x0122, 0x0122, 0x0124, 0x0124, 0x0126, 0x0126, 0x0128, 0x0128,
	0x012A, 0x012A, 0x012C, 0x012C, 0x012E, 0x012E, 0x0130, 0x0130,
	0x0132, 0x0132, 0x0134, 0x0134, 0x0136, 0x0136, 0x0139, 0x0139,
	0x013B, 0x013B, 0x013D, 0x013D, 0x013F, 0x013F, 0x0141, 0x0141,
	0x0143, 0x0143, 0x0145, 0x0145, 0x0147, 0x0147, 0x014A, 0x014A,
	0x014C, 0x014C, 0x014E, 0x014E, 0x0150, 0x0150, 0x0152, 0x0152,
	0x0154, 0x0154, 0x0156, 0x0156, 0x0158, 0x0158, 0x015A, 0x015A,
	0x015C, 0x015C, 0x015E, 0x015E, 0x0160, 0x0160, 0x0162, 0x0162,
	0x0164, 0x0164, 0x0166, 0x0166, 0x0168, 0x0168, 0x016A, 0x016A,
	0x016C, 0x016C, 0x016E, 0x016E, 0x0170, 0x0170, 0x0172, 0x0172,
	0x0174, 0x0174, 0x0176, 0x0176, 0x0178, 0x0179, 0x017B, 0x017B,
	0x017D, 0x017D, 0x0181, 0x0182, 0x0184, 0x0184, 0x0186, 0x0187,
	0x0189, 0x018B, 0x018E, 0x0191, 0x0193, 0x0194, 0x0196, 0x0198,
	0x019C, 0x019D, 0x019F, 0x01A0, 0x01A2, 0x01A2, 0x01A4, 0x01A4,
	0x01A6, 0x01A7, 0x01A9, 0x01A9, 0x01AC, 0x01AC, 0x01AE, 0x01AF,
	0x01B1, 0x01B3, 0x01B5, 0x01B5, 0x01B7, 0x01B8, 0x01BC, 0x01BC,
	0x01C4, 0x01C4, 0x01C7, 0x01C7, 0x01CA, 0x01CA, 0x01CD, 0x01CD,
	0x01CF, 0x01CF, 0x01D1, 0x01D1, 0x01D3, 0x01D3, 0x01D5, 0x01D5,
	0x01D7, 0x01D7, 0x01D9, 0x01D9, 0x01DB, 0x01DB, 0x01DE, 0x01DE,
	0x01E0, 0x01E0, 0x01E2, 0x01E2, 0x01E4, 0x01E4, 0x01E6, 0x01E6,
	0x01E8, 0x01E8, 0x01EA, 0x01EA, 0x01EC, 0x01EC, 0x01EE, 0x01EE,
	0x01F1, 0x01F1, 0x01F4, 0x01F4, 0x01F6, 0x01F8, 0x01FA, 0x01FA,
	0x01FC, 0x01FC, 0x01FE, 0x01FE, 0x0200, 0x0200, 0x0202, 0x0202,
	0x0204, 0x0204, 0x0206, 0x0206, 0x0208, 0x0208, 0x020A, 0x020A,
	0x020C, 0x020C, 0x020E, 0x020E, 0x0210, 0x0210, 0x0212, 0x0212,
	0x0214, 0x0214, 0x0216, 0x0216, 0x0218, 0x0218, 0x021A, 0x021A,
	0x021C, 0x021C, 0x021E, 0x021E, 0x0220, 0x0220, 0x0222, 0x0222,
	0x0224, 0x0224, 0x0226, 0x0226, 0x0228, 0x0228, 0x022A, 0x022A,
	0x022C, 0x022C, 0x022E, 0x022E, 0x0230, 0x0230, 0x0232, 0x0232,
	0x023A, 0x023B, 0x023D, 0x023E, 0x0241, 0x0241, 0x0243, 0x0246,
	0x0248, 0x0248, 0x024A, 0x024A, 0x024C, 0x024C, 0x024E, 0x024E,
	0x0370, 0x0370, 0x0372, 0x0372, 0x0376, 0x0376, 0x037F, 0x037F,
	0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x038F,
	0x0391, 0x03A1, 0x03A3, 0x03AB, 0x03CF, 0x03CF, 0x03D2, 0x03D4,
	0x03D8, 0x03D8, 0x03DA, 0x03DA, 0x03DC, 0x03DC, 0x03DE, 0x03DE,
	0x03E0, 0x03E0, 0x03E2, 0x03E2, 0x03E4, 0x03E4, 0x03E6, 0x03E6,
	0x03E8, 0x03E8, 0x03EA, 0x03EA, 0x03EC, 0x03EC, 0x03EE, 0x03EE,
	0x03F4, 0x03F4, 0x03F7, 0x03F7, 0x03F9, 0x03FA, 0x03FD, 0x042F,
	0x0460, 0x0460, 0x0462, 0x0462, 0x0464, 0x0464, 0x0466, 0x0466,
	0x0468, 0x0468, 0x046A, 0x046A, 0x046C, 0x046C, 0x046E, 0x046E,
	0x0470, 0x0470, 0x0472, 0x0472, 0x0474, 0x0474, 0x0476, 0x0476,
	0x0478, 0x0478, 0x047A, 0x047A, 0x047C, 0x047C, 0x047E, 0x047E,
	0x0480, 0x0480, 0x048A, 0x048A, 0x048C, 0x048C, 0x048E, 0x048E,
	0x0490, 0x0490, 0x0492, 0x0492, 0x0494, 0x0494, 0x0496, 0x0496,
	0x0498, 0x0498, 0x049A, 0x049A, 0x049C, 0x049C, 0x049E, 0x049E,
	0x04A0, 0x04A0, 0x04A2, 0x04A2, 0x04A4, 0x04A4, 0x04A6, 0x04A6,
	0x04A8, 0x04A8, 0x04AA, 0x04AA, 0x04AC, 0x04AC, 0x04AE, 0x04AE,
	0x04B0, 0x04B0, 0x04B2, 0x04B2, 0x04B4, 0x04B4, 0x04B6, 0x04B6,
	0x04B8, 0x04B8, 0x04BA, 0x04BA, 0x04BC, 0x04BC, 0x04BE, 0x04BE,
	0x04C0, 0x04C1, 0x04C3, 0x04C3, 0x04C5, 0x04C5, 0x04C7, 0x04C7,
	0x04C9, 0x04C9, 0x04CB, 0x04CB, 0x04CD, 0x04CD, 0x04D0, 0x04D0,
	0x04D2, 0x04D2, 0x04D4, 0x04D4, 0x04D6, 0x04D6, 0x04D8, 0x04D8,
	0x04DA, 0x04DA, 0x04DC, 0x04DC, 0x04DE, 0x04DE, 0x04E0, 0x04E0,
	0x04E2, 0x04E2, 0x04E4, 0x04E4, 0x04E6, 0x04E6, 0x04E8, 0x04E8,
	0x04EA, 0x04EA, 0x04EC, 0x04EC, 0x04EE, 0x04EE, 0x04F0, 0x04F0,
	0x04F2, 0x04F2, 0x04F4, 0x04F4, 0x04F6, 0x04F6, 0x04F8, 0x04F8,
	0x04FA, 0x04FA, 0x04FC, 0x04FC, 0x04FE, 0x04FE, 0x0500, 0x0500,
	0x0502, 0x0502, 0x0504, 0x0504, 0x0506, 0x0506, 0x0508, 0x0508,
	0x050A, 0x050A, 0x050C, 0x050C, 0x050E, 0x050E, 0x0510, 0x0510,
	0x0512, 0x0512, 0x0514, 0x0514, 0x0516, 0x0516, 0x0518, 0x0518,
	0x051A, 0x051A, 0x051C, 0x051C, 0x051E, 0x051E, 0x0520, 0x0520,
	0x0522, 0x0522, 0x0524, 0x0524, 0x0526, 0x0526, 0x0528, 0x0528,
	0x052A, 0x052A, 0x052C, 0x052C, 0x052E, 0x052E, 0x0531, 0x0556,
	0x10A0, 0x10C5, 0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x13A0, 0x13F5,
	0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x1E00, 0x1E00, 0x1E02, 0x1E02,
	0x1E04, 0x1E04, 0x1E06, 0x1E06, 0x1E08, 0x1E08, 0x1E0A, 0x1E0A,
	0x1E0C, 0x1E0C, 0x1E0E, 0x1E0E, 0x1E10, 0x1E10, 0x1E12, 0x1E12,
	0x1E14, 0x1E14, 0x1E16, 0x1E16, 0x1E18, 0x1E18, 0x1E1A, 0x1E1A,
	0x1E1C, 0x1E1C, 0x1E1E, 0x1E1E, 0x1E20, 0x1E20, 0x1E22, 0x1E22,
	0x1E24, 0x1E24, 0x1E26, 0x1E26, 0x1E28, 0x1E28, 0x1E2A, 0x1E2A,
	0x1E2C, 0x1E2C, 0x1E2E, 0x1E2E, 0x1E30, 0x1E30, 0x1E32, 0x1E32,
	0x1E34, 0x1E34, 0x1E36, 0x1E36, 0x1E38, 0x1E38, 0x1E3A, 0x1E3A,
	0x1E3C, 0x1E3C, 0x1E3E, 0x1E3E, 0x1E40, 0x1E40, 0x1E42, 0x1E42,
	0x1E44, 0x1E44, 0x1E46, 0x1E46, 0x1E48, 0x1E48, 0x1E4A, 0x1E4A,
	0x1E4C, 0x1E4C, 0x1E4E, 0x1E4E, 0x1E50, 0x1E50, 0x1E52, 0x1E52,
	0x1E54, 0x1E54, 0x1E56, 0x1E56, 0x1E58, 0x1E58, 0x1E5A, 0x1E5A,
	0x1E5C, 0x1E5C, 0x1E5E, 0x1E5E, 0x1E60, 0x1E60, 0x1E62, 0x1E62,
	0x1E64, 0x1E64, 0x1E66, 0x1E66, 0x1E68, 0x1E68, 0x1E6A, 0x1E6A,
	0x1E6C, 0x1E6C, 0x1E6E, 0x1E6E, 0x1E70, 0x1E70, 0x1E72, 0x1E72,
	0x1E74, 0x1E74, 0x1E76, 0x1E76, 0x1E78, 0x1E78, 0x1E7A, 0x1E7A,
	0x1E7C, 0x1E7C, 0x1E7E, 0x1E7E, 0x1E80, 0x1E80, 0x1E82, 0x1E82,
	0x1E84, 0x1E84, 0x1E86, 0x1E86, 0x1E88, 0x1E88, 0x1E8A, 0x1E8A,
	0x1E8C, 0x1E8C, 0x1E8E, 0x1E8E, 0x1E90, 0x1E90, 0x1E92, 0x1E92,
	0x1E94, 0x1E94, 0x1E9E, 0x1E9E, 0x1EA0, 0x1EA0, 0x1EA2, 0x1EA2,
	0x1EA4, 0x1EA4, 0x1EA6, 0x1EA6, 0x1EA8, 0x1EA8, 0x1EAA, 0x1EAA,
	0x1EAC, 0x1EAC, 0x1EAE, 0x1EAE, 0x1EB0, 0x1EB0, 0x1EB2, 0x1EB2,
	0x1EB4, 0x1EB4, 0x1EB6, 0x1EB6, 0x1EB8, 0x1EB8, 0x1EBA, 0x1EBA,
	0x1EBC, 0x1EBC, 0x1EBE, 0x1EBE, 0x1EC0, 0x1EC0, 0x1EC2, 0x1EC2,
	0x1EC4, 0x1EC4, 0x1EC6, 0x1EC6, 0x1EC8, 0x1EC8, 0x1ECA, 0x1ECA,
	0x1ECC, 0x1ECC, 0x1ECE, 0x1ECE, 0x1ED0, 0x1ED0, 0x1ED2, 0x1ED2,
	0x1ED4, 0x1ED4, 0x1ED6, 0x1ED6, 0x1ED8, 0x1ED8, 0x1EDA, 0x1EDA,
	0x1EDC, 0x1EDC, 0x1EDE, 0x1EDE, 0x1EE0, 0x1EE0, 0x1EE2, 0x1EE2,
	0x1EE4, 0x1EE4, 0x1EE6, 0x1EE6, 0x1EE8, 0x1EE8, 0x1EEA, 0x1EEA,
	0x1EEC, 0x1EEC, 0x1EEE, 0x1EEE, 0x1EF0, 0x1EF0, 0x1EF2, 0x1EF2,
	0x1EF4, 0x1EF4, 0x1EF6, 0x1EF6, 0x1EF8, 0x1EF8, 0x1EFA, 0x1EFA,
	0x1EFC, 0x1EFC, 0x1EFE, 0x1EFE, 0x1F08, 0x1F0F, 0x1F18, 0x1F1D,
	0x1F28, 0x1F2F, 0x1F38, 0x1F3F, 0x1F48, 0x1F4D, 0x1F59, 0x1F59,
	0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F5F, 0x1F68, 0x1F6F,
	0x1FB8, 0x1FBB, 0x1FC8, 0x1FCB, 0x1FD8, 0x1FDB, 0x1FE8, 0x1FEC,
	0x1FF8, 0x1FFB, 0x2102, 0x2102, 0x2107, 0x2107, 0x210B, 0x210D,
	0x2110, 0x2112, 0x2115, 0x2115, 0x2119, 0x211D, 0x2124, 0x2124,
	0x2126, 0x2126, 0x2128, 0x2128, 0x212A, 0x212D, 0x2130, 0x2133,
	0x213E, 0x213F, 0x2145, 0x2145, 0x2160, 0x216F, 0x2183, 0x2183,
	0x24B6, 0x24CF, 0x2C00, 0x2C2E, 0x2C60, 0x2C60, 0x2C62, 0x2C64,
	0x2C67, 0x2C67, 0x2C69, 0x2C69, 0x2C6B, 0x2C6B, 0x2C6D, 0x2C70,
	0x2C72, 0x2C72, 0x2C75, 0x2C75, 0x2C7E, 0x2C80, 0x2C82, 0x2C82,
	0x2C84, 0x2C84, 0x2C86, 0x2C86, 0x2C88, 0x2C88, 0x2C8A, 0x2C8A,
	0x2C8C, 0x2C8C, 0x2C8E, 0x2C8E, 0x2C90, 0x2C90, 0x2C92, 0x2C92,
	0x2C94, 0x2C94, 0x2C96, 0x2C96, 0x2C98, 0x2C98, 0x2C9A, 0x2C9A,
	0x2C9C, 0x2C9C, 0x2C9E, 0x2C9E, 0x2CA0, 0x2CA0, 0x2CA2, 0x2CA2,
	0x2CA4, 0x2CA4, 0x2CA6, 0x2CA6, 0x2CA8, 0x2CA8, 0x2CAA, 0x2CAA,
	0x2CAC, 0x2CAC, 0x2CAE, 0x2CAE, 0x2CB0, 0x2CB0, 0x2CB2, 0x2CB2,
	0x2CB4, 0x2CB4, 0x2CB6, 0x2CB6, 0x2CB8, 0x2CB8, 0x2CBA, 0x2CBA,
	0x2CBC, 0x2CBC, 0x2CBE, 0x2CBE, 0x2CC0, 0x2CC0, 0x2CC2, 0x2CC2,
	0x2CC4, 0x2CC4, 0x2CC6, 0x2CC6, 0x2CC8, 0x2CC8, 0x2CCA, 0x2CCA,
	0x2CCC, 0x2CCC, 0x2CCE, 0x2CCE, 0x2CD0, 0x2CD0, 0x2CD2, 0x2CD2,
	0x2CD4, 0x2CD4, 0x2CD6, 0x2CD6, 0x2CD8, 0x2CD8, 0x2CDA, 0x2CDA,
	0x2CDC, 0x2CDC, 0x2CDE, 0x2CDE, 0x2CE0, 0x2CE0, 0x2CE2, 0x2CE2,
	0x2CEB, 0x2CEB, 0x2CED, 0x2CED, 0x2CF2, 0x2CF2, 0xA640, 0xA640,
	0xA642, 0xA642, 0xA644, 0xA644, 0xA646, 0xA646, 0xA648, 0xA648,
	0xA64A, 0xA64A, 0xA64C, 0xA64C, 0xA64E, 0xA64E, 0xA650, 0xA650,
	0xA652, 0xA652, 0xA654, 0xA654, 0xA656, 0xA656, 0xA658, 0xA658,
	0xA65A, 0xA65A, 0xA65C, 0xA65C, 0xA65E, 0xA65E, 0xA660, 0xA660,
	0xA662, 0xA662, 0xA664, 0xA664, 0xA666, 0xA666, 0xA668, 0xA668,
	0xA66A, 0xA66A, 0xA66C, 0xA66C, 0xA680, 0xA680, 0xA682, 0xA682,
	0xA684, 0xA684, 0xA686, 0xA686, 0xA688, 0xA688, 0xA68A, 0xA68A,
	0xA68C, 0xA68C, 0xA68E, 0xA68E, 0xA690, 0xA690, 0xA692, 0xA692,
	0xA694, 0xA694, 0xA696, 0xA696, 0xA698, 0xA698, 0xA69A, 0xA69A,
	0xA722, 0xA722, 0xA724, 0xA724, 0xA726, 0xA726, 0xA728, 0xA728,
	0xA72A, 0xA72A, 0xA72C, 0xA72C, 0xA72E, 0xA72E, 0xA732, 0xA732,
	0xA734, 0xA734, 0xA736, 0xA736, 0xA738, 0xA738, 0xA73A, 0xA73A,
	0xA73C, 0xA73C, 0xA73E, 0xA73E, 0xA740, 0xA740, 0xA742, 0xA742,
	0xA744, 0xA744, 0xA746, 0xA746, 0xA748, 0xA748, 0xA74A, 0xA74A,
	0xA74C, 0xA74C, 0xA74E, 0xA74E, 0xA750, 0xA750, 0xA752, 0xA752,
	0xA754, 0xA754, 0xA756, 0xA756, 0xA758, 0xA758, 0xA75A, 0xA75A,
	0xA75C, 0xA75C, 0xA75E, 0xA75E, 0xA760, 0xA760, 0xA762, 0xA762,
	0xA764, 0xA764, 0xA766, 0xA766, 0xA768, 0xA768, 0xA76A, 0xA76A,
	0xA76C, 0xA76C, 0xA76E, 0xA76E, 0xA779, 0xA779, 0xA77B, 0xA77B,
	0xA77D, 0xA77E, 0xA780, 0xA780, 0xA782, 0xA782, 0xA784, 0xA784,
	0xA786, 0xA786, 0xA78B, 0xA78B, 0xA78D, 0xA78D, 0xA790, 0xA790,
	0xA792, 0xA792, 0xA796, 0xA796, 0xA798, 0xA798, 0xA79A, 0xA79A,
	0xA79C, 0xA79C, 0xA79E, 0xA79E, 0xA7A0, 0xA7A0, 0xA7A2, 0xA7A2,
	0xA7A4, 0xA7A4, 0xA7A6, 0xA7A6, 0xA7A8, 0xA7A8, 0xA7AA, 0xA7AE,
	0xA7B0, 0xA7B4, 0xA7B6, 0xA7B6, 0xA7B8, 0xA7B8, 0xA7BA, 0xA7BA,
	0xA7BC, 0xA7BC, 0xA7BE, 0xA7BE, 0xA7C2, 0xA7C2, 0xA7C4, 0xA7C6,
	0xFF21, 0xFF3A, 0x10400, 0x10427, 0x104B0, 0x104D3, 0x10C80, 0x10CB2,
	0x118A0, 0x118BF, 0x16E40, 0x16E5F, 0x1D400, 0x1D419, 0x1D434, 0x1D44D,
	0x1D468, 0x1D481, 0x1D49C, 0x1D49C, 0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2,
	0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B5, 0x1D4D0, 0x1D4E9,
	0x1D504, 0x1D505, 0x1D507, 0x1D50A, 0x1D50D, 0x1D514, 0x1D516, 0x1D51C,
	0x1D538, 0x1D539, 0x1D53B, 0x1D53E, 0x1D540, 0x1D544, 0x1D546, 0x1D546,
	0x1D54A, 0x1D550, 0x1D56C, 0x1D585, 0x1D5A0, 0x1D5B9, 0x1D5D4, 0x1D5ED,
	0x1D608, 0x1D621, 0x1D63C, 0x1D655, 0x1D670, 0x1D689, 0x1D6A8, 0x1D6C0,
	0x1D6E2, 0x1D6FA, 0x1D71C, 0x1D734, 0x1D756, 0x1D76E, 0x1D790, 0x1D7A8,
	0x1D7CA, 0x1D7CA, 0x1E900, 0x1E921, 0x1F130, 0x1F149, 0x1F150, 0x1F169,
	0x1F170, 0x1F189,
	//  #87 (13304+3): bp=Variation_Selector:VS
	0x180B, 0x180D, 0xFE00, 0xFE0F, 0xE0100, 0xE01EF,
	//  #88 (13307+10): bp=White_Space:space
	0x0009, 0x000D, 0x0020, 0x0020, 0x0085, 0x0085, 0x00A0, 0x00A0,
	0x1680, 0x1680, 0x2000, 0x200A, 0x2028, 0x2029, 0x202F, 0x202F,
	0x205F, 0x205F, 0x3000, 0x3000,
	//  #89 (13317+720): bp=XID_Continue:XIDC
	0x0030, 0x0039, 0x0041, 0x005A, 0x005F, 0x005F, 0x0061, 0x007A,
	0x00AA, 0x00AA, 0x00B5, 0x00B5, 0x00B7, 0x00B7, 0x00BA, 0x00BA,
	0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x02C1, 0x02C6, 0x02D1,
	0x02E0, 0x02E4, 0x02EC, 0x02EC, 0x02EE, 0x02EE, 0x0300, 0x0374,
	0x0376, 0x0377, 0x037B, 0x037D, 0x037F, 0x037F, 0x0386, 0x038A,
	0x038C, 0x038C, 0x038E, 0x03A1, 0x03A3, 0x03F5, 0x03F7, 0x0481,
	0x0483, 0x0487, 0x048A, 0x052F, 0x0531, 0x0556, 0x0559, 0x0559,
	0x0560, 0x0588, 0x0591, 0x05BD, 0x05BF, 0x05BF, 0x05C1, 0x05C2,
	0x05C4, 0x05C5, 0x05C7, 0x05C7, 0x05D0, 0x05EA, 0x05EF, 0x05F2,
	0x0610, 0x061A, 0x0620, 0x0669, 0x066E, 0x06D3, 0x06D5, 0x06DC,
	0x06DF, 0x06E8, 0x06EA, 0x06FC, 0x06FF, 0x06FF, 0x0710, 0x074A,
	0x074D, 0x07B1, 0x07C0, 0x07F5, 0x07FA, 0x07FA, 0x07FD, 0x07FD,
	0x0800, 0x082D, 0x0840, 0x085B, 0x0860, 0x086A, 0x08A0, 0x08B4,
	0x08B6, 0x08BD, 0x08D3, 0x08E1, 0x08E3, 0x0963, 0x0966, 0x096F,
	0x0971, 0x0983, 0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8,
	0x09AA, 0x09B0, 0x09B2, 0x09B2, 0x09B6, 0x09B9, 0x09BC, 0x09C4,
	0x09C7, 0x09C8, 0x09CB, 0x09CE, 0x09D7, 0x09D7, 0x09DC, 0x09DD,
	0x09DF, 0x09E3, 0x09E6, 0x09F1, 0x09FC, 0x09FC, 0x09FE, 0x09FE,
	0x0A01, 0x0A03, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10, 0x0A13, 0x0A28,
	0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36, 0x0A38, 0x0A39,
	0x0A3C, 0x0A3C, 0x0A3E, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4D,
	0x0A51, 0x0A51, 0x0A59, 0x0A5C, 0x0A5E, 0x0A5E, 0x0A66, 0x0A75,
	0x0A81, 0x0A83, 0x0A85, 0x0A8D, 0x0A8F, 0x0A91, 0x0A93, 0x0AA8,
	0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9, 0x0ABC, 0x0AC5,
	0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD, 0x0AD0, 0x0AD0, 0x0AE0, 0x0AE3,
	0x0AE6, 0x0AEF, 0x0AF9, 0x0AFF, 0x0B01, 0x0B03, 0x0B05, 0x0B0C,
	0x0B0F, 0x0B10, 0x0B13, 0x0B28, 0x0B2A, 0x0B30, 0x0B32, 0x0B33,
	0x0B35, 0x0B39, 0x0B3C, 0x0B44, 0x0B47, 0x0B48, 0x0B4B, 0x0B4D,
	0x0B56, 0x0B57, 0x0B5C, 0x0B5D, 0x0B5F, 0x0B63, 0x0B66, 0x0B6F,
	0x0B71, 0x0B71, 0x0B82, 0x0B83, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90,
	0x0B92, 0x0B95, 0x0B99, 0x0B9A, 0x0B9C, 0x0B9C, 0x0B9E, 0x0B9F,
	0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9, 0x0BBE, 0x0BC2,
	0x0BC6, 0x0BC8, 0x0BCA, 0x0BCD, 0x0BD0, 0x0BD0, 0x0BD7, 0x0BD7,
	0x0BE6, 0x0BEF, 0x0C00, 0x0C0C, 0x0C0E, 0x0C10, 0x0C12, 0x0C28,
	0x0C2A, 0x0C39, 0x0C3D, 0x0C44, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D,
	0x0C55, 0x0C56, 0x0C58, 0x0C5A, 0x0C60, 0x0C63, 0x0C66, 0x0C6F,
	0x0C80, 0x0C83, 0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8,
	0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBC, 0x0CC4, 0x0CC6, 0x0CC8,
	0x0CCA, 0x0CCD, 0x0CD5, 0x0CD6, 0x0CDE, 0x0CDE, 0x0CE0, 0x0CE3,
	0x0CE6, 0x0CEF, 0x0CF1, 0x0CF2, 0x0D00, 0x0D03, 0x0D05, 0x0D0C,
	0x0D0E, 0x0D10, 0x0D12, 0x0D44, 0x0D46, 0x0D48, 0x0D4A, 0x0D4E,
	0x0D54, 0x0D57, 0x0D5F, 0x0D63, 0x0D66, 0x0D6F, 0x0D7A, 0x0D7F,
	0x0D82, 0x0D83, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1, 0x0DB3, 0x0DBB,
	0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0DCA, 0x0DCA, 0x0DCF, 0x0DD4,
	0x0DD6, 0x0DD6, 0x0DD8, 0x0DDF, 0x0DE6, 0x0DEF, 0x0DF2, 0x0DF3,
	0x0E01, 0x0E3A, 0x0E40, 0x0E4E, 0x0E50, 0x0E59, 0x0E81, 0x0E82,
	0x0E84, 0x0E84, 0x0E86, 0x0E8A, 0x0E8C, 0x0EA3, 0x0EA5, 0x0EA5,
	0x0EA7, 0x0EBD, 0x0EC0, 0x0EC4, 0x0EC6, 0x0EC6, 0x0EC8, 0x0ECD,
	0x0ED0, 0x0ED9, 0x0EDC, 0x0EDF, 0x0F00, 0x0F00, 0x0F18, 0x0F19,
	0x0F20, 0x0F29, 0x0F35, 0x0F35, 0x0F37, 0x0F37, 0x0F39, 0x0F39,
	0x0F3E, 0x0F47, 0x0F49, 0x0F6C, 0x0F71, 0x0F84, 0x0F86, 0x0F97,
	0x0F99, 0x0FBC, 0x0FC6, 0x0FC6, 0x1000, 0x1049, 0x1050, 0x109D,
	0x10A0, 0x10C5, 0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x10D0, 0x10FA,
	0x10FC, 0x1248, 0x124A, 0x124D, 0x1250, 0x1256, 0x1258, 0x1258,
	0x125A, 0x125D, 0x1260, 0x1288, 0x128A, 0x128D, 0x1290, 0x12B0,
	0x12B2, 0x12B5, 0x12B8, 0x12BE, 0x12C0, 0x12C0, 0x12C2, 0x12C5,
	0x12C8, 0x12D6, 0x12D8, 0x1310, 0x1312, 0x1315, 0x1318, 0x135A,
	0x135D, 0x135F, 0x1369, 0x1371, 0x1380, 0x138F, 0x13A0, 0x13F5,
	0x13F8, 0x13FD, 0x1401, 0x166C, 0x166F, 0x167F, 0x1681, 0x169A,
	0x16A0, 0x16EA, 0x16EE, 0x16F8, 0x1700, 0x170C, 0x170E, 0x1714,
	0x1720, 0x1734, 0x1740, 0x1753, 0x1760, 0x176C, 0x176E, 0x1770,
	0x1772, 0x1773, 0x1780, 0x17D3, 0x17D7, 0x17D7, 0x17DC, 0x17DD,
	0x17E0, 0x17E9, 0x180B, 0x180D, 0x1810, 0x1819, 0x1820, 0x1878,
	0x1880, 0x18AA, 0x18B0, 0x18F5, 0x1900, 0x191E, 0x1920, 0x192B,
	0x1930, 0x193B, 0x1946, 0x196D, 0x1970, 0x1974, 0x1980, 0x19AB,
	0x19B0, 0x19C9, 0x19D0, 0x19DA, 0x1A00, 0x1A1B, 0x1A20, 0x1A5E,
	0x1A60, 0x1A7C, 0x1A7F, 0x1A89, 0x1A90, 0x1A99, 0x1AA7, 0x1AA7,
	0x1AB0, 0x1ABD, 0x1B00, 0x1B4B, 0x1B50, 0x1B59, 0x1B6B, 0x1B73,
	0x1B80, 0x1BF3, 0x1C00, 0x1C37, 0x1C40, 0x1C49, 0x1C4D, 0x1C7D,
	0x1C80, 0x1C88, 0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x1CD0, 0x1CD2,
	0x1CD4, 0x1CFA, 0x1D00, 0x1DF9, 0x1DFB, 0x1F15, 0x1F18, 0x1F1D,
	0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57, 0x1F59, 0x1F59,
	0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4,
	0x1FB6, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC,
	0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4,
	0x1FF6, 0x1FFC, 0x203F, 0x2040, 0x2054, 0x2054, 0x2071, 0x2071,
	0x207F, 0x207F, 0x2090, 0x209C, 0x20D0, 0x20DC, 0x20E1, 0x20E1,
	0x20E5, 0x20F0, 0x2102, 0x2102, 0x2107, 0x2107, 0x210A, 0x2113,
	0x2115, 0x2115, 0x2118, 0x211D, 0x2124, 0x2124, 0x2126, 0x2126,
	0x2128, 0x2128, 0x212A, 0x2139, 0x213C, 0x213F, 0x2145, 0x2149,
	0x214E, 0x214E, 0x2160, 0x2188, 0x2C00, 0x2C2E, 0x2C30, 0x2C5E,
	0x2C60, 0x2CE4, 0x2CEB, 0x2CF3, 0x2D00, 0x2D25, 0x2D27, 0x2D27,
	0x2D2D, 0x2D2D, 0x2D30, 0x2D67, 0x2D6F, 0x2D6F, 0x2D7F, 0x2D96,
	0x2DA0, 0x2DA6, 0x2DA8, 0x2DAE, 0x2DB0, 0x2DB6, 0x2DB8, 0x2DBE,
	0x2DC0, 0x2DC6, 0x2DC8, 0x2DCE, 0x2DD0, 0x2DD6, 0x2DD8, 0x2DDE,
	0x2DE0, 0x2DFF, 0x3005, 0x3007, 0x3021, 0x302F, 0x3031, 0x3035,
	0x3038, 0x303C, 0x3041, 0x3096, 0x3099, 0x309A, 0x309D, 0x309F,
	0x30A1, 0x30FA, 0x30FC, 0x30FF, 0x3105, 0x312F, 0x3131, 0x318E,
	0x31A0, 0x31BA, 0x31F0, 0x31FF, 0x3400, 0x4DB5, 0x4E00, 0x9FEF,
	0xA000, 0xA48C, 0xA4D0, 0xA4FD, 0xA500, 0xA60C, 0xA610, 0xA62B,
	0xA640, 0xA66F, 0xA674, 0xA67D, 0xA67F, 0xA6F1, 0xA717, 0xA71F,
	0xA722, 0xA788, 0xA78B, 0xA7BF, 0xA7C2, 0xA7C6, 0xA7F7, 0xA827,
	0xA840, 0xA873, 0xA880, 0xA8C5, 0xA8D0, 0xA8D9, 0xA8E0, 0xA8F7,
	0xA8FB, 0xA8FB, 0xA8FD, 0xA92D, 0xA930, 0xA953, 0xA960, 0xA97C,
	0xA980, 0xA9C0, 0xA9CF, 0xA9D9, 0xA9E0, 0xA9FE, 0xAA00, 0xAA36,
	0xAA40, 0xAA4D, 0xAA50, 0xAA59, 0xAA60, 0xAA76, 0xAA7A, 0xAAC2,
	0xAADB, 0xAADD, 0xAAE0, 0xAAEF, 0xAAF2, 0xAAF6, 0xAB01, 0xAB06,
	0xAB09, 0xAB0E, 0xAB11, 0xAB16, 0xAB20, 0xAB26, 0xAB28, 0xAB2E,
	0xAB30, 0xAB5A, 0xAB5C, 0xAB67, 0xAB70, 0xABEA, 0xABEC, 0xABED,
	0xABF0, 0xABF9, 0xAC00, 0xD7A3, 0xD7B0, 0xD7C6, 0xD7CB, 0xD7FB,
	0xF900, 0xFA6D, 0xFA70, 0xFAD9, 0xFB00, 0xFB06, 0xFB13, 0xFB17,
	0xFB1D, 0xFB28, 0xFB2A, 0xFB36, 0xFB38, 0xFB3C, 0xFB3E, 0xFB3E,
	0xFB40, 0xFB41, 0xFB43, 0xFB44, 0xFB46, 0xFBB1, 0xFBD3, 0xFC5D,
	0xFC64, 0xFD3D, 0xFD50, 0xFD8F, 0xFD92, 0xFDC7, 0xFDF0, 0xFDF9,
	0xFE00, 0xFE0F, 0xFE20, 0xFE2F, 0xFE33, 0xFE34, 0xFE4D, 0xFE4F,
	0xFE71, 0xFE71, 0xFE73, 0xFE73, 0xFE77, 0xFE77, 0xFE79, 0xFE79,
	0xFE7B, 0xFE7B, 0xFE7D, 0xFE7D, 0xFE7F, 0xFEFC, 0xFF10, 0xFF19,
	0xFF21, 0xFF3A, 0xFF3F, 0xFF3F, 0xFF41, 0xFF5A, 0xFF66, 0xFFBE,
	0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF, 0xFFD2, 0xFFD7, 0xFFDA, 0xFFDC,
	0x10000, 0x1000B, 0x1000D, 0x10026, 0x10028, 0x1003A, 0x1003C, 0x1003D,
	0x1003F, 0x1004D, 0x10050, 0x1005D, 0x10080, 0x100FA, 0x10140, 0x10174,
	0x101FD, 0x101FD, 0x10280, 0x1029C, 0x102A0, 0x102D0, 0x102E0, 0x102E0,
	0x10300, 0x1031F, 0x1032D, 0x1034A, 0x10350, 0x1037A, 0x10380, 0x1039D,
	0x103A0, 0x103C3, 0x103C8, 0x103CF, 0x103D1, 0x103D5, 0x10400, 0x1049D,
	0x104A0, 0x104A9, 0x104B0, 0x104D3, 0x104D8, 0x104FB, 0x10500, 0x10527,
	0x10530, 0x10563, 0x10600, 0x10736, 0x10740, 0x10755, 0x10760, 0x10767,
	0x10800, 0x10805, 0x10808, 0x10808, 0x1080A, 0x10835, 0x10837, 0x10838,
	0x1083C, 0x1083C, 0x1083F, 0x10855, 0x10860, 0x10876, 0x10880, 0x1089E,
	0x108E0, 0x108F2, 0x108F4, 0x108F5, 0x10900, 0x10915, 0x10920, 0x10939,
	0x10980, 0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A03, 0x10A05, 0x10A06,
	0x10A0C, 0x10A13, 0x10A15, 0x10A17, 0x10A19, 0x10A35, 0x10A38, 0x10A3A,
	0x10A3F, 0x10A3F, 0x10A60, 0x10A7C, 0x10A80, 0x10A9C, 0x10AC0, 0x10AC7,
	0x10AC9, 0x10AE6, 0x10B00, 0x10B35, 0x10B40, 0x10B55, 0x10B60, 0x10B72,
	0x10B80, 0x10B91, 0x10C00, 0x10C48, 0x10C80, 0x10CB2, 0x10CC0, 0x10CF2,
	0x10D00, 0x10D27, 0x10D30, 0x10D39, 0x10F00, 0x10F1C, 0x10F27, 0x10F27,
	0x10F30, 0x10F50, 0x10FE0, 0x10FF6, 0x11000, 0x11046, 0x11066, 0x1106F,
	0x1107F, 0x110BA, 0x110D0, 0x110E8, 0x110F0, 0x110F9, 0x11100, 0x11134,
	0x11136, 0x1113F, 0x11144, 0x11146, 0x11150, 0x11173, 0x11176, 0x11176,
	0x11180, 0x111C4, 0x111C9, 0x111CC, 0x111D0, 0x111DA, 0x111DC, 0x111DC,
	0x11200, 0x11211, 0x11213, 0x11237, 0x1123E, 0x1123E, 0x11280, 0x11286,
	0x11288, 0x11288, 0x1128A, 0x1128D, 0x1128F, 0x1129D, 0x1129F, 0x112A8,
	0x112B0, 0x112EA, 0x112F0, 0x112F9, 0x11300, 0x11303, 0x11305, 0x1130C,
	0x1130F, 0x11310, 0x11313, 0x11328, 0x1132A, 0x11330, 0x11332, 0x11333,
	0x11335, 0x11339, 0x1133B, 0x11344, 0x11347, 0x11348, 0x1134B, 0x1134D,
	0x11350, 0x11350, 0x11357, 0x11357, 0x1135D, 0x11363, 0x11366, 0x1136C,
	0x11370, 0x11374, 0x11400, 0x1144A, 0x11450, 0x11459, 0x1145E, 0x1145F,
	0x11480, 0x114C5, 0x114C7, 0x114C7, 0x114D0, 0x114D9, 0x11580, 0x115B5,
	0x115B8, 0x115C0, 0x115D8, 0x115DD, 0x11600, 0x11640, 0x11644, 0x11644,
	0x11650, 0x11659, 0x11680, 0x116B8, 0x116C0, 0x116C9, 0x11700, 0x1171A,
	0x1171D, 0x1172B, 0x11730, 0x11739, 0x11800, 0x1183A, 0x118A0, 0x118E9,
	0x118FF, 0x118FF, 0x119A0, 0x119A7, 0x119AA, 0x119D7, 0x119DA, 0x119E1,
	0x119E3, 0x119E4, 0x11A00, 0x11A3E, 0x11A47, 0x11A47, 0x11A50, 0x11A99,
	0x11A9D, 0x11A9D, 0x11AC0, 0x11AF8, 0x11C00, 0x11C08, 0x11C0A, 0x11C36,
	0x11C38, 0x11C40, 0x11C50, 0x11C59, 0x11C72, 0x11C8F, 0x11C92, 0x11CA7,
	0x11CA9, 0x11CB6, 0x11D00, 0x11D06, 0x11D08, 0x11D09, 0x11D0B, 0x11D36,
	0x11D3A, 0x11D3A, 0x11D3C, 0x11D3D, 0x11D3F, 0x11D47, 0x11D50, 0x11D59,
	0x11D60, 0x11D65, 0x11D67, 0x11D68, 0x11D6A, 0x11D8E, 0x11D90, 0x11D91,
	0x11D93, 0x11D98, 0x11DA0, 0x11DA9, 0x11EE0, 0x11EF6, 0x12000, 0x12399,
	0x12400, 0x1246E, 0x12480, 0x12543, 0x13000, 0x1342E, 0x14400, 0x14646,
	0x16800, 0x16A38, 0x16A40, 0x16A5E, 0x16A60, 0x16A69, 0x16AD0, 0x16AED,
	0x16AF0, 0x16AF4, 0x16B00, 0x16B36, 0x16B40, 0x16B43, 0x16B50, 0x16B59,
	0x16B63, 0x16B77, 0x16B7D, 0x16B8F, 0x16E40, 0x16E7F, 0x16F00, 0x16F4A,
	0x16F4F, 0x16F87, 0x16F8F, 0x16F9F, 0x16FE0, 0x16FE1, 0x16FE3, 0x16FE3,
	0x17000, 0x187F7, 0x18800, 0x18AF2, 0x1B000, 0x1B11E, 0x1B150, 0x1B152,
	0x1B164, 0x1B167, 0x1B170, 0x1B2FB, 0x1BC00, 0x1BC6A, 0x1BC70, 0x1BC7C,
	0x1BC80, 0x1BC88, 0x1BC90, 0x1BC99, 0x1BC9D, 0x1BC9E, 0x1D165, 0x1D169,
	0x1D16D, 0x1D172, 0x1D17B, 0x1D182, 0x1D185, 0x1D18B, 0x1D1AA, 0x1D1AD,
	0x1D242, 0x1D244, 0x1D400, 0x1D454, 0x1D456, 0x1D49C, 0x1D49E, 0x1D49F,
	0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B9,
	0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505, 0x1D507, 0x1D50A,
	0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539, 0x1D53B, 0x1D53E,
	0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550, 0x1D552, 0x1D6A5,
	0x1D6A8, 0x1D6C0, 0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6FA, 0x1D6FC, 0x1D714,
	0x1D716, 0x1D734, 0x1D736, 0x1D74E, 0x1D750, 0x1D76E, 0x1D770, 0x1D788,
	0x1D78A, 0x1D7A8, 0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7CB, 0x1D7CE, 0x1D7FF,
	0x1DA00, 0x1DA36, 0x1DA3B, 0x1DA6C, 0x1DA75, 0x1DA75, 0x1DA84, 0x1DA84,
	0x1DA9B, 0x1DA9F, 0x1DAA1, 0x1DAAF, 0x1E000, 0x1E006, 0x1E008, 0x1E018,
	0x1E01B, 0x1E021, 0x1E023, 0x1E024, 0x1E026, 0x1E02A, 0x1E100, 0x1E12C,
	0x1E130, 0x1E13D, 0x1E140, 0x1E149, 0x1E14E, 0x1E14E, 0x1E2C0, 0x1E2F9,
	0x1E800, 0x1E8C4, 0x1E8D0, 0x1E8D6, 0x1E900, 0x1E94B, 0x1E950, 0x1E959,
	0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22, 0x1EE24, 0x1EE24,
	0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37, 0x1EE39, 0x1EE39,
	0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47, 0x1EE49, 0x1EE49,
	0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE54,
	0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B, 0x1EE5D, 0x1EE5D,
	0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64, 0x1EE67, 0x1EE6A,
	0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C, 0x1EE7E, 0x1EE7E,
	0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3, 0x1EEA5, 0x1EEA9,
	0x1EEAB, 0x1EEBB, 0x20000, 0x2A6D6, 0x2A700, 0x2B734, 0x2B740, 0x2B81D,
	0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0, 0x2F800, 0x2FA1D, 0xE0100, 0xE01EF,
	//  #90 (14037+616): bp=XID_Start:XIDS
	0x0041, 0x005A, 0x0061, 0x007A, 0x00AA, 0x00AA, 0x00B5, 0x00B5,
	0x00BA, 0x00BA, 0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x02C1,
	0x02C6, 0x02D1, 0x02E0, 0x02E4, 0x02EC, 0x02EC, 0x02EE, 0x02EE,
	0x0370, 0x0374, 0x0376, 0x0377, 0x037B, 0x037D, 0x037F, 0x037F,
	0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x03A1,
	0x03A3, 0x03F5, 0x03F7, 0x0481, 0x048A, 0x052F, 0x0531, 0x0556,
	0x0559, 0x0559, 0x0560, 0x0588, 0x05D0, 0x05EA, 0x05EF, 0x05F2,
	0x0620, 0x064A, 0x066E, 0x066F, 0x0671, 0x06D3, 0x06D5, 0x06D5,
	0x06E5, 0x06E6, 0x06EE, 0x06EF, 0x06FA, 0x06FC, 0x06FF, 0x06FF,
	0x0710, 0x0710, 0x0712, 0x072F, 0x074D, 0x07A5, 0x07B1, 0x07B1,
	0x07CA, 0x07EA, 0x07F4, 0x07F5, 0x07FA, 0x07FA, 0x0800, 0x0815,
	0x081A, 0x081A, 0x0824, 0x0824, 0x0828, 0x0828, 0x0840, 0x0858,
	0x0860, 0x086A, 0x08A0, 0x08B4, 0x08B6, 0x08BD, 0x0904, 0x0939,
	0x093D, 0x093D, 0x0950, 0x0950, 0x0958, 0x0961, 0x0971, 0x0980,
	0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8, 0x09AA, 0x09B0,
	0x09B2, 0x09B2, 0x09B6, 0x09B9, 0x09BD, 0x09BD, 0x09CE, 0x09CE,
	0x09DC, 0x09DD, 0x09DF, 0x09E1, 0x09F0, 0x09F1, 0x09FC, 0x09FC,
	0x0A05, 0x0A0A, 0x0A0F, 0x0A10, 0x0A13, 0x0A28, 0x0A2A, 0x0A30,
	0x0A32, 0x0A33, 0x0A35, 0x0A36, 0x0A38, 0x0A39, 0x0A59, 0x0A5C,
	0x0A5E, 0x0A5E, 0x0A72, 0x0A74, 0x0A85, 0x0A8D, 0x0A8F, 0x0A91,
	0x0A93, 0x0AA8, 0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9,
	0x0ABD, 0x0ABD, 0x0AD0, 0x0AD0, 0x0AE0, 0x0AE1, 0x0AF9, 0x0AF9,
	0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28, 0x0B2A, 0x0B30,
	0x0B32, 0x0B33, 0x0B35, 0x0B39, 0x0B3D, 0x0B3D, 0x0B5C, 0x0B5D,
	0x0B5F, 0x0B61, 0x0B71, 0x0B71, 0x0B83, 0x0B83, 0x0B85, 0x0B8A,
	0x0B8E, 0x0B90, 0x0B92, 0x0B95, 0x0B99, 0x0B9A, 0x0B9C, 0x0B9C,
	0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9,
	0x0BD0, 0x0BD0, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10, 0x0C12, 0x0C28,
	0x0C2A, 0x0C39, 0x0C3D, 0x0C3D, 0x0C58, 0x0C5A, 0x0C60, 0x0C61,
	0x0C80, 0x0C80, 0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8,
	0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBD, 0x0CBD, 0x0CDE, 0x0CDE,
	0x0CE0, 0x0CE1, 0x0CF1, 0x0CF2, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10,
	0x0D12, 0x0D3A, 0x0D3D, 0x0D3D, 0x0D4E, 0x0D4E, 0x0D54, 0x0D56,
	0x0D5F, 0x0D61, 0x0D7A, 0x0D7F, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1,
	0x0DB3, 0x0DBB, 0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0E01, 0x0E30,
	0x0E32, 0x0E32, 0x0E40, 0x0E46, 0x0E81, 0x0E82, 0x0E84, 0x0E84,
	0x0E86, 0x0E8A, 0x0E8C, 0x0EA3, 0x0EA5, 0x0EA5, 0x0EA7, 0x0EB0,
	0x0EB2, 0x0EB2, 0x0EBD, 0x0EBD, 0x0EC0, 0x0EC4, 0x0EC6, 0x0EC6,
	0x0EDC, 0x0EDF, 0x0F00, 0x0F00, 0x0F40, 0x0F47, 0x0F49, 0x0F6C,
	0x0F88, 0x0F8C, 0x1000, 0x102A, 0x103F, 0x103F, 0x1050, 0x1055,
	0x105A, 0x105D, 0x1061, 0x1061, 0x1065, 0x1066, 0x106E, 0x1070,
	0x1075, 0x1081, 0x108E, 0x108E, 0x10A0, 0x10C5, 0x10C7, 0x10C7,
	0x10CD, 0x10CD, 0x10D0, 0x10FA, 0x10FC, 0x1248, 0x124A, 0x124D,
	0x1250, 0x1256, 0x1258, 0x1258, 0x125A, 0x125D, 0x1260, 0x1288,
	0x128A, 0x128D, 0x1290, 0x12B0, 0x12B2, 0x12B5, 0x12B8, 0x12BE,
	0x12C0, 0x12C0, 0x12C2, 0x12C5, 0x12C8, 0x12D6, 0x12D8, 0x1310,
	0x1312, 0x1315, 0x1318, 0x135A, 0x1380, 0x138F, 0x13A0, 0x13F5,
	0x13F8, 0x13FD, 0x1401, 0x166C, 0x166F, 0x167F, 0x1681, 0x169A,
	0x16A0, 0x16EA, 0x16EE, 0x16F8, 0x1700, 0x170C, 0x170E, 0x1711,
	0x1720, 0x1731, 0x1740, 0x1751, 0x1760, 0x176C, 0x176E, 0x1770,
	0x1780, 0x17B3, 0x17D7, 0x17D7, 0x17DC, 0x17DC, 0x1820, 0x1878,
	0x1880, 0x18A8, 0x18AA, 0x18AA, 0x18B0, 0x18F5, 0x1900, 0x191E,
	0x1950, 0x196D, 0x1970, 0x1974, 0x1980, 0x19AB, 0x19B0, 0x19C9,
	0x1A00, 0x1A16, 0x1A20, 0x1A54, 0x1AA7, 0x1AA7, 0x1B05, 0x1B33,
	0x1B45, 0x1B4B, 0x1B83, 0x1BA0, 0x1BAE, 0x1BAF, 0x1BBA, 0x1BE5,
	0x1C00, 0x1C23, 0x1C4D, 0x1C4F, 0x1C5A, 0x1C7D, 0x1C80, 0x1C88,
	0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x1CE9, 0x1CEC, 0x1CEE, 0x1CF3,
	0x1CF5, 0x1CF6, 0x1CFA, 0x1CFA, 0x1D00, 0x1DBF, 0x1E00, 0x1F15,
	0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57,
	0x1F59, 0x1F59, 0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D,
	0x1F80, 0x1FB4, 0x1FB6, 0x1FBC, 0x1FBE, 0x1FBE, 0x1FC2, 0x1FC4,
	0x1FC6, 0x1FCC, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC,
	0x1FF2, 0x1FF4, 0x1FF6, 0x1FFC, 0x2071, 0x2071, 0x207F, 0x207F,
	0x2090, 0x209C, 0x2102, 0x2102, 0x2107, 0x2107, 0x210A, 0x2113,
	0x2115, 0x2115, 0x2118, 0x211D, 0x2124, 0x2124, 0x2126, 0x2126,
	0x2128, 0x2128, 0x212A, 0x2139, 0x213C, 0x213F, 0x2145, 0x2149,
	0x214E, 0x214E, 0x2160, 0x2188, 0x2C00, 0x2C2E, 0x2C30, 0x2C5E,
	0x2C60, 0x2CE4, 0x2CEB, 0x2CEE, 0x2CF2, 0x2CF3, 0x2D00, 0x2D25,
	0x2D27, 0x2D27, 0x2D2D, 0x2D2D, 0x2D30, 0x2D67, 0x2D6F, 0x2D6F,
	0x2D80, 0x2D96, 0x2DA0, 0x2DA6, 0x2DA8, 0x2DAE, 0x2DB0, 0x2DB6,
	0x2DB8, 0x2DBE, 0x2DC0, 0x2DC6, 0x2DC8, 0x2DCE, 0x2DD0, 0x2DD6,
	0x2DD8, 0x2DDE, 0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035,
	0x3038, 0x303C, 0x3041, 0x3096, 0x309D, 0x309F, 0x30A1, 0x30FA,
	0x30FC, 0x30FF, 0x3105, 0x312F, 0x3131, 0x318E, 0x31A0, 0x31BA,
	0x31F0, 0x31FF, 0x3400, 0x4DB5, 0x4E00, 0x9FEF, 0xA000, 0xA48C,
	0xA4D0, 0xA4FD, 0xA500, 0xA60C, 0xA610, 0xA61F, 0xA62A, 0xA62B,
	0xA640, 0xA66E, 0xA67F, 0xA69D, 0xA6A0, 0xA6EF, 0xA717, 0xA71F,
	0xA722, 0xA788, 0xA78B, 0xA7BF, 0xA7C2, 0xA7C6, 0xA7F7, 0xA801,
	0xA803, 0xA805, 0xA807, 0xA80A, 0xA80C, 0xA822, 0xA840, 0xA873,
	0xA882, 0xA8B3, 0xA8F2, 0xA8F7, 0xA8FB, 0xA8FB, 0xA8FD, 0xA8FE,
	0xA90A, 0xA925, 0xA930, 0xA946, 0xA960, 0xA97C, 0xA984, 0xA9B2,
	0xA9CF, 0xA9CF, 0xA9E0, 0xA9E4, 0xA9E6, 0xA9EF, 0xA9FA, 0xA9FE,
	0xAA00, 0xAA28, 0xAA40, 0xAA42, 0xAA44, 0xAA4B, 0xAA60, 0xAA76,
	0xAA7A, 0xAA7A, 0xAA7E, 0xAAAF, 0xAAB1, 0xAAB1, 0xAAB5, 0xAAB6,
	0xAAB9, 0xAABD, 0xAAC0, 0xAAC0, 0xAAC2, 0xAAC2, 0xAADB, 0xAADD,
	0xAAE0, 0xAAEA, 0xAAF2, 0xAAF4, 0xAB01, 0xAB06, 0xAB09, 0xAB0E,
	0xAB11, 0xAB16, 0xAB20, 0xAB26, 0xAB28, 0xAB2E, 0xAB30, 0xAB5A,
	0xAB5C, 0xAB67, 0xAB70, 0xABE2, 0xAC00, 0xD7A3, 0xD7B0, 0xD7C6,
	0xD7CB, 0xD7FB, 0xF900, 0xFA6D, 0xFA70, 0xFAD9, 0xFB00, 0xFB06,
	0xFB13, 0xFB17, 0xFB1D, 0xFB1D, 0xFB1F, 0xFB28, 0xFB2A, 0xFB36,
	0xFB38, 0xFB3C, 0xFB3E, 0xFB3E, 0xFB40, 0xFB41, 0xFB43, 0xFB44,
	0xFB46, 0xFBB1, 0xFBD3, 0xFC5D, 0xFC64, 0xFD3D, 0xFD50, 0xFD8F,
	0xFD92, 0xFDC7, 0xFDF0, 0xFDF9, 0xFE71, 0xFE71, 0xFE73, 0xFE73,
	0xFE77, 0xFE77, 0xFE79, 0xFE79, 0xFE7B, 0xFE7B, 0xFE7D, 0xFE7D,
	0xFE7F, 0xFEFC, 0xFF21, 0xFF3A, 0xFF41, 0xFF5A, 0xFF66, 0xFF9D,
	0xFFA0, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF, 0xFFD2, 0xFFD7,
	0xFFDA, 0xFFDC, 0x10000, 0x1000B, 0x1000D, 0x10026, 0x10028, 0x1003A,
	0x1003C, 0x1003D, 0x1003F, 0x1004D, 0x10050, 0x1005D, 0x10080, 0x100FA,
	0x10140, 0x10174, 0x10280, 0x1029C, 0x102A0, 0x102D0, 0x10300, 0x1031F,
	0x1032D, 0x1034A, 0x10350, 0x10375, 0x10380, 0x1039D, 0x103A0, 0x103C3,
	0x103C8, 0x103CF, 0x103D1, 0x103D5, 0x10400, 0x1049D, 0x104B0, 0x104D3,
	0x104D8, 0x104FB, 0x10500, 0x10527, 0x10530, 0x10563, 0x10600, 0x10736,
	0x10740, 0x10755, 0x10760, 0x10767, 0x10800, 0x10805, 0x10808, 0x10808,
	0x1080A, 0x10835, 0x10837, 0x10838, 0x1083C, 0x1083C, 0x1083F, 0x10855,
	0x10860, 0x10876, 0x10880, 0x1089E, 0x108E0, 0x108F2, 0x108F4, 0x108F5,
	0x10900, 0x10915, 0x10920, 0x10939, 0x10980, 0x109B7, 0x109BE, 0x109BF,
	0x10A00, 0x10A00, 0x10A10, 0x10A13, 0x10A15, 0x10A17, 0x10A19, 0x10A35,
	0x10A60, 0x10A7C, 0x10A80, 0x10A9C, 0x10AC0, 0x10AC7, 0x10AC9, 0x10AE4,
	0x10B00, 0x10B35, 0x10B40, 0x10B55, 0x10B60, 0x10B72, 0x10B80, 0x10B91,
	0x10C00, 0x10C48, 0x10C80, 0x10CB2, 0x10CC0, 0x10CF2, 0x10D00, 0x10D23,
	0x10F00, 0x10F1C, 0x10F27, 0x10F27, 0x10F30, 0x10F45, 0x10FE0, 0x10FF6,
	0x11003, 0x11037, 0x11083, 0x110AF, 0x110D0, 0x110E8, 0x11103, 0x11126,
	0x11144, 0x11144, 0x11150, 0x11172, 0x11176, 0x11176, 0x11183, 0x111B2,
	0x111C1, 0x111C4, 0x111DA, 0x111DA, 0x111DC, 0x111DC, 0x11200, 0x11211,
	0x11213, 0x1122B, 0x11280, 0x11286, 0x11288, 0x11288, 0x1128A, 0x1128D,
	0x1128F, 0x1129D, 0x1129F, 0x112A8, 0x112B0, 0x112DE, 0x11305, 0x1130C,
	0x1130F, 0x11310, 0x11313, 0x11328, 0x1132A, 0x11330, 0x11332, 0x11333,
	0x11335, 0x11339, 0x1133D, 0x1133D, 0x11350, 0x11350, 0x1135D, 0x11361,
	0x11400, 0x11434, 0x11447, 0x1144A, 0x1145F, 0x1145F, 0x11480, 0x114AF,
	0x114C4, 0x114C5, 0x114C7, 0x114C7, 0x11580, 0x115AE, 0x115D8, 0x115DB,
	0x11600, 0x1162F, 0x11644, 0x11644, 0x11680, 0x116AA, 0x116B8, 0x116B8,
	0x11700, 0x1171A, 0x11800, 0x1182B, 0x118A0, 0x118DF, 0x118FF, 0x118FF,
	0x119A0, 0x119A7, 0x119AA, 0x119D0, 0x119E1, 0x119E1, 0x119E3, 0x119E3,
	0x11A00, 0x11A00, 0x11A0B, 0x11A32, 0x11A3A, 0x11A3A, 0x11A50, 0x11A50,
	0x11A5C, 0x11A89, 0x11A9D, 0x11A9D, 0x11AC0, 0x11AF8, 0x11C00, 0x11C08,
	0x11C0A, 0x11C2E, 0x11C40, 0x11C40, 0x11C72, 0x11C8F, 0x11D00, 0x11D06,
	0x11D08, 0x11D09, 0x11D0B, 0x11D30, 0x11D46, 0x11D46, 0x11D60, 0x11D65,
	0x11D67, 0x11D68, 0x11D6A, 0x11D89, 0x11D98, 0x11D98, 0x11EE0, 0x11EF2,
	0x12000, 0x12399, 0x12400, 0x1246E, 0x12480, 0x12543, 0x13000, 0x1342E,
	0x14400, 0x14646, 0x16800, 0x16A38, 0x16A40, 0x16A5E, 0x16AD0, 0x16AED,
	0x16B00, 0x16B2F, 0x16B40, 0x16B43, 0x16B63, 0x16B77, 0x16B7D, 0x16B8F,
	0x16E40, 0x16E7F, 0x16F00, 0x16F4A, 0x16F50, 0x16F50, 0x16F93, 0x16F9F,
	0x16FE0, 0x16FE1, 0x16FE3, 0x16FE3, 0x17000, 0x187F7, 0x18800, 0x18AF2,
	0x1B000, 0x1B11E, 0x1B150, 0x1B152, 0x1B164, 0x1B167, 0x1B170, 0x1B2FB,
	0x1BC00, 0x1BC6A, 0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88, 0x1BC90, 0x1BC99,
	0x1D400, 0x1D454, 0x1D456, 0x1D49C, 0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2,
	0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B9, 0x1D4BB, 0x1D4BB,
	0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505, 0x1D507, 0x1D50A, 0x1D50D, 0x1D514,
	0x1D516, 0x1D51C, 0x1D51E, 0x1D539, 0x1D53B, 0x1D53E, 0x1D540, 0x1D544,
	0x1D546, 0x1D546, 0x1D54A, 0x1D550, 0x1D552, 0x1D6A5, 0x1D6A8, 0x1D6C0,
	0x1D6C2, 0x1D6DA, 0x1D6DC, 0x1D6FA, 0x1D6FC, 0x1D714, 0x1D716, 0x1D734,
	0x1D736, 0x1D74E, 0x1D750, 0x1D76E, 0x1D770, 0x1D788, 0x1D78A, 0x1D7A8,
	0x1D7AA, 0x1D7C2, 0x1D7C4, 0x1D7CB, 0x1E100, 0x1E12C, 0x1E137, 0x1E13D,
	0x1E14E, 0x1E14E, 0x1E2C0, 0x1E2EB, 0x1E800, 0x1E8C4, 0x1E900, 0x1E943,
	0x1E94B, 0x1E94B, 0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22,
	0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37,
	0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47,
	0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52,
	0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B,
	0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64,
	0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C,
	0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3,
	0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB, 0x20000, 0x2A6D6, 0x2A700, 0x2B734,
	0x2B740, 0x2B81D, 0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0, 0x2F800, 0x2FA1D,
	//  #91 (14653+77): bp=Extended_Pictographic
	0x00A9, 0x00A9, 0x00AE, 0x00AE, 0x203C, 0x203C, 0x2049, 0x2049,
	0x2122, 0x2122, 0x2139, 0x2139, 0x2194, 0x2199, 0x21A9, 0x21AA,
	0x231A, 0x231B, 0x2328, 0x2328, 0x2388, 0x2388, 0x23CF, 0x23CF,
	0x23E9, 0x23F3, 0x23F8, 0x23FA, 0x24C2, 0x24C2, 0x25AA, 0x25AB,
	0x25B6, 0x25B6, 0x25C0, 0x25C0, 0x25FB, 0x25FE, 0x2600, 0x2605,
	0x2607, 0x2612, 0x2614, 0x2685, 0x2690, 0x2705, 0x2708, 0x2712,
	0x2714, 0x2714, 0x2716, 0x2716, 0x271D, 0x271D, 0x2721, 0x2721,
	0x2728, 0x2728, 0x2733, 0x2734, 0x2744, 0x2744, 0x2747, 0x2747,
	0x274C, 0x274C, 0x274E, 0x274E, 0x2753, 0x2755, 0x2757, 0x2757,
	0x2763, 0x2767, 0x2795, 0x2797, 0x27A1, 0x27A1, 0x27B0, 0x27B0,
	0x27BF, 0x27BF, 0x2934, 0x2935, 0x2B05, 0x2B07, 0x2B1B, 0x2B1C,
	0x2B50, 0x2B50, 0x2B55, 0x2B55, 0x3030, 0x3030, 0x303D, 0x303D,
	0x3297, 0x3297, 0x3299, 0x3299, 0x1F000, 0x1F0FF, 0x1F10D, 0x1F10F,
	0x1F12F, 0x1F12F, 0x1F16C, 0x1F171, 0x1F17E, 0x1F17F, 0x1F18E, 0x1F18E,
	0x1F191, 0x1F19A, 0x1F1AD, 0x1F1E5, 0x1F201, 0x1F20F, 0x1F21A, 0x1F21A,
	0x1F22F, 0x1F22F, 0x1F232, 0x1F23A, 0x1F23C, 0x1F23F, 0x1F249, 0x1F3FA,
	0x1F400, 0x1F53D, 0x1F546, 0x1F64F, 0x1F680, 0x1F6FF, 0x1F774, 0x1F77F,
	0x1F7D5, 0x1F7FF, 0x1F80C, 0x1F80F, 0x1F848, 0x1F84F, 0x1F85A, 0x1F85F,
	0x1F888, 0x1F88F, 0x1F8AE, 0x1F8FF, 0x1F90C, 0x1F93A, 0x1F93C, 0x1F945,
	0x1F947, 0x1FFFD,
	//  #92 (14730+3): sc=Adlam:Adlm
	0x1E900, 0x1E94B, 0x1E950, 0x1E959, 0x1E95E, 0x1E95F,
	//  #93 (14733+3): sc=Ahom:Ahom scx=Ahom:Ahom
	0x11700, 0x1171A, 0x1171D, 0x1172B, 0x11730, 0x1173F,
	//  #94 (14736+1): sc=Anatolian_Hieroglyphs:Hluw scx=Anatolian_Hieroglyphs:Hluw
	0x14400, 0x14646,
	//  #95 (14737+57): sc=Arabic:Arab
	0x0600, 0x0604, 0x0606, 0x060B, 0x060D, 0x061A, 0x061C, 0x061C,
	0x061E, 0x061E, 0x0620, 0x063F, 0x0641, 0x064A, 0x0656, 0x066F,
	0x0671, 0x06DC, 0x06DE, 0x06FF, 0x0750, 0x077F, 0x08A0, 0x08B4,
	0x08B6, 0x08BD, 0x08D3, 0x08E1, 0x08E3, 0x08FF, 0xFB50, 0xFBC1,
	0xFBD3, 0xFD3D, 0xFD50, 0xFD8F, 0xFD92, 0xFDC7, 0xFDF0, 0xFDFD,
	0xFE70, 0xFE74, 0xFE76, 0xFEFC, 0x10E60, 0x10E7E, 0x1EE00, 0x1EE03,
	0x1EE05, 0x1EE1F, 0x1EE21, 0x1EE22, 0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27,
	0x1EE29, 0x1EE32, 0x1EE34, 0x1EE37, 0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B,
	0x1EE42, 0x1EE42, 0x1EE47, 0x1EE47, 0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B,
	0x1EE4D, 0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57,
	0x1EE59, 0x1EE59, 0x1EE5B, 0x1EE5B, 0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F,
	0x1EE61, 0x1EE62, 0x1EE64, 0x1EE64, 0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72,
	0x1EE74, 0x1EE77, 0x1EE79, 0x1EE7C, 0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89,
	0x1EE8B, 0x1EE9B, 0x1EEA1, 0x1EEA3, 0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB,
	0x1EEF0, 0x1EEF1,
	//  #96 (14794+5): sc=Armenian:Armn
	0x0531, 0x0556, 0x0559, 0x0588, 0x058A, 0x058A, 0x058D, 0x058F,
	0xFB13, 0xFB17,
	//  #97 (14799+2): sc=Avestan:Avst scx=Avestan:Avst
	0x10B00, 0x10B35, 0x10B39, 0x10B3F,
	//  #98 (14801+2): sc=Balinese:Bali scx=Balinese:Bali
	0x1B00, 0x1B4B, 0x1B50, 0x1B7C,
	//  #99 (14803+2): sc=Bamum:Bamu scx=Bamum:Bamu
	0xA6A0, 0xA6F7, 0x16800, 0x16A38,
	//  #100 (14805+2): sc=Bassa_Vah:Bass scx=Bassa_Vah:Bass
	0x16AD0, 0x16AED, 0x16AF0, 0x16AF5,
	//  #101 (14807+2): sc=Batak:Batk scx=Batak:Batk
	0x1BC0, 0x1BF3, 0x1BFC, 0x1BFF,
	//  #102 (14809+14): sc=Bengali:Beng
	0x0980, 0x0983, 0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8,
	0x09AA, 0x09B0, 0x09B2, 0x09B2, 0x09B6, 0x09B9, 0x09BC, 0x09C4,
	0x09C7, 0x09C8, 0x09CB, 0x09CE, 0x09D7, 0x09D7, 0x09DC, 0x09DD,
	0x09DF, 0x09E3, 0x09E6, 0x09FE,
	//  #103 (14823+4): sc=Bhaiksuki:Bhks scx=Bhaiksuki:Bhks
	0x11C00, 0x11C08, 0x11C0A, 0x11C36, 0x11C38, 0x11C45, 0x11C50, 0x11C6C,
	//  #104 (14827+3): sc=Bopomofo:Bopo
	0x02EA, 0x02EB, 0x3105, 0x312F, 0x31A0, 0x31BA,
	//  #105 (14830+3): sc=Brahmi:Brah scx=Brahmi:Brah
	0x11000, 0x1104D, 0x11052, 0x1106F, 0x1107F, 0x1107F,
	//  #106 (14833+1): sc=Braille:Brai scx=Braille:Brai
	0x2800, 0x28FF,
	//  #107 (14834+2): sc=Buginese:Bugi
	0x1A00, 0x1A1B, 0x1A1E, 0x1A1F,
	//  #108 (14836+1): sc=Buhid:Buhd
	0x1740, 0x1753,
	//  #109 (14837+2): sc=Canadian_Aboriginal:Cans scx=Canadian_Aboriginal:Cans
	0x1400, 0x167F, 0x18B0, 0x18F5,
	//  #110 (14839+1): sc=Carian:Cari scx=Carian:Cari
	0x102A0, 0x102D0,
	//  #111 (14840+2): sc=Caucasian_Albanian:Aghb scx=Caucasian_Albanian:Aghb
	0x10530, 0x10563, 0x1056F, 0x1056F,
	//  #112 (14842+2): sc=Chakma:Cakm
	0x11100, 0x11134, 0x11136, 0x11146,
	//  #113 (14844+4): sc=Cham:Cham scx=Cham:Cham
	0xAA00, 0xAA36, 0xAA40, 0xAA4D, 0xAA50, 0xAA59, 0xAA5C, 0xAA5F,
	//  #114 (14848+3): sc=Cherokee:Cher scx=Cherokee:Cher
	0x13A0, 0x13F5, 0x13F8, 0x13FD, 0xAB70, 0xABBF,
	//  #115 (14851+172): sc=Common:Zyyy
	0x0000, 0x0040, 0x005B, 0x0060, 0x007B, 0x00A9, 0x00AB, 0x00B9,
	0x00BB, 0x00BF, 0x00D7, 0x00D7, 0x00F7, 0x00F7, 0x02B9, 0x02DF,
	0x02E5, 0x02E9, 0x02EC, 0x02FF, 0x0374, 0x0374, 0x037E, 0x037E,
	0x0385, 0x0385, 0x0387, 0x0387, 0x0589, 0x0589, 0x0605, 0x0605,
	0x060C, 0x060C, 0x061B, 0x061B, 0x061F, 0x061F, 0x0640, 0x0640,
	0x06DD, 0x06DD, 0x08E2, 0x08E2, 0x0964, 0x0965, 0x0E3F, 0x0E3F,
	0x0FD5, 0x0FD8, 0x10FB, 0x10FB, 0x16EB, 0x16ED, 0x1735, 0x1736,
	0x1802, 0x1803, 0x1805, 0x1805, 0x1CD3, 0x1CD3, 0x1CE1, 0x1CE1,
	0x1CE9, 0x1CEC, 0x1CEE, 0x1CF3, 0x1CF5, 0x1CF7, 0x1CFA, 0x1CFA,
	0x2000, 0x200B, 0x200E, 0x2064, 0x2066, 0x2070, 0x2074, 0x207E,
	0x2080, 0x208E, 0x20A0, 0x20BF, 0x2100, 0x2125, 0x2127, 0x2129,
	0x212C, 0x2131, 0x2133, 0x214D, 0x214F, 0x215F, 0x2189, 0x218B,
	0x2190, 0x2426, 0x2440, 0x244A, 0x2460, 0x27FF, 0x2900, 0x2B73,
	0x2B76, 0x2B95, 0x2B98, 0x2BFF, 0x2E00, 0x2E4F, 0x2FF0, 0x2FFB,
	0x3000, 0x3004, 0x3006, 0x3006, 0x3008, 0x3020, 0x3030, 0x3037,
	0x303C, 0x303F, 0x309B, 0x309C, 0x30A0, 0x30A0, 0x30FB, 0x30FC,
	0x3190, 0x319F, 0x31C0, 0x31E3, 0x3220, 0x325F, 0x327F, 0x32CF,
	0x32FF, 0x32FF, 0x3358, 0x33FF, 0x4DC0, 0x4DFF, 0xA700, 0xA721,
	0xA788, 0xA78A, 0xA830, 0xA839, 0xA92E, 0xA92E, 0xA9CF, 0xA9CF,
	0xAB5B, 0xAB5B, 0xFD3E, 0xFD3F, 0xFE10, 0xFE19, 0xFE30, 0xFE52,
	0xFE54, 0xFE66, 0xFE68, 0xFE6B, 0xFEFF, 0xFEFF, 0xFF01, 0xFF20,
	0xFF3B, 0xFF40, 0xFF5B, 0xFF65, 0xFF70, 0xFF70, 0xFF9E, 0xFF9F,
	0xFFE0, 0xFFE6, 0xFFE8, 0xFFEE, 0xFFF9, 0xFFFD, 0x10100, 0x10102,
	0x10107, 0x10133, 0x10137, 0x1013F, 0x10190, 0x1019B, 0x101D0, 0x101FC,
	0x102E1, 0x102FB, 0x16FE2, 0x16FE3, 0x1BCA0, 0x1BCA3, 0x1D000, 0x1D0F5,
	0x1D100, 0x1D126, 0x1D129, 0x1D166, 0x1D16A, 0x1D17A, 0x1D183, 0x1D184,
	0x1D18C, 0x1D1A9, 0x1D1AE, 0x1D1E8, 0x1D2E0, 0x1D2F3, 0x1D300, 0x1D356,
	0x1D360, 0x1D378, 0x1D400, 0x1D454, 0x1D456, 0x1D49C, 0x1D49E, 0x1D49F,
	0x1D4A2, 0x1D4A2, 0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B9,
	0x1D4BB, 0x1D4BB, 0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505, 0x1D507, 0x1D50A,
	0x1D50D, 0x1D514, 0x1D516, 0x1D51C, 0x1D51E, 0x1D539, 0x1D53B, 0x1D53E,
	0x1D540, 0x1D544, 0x1D546, 0x1D546, 0x1D54A, 0x1D550, 0x1D552, 0x1D6A5,
	0x1D6A8, 0x1D7CB, 0x1D7CE, 0x1D7FF, 0x1EC71, 0x1ECB4, 0x1ED01, 0x1ED3D,
	0x1F000, 0x1F02B, 0x1F030, 0x1F093, 0x1F0A0, 0x1F0AE, 0x1F0B1, 0x1F0BF,
	0x1F0C1, 0x1F0CF, 0x1F0D1, 0x1F0F5, 0x1F100, 0x1F10C, 0x1F110, 0x1F16C,
	0x1F170, 0x1F1AC, 0x1F1E6, 0x1F1FF, 0x1F201, 0x1F202, 0x1F210, 0x1F23B,
	0x1F240, 0x1F248, 0x1F250, 0x1F251, 0x1F260, 0x1F265, 0x1F300, 0x1F6D5,
	0x1F6E0, 0x1F6EC, 0x1F6F0, 0x1F6FA, 0x1F700, 0x1F773, 0x1F780, 0x1F7D8,
	0x1F7E0, 0x1F7EB, 0x1F800, 0x1F80B, 0x1F810, 0x1F847, 0x1F850, 0x1F859,
	0x1F860, 0x1F887, 0x1F890, 0x1F8AD, 0x1F900, 0x1F90B, 0x1F90D, 0x1F971,
	0x1F973, 0x1F976, 0x1F97A, 0x1F9A2, 0x1F9A5, 0x1F9AA, 0x1F9AE, 0x1F9CA,
	0x1F9CD, 0x1FA53, 0x1FA60, 0x1FA6D, 0x1FA70, 0x1FA73, 0x1FA78, 0x1FA7A,
	0x1FA80, 0x1FA82, 0x1FA90, 0x1FA95, 0xE0001, 0xE0001, 0xE0020, 0xE007F,
	//  #116 (15023+3): sc=Coptic:Copt:Qaac
	0x03E2, 0x03EF, 0x2C80, 0x2CF3, 0x2CF9, 0x2CFF,
	//  #117 (15026+4): sc=Cuneiform:Xsux scx=Cuneiform:Xsux
	0x12000, 0x12399, 0x12400, 0x1246E, 0x12470, 0x12474, 0x12480, 0x12543,
	//  #118 (15030+6): sc=Cypriot:Cprt
	0x10800, 0x10805, 0x10808, 0x10808, 0x1080A, 0x10835, 0x10837, 0x10838,
	0x1083C, 0x1083C, 0x1083F, 0x1083F,
	//  #119 (15036+8): sc=Cyrillic:Cyrl
	0x0400, 0x0484, 0x0487, 0x052F, 0x1C80, 0x1C88, 0x1D2B, 0x1D2B,
	0x1D78, 0x1D78, 0x2DE0, 0x2DFF, 0xA640, 0xA69F, 0xFE2E, 0xFE2F,
	//  #120 (15044+1): sc=Deseret:Dsrt scx=Deseret:Dsrt
	0x10400, 0x1044F,
	//  #121 (15045+4): sc=Devanagari:Deva
	0x0900, 0x0950, 0x0955, 0x0963, 0x0966, 0x097F, 0xA8E0, 0xA8FF,
	//  #122 (15049+5): sc=Duployan:Dupl
	0x1BC00, 0x1BC6A, 0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88, 0x1BC90, 0x1BC99,
	0x1BC9C, 0x1BC9F,
	//  #123 (15054+2): sc=Egyptian_Hieroglyphs:Egyp scx=Egyptian_Hieroglyphs:Egyp
	0x13000, 0x1342E, 0x13430, 0x13438,
	//  #124 (15056+1): sc=Elbasan:Elba scx=Elbasan:Elba
	0x10500, 0x10527,
	//  #125 (15057+32): sc=Ethiopic:Ethi scx=Ethiopic:Ethi
	0x1200, 0x1248, 0x124A, 0x124D, 0x1250, 0x1256, 0x1258, 0x1258,
	0x125A, 0x125D, 0x1260, 0x1288, 0x128A, 0x128D, 0x1290, 0x12B0,
	0x12B2, 0x12B5, 0x12B8, 0x12BE, 0x12C0, 0x12C0, 0x12C2, 0x12C5,
	0x12C8, 0x12D6, 0x12D8, 0x1310, 0x1312, 0x1315, 0x1318, 0x135A,
	0x135D, 0x137C, 0x1380, 0x1399, 0x2D80, 0x2D96, 0x2DA0, 0x2DA6,
	0x2DA8, 0x2DAE, 0x2DB0, 0x2DB6, 0x2DB8, 0x2DBE, 0x2DC0, 0x2DC6,
	0x2DC8, 0x2DCE, 0x2DD0, 0x2DD6, 0x2DD8, 0x2DDE, 0xAB01, 0xAB06,
	0xAB09, 0xAB0E, 0xAB11, 0xAB16, 0xAB20, 0xAB26, 0xAB28, 0xAB2E,
	//  #126 (15089+10): sc=Georgian:Geor
	0x10A0, 0x10C5, 0x10C7, 0x10C7, 0x10CD, 0x10CD, 0x10D0, 0x10FA,
	0x10FC, 0x10FF, 0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x2D00, 0x2D25,
	0x2D27, 0x2D27, 0x2D2D, 0x2D2D,
	//  #127 (15099+7): sc=Glagolitic:Glag
	0x2C00, 0x2C2E, 0x2C30, 0x2C5E, 0x1E000, 0x1E006, 0x1E008, 0x1E018,
	0x1E01B, 0x1E021, 0x1E023, 0x1E024, 0x1E026, 0x1E02A,
	//  #128 (15106+1): sc=Gothic:Goth scx=Gothic:Goth
	0x10330, 0x1034A,
	//  #129 (15107+15): sc=Grantha:Gran
	0x11300, 0x11303, 0x11305, 0x1130C, 0x1130F, 0x11310, 0x11313, 0x11328,
	0x1132A, 0x11330, 0x11332, 0x11333, 0x11335, 0x11339, 0x1133C, 0x11344,
	0x11347, 0x11348, 0x1134B, 0x1134D, 0x11350, 0x11350, 0x11357, 0x11357,
	0x1135D, 0x11363, 0x11366, 0x1136C, 0x11370, 0x11374,
	//  #130 (15122+36): sc=Greek:Grek
	0x0370, 0x0373, 0x0375, 0x0377, 0x037A, 0x037D, 0x037F, 0x037F,
	0x0384, 0x0384, 0x0386, 0x0386, 0x0388, 0x038A, 0x038C, 0x038C,
	0x038E, 0x03A1, 0x03A3, 0x03E1, 0x03F0, 0x03FF, 0x1D26, 0x1D2A,
	0x1D5D, 0x1D61, 0x1D66, 0x1D6A, 0x1DBF, 0x1DBF, 0x1F00, 0x1F15,
	0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57,
	0x1F59, 0x1F59, 0x1F5B, 0x1F5B, 0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D,
	0x1F80, 0x1FB4, 0x1FB6, 0x1FC4, 0x1FC6, 0x1FD3, 0x1FD6, 0x1FDB,
	0x1FDD, 0x1FEF, 0x1FF2, 0x1FF4, 0x1FF6, 0x1FFE, 0x2126, 0x2126,
	0xAB65, 0xAB65, 0x10140, 0x1018E, 0x101A0, 0x101A0, 0x1D200, 0x1D245,
	//  #131 (15158+14): sc=Gujarati:Gujr
	0x0A81, 0x0A83, 0x0A85, 0x0A8D, 0x0A8F, 0x0A91, 0x0A93, 0x0AA8,
	0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9, 0x0ABC, 0x0AC5,
	0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD, 0x0AD0, 0x0AD0, 0x0AE0, 0x0AE3,
	0x0AE6, 0x0AF1, 0x0AF9, 0x0AFF,
	//  #132 (15172+16): sc=Gurmukhi:Guru
	0x0A01, 0x0A03, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10, 0x0A13, 0x0A28,
	0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36, 0x0A38, 0x0A39,
	0x0A3C, 0x0A3C, 0x0A3E, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4D,
	0x0A51, 0x0A51, 0x0A59, 0x0A5C, 0x0A5E, 0x0A5E, 0x0A66, 0x0A76,
	//  #133 (15188+17): sc=Han:Hani
	0x2E80, 0x2E99, 0x2E9B, 0x2EF3, 0x2F00, 0x2FD5, 0x3005, 0x3005,
	0x3007, 0x3007, 0x3021, 0x3029, 0x3038, 0x303B, 0x3400, 0x4DB5,
	0x4E00, 0x9FEF, 0xF900, 0xFA6D, 0xFA70, 0xFAD9, 0x20000, 0x2A6D6,
	0x2A700, 0x2B734, 0x2B740, 0x2B81D, 0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0,
	0x2F800, 0x2FA1D,
	//  #134 (15205+14): sc=Hangul:Hang
	0x1100, 0x11FF, 0x302E, 0x302F, 0x3131, 0x318E, 0x3200, 0x321E,
	0x3260, 0x327E, 0xA960, 0xA97C, 0xAC00, 0xD7A3, 0xD7B0, 0xD7C6,
	0xD7CB, 0xD7FB, 0xFFA0, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF,
	0xFFD2, 0xFFD7, 0xFFDA, 0xFFDC,
	//  #135 (15219+1): sc=Hanunoo:Hano
	0x1720, 0x1734,
	//  #136 (15220+3): sc=Hatran:Hatr scx=Hatran:Hatr
	0x108E0, 0x108F2, 0x108F4, 0x108F5, 0x108FB, 0x108FF,
	//  #137 (15223+9): sc=Hebrew:Hebr scx=Hebrew:Hebr
	0x0591, 0x05C7, 0x05D0, 0x05EA, 0x05EF, 0x05F4, 0xFB1D, 0xFB36,
	0xFB38, 0xFB3C, 0xFB3E, 0xFB3E, 0xFB40, 0xFB41, 0xFB43, 0xFB44,
	0xFB46, 0xFB4F,
	//  #138 (15232+5): sc=Hiragana:Hira
	0x3041, 0x3096, 0x309D, 0x309F, 0x1B001, 0x1B11E, 0x1B150, 0x1B152,
	0x1F200, 0x1F200,
	//  #139 (15237+2): sc=Imperial_Aramaic:Armi scx=Imperial_Aramaic:Armi
	0x10840, 0x10855, 0x10857, 0x1085F,
	//  #140 (15239+28): sc=Inherited:Zinh:Qaai
	0x0300, 0x036F, 0x0485, 0x0486, 0x064B, 0x0655, 0x0670, 0x0670,
	0x0951, 0x0954, 0x1AB0, 0x1ABE, 0x1CD0, 0x1CD2, 0x1CD4, 0x1CE0,
	0x1CE2, 0x1CE8, 0x1CED, 0x1CED, 0x1CF4, 0x1CF4, 0x1CF8, 0x1CF9,
	0x1DC0, 0x1DF9, 0x1DFB, 0x1DFF, 0x200C, 0x200D, 0x20D0, 0x20F0,
	0x302A, 0x302D, 0x3099, 0x309A, 0xFE00, 0xFE0F, 0xFE20, 0xFE2D,
	0x101FD, 0x101FD, 0x102E0, 0x102E0, 0x1133B, 0x1133B, 0x1D167, 0x1D169,
	0x1D17B, 0x1D182, 0x1D185, 0x1D18B, 0x1D1AA, 0x1D1AD, 0xE0100, 0xE01EF,
	//  #141 (15267+2): sc=Inscriptional_Pahlavi:Phli scx=Inscriptional_Pahlavi:Phli
	0x10B60, 0x10B72, 0x10B78, 0x10B7F,
	//  #142 (15269+2): sc=Inscriptional_Parthian:Prti scx=Inscriptional_Parthian:Prti
	0x10B40, 0x10B55, 0x10B58, 0x10B5F,
	//  #143 (15271+3): sc=Javanese:Java
	0xA980, 0xA9CD, 0xA9D0, 0xA9D9, 0xA9DE, 0xA9DF,
	//  #144 (15274+2): sc=Kaithi:Kthi
	0x11080, 0x110C1, 0x110CD, 0x110CD,
	//  #145 (15276+13): sc=Kannada:Knda
	0x0C80, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8, 0x0CAA, 0x0CB3,
	0x0CB5, 0x0CB9, 0x0CBC, 0x0CC4, 0x0CC6, 0x0CC8, 0x0CCA, 0x0CCD,
	0x0CD5, 0x0CD6, 0x0CDE, 0x0CDE, 0x0CE0, 0x0CE3, 0x0CE6, 0x0CEF,
	0x0CF1, 0x0CF2,
	//  #146 (15289+9): sc=Katakana:Kana
	0x30A1, 0x30FA, 0x30FD, 0x30FF, 0x31F0, 0x31FF, 0x32D0, 0x32FE,
	0x3300, 0x3357, 0xFF66, 0xFF6F, 0xFF71, 0xFF9D, 0x1B000, 0x1B000,
	0x1B164, 0x1B167,
	//  #147 (15298+2): sc=Kayah_Li:Kali
	0xA900, 0xA92D, 0xA92F, 0xA92F,
	//  #148 (15300+8): sc=Kharoshthi:Khar scx=Kharoshthi:Khar
	0x10A00, 0x10A03, 0x10A05, 0x10A06, 0x10A0C, 0x10A13, 0x10A15, 0x10A17,
	0x10A19, 0x10A35, 0x10A38, 0x10A3A, 0x10A3F, 0x10A48, 0x10A50, 0x10A58,
	//  #149 (15308+4): sc=Khmer:Khmr scx=Khmer:Khmr
	0x1780, 0x17DD, 0x17E0, 0x17E9, 0x17F0, 0x17F9, 0x19E0, 0x19FF,
	//  #150 (15312+2): sc=Khojki:Khoj
	0x11200, 0x11211, 0x11213, 0x1123E,
	//  #151 (15314+2): sc=Khudawadi:Sind
	0x112B0, 0x112EA, 0x112F0, 0x112F9,
	//  #152 (15316+11): sc=Lao:Laoo scx=Lao:Laoo
	0x0E81, 0x0E82, 0x0E84, 0x0E84, 0x0E86, 0x0E8A, 0x0E8C, 0x0EA3,
	0x0EA5, 0x0EA5, 0x0EA7, 0x0EBD, 0x0EC0, 0x0EC4, 0x0EC6, 0x0EC6,
	0x0EC8, 0x0ECD, 0x0ED0, 0x0ED9, 0x0EDC, 0x0EDF,
	//  #153 (15327+32): sc=Latin:Latn
	0x0041, 0x005A, 0x0061, 0x007A, 0x00AA, 0x00AA, 0x00BA, 0x00BA,
	0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x02B8, 0x02E0, 0x02E4,
	0x1D00, 0x1D25, 0x1D2C, 0x1D5C, 0x1D62, 0x1D65, 0x1D6B, 0x1D77,
	0x1D79, 0x1DBE, 0x1E00, 0x1EFF, 0x2071, 0x2071, 0x207F, 0x207F,
	0x2090, 0x209C, 0x212A, 0x212B, 0x2132, 0x2132, 0x214E, 0x214E,
	0x2160, 0x2188, 0x2C60, 0x2C7F, 0xA722, 0xA787, 0xA78B, 0xA7BF,
	0xA7C2, 0xA7C6, 0xA7F7, 0xA7FF, 0xAB30, 0xAB5A, 0xAB5C, 0xAB64,
	0xAB66, 0xAB67, 0xFB00, 0xFB06, 0xFF21, 0xFF3A, 0xFF41, 0xFF5A,
	//  #154 (15359+3): sc=Lepcha:Lepc scx=Lepcha:Lepc
	0x1C00, 0x1C37, 0x1C3B, 0x1C49, 0x1C4D, 0x1C4F,
	//  #155 (15362+5): sc=Limbu:Limb
	0x1900, 0x191E, 0x1920, 0x192B, 0x1930, 0x193B, 0x1940, 0x1940,
	0x1944, 0x194F,
	//  #156 (15367+3): sc=Linear_A:Lina
	0x10600, 0x10736, 0x10740, 0x10755, 0x10760, 0x10767,
	//  #157 (15370+7): sc=Linear_B:Linb
	0x10000, 0x1000B, 0x1000D, 0x10026, 0x10028, 0x1003A, 0x1003C, 0x1003D,
	0x1003F, 0x1004D, 0x10050, 0x1005D, 0x10080, 0x100FA,
	//  #158 (15377+1): sc=Lisu:Lisu scx=Lisu:Lisu
	0xA4D0, 0xA4FF,
	//  #159 (15378+1): sc=Lycian:Lyci scx=Lycian:Lyci
	0x10280, 0x1029C,
	//  #160 (15379+2): sc=Lydian:Lydi scx=Lydian:Lydi
	0x10920, 0x10939, 0x1093F, 0x1093F,
	//  #161 (15381+1): sc=Mahajani:Mahj
	0x11150, 0x11176,
	//  #162 (15382+8): sc=Malayalam:Mlym
	0x0D00, 0x0D03, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10, 0x0D12, 0x0D44,
	0x0D46, 0x0D48, 0x0D4A, 0x0D4F, 0x0D54, 0x0D63, 0x0D66, 0x0D7F,
	//  #163 (15390+2): sc=Mandaic:Mand
	0x0840, 0x085B, 0x085E, 0x085E,
	//  #164 (15392+2): sc=Manichaean:Mani
	0x10AC0, 0x10AE6, 0x10AEB, 0x10AF6,
	//  #165 (15394+3): sc=Marchen:Marc scx=Marchen:Marc
	0x11C70, 0x11C8F, 0x11C92, 0x11CA7, 0x11CA9, 0x11CB6,
	//  #166 (15397+7): sc=Masaram_Gondi:Gonm
	0x11D00, 0x11D06, 0x11D08, 0x11D09, 0x11D0B, 0x11D36, 0x11D3A, 0x11D3A,
	0x11D3C, 0x11D3D, 0x11D3F, 0x11D47, 0x11D50, 0x11D59,
	//  #167 (15404+3): sc=Meetei_Mayek:Mtei scx=Meetei_Mayek:Mtei
	0xAAE0, 0xAAF6, 0xABC0, 0xABED, 0xABF0, 0xABF9,
	//  #168 (15407+2): sc=Mende_Kikakui:Mend scx=Mende_Kikakui:Mend
	0x1E800, 0x1E8C4, 0x1E8C7, 0x1E8D6,
	//  #169 (15409+3): sc=Meroitic_Cursive:Merc scx=Meroitic_Cursive:Merc
	0x109A0, 0x109B7, 0x109BC, 0x109CF, 0x109D2, 0x109FF,
	//  #170 (15412+1): sc=Meroitic_Hieroglyphs:Mero scx=Meroitic_Hieroglyphs:Mero
	0x10980, 0x1099F,
	//  #171 (15413+3): sc=Miao:Plrd scx=Miao:Plrd
	0x16F00, 0x16F4A, 0x16F4F, 0x16F87, 0x16F8F, 0x16F9F,
	//  #172 (15416+2): sc=Modi:Modi
	0x11600, 0x11644, 0x11650, 0x11659,
	//  #173 (15418+7): sc=Mongolian:Mong
	0x1800, 0x1801, 0x1804, 0x1804, 0x1806, 0x180E, 0x1810, 0x1819,
	0x1820, 0x1878, 0x1880, 0x18AA, 0x11660, 0x1166C,
	//  #174 (15425+3): sc=Mro:Mroo scx=Mro:Mroo
	0x16A40, 0x16A5E, 0x16A60, 0x16A69, 0x16A6E, 0x16A6F,
	//  #175 (15428+5): sc=Multani:Mult
	0x11280, 0x11286, 0x11288, 0x11288, 0x1128A, 0x1128D, 0x1128F, 0x1129D,
	0x1129F, 0x112A9,
	//  #176 (15433+3): sc=Myanmar:Mymr
	0x1000, 0x109F, 0xA9E0, 0xA9FE, 0xAA60, 0xAA7F,
	//  #177 (15436+2): sc=Nabataean:Nbat scx=Nabataean:Nbat
	0x10880, 0x1089E, 0x108A7, 0x108AF,
	//  #178 (15438+4): sc=New_Tai_Lue:Talu scx=New_Tai_Lue:Talu
	0x1980, 0x19AB, 0x19B0, 0x19C9, 0x19D0, 0x19DA, 0x19DE, 0x19DF,
	//  #179 (15442+3): sc=Newa:Newa scx=Newa:Newa
	0x11400, 0x11459, 0x1145B, 0x1145B, 0x1145D, 0x1145F,
	//  #180 (15445+2): sc=Nko:Nkoo scx=Nko:Nkoo
	0x07C0, 0x07FA, 0x07FD, 0x07FF,
	//  #181 (15447+2): sc=Nushu:Nshu scx=Nushu:Nshu
	0x16FE1, 0x16FE1, 0x1B170, 0x1B2FB,
	//  #182 (15449+1): sc=Ogham:Ogam scx=Ogham:Ogam
	0x1680, 0x169C,
	//  #183 (15450+1): sc=Ol_Chiki:Olck scx=Ol_Chiki:Olck
	0x1C50, 0x1C7F,
	//  #184 (15451+3): sc=Old_Hungarian:Hung scx=Old_Hungarian:Hung
	0x10C80, 0x10CB2, 0x10CC0, 0x10CF2, 0x10CFA, 0x10CFF,
	//  #185 (15454+2): sc=Old_Italic:Ital scx=Old_Italic:Ital
	0x10300, 0x10323, 0x1032D, 0x1032F,
	//  #186 (15456+1): sc=Old_North_Arabian:Narb scx=Old_North_Arabian:Narb
	0x10A80, 0x10A9F,
	//  #187 (15457+1): sc=Old_Permic:Perm
	0x10350, 0x1037A,
	//  #188 (15458+2): sc=Old_Persian:Xpeo scx=Old_Persian:Xpeo
	0x103A0, 0x103C3, 0x103C8, 0x103D5,
	//  #189 (15460+1): sc=Old_South_Arabian:Sarb scx=Old_South_Arabian:Sarb
	0x10A60, 0x10A7F,
	//  #190 (15461+1): sc=Old_Turkic:Orkh scx=Old_Turkic:Orkh
	0x10C00, 0x10C48,
	//  #191 (15462+14): sc=Oriya:Orya
	0x0B01, 0x0B03, 0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28,
	0x0B2A, 0x0B30, 0x0B32, 0x0B33, 0x0B35, 0x0B39, 0x0B3C, 0x0B44,
	0x0B47, 0x0B48, 0x0B4B, 0x0B4D, 0x0B56, 0x0B57, 0x0B5C, 0x0B5D,
	0x0B5F, 0x0B63, 0x0B66, 0x0B77,
	//  #192 (15476+2): sc=Osage:Osge scx=Osage:Osge
	0x104B0, 0x104D3, 0x104D8, 0x104FB,
	//  #193 (15478+2): sc=Osmanya:Osma scx=Osmanya:Osma
	0x10480, 0x1049D, 0x104A0, 0x104A9,
	//  #194 (15480+5): sc=Pahawh_Hmong:Hmng scx=Pahawh_Hmong:Hmng
	0x16B00, 0x16B45, 0x16B50, 0x16B59, 0x16B5B, 0x16B61, 0x16B63, 0x16B77,
	0x16B7D, 0x16B8F,
	//  #195 (15485+1): sc=Palmyrene:Palm scx=Palmyrene:Palm
	0x10860, 0x1087F,
	//  #196 (15486+1): sc=Pau_Cin_Hau:Pauc scx=Pau_Cin_Hau:Pauc
	0x11AC0, 0x11AF8,
	//  #197 (15487+1): sc=Phags_Pa:Phag
	0xA840, 0xA877,
	//  #198 (15488+2): sc=Phoenician:Phnx scx=Phoenician:Phnx
	0x10900, 0x1091B, 0x1091F, 0x1091F,
	//  #199 (15490+3): sc=Psalter_Pahlavi:Phlp
	0x10B80, 0x10B91, 0x10B99, 0x10B9C, 0x10BA9, 0x10BAF,
	//  #200 (15493+2): sc=Rejang:Rjng scx=Rejang:Rjng
	0xA930, 0xA953, 0xA95F, 0xA95F,
	//  #201 (15495+2): sc=Runic:Runr scx=Runic:Runr
	0x16A0, 0x16EA, 0x16EE, 0x16F8,
	//  #202 (15497+2): sc=Samaritan:Samr scx=Samaritan:Samr
	0x0800, 0x082D, 0x0830, 0x083E,
	//  #203 (15499+2): sc=Saurashtra:Saur scx=Saurashtra:Saur
	0xA880, 0xA8C5, 0xA8CE, 0xA8D9,
	//  #204 (15501+2): sc=Sharada:Shrd
	0x11180, 0x111CD, 0x111D0, 0x111DF,
	//  #205 (15503+1): sc=Shavian:Shaw scx=Shavian:Shaw
	0x10450, 0x1047F,
	//  #206 (15504+2): sc=Siddham:Sidd scx=Siddham:Sidd
	0x11580, 0x115B5, 0x115B8, 0x115DD,
	//  #207 (15506+3): sc=SignWriting:Sgnw scx=SignWriting:Sgnw
	0x1D800, 0x1DA8B, 0x1DA9B, 0x1DA9F, 0x1DAA1, 0x1DAAF,
	//  #208 (15509+13): sc=Sinhala:Sinh
	0x0D82, 0x0D83, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1, 0x0DB3, 0x0DBB,
	0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0DCA, 0x0DCA, 0x0DCF, 0x0DD4,
	0x0DD6, 0x0DD6, 0x0DD8, 0x0DDF, 0x0DE6, 0x0DEF, 0x0DF2, 0x0DF4,
	0x111E1, 0x111F4,
	//  #209 (15522+2): sc=Sora_Sompeng:Sora scx=Sora_Sompeng:Sora
	0x110D0, 0x110E8, 0x110F0, 0x110F9,
	//  #210 (15524+1): sc=Soyombo:Soyo scx=Soyombo:Soyo
	0x11A50, 0x11AA2,
	//  #211 (15525+2): sc=Sundanese:Sund scx=Sundanese:Sund
	0x1B80, 0x1BBF, 0x1CC0, 0x1CC7,
	//  #212 (15527+1): sc=Syloti_Nagri:Sylo
	0xA800, 0xA82B,
	//  #213 (15528+4): sc=Syriac:Syrc
	0x0700, 0x070D, 0x070F, 0x074A, 0x074D, 0x074F, 0x0860, 0x086A,
	//  #214 (15532+2): sc=Tagalog:Tglg
	0x1700, 0x170C, 0x170E, 0x1714,
	//  #215 (15534+3): sc=Tagbanwa:Tagb
	0x1760, 0x176C, 0x176E, 0x1770, 0x1772, 0x1773,
	//  #216 (15537+2): sc=Tai_Le:Tale
	0x1950, 0x196D, 0x1970, 0x1974,
	//  #217 (15539+5): sc=Tai_Tham:Lana scx=Tai_Tham:Lana
	0x1A20, 0x1A5E, 0x1A60, 0x1A7C, 0x1A7F, 0x1A89, 0x1A90, 0x1A99,
	0x1AA0, 0x1AAD,
	//  #218 (15544+2): sc=Tai_Viet:Tavt scx=Tai_Viet:Tavt
	0xAA80, 0xAAC2, 0xAADB, 0xAADF,
	//  #219 (15546+2): sc=Takri:Takr
	0x11680, 0x116B8, 0x116C0, 0x116C9,
	//  #220 (15548+18): sc=Tamil:Taml
	0x0B82, 0x0B83, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90, 0x0B92, 0x0B95,
	0x0B99, 0x0B9A, 0x0B9C, 0x0B9C, 0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4,
	0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9, 0x0BBE, 0x0BC2, 0x0BC6, 0x0BC8,
	0x0BCA, 0x0BCD, 0x0BD0, 0x0BD0, 0x0BD7, 0x0BD7, 0x0BE6, 0x0BFA,
	0x11FC0, 0x11FF1, 0x11FFF, 0x11FFF,
	//  #221 (15566+3): sc=Tangut:Tang scx=Tangut:Tang
	0x16FE0, 0x16FE0, 0x17000, 0x187F7, 0x18800, 0x18AF2,
	//  #222 (15569+12): sc=Telugu:Telu
	0x0C00, 0x0C0C, 0x0C0E, 0x0C10, 0x0C12, 0x0C28, 0x0C2A, 0x0C39,
	0x0C3D, 0x0C44, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D, 0x0C55, 0x0C56,
	0x0C58, 0x0C5A, 0x0C60, 0x0C63, 0x0C66, 0x0C6F, 0x0C77, 0x0C7F,
	//  #223 (15581+1): sc=Thaana:Thaa
	0x0780, 0x07B1,
	//  #224 (15582+2): sc=Thai:Thai scx=Thai:Thai
	0x0E01, 0x0E3A, 0x0E40, 0x0E5B,
	//  #225 (15584+7): sc=Tibetan:Tibt scx=Tibetan:Tibt
	0x0F00, 0x0F47, 0x0F49, 0x0F6C, 0x0F71, 0x0F97, 0x0F99, 0x0FBC,
	0x0FBE, 0x0FCC, 0x0FCE, 0x0FD4, 0x0FD9, 0x0FDA,
	//  #226 (15591+3): sc=Tifinagh:Tfng scx=Tifinagh:Tfng
	0x2D30, 0x2D67, 0x2D6F, 0x2D70, 0x2D7F, 0x2D7F,
	//  #227 (15594+2): sc=Tirhuta:Tirh
	0x11480, 0x114C7, 0x114D0, 0x114D9,
	//  #228 (15596+2): sc=Ugaritic:Ugar scx=Ugaritic:Ugar
	0x10380, 0x1039D, 0x1039F, 0x1039F,
	//  #229 (15598+1): sc=Vai:Vaii scx=Vai:Vaii
	0xA500, 0xA62B,
	//  #230 (15599+2): sc=Warang_Citi:Wara scx=Warang_Citi:Wara
	0x118A0, 0x118F2, 0x118FF, 0x118FF,
	//  #231 (15601+2): sc=Yi:Yiii
	0xA000, 0xA48C, 0xA490, 0xA4C6,
	//  #232 (15603+1): sc=Zanabazar_Square:Zanb scx=Zanabazar_Square:Zanb
	0x11A00, 0x11A47,
	//  #233 (15604+1): sc=Dogra:Dogr
	0x11800, 0x1183B,
	//  #234 (15605+6): sc=Gunjala_Gondi:Gong
	0x11D60, 0x11D65, 0x11D67, 0x11D68, 0x11D6A, 0x11D8E, 0x11D90, 0x11D91,
	0x11D93, 0x11D98, 0x11DA0, 0x11DA9,
	//  #235 (15611+2): sc=Hanifi_Rohingya:Rohg
	0x10D00, 0x10D27, 0x10D30, 0x10D39,
	//  #236 (15613+1): sc=Makasar:Maka scx=Makasar:Maka
	0x11EE0, 0x11EF8,
	//  #237 (15614+1): sc=Medefaidrin:Medf scx=Medefaidrin:Medf
	0x16E40, 0x16E9A,
	//  #238 (15615+1): sc=Old_Sogdian:Sogo scx=Old_Sogdian:Sogo
	0x10F00, 0x10F27,
	//  #239 (15616+1): sc=Sogdian:Sogd
	0x10F30, 0x10F59,
	//  #240 (15617+1): sc=Elymaic:Elym scx=Elymaic:Elym
	0x10FE0, 0x10FF6,
	//  #241 (15618+3): sc=Nandinagari:Nand
	0x119A0, 0x119A7, 0x119AA, 0x119D7, 0x119DA, 0x119E4,
	//  #242 (15621+4): sc=Nyiakeng_Puachue_Hmong:Hmnp scx=Nyiakeng_Puachue_Hmong:Hmnp
	0x1E100, 0x1E12C, 0x1E130, 0x1E13D, 0x1E140, 0x1E149, 0x1E14E, 0x1E14F,
	//  #243 (15625+2): sc=Wancho:Wcho scx=Wancho:Wcho
	0x1E2C0, 0x1E2F9, 0x1E2FF, 0x1E2FF,
	//  #244 (15627+4): scx=Adlam:Adlm
	0x0640, 0x0640, 0x1E900, 0x1E94B, 0x1E950, 0x1E959, 0x1E95E, 0x1E95F,
	//  #245 (15631+52): scx=Arabic:Arab
	0x0600, 0x0604, 0x0606, 0x061C, 0x061E, 0x06DC, 0x06DE, 0x06FF,
	0x0750, 0x077F, 0x08A0, 0x08B4, 0x08B6, 0x08BD, 0x08D3, 0x08E1,
	0x08E3, 0x08FF, 0xFB50, 0xFBC1, 0xFBD3, 0xFD3D, 0xFD50, 0xFD8F,
	0xFD92, 0xFDC7, 0xFDF0, 0xFDFD, 0xFE70, 0xFE74, 0xFE76, 0xFEFC,
	0x102E0, 0x102FB, 0x10E60, 0x10E7E, 0x1EE00, 0x1EE03, 0x1EE05, 0x1EE1F,
	0x1EE21, 0x1EE22, 0x1EE24, 0x1EE24, 0x1EE27, 0x1EE27, 0x1EE29, 0x1EE32,
	0x1EE34, 0x1EE37, 0x1EE39, 0x1EE39, 0x1EE3B, 0x1EE3B, 0x1EE42, 0x1EE42,
	0x1EE47, 0x1EE47, 0x1EE49, 0x1EE49, 0x1EE4B, 0x1EE4B, 0x1EE4D, 0x1EE4F,
	0x1EE51, 0x1EE52, 0x1EE54, 0x1EE54, 0x1EE57, 0x1EE57, 0x1EE59, 0x1EE59,
	0x1EE5B, 0x1EE5B, 0x1EE5D, 0x1EE5D, 0x1EE5F, 0x1EE5F, 0x1EE61, 0x1EE62,
	0x1EE64, 0x1EE64, 0x1EE67, 0x1EE6A, 0x1EE6C, 0x1EE72, 0x1EE74, 0x1EE77,
	0x1EE79, 0x1EE7C, 0x1EE7E, 0x1EE7E, 0x1EE80, 0x1EE89, 0x1EE8B, 0x1EE9B,
	0x1EEA1, 0x1EEA3, 0x1EEA5, 0x1EEA9, 0x1EEAB, 0x1EEBB, 0x1EEF0, 0x1EEF1,
	//  #246 (15683+4): scx=Armenian:Armn
	0x0531, 0x0556, 0x0559, 0x058A, 0x058D, 0x058F, 0xFB13, 0xFB17,
	//  #247 (15687+26): scx=Bengali:Beng
	0x0951, 0x0952, 0x0964, 0x0965, 0x0980, 0x0983, 0x0985, 0x098C,
	0x098F, 0x0990, 0x0993, 0x09A8, 0x09AA, 0x09B0, 0x09B2, 0x09B2,
	0x09B6, 0x09B9, 0x09BC, 0x09C4, 0x09C7, 0x09C8, 0x09CB, 0x09CE,
	0x09D7, 0x09D7, 0x09DC, 0x09DD, 0x09DF, 0x09E3, 0x09E6, 0x09FE,
	0x1CD0, 0x1CD0, 0x1CD2, 0x1CD2, 0x1CD5, 0x1CD6, 0x1CD8, 0x1CD8,
	0x1CE1, 0x1CE1, 0x1CEA, 0x1CEA, 0x1CED, 0x1CED, 0x1CF2, 0x1CF2,
	0x1CF5, 0x1CF7, 0xA8F1, 0xA8F1,
	//  #248 (15713+12): scx=Bopomofo:Bopo
	0x02EA, 0x02EB, 0x3001, 0x3003, 0x3008, 0x3011, 0x3013, 0x301F,
	0x302A, 0x302D, 0x3030, 0x3030, 0x3037, 0x3037, 0x30FB, 0x30FB,
	0x3105, 0x312F, 0x31A0, 0x31BA, 0xFE45, 0xFE46, 0xFF61, 0xFF65,
	//  #249 (15725+3): scx=Buginese:Bugi
	0x1A00, 0x1A1B, 0x1A1E, 0x1A1F, 0xA9CF, 0xA9CF,
	//  #250 (15728+2): scx=Buhid:Buhd
	0x1735, 0x1736, 0x1740, 0x1753,
	//  #251 (15730+4): scx=Chakma:Cakm
	0x09E6, 0x09EF, 0x1040, 0x1049, 0x11100, 0x11134, 0x11136, 0x11146,
	//  #252 (15734+146): scx=Common:Zyyy
	0x0000, 0x0040, 0x005B, 0x0060, 0x007B, 0x00A9, 0x00AB, 0x00B9,
	0x00BB, 0x00BF, 0x00D7, 0x00D7, 0x00F7, 0x00F7, 0x02B9, 0x02DF,
	0x02E5, 0x02E9, 0x02EC, 0x02FF, 0x0374, 0x0374, 0x037E, 0x037E,
	0x0385, 0x0385, 0x0387, 0x0387, 0x0605, 0x0605, 0x06DD, 0x06DD,
	0x08E2, 0x08E2, 0x0E3F, 0x0E3F, 0x0FD5, 0x0FD8, 0x16EB, 0x16ED,
	0x2000, 0x200B, 0x200E, 0x202E, 0x2030, 0x2064, 0x2066, 0x2070,
	0x2074, 0x207E, 0x2080, 0x208E, 0x20A0, 0x20BF, 0x2100, 0x2125,
	0x2127, 0x2129, 0x212C, 0x2131, 0x2133, 0x214D, 0x214F, 0x215F,
	0x2189, 0x218B, 0x2190, 0x2426, 0x2440, 0x244A, 0x2460, 0x27FF,
	0x2900, 0x2B73, 0x2B76, 0x2B95, 0x2B98, 0x2BFF, 0x2E00, 0x2E42,
	0x2E44, 0x2E4F, 0x2FF0, 0x2FFB, 0x3000, 0x3000, 0x3004, 0x3004,
	0x3012, 0x3012, 0x3020, 0x3020, 0x3036, 0x3036, 0x3248, 0x325F,
	0x327F, 0x327F, 0x32B1, 0x32BF, 0x32CC, 0x32CF, 0x3371, 0x337A,
	0x3380, 0x33DF, 0x33FF, 0x33FF, 0x4DC0, 0x4DFF, 0xA700, 0xA721,
	0xA788, 0xA78A, 0xAB5B, 0xAB5B, 0xFD3E, 0xFD3F, 0xFE10, 0xFE19,
	0xFE30, 0xFE44, 0xFE47, 0xFE52, 0xFE54, 0xFE66, 0xFE68, 0xFE6B,
	0xFEFF, 0xFEFF, 0xFF01, 0xFF20, 0xFF3B, 0xFF40, 0xFF5B, 0xFF60,
	0xFFE0, 0xFFE6, 0xFFE8, 0xFFEE, 0xFFF9, 0xFFFD, 0x10190, 0x1019B,
	0x101D0, 0x101FC, 0x16FE2, 0x16FE3, 0x1D000, 0x1D0F5, 0x1D100, 0x1D126,
	0x1D129, 0x1D166, 0x1D16A, 0x1D17A, 0x1D183, 0x1D184, 0x1D18C, 0x1D1A9,
	0x1D1AE, 0x1D1E8, 0x1D2E0, 0x1D2F3, 0x1D300, 0x1D356, 0x1D372, 0x1D378,
	0x1D400, 0x1D454, 0x1D456, 0x1D49C, 0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A2,
	0x1D4A5, 0x1D4A6, 0x1D4A9, 0x1D4AC, 0x1D4AE, 0x1D4B9, 0x1D4BB, 0x1D4BB,
	0x1D4BD, 0x1D4C3, 0x1D4C5, 0x1D505, 0x1D507, 0x1D50A, 0x1D50D, 0x1D514,
	0x1D516, 0x1D51C, 0x1D51E, 0x1D539, 0x1D53B, 0x1D53E, 0x1D540, 0x1D544,
	0x1D546, 0x1D546, 0x1D54A, 0x1D550, 0x1D552, 0x1D6A5, 0x1D6A8, 0x1D7CB,
	0x1D7CE, 0x1D7FF, 0x1EC71, 0x1ECB4, 0x1ED01, 0x1ED3D, 0x1F000, 0x1F02B,
	0x1F030, 0x1F093, 0x1F0A0, 0x1F0AE, 0x1F0B1, 0x1F0BF, 0x1F0C1, 0x1F0CF,
	0x1F0D1, 0x1F0F5, 0x1F100, 0x1F10C, 0x1F110, 0x1F16C, 0x1F170, 0x1F1AC,
	0x1F1E6, 0x1F1FF, 0x1F201, 0x1F202, 0x1F210, 0x1F23B, 0x1F240, 0x1F248,
	0x1F260, 0x1F265, 0x1F300, 0x1F6D5, 0x1F6E0, 0x1F6EC, 0x1F6F0, 0x1F6FA,
	0x1F700, 0x1F773, 0x1F780, 0x1F7D8, 0x1F7E0, 0x1F7EB, 0x1F800, 0x1F80B,
	0x1F810, 0x1F847, 0x1F850, 0x1F859, 0x1F860, 0x1F887, 0x1F890, 0x1F8AD,
	0x1F900, 0x1F90B, 0x1F90D, 0x1F971, 0x1F973, 0x1F976, 0x1F97A, 0x1F9A2,
	0x1F9A5, 0x1F9AA, 0x1F9AE, 0x1F9CA, 0x1F9CD, 0x1FA53, 0x1FA60, 0x1FA6D,
	0x1FA70, 0x1FA73, 0x1FA78, 0x1FA7A, 0x1FA80, 0x1FA82, 0x1FA90, 0x1FA95,
	0xE0001, 0xE0001, 0xE0020, 0xE007F,
	//  #253 (15880+4): scx=Coptic:Copt:Qaac
	0x03E2, 0x03EF, 0x2C80, 0x2CF3, 0x2CF9, 0x2CFF, 0x102E0, 0x102FB,
	//  #254 (15884+9): scx=Cypriot:Cprt
	0x10100, 0x10102, 0x10107, 0x10133, 0x10137, 0x1013F, 0x10800, 0x10805,
	0x10808, 0x10808, 0x1080A, 0x10835, 0x10837, 0x10838, 0x1083C, 0x1083C,
	0x1083F, 0x1083F,
	//  #255 (15893+8): scx=Cyrillic:Cyrl
	0x0400, 0x052F, 0x1C80, 0x1C88, 0x1D2B, 0x1D2B, 0x1D78, 0x1D78,
	0x2DE0, 0x2DFF, 0x2E43, 0x2E43, 0xA640, 0xA69F, 0xFE2E, 0xFE2F,
	//  #256 (15901+7): scx=Devanagari:Deva
	0x0900, 0x0952, 0x0955, 0x097F, 0x1CD0, 0x1CF6, 0x1CF8, 0x1CF9,
	0x20F0, 0x20F0, 0xA830, 0xA839, 0xA8E0, 0xA8FF,
	//  #257 (15908+5): scx=Duployan:Dupl
	0x1BC00, 0x1BC6A, 0x1BC70, 0x1BC7C, 0x1BC80, 0x1BC88, 0x1BC90, 0x1BC99,
	0x1BC9C, 0x1BCA3,
	//  #258 (15913+10): scx=Georgian:Geor
	0x0589, 0x0589, 0x10A0, 0x10C5, 0x10C7, 0x10C7, 0x10CD, 0x10CD,
	0x10D0, 0x10FF, 0x1C90, 0x1CBA, 0x1CBD, 0x1CBF, 0x2D00, 0x2D25,
	0x2D27, 0x2D27, 0x2D2D, 0x2D2D,
	//  #259 (15923+11): scx=Glagolitic:Glag
	0x0484, 0x0484, 0x0487, 0x0487, 0x2C00, 0x2C2E, 0x2C30, 0x2C5E,
	0x2E43, 0x2E43, 0xA66F, 0xA66F, 0x1E000, 0x1E006, 0x1E008, 0x1E018,
	0x1E01B, 0x1E021, 0x1E023, 0x1E024, 0x1E026, 0x1E02A,
	//  #260 (15934+25): scx=Grantha:Gran
	0x0951, 0x0952, 0x0964, 0x0965, 0x0BE6, 0x0BF3, 0x1CD0, 0x1CD0,
	0x1CD2, 0x1CD3, 0x1CF2, 0x1CF4, 0x1CF8, 0x1CF9, 0x20F0, 0x20F0,
	0x11300, 0x11303, 0x11305, 0x1130C, 0x1130F, 0x11310, 0x11313, 0x11328,
	0x1132A, 0x11330, 0x11332, 0x11333, 0x11335, 0x11339, 0x1133B, 0x11344,
	0x11347, 0x11348, 0x1134B, 0x1134D, 0x11350, 0x11350, 0x11357, 0x11357,
	0x1135D, 0x11363, 0x11366, 0x1136C, 0x11370, 0x11374, 0x11FD0, 0x11FD1,
	0x11FD3, 0x11FD3,
	//  #261 (15959+38): scx=Greek:Grek
	0x0342, 0x0342, 0x0345, 0x0345, 0x0370, 0x0373, 0x0375, 0x0377,
	0x037A, 0x037D, 0x037F, 0x037F, 0x0384, 0x0384, 0x0386, 0x0386,
	0x0388, 0x038A, 0x038C, 0x038C, 0x038E, 0x03A1, 0x03A3, 0x03E1,
	0x03F0, 0x03FF, 0x1D26, 0x1D2A, 0x1D5D, 0x1D61, 0x1D66, 0x1D6A,
	0x1DBF, 0x1DC1, 0x1F00, 0x1F15, 0x1F18, 0x1F1D, 0x1F20, 0x1F45,
	0x1F48, 0x1F4D, 0x1F50, 0x1F57, 0x1F59, 0x1F59, 0x1F5B, 0x1F5B,
	0x1F5D, 0x1F5D, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4, 0x1FB6, 0x1FC4,
	0x1FC6, 0x1FD3, 0x1FD6, 0x1FDB, 0x1FDD, 0x1FEF, 0x1FF2, 0x1FF4,
	0x1FF6, 0x1FFE, 0x2126, 0x2126, 0xAB65, 0xAB65, 0x10140, 0x1018E,
	0x101A0, 0x101A0, 0x1D200, 0x1D245,
	//  #262 (15997+17): scx=Gujarati:Gujr
	0x0951, 0x0952, 0x0964, 0x0965, 0x0A81, 0x0A83, 0x0A85, 0x0A8D,
	0x0A8F, 0x0A91, 0x0A93, 0x0AA8, 0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3,
	0x0AB5, 0x0AB9, 0x0ABC, 0x0AC5, 0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD,
	0x0AD0, 0x0AD0, 0x0AE0, 0x0AE3, 0x0AE6, 0x0AF1, 0x0AF9, 0x0AFF,
	0xA830, 0xA839,
	//  #263 (16014+19): scx=Gurmukhi:Guru
	0x0951, 0x0952, 0x0964, 0x0965, 0x0A01, 0x0A03, 0x0A05, 0x0A0A,
	0x0A0F, 0x0A10, 0x0A13, 0x0A28, 0x0A2A, 0x0A30, 0x0A32, 0x0A33,
	0x0A35, 0x0A36, 0x0A38, 0x0A39, 0x0A3C, 0x0A3C, 0x0A3E, 0x0A42,
	0x0A47, 0x0A48, 0x0A4B, 0x0A4D, 0x0A51, 0x0A51, 0x0A59, 0x0A5C,
	0x0A5E, 0x0A5E, 0x0A66, 0x0A76, 0xA830, 0xA839,
	//  #264 (16033+33): scx=Han:Hani
	0x2E80, 0x2E99, 0x2E9B, 0x2EF3, 0x2F00, 0x2FD5, 0x3001, 0x3003,
	0x3005, 0x3011, 0x3013, 0x301F, 0x3021, 0x302D, 0x3030, 0x3030,
	0x3037, 0x303F, 0x30FB, 0x30FB, 0x3190, 0x319F, 0x31C0, 0x31E3,
	0x3220, 0x3247, 0x3280, 0x32B0, 0x32C0, 0x32CB, 0x32FF, 0x32FF,
	0x3358, 0x3370, 0x337B, 0x337F, 0x33E0, 0x33FE, 0x3400, 0x4DB5,
	0x4E00, 0x9FEF, 0xF900, 0xFA6D, 0xFA70, 0xFAD9, 0xFE45, 0xFE46,
	0xFF61, 0xFF65, 0x1D360, 0x1D371, 0x1F250, 0x1F251, 0x20000, 0x2A6D6,
	0x2A700, 0x2B734, 0x2B740, 0x2B81D, 0x2B820, 0x2CEA1, 0x2CEB0, 0x2EBE0,
	0x2F800, 0x2FA1D,
	//  #265 (16066+21): scx=Hangul:Hang
	0x1100, 0x11FF, 0x3001, 0x3003, 0x3008, 0x3011, 0x3013, 0x301F,
	0x302E, 0x3030, 0x3037, 0x3037, 0x30FB, 0x30FB, 0x3131, 0x318E,
	0x3200, 0x321E, 0x3260, 0x327E, 0xA960, 0xA97C, 0xAC00, 0xD7A3,
	0xD7B0, 0xD7C6, 0xD7CB, 0xD7FB, 0xFE45, 0xFE46, 0xFF61, 0xFF65,
	0xFFA0, 0xFFBE, 0xFFC2, 0xFFC7, 0xFFCA, 0xFFCF, 0xFFD2, 0xFFD7,
	0xFFDA, 0xFFDC,
	//  #266 (16087+1): scx=Hanunoo:Hano
	0x1720, 0x1736,
	//  #267 (16088+16): scx=Hiragana:Hira
	0x3001, 0x3003, 0x3008, 0x3011, 0x3013, 0x301F, 0x3030, 0x3035,
	0x3037, 0x3037, 0x303C, 0x303D, 0x3041, 0x3096, 0x3099, 0x30A0,
	0x30FB, 0x30FC, 0xFE45, 0xFE46, 0xFF61, 0xFF65, 0xFF70, 0xFF70,
	0xFF9E, 0xFF9F, 0x1B001, 0x1B11E, 0x1B150, 0x1B152, 0x1F200, 0x1F200,
	//  #268 (16104+17): scx=Inherited:Zinh:Qaai
	0x0300, 0x0341, 0x0343, 0x0344, 0x0346, 0x0362, 0x0953, 0x0954,
	0x1AB0, 0x1ABE, 0x1DC2, 0x1DF9, 0x1DFB, 0x1DFF, 0x200C, 0x200D,
	0x20D0, 0x20EF, 0xFE00, 0xFE0F, 0xFE20, 0xFE2D, 0x101FD, 0x101FD,
	0x1D167, 0x1D169, 0x1D17B, 0x1D182, 0x1D185, 0x1D18B, 0x1D1AA, 0x1D1AD,
	0xE0100, 0xE01EF,
	//  #269 (16121+3): scx=Javanese:Java
	0xA980, 0xA9CD, 0xA9CF, 0xA9D9, 0xA9DE, 0xA9DF,
	//  #270 (16124+4): scx=Kaithi:Kthi
	0x0966, 0x096F, 0xA830, 0xA839, 0x11080, 0x110C1, 0x110CD, 0x110CD,
	//  #271 (16128+21): scx=Kannada:Knda
	0x0951, 0x0952, 0x0964, 0x0965, 0x0C80, 0x0C8C, 0x0C8E, 0x0C90,
	0x0C92, 0x0CA8, 0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBC, 0x0CC4,
	0x0CC6, 0x0CC8, 0x0CCA, 0x0CCD, 0x0CD5, 0x0CD6, 0x0CDE, 0x0CDE,
	0x0CE0, 0x0CE3, 0x0CE6, 0x0CEF, 0x0CF1, 0x0CF2, 0x1CD0, 0x1CD0,
	0x1CD2, 0x1CD2, 0x1CDA, 0x1CDA, 0x1CF2, 0x1CF2, 0x1CF4, 0x1CF4,
	0xA830, 0xA835,
	//  #272 (16149+15): scx=Katakana:Kana
	0x3001, 0x3003, 0x3008, 0x3011, 0x3013, 0x301F, 0x3030, 0x3035,
	0x3037, 0x3037, 0x303C, 0x303D, 0x3099, 0x309C, 0x30A0, 0x30FF,
	0x31F0, 0x31FF, 0x32D0, 0x32FE, 0x3300, 0x3357, 0xFE45, 0xFE46,
	0xFF61, 0xFF9F, 0x1B000, 0x1B000, 0x1B164, 0x1B167,
	//  #273 (16164+1): scx=Kayah_Li:Kali
	0xA900, 0xA92F,
	//  #274 (16165+4): scx=Khojki:Khoj
	0x0AE6, 0x0AEF, 0xA830, 0xA839, 0x11200, 0x11211, 0x11213, 0x1123E,
	//  #275 (16169+4): scx=Khudawadi:Sind
	0x0964, 0x0965, 0xA830, 0xA839, 0x112B0, 0x112EA, 0x112F0, 0x112F9,
	//  #276 (16173+39): scx=Latin:Latn
	0x0041, 0x005A, 0x0061, 0x007A, 0x00AA, 0x00AA, 0x00BA, 0x00BA,
	0x00C0, 0x00D6, 0x00D8, 0x00F6, 0x00F8, 0x02B8, 0x02E0, 0x02E4,
	0x0363, 0x036F, 0x0485, 0x0486, 0x0951, 0x0952, 0x10FB, 0x10FB,
	0x1D00, 0x1D25, 0x1D2C, 0x1D5C, 0x1D62, 0x1D65, 0x1D6B, 0x1D77,
	0x1D79, 0x1DBE, 0x1E00, 0x1EFF, 0x202F, 0x202F, 0x2071, 0x2071,
	0x207F, 0x207F, 0x2090, 0x209C, 0x20F0, 0x20F0, 0x212A, 0x212B,
	0x2132, 0x2132, 0x214E, 0x214E, 0x2160, 0x2188, 0x2C60, 0x2C7F,
	0xA722, 0xA787, 0xA78B, 0xA7BF, 0xA7C2, 0xA7C6, 0xA7F7, 0xA7FF,
	0xA92E, 0xA92E, 0xAB30, 0xAB5A, 0xAB5C, 0xAB64, 0xAB66, 0xAB67,
	0xFB00, 0xFB06, 0xFF21, 0xFF3A, 0xFF41, 0xFF5A,
	//  #277 (16212+6): scx=Limbu:Limb
	0x0965, 0x0965, 0x1900, 0x191E, 0x1920, 0x192B, 0x1930, 0x193B,
	0x1940, 0x1940, 0x1944, 0x194F,
	//  #278 (16218+4): scx=Linear_A:Lina
	0x10107, 0x10133, 0x10600, 0x10736, 0x10740, 0x10755, 0x10760, 0x10767,
	//  #279 (16222+10): scx=Linear_B:Linb
	0x10000, 0x1000B, 0x1000D, 0x10026, 0x10028, 0x1003A, 0x1003C, 0x1003D,
	0x1003F, 0x1004D, 0x10050, 0x1005D, 0x10080, 0x100FA, 0x10100, 0x10102,
	0x10107, 0x10133, 0x10137, 0x1013F,
	//  #280 (16232+3): scx=Mahajani:Mahj
	0x0964, 0x096F, 0xA830, 0xA839, 0x11150, 0x11176,
	//  #281 (16235+12): scx=Malayalam:Mlym
	0x0951, 0x0952, 0x0964, 0x0965, 0x0D00, 0x0D03, 0x0D05, 0x0D0C,
	0x0D0E, 0x0D10, 0x0D12, 0x0D44, 0x0D46, 0x0D48, 0x0D4A, 0x0D4F,
	0x0D54, 0x0D63, 0x0D66, 0x0D7F, 0x1CDA, 0x1CDA, 0xA830, 0xA832,
	//  #282 (16247+3): scx=Mandaic:Mand
	0x0640, 0x0640, 0x0840, 0x085B, 0x085E, 0x085E,
	//  #283 (16250+3): scx=Manichaean:Mani
	0x0640, 0x0640, 0x10AC0, 0x10AE6, 0x10AEB, 0x10AF6,
	//  #284 (16253+8): scx=Masaram_Gondi:Gonm
	0x0964, 0x0965, 0x11D00, 0x11D06, 0x11D08, 0x11D09, 0x11D0B, 0x11D36,
	0x11D3A, 0x11D3A, 0x11D3C, 0x11D3D, 0x11D3F, 0x11D47, 0x11D50, 0x11D59,
	//  #285 (16261+3): scx=Modi:Modi
	0xA830, 0xA839, 0x11600, 0x11644, 0x11650, 0x11659,
	//  #286 (16264+6): scx=Mongolian:Mong
	0x1800, 0x180E, 0x1810, 0x1819, 0x1820, 0x1878, 0x1880, 0x18AA,
	0x202F, 0x202F, 0x11660, 0x1166C,
	//  #287 (16270+6): scx=Multani:Mult
	0x0A66, 0x0A6F, 0x11280, 0x11286, 0x11288, 0x11288, 0x1128A, 0x1128D,
	0x1128F, 0x1129D, 0x1129F, 0x112A9,
	//  #288 (16276+4): scx=Myanmar:Mymr
	0x1000, 0x109F, 0xA92E, 0xA92E, 0xA9E0, 0xA9FE, 0xAA60, 0xAA7F,
	//  #289 (16280+2): scx=Old_Permic:Perm
	0x0483, 0x0483, 0x10350, 0x1037A,
	//  #290 (16282+18): scx=Oriya:Orya
	0x0951, 0x0952, 0x0964, 0x0965, 0x0B01, 0x0B03, 0x0B05, 0x0B0C,
	0x0B0F, 0x0B10, 0x0B13, 0x0B28, 0x0B2A, 0x0B30, 0x0B32, 0x0B33,
	0x0B35, 0x0B39, 0x0B3C, 0x0B44, 0x0B47, 0x0B48, 0x0B4B, 0x0B4D,
	0x0B56, 0x0B57, 0x0B5C, 0x0B5D, 0x0B5F, 0x0B63, 0x0B66, 0x0B77,
	0x1CDA, 0x1CDA, 0x1CF2, 0x1CF2,
	//  #291 (16300+3): scx=Phags_Pa:Phag
	0x1802, 0x1803, 0x1805, 0x1805, 0xA840, 0xA877,
	//  #292 (16303+4): scx=Psalter_Pahlavi:Phlp
	0x0640, 0x0640, 0x10B80, 0x10B91, 0x10B99, 0x10B9C, 0x10BA9, 0x10BAF,
	//  #293 (16307+7): scx=Sharada:Shrd
	0x0951, 0x0951, 0x1CD7, 0x1CD7, 0x1CD9, 0x1CD9, 0x1CDC, 0x1CDD,
	0x1CE0, 0x1CE0, 0x11180, 0x111CD, 0x111D0, 0x111DF,
	//  #294 (16314+14): scx=Sinhala:Sinh
	0x0964, 0x0965, 0x0D82, 0x0D83, 0x0D85, 0x0D96, 0x0D9A, 0x0DB1,
	0x0DB3, 0x0DBB, 0x0DBD, 0x0DBD, 0x0DC0, 0x0DC6, 0x0DCA, 0x0DCA,
	0x0DCF, 0x0DD4, 0x0DD6, 0x0DD6, 0x0DD8, 0x0DDF, 0x0DE6, 0x0DEF,
	0x0DF2, 0x0DF4, 0x111E1, 0x111F4,
	//  #295 (16328+3): scx=Syloti_Nagri:Sylo
	0x0964, 0x0965, 0x09E6, 0x09EF, 0xA800, 0xA82B,
	//  #296 (16331+10): scx=Syriac:Syrc
	0x060C, 0x060C, 0x061B, 0x061C, 0x061F, 0x061F, 0x0640, 0x0640,
	0x064B, 0x0655, 0x0670, 0x0670, 0x0700, 0x070D, 0x070F, 0x074A,
	0x074D, 0x074F, 0x0860, 0x086A,
	//  #297 (16341+3): scx=Tagalog:Tglg
	0x1700, 0x170C, 0x170E, 0x1714, 0x1735, 0x1736,
	//  #298 (16344+4): scx=Tagbanwa:Tagb
	0x1735, 0x1736, 0x1760, 0x176C, 0x176E, 0x1770, 0x1772, 0x1773,
	//  #299 (16348+3): scx=Tai_Le:Tale
	0x1040, 0x1049, 0x1950, 0x196D, 0x1970, 0x1974,
	//  #300 (16351+4): scx=Takri:Takr
	0x0964, 0x0965, 0xA830, 0xA839, 0x11680, 0x116B8, 0x116C0, 0x116C9,
	//  #301 (16355+25): scx=Tamil:Taml
	0x0951, 0x0952, 0x0964, 0x0965, 0x0B82, 0x0B83, 0x0B85, 0x0B8A,
	0x0B8E, 0x0B90, 0x0B92, 0x0B95, 0x0B99, 0x0B9A, 0x0B9C, 0x0B9C,
	0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA, 0x0BAE, 0x0BB9,
	0x0BBE, 0x0BC2, 0x0BC6, 0x0BC8, 0x0BCA, 0x0BCD, 0x0BD0, 0x0BD0,
	0x0BD7, 0x0BD7, 0x0BE6, 0x0BFA, 0x1CDA, 0x1CDA, 0xA8F3, 0xA8F3,
	0x11301, 0x11301, 0x11303, 0x11303, 0x1133B, 0x1133C, 0x11FC0, 0x11FF1,
	0x11FFF, 0x11FFF,
	//  #302 (16380+16): scx=Telugu:Telu
	0x0951, 0x0952, 0x0964, 0x0965, 0x0C00, 0x0C0C, 0x0C0E, 0x0C10,
	0x0C12, 0x0C28, 0x0C2A, 0x0C39, 0x0C3D, 0x0C44, 0x0C46, 0x0C48,
	0x0C4A, 0x0C4D, 0x0C55, 0x0C56, 0x0C58, 0x0C5A, 0x0C60, 0x0C63,
	0x0C66, 0x0C6F, 0x0C77, 0x0C7F, 0x1CDA, 0x1CDA, 0x1CF2, 0x1CF2,
	//  #303 (16396+7): scx=Thaana:Thaa
	0x060C, 0x060C, 0x061B, 0x061C, 0x061F, 0x061F, 0x0660, 0x0669,
	0x0780, 0x07B1, 0xFDF2, 0xFDF2, 0xFDFD, 0xFDFD,
	//  #304 (16403+6): scx=Tirhuta:Tirh
	0x0951, 0x0952, 0x0964, 0x0965, 0x1CF2, 0x1CF2, 0xA830, 0xA839,
	0x11480, 0x114C7, 0x114D0, 0x114D9,
	//  #305 (16409+7): scx=Yi:Yiii
	0x3001, 0x3002, 0x3008, 0x3011, 0x3014, 0x301B, 0x30FB, 0x30FB,
	0xA000, 0xA48C, 0xA490, 0xA4C6, 0xFF61, 0xFF65,
	//  #306 (16416+3): scx=Dogra:Dogr
	0x0964, 0x096F, 0xA830, 0xA839, 0x11800, 0x1183B,
	//  #307 (16419+7): scx=Gunjala_Gondi:Gong
	0x0964, 0x0965, 0x11D60, 0x11D65, 0x11D67, 0x11D68, 0x11D6A, 0x11D8E,
	0x11D90, 0x11D91, 0x11D93, 0x11D98, 0x11DA0, 0x11DA9,
	//  #308 (16426+7): scx=Hanifi_Rohingya:Rohg
	0x060C, 0x060C, 0x061B, 0x061B, 0x061F, 0x061F, 0x0640, 0x0640,
	0x06D4, 0x06D4, 0x10D00, 0x10D27, 0x10D30, 0x10D39,
	//  #309 (16433+2): scx=Sogdian:Sogd
	0x0640, 0x0640, 0x10F30, 0x10F59,
	//  #310 (16435+9): scx=Nandinagari:Nand
	0x0964, 0x0965, 0x0CE6, 0x0CEF, 0x1CE9, 0x1CE9, 0x1CF2, 0x1CF2,
	0x1CFA, 0x1CFA, 0xA830, 0xA835, 0x119A0, 0x119A7, 0x119AA, 0x119D7,
	0x119DA, 0x119E4
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
const T5 unicode_property_data<T1, T2, T3, T4, T5, T6>::rangenumbertable[] =
{
	{ ptype::unknown, "*", 0 },	//  #0
	{ ptype::general_category, "Other:C", 1 },	//  #1
	{ ptype::general_category, "Control:Cc:cntrl", 2 },	//  #2
	{ ptype::general_category, "Format:Cf", 3 },	//  #3
	{ ptype::general_category, "Unassigned:Cn", 4 },	//  #4
	{ ptype::general_category, "Private_Use:Co", 5 },	//  #5
	{ ptype::general_category, "Surrogate:Cs", 6 },	//  #6
	{ ptype::general_category, "Letter:L", 7 },	//  #7
	{ ptype::general_category, "Cased_Letter:LC", 8 },	//  #8
	{ ptype::general_category, "Lowercase_Letter:Ll", 9 },	//  #9
	{ ptype::general_category, "Titlecase_Letter:Lt", 10 },	//  #10
	{ ptype::general_category, "Uppercase_Letter:Lu", 11 },	//  #11
	{ ptype::general_category, "Modifier_Letter:Lm", 12 },	//  #12
	{ ptype::general_category, "Other_Letter:Lo", 13 },	//  #13
	{ ptype::general_category, "Mark:M:Combining_Mark", 14 },	//  #14
	{ ptype::general_category, "Spacing_Mark:Mc", 15 },	//  #15
	{ ptype::general_category, "Enclosing_Mark:Me", 16 },	//  #16
	{ ptype::general_category, "Nonspacing_Mark:Mn", 17 },	//  #17
	{ ptype::general_category, "Number:N", 18 },	//  #18
	{ ptype::general_category, "Decimal_Number:Nd:digit", 19 },	//  #19
	{ ptype::general_category, "Letter_Number:Nl", 20 },	//  #20
	{ ptype::general_category, "Other_Number:No", 21 },	//  #21
	{ ptype::general_category, "Punctuation:P:punct", 22 },	//  #22
	{ ptype::general_category, "Connector_Punctuation:Pc", 23 },	//  #23
	{ ptype::general_category, "Dash_Punctuation:Pd", 24 },	//  #24
	{ ptype::general_category, "Close_Punctuation:Pe", 25 },	//  #25
	{ ptype::general_category, "Final_Punctuation:Pf", 26 },	//  #26
	{ ptype::general_category, "Initial_Punctuation:Pi", 27 },	//  #27
	{ ptype::general_category, "Other_Punctuation:Po", 28 },	//  #28
	{ ptype::general_category, "Open_Punctuation:Ps", 29 },	//  #29
	{ ptype::general_category, "Symbol:S", 30 },	//  #30
	{ ptype::general_category, "Currency_Symbol:Sc", 31 },	//  #31
	{ ptype::general_category, "Modifier_Symbol:Sk", 32 },	//  #32
	{ ptype::general_category, "Math_Symbol:Sm", 33 },	//  #33
	{ ptype::general_category, "Other_Symbol:So", 34 },	//  #34
	{ ptype::general_category, "Separator:Z", 35 },	//  #35
	{ ptype::general_category, "Line_Separator:Zl", 36 },	//  #36
	{ ptype::general_category, "Paragraph_Separator:Zp", 37 },	//  #37
	{ ptype::general_category, "Space_Separator:Zs", 38 },	//  #38
	{ ptype::binary, "ASCII", 39 },	//  #39
	{ ptype::binary, "ASCII_Hex_Digit:AHex", 40 },	//  #40
	{ ptype::binary, "Alphabetic:Alpha", 41 },	//  #41
	{ ptype::binary, "Any", 42 },	//  #42
	{ ptype::binary, "Assigned", 43 },	//  #43
	{ ptype::binary, "Bidi_Control:Bidi_C", 44 },	//  #44
	{ ptype::binary, "Bidi_Mirrored:Bidi_M", 45 },	//  #45
	{ ptype::binary, "Case_Ignorable:CI", 46 },	//  #46
	{ ptype::binary, "Cased", 47 },	//  #47
	{ ptype::binary, "Changes_When_Casefolded:CWCF", 48 },	//  #48
	{ ptype::binary, "Changes_When_Casemapped:CWCM", 49 },	//  #49
	{ ptype::binary, "Changes_When_Lowercased:CWL", 50 },	//  #50
	{ ptype::binary, "Changes_When_NFKC_Casefolded:CWKCF", 51 },	//  #51
	{ ptype::binary, "Changes_When_Titlecased:CWT", 52 },	//  #52
	{ ptype::binary, "Changes_When_Uppercased:CWU", 53 },	//  #53
	{ ptype::binary, "Dash", 54 },	//  #54
	{ ptype::binary, "Default_Ignorable_Code_Point:DI", 55 },	//  #55
	{ ptype::binary, "Deprecated:Dep", 56 },	//  #56
	{ ptype::binary, "Diacritic:Dia", 57 },	//  #57
	{ ptype::binary, "Emoji", 58 },	//  #58
	{ ptype::binary, "Emoji_Component", 59 },	//  #59
	{ ptype::binary, "Emoji_Modifier", 60 },	//  #60
	{ ptype::binary, "Emoji_Modifier_Base", 61 },	//  #61
	{ ptype::binary, "Emoji_Presentation", 62 },	//  #62
	{ ptype::binary, "Extender:Ext", 63 },	//  #63
	{ ptype::binary, "Grapheme_Base:Gr_Base", 64 },	//  #64
	{ ptype::binary, "Grapheme_Extend:Gr_Ext", 65 },	//  #65
	{ ptype::binary, "Hex_Digit:Hex", 66 },	//  #66
	{ ptype::binary, "IDS_Binary_Operator:IDSB", 67 },	//  #67
	{ ptype::binary, "IDS_Trinary_Operator:IDST", 68 },	//  #68
	{ ptype::binary, "ID_Continue:IDC", 69 },	//  #69
	{ ptype::binary, "ID_Start:IDS", 70 },	//  #70
	{ ptype::binary, "Ideographic:Ideo", 71 },	//  #71
	{ ptype::binary, "Join_Control:Join_C", 72 },	//  #72
	{ ptype::binary, "Logical_Order_Exception:LOE", 73 },	//  #73
	{ ptype::binary, "Lowercase:Lower", 74 },	//  #74
	{ ptype::binary, "Math", 75 },	//  #75
	{ ptype::binary, "Noncharacter_Code_Point:NChar", 76 },	//  #76
	{ ptype::binary, "Pattern_Syntax:Pat_Syn", 77 },	//  #77
	{ ptype::binary, "Pattern_White_Space:Pat_WS", 78 },	//  #78
	{ ptype::binary, "Quotation_Mark:QMark", 79 },	//  #79
	{ ptype::binary, "Radical", 80 },	//  #80
	{ ptype::binary, "Regional_Indicator:RI", 81 },	//  #81
	{ ptype::binary, "Sentence_Terminal:STerm", 82 },	//  #82
	{ ptype::binary, "Soft_Dotted:SD", 83 },	//  #83
	{ ptype::binary, "Terminal_Punctuation:Term", 84 },	//  #84
	{ ptype::binary, "Unified_Ideograph:UIdeo", 85 },	//  #85
	{ ptype::binary, "Uppercase:Upper", 86 },	//  #86
	{ ptype::binary, "Variation_Selector:VS", 87 },	//  #87
	{ ptype::binary, "White_Space:space", 88 },	//  #88
	{ ptype::binary, "XID_Continue:XIDC", 89 },	//  #89
	{ ptype::binary, "XID_Start:XIDS", 90 },	//  #90
	{ ptype::binary, "Extended_Pictographic", 91 },	//  #91
	{ ptype::script, "Adlam:Adlm", 92 },	//  #92
	{ ptype::script, "Ahom:Ahom", 93 },	//  #93
	{ ptype::script, "Anatolian_Hieroglyphs:Hluw", 94 },	//  #94
	{ ptype::script, "Arabic:Arab", 95 },	//  #95
	{ ptype::script, "Armenian:Armn", 96 },	//  #96
	{ ptype::script, "Avestan:Avst", 97 },	//  #97
	{ ptype::script, "Balinese:Bali", 98 },	//  #98
	{ ptype::script, "Bamum:Bamu", 99 },	//  #99
	{ ptype::script, "Bassa_Vah:Bass", 100 },	//  #100
	{ ptype::script, "Batak:Batk", 101 },	//  #101
	{ ptype::script, "Bengali:Beng", 102 },	//  #102
	{ ptype::script, "Bhaiksuki:Bhks", 103 },	//  #103
	{ ptype::script, "Bopomofo:Bopo", 104 },	//  #104
	{ ptype::script, "Brahmi:Brah", 105 },	//  #105
	{ ptype::script, "Braille:Brai", 106 },	//  #106
	{ ptype::script, "Buginese:Bugi", 107 },	//  #107
	{ ptype::script, "Buhid:Buhd", 108 },	//  #108
	{ ptype::script, "Canadian_Aboriginal:Cans", 109 },	//  #109
	{ ptype::script, "Carian:Cari", 110 },	//  #110
	{ ptype::script, "Caucasian_Albanian:Aghb", 111 },	//  #111
	{ ptype::script, "Chakma:Cakm", 112 },	//  #112
	{ ptype::script, "Cham:Cham", 113 },	//  #113
	{ ptype::script, "Cherokee:Cher", 114 },	//  #114
	{ ptype::script, "Common:Zyyy", 115 },	//  #115
	{ ptype::script, "Coptic:Copt:Qaac", 116 },	//  #116
	{ ptype::script, "Cuneiform:Xsux", 117 },	//  #117
	{ ptype::script, "Cypriot:Cprt", 118 },	//  #118
	{ ptype::script, "Cyrillic:Cyrl", 119 },	//  #119
	{ ptype::script, "Deseret:Dsrt", 120 },	//  #120
	{ ptype::script, "Devanagari:Deva", 121 },	//  #121
	{ ptype::script, "Duployan:Dupl", 122 },	//  #122
	{ ptype::script, "Egyptian_Hieroglyphs:Egyp", 123 },	//  #123
	{ ptype::script, "Elbasan:Elba", 124 },	//  #124
	{ ptype::script, "Ethiopic:Ethi", 125 },	//  #125
	{ ptype::script, "Georgian:Geor", 126 },	//  #126
	{ ptype::script, "Glagolitic:Glag", 127 },	//  #127
	{ ptype::script, "Gothic:Goth", 128 },	//  #128
	{ ptype::script, "Grantha:Gran", 129 },	//  #129
	{ ptype::script, "Greek:Grek", 130 },	//  #130
	{ ptype::script, "Gujarati:Gujr", 131 },	//  #131
	{ ptype::script, "Gurmukhi:Guru", 132 },	//  #132
	{ ptype::script, "Han:Hani", 133 },	//  #133
	{ ptype::script, "Hangul:Hang", 134 },	//  #134
	{ ptype::script, "Hanunoo:Hano", 135 },	//  #135
	{ ptype::script, "Hatran:Hatr", 136 },	//  #136
	{ ptype::script, "Hebrew:Hebr", 137 },	//  #137
	{ ptype::script, "Hiragana:Hira", 138 },	//  #138
	{ ptype::script, "Imperial_Aramaic:Armi", 139 },	//  #139
	{ ptype::script, "Inherited:Zinh:Qaai", 140 },	//  #140
	{ ptype::script, "Inscriptional_Pahlavi:Phli", 141 },	//  #141
	{ ptype::script, "Inscriptional_Parthian:Prti", 142 },	//  #142
	{ ptype::script, "Javanese:Java", 143 },	//  #143
	{ ptype::script, "Kaithi:Kthi", 144 },	//  #144
	{ ptype::script, "Kannada:Knda", 145 },	//  #145
	{ ptype::script, "Katakana:Kana", 146 },	//  #146
	{ ptype::script, "Kayah_Li:Kali", 147 },	//  #147
	{ ptype::script, "Kharoshthi:Khar", 148 },	//  #148
	{ ptype::script, "Khmer:Khmr", 149 },	//  #149
	{ ptype::script, "Khojki:Khoj", 150 },	//  #150
	{ ptype::script, "Khudawadi:Sind", 151 },	//  #151
	{ ptype::script, "Lao:Laoo", 152 },	//  #152
	{ ptype::script, "Latin:Latn", 153 },	//  #153
	{ ptype::script, "Lepcha:Lepc", 154 },	//  #154
	{ ptype::script, "Limbu:Limb", 155 },	//  #155
	{ ptype::script, "Linear_A:Lina", 156 },	//  #156
	{ ptype::script, "Linear_B:Linb", 157 },	//  #157
	{ ptype::script, "Lisu:Lisu", 158 },	//  #158
	{ ptype::script, "Lycian:Lyci", 159 },	//  #159
	{ ptype::script, "Lydian:Lydi", 160 },	//  #160
	{ ptype::script, "Mahajani:Mahj", 161 },	//  #161
	{ ptype::script, "Malayalam:Mlym", 162 },	//  #162
	{ ptype::script, "Mandaic:Mand", 163 },	//  #163
	{ ptype::script, "Manichaean:Mani", 164 },	//  #164
	{ ptype::script, "Marchen:Marc", 165 },	//  #165
	{ ptype::script, "Masaram_Gondi:Gonm", 166 },	//  #166
	{ ptype::script, "Meetei_Mayek:Mtei", 167 },	//  #167
	{ ptype::script, "Mende_Kikakui:Mend", 168 },	//  #168
	{ ptype::script, "Meroitic_Cursive:Merc", 169 },	//  #169
	{ ptype::script, "Meroitic_Hieroglyphs:Mero", 170 },	//  #170
	{ ptype::script, "Miao:Plrd", 171 },	//  #171
	{ ptype::script, "Modi:Modi", 172 },	//  #172
	{ ptype::script, "Mongolian:Mong", 173 },	//  #173
	{ ptype::script, "Mro:Mroo", 174 },	//  #174
	{ ptype::script, "Multani:Mult", 175 },	//  #175
	{ ptype::script, "Myanmar:Mymr", 176 },	//  #176
	{ ptype::script, "Nabataean:Nbat", 177 },	//  #177
	{ ptype::script, "New_Tai_Lue:Talu", 178 },	//  #178
	{ ptype::script, "Newa:Newa", 179 },	//  #179
	{ ptype::script, "Nko:Nkoo", 180 },	//  #180
	{ ptype::script, "Nushu:Nshu", 181 },	//  #181
	{ ptype::script, "Ogham:Ogam", 182 },	//  #182
	{ ptype::script, "Ol_Chiki:Olck", 183 },	//  #183
	{ ptype::script, "Old_Hungarian:Hung", 184 },	//  #184
	{ ptype::script, "Old_Italic:Ital", 185 },	//  #185
	{ ptype::script, "Old_North_Arabian:Narb", 186 },	//  #186
	{ ptype::script, "Old_Permic:Perm", 187 },	//  #187
	{ ptype::script, "Old_Persian:Xpeo", 188 },	//  #188
	{ ptype::script, "Old_South_Arabian:Sarb", 189 },	//  #189
	{ ptype::script, "Old_Turkic:Orkh", 190 },	//  #190
	{ ptype::script, "Oriya:Orya", 191 },	//  #191
	{ ptype::script, "Osage:Osge", 192 },	//  #192
	{ ptype::script, "Osmanya:Osma", 193 },	//  #193
	{ ptype::script, "Pahawh_Hmong:Hmng", 194 },	//  #194
	{ ptype::script, "Palmyrene:Palm", 195 },	//  #195
	{ ptype::script, "Pau_Cin_Hau:Pauc", 196 },	//  #196
	{ ptype::script, "Phags_Pa:Phag", 197 },	//  #197
	{ ptype::script, "Phoenician:Phnx", 198 },	//  #198
	{ ptype::script, "Psalter_Pahlavi:Phlp", 199 },	//  #199
	{ ptype::script, "Rejang:Rjng", 200 },	//  #200
	{ ptype::script, "Runic:Runr", 201 },	//  #201
	{ ptype::script, "Samaritan:Samr", 202 },	//  #202
	{ ptype::script, "Saurashtra:Saur", 203 },	//  #203
	{ ptype::script, "Sharada:Shrd", 204 },	//  #204
	{ ptype::script, "Shavian:Shaw", 205 },	//  #205
	{ ptype::script, "Siddham:Sidd", 206 },	//  #206
	{ ptype::script, "SignWriting:Sgnw", 207 },	//  #207
	{ ptype::script, "Sinhala:Sinh", 208 },	//  #208
	{ ptype::script, "Sora_Sompeng:Sora", 209 },	//  #209
	{ ptype::script, "Soyombo:Soyo", 210 },	//  #210
	{ ptype::script, "Sundanese:Sund", 211 },	//  #211
	{ ptype::script, "Syloti_Nagri:Sylo", 212 },	//  #212
	{ ptype::script, "Syriac:Syrc", 213 },	//  #213
	{ ptype::script, "Tagalog:Tglg", 214 },	//  #214
	{ ptype::script, "Tagbanwa:Tagb", 215 },	//  #215
	{ ptype::script, "Tai_Le:Tale", 216 },	//  #216
	{ ptype::script, "Tai_Tham:Lana", 217 },	//  #217
	{ ptype::script, "Tai_Viet:Tavt", 218 },	//  #218
	{ ptype::script, "Takri:Takr", 219 },	//  #219
	{ ptype::script, "Tamil:Taml", 220 },	//  #220
	{ ptype::script, "Tangut:Tang", 221 },	//  #221
	{ ptype::script, "Telugu:Telu", 222 },	//  #222
	{ ptype::script, "Thaana:Thaa", 223 },	//  #223
	{ ptype::script, "Thai:Thai", 224 },	//  #224
	{ ptype::script, "Tibetan:Tibt", 225 },	//  #225
	{ ptype::script, "Tifinagh:Tfng", 226 },	//  #226
	{ ptype::script, "Tirhuta:Tirh", 227 },	//  #227
	{ ptype::script, "Ugaritic:Ugar", 228 },	//  #228
	{ ptype::script, "Vai:Vaii", 229 },	//  #229
	{ ptype::script, "Warang_Citi:Wara", 230 },	//  #230
	{ ptype::script, "Yi:Yiii", 231 },	//  #231
	{ ptype::script, "Zanabazar_Square:Zanb", 232 },	//  #232
	{ ptype::script, "Dogra:Dogr", 233 },	//  #233
	{ ptype::script, "Gunjala_Gondi:Gong", 234 },	//  #234
	{ ptype::script, "Hanifi_Rohingya:Rohg", 235 },	//  #235
	{ ptype::script, "Makasar:Maka", 236 },	//  #236
	{ ptype::script, "Medefaidrin:Medf", 237 },	//  #237
	{ ptype::script, "Old_Sogdian:Sogo", 238 },	//  #238
	{ ptype::script, "Sogdian:Sogd", 239 },	//  #239
	{ ptype::script, "Elymaic:Elym", 240 },	//  #240
	{ ptype::script, "Nandinagari:Nand", 241 },	//  #241
	{ ptype::script, "Nyiakeng_Puachue_Hmong:Hmnp", 242 },	//  #242
	{ ptype::script, "Wancho:Wcho", 243 },	//  #243
	{ ptype::script_extensions, "Adlam:Adlm", 244 },	//  #244
	{ ptype::script_extensions, "Ahom:Ahom", 93 },	//  #245
	{ ptype::script_extensions, "Anatolian_Hieroglyphs:Hluw", 94 },	//  #246
	{ ptype::script_extensions, "Arabic:Arab", 245 },	//  #247
	{ ptype::script_extensions, "Armenian:Armn", 246 },	//  #248
	{ ptype::script_extensions, "Avestan:Avst", 97 },	//  #249
	{ ptype::script_extensions, "Balinese:Bali", 98 },	//  #250
	{ ptype::script_extensions, "Bamum:Bamu", 99 },	//  #251
	{ ptype::script_extensions, "Bassa_Vah:Bass", 100 },	//  #252
	{ ptype::script_extensions, "Batak:Batk", 101 },	//  #253
	{ ptype::script_extensions, "Bengali:Beng", 247 },	//  #254
	{ ptype::script_extensions, "Bhaiksuki:Bhks", 103 },	//  #255
	{ ptype::script_extensions, "Bopomofo:Bopo", 248 },	//  #256
	{ ptype::script_extensions, "Brahmi:Brah", 105 },	//  #257
	{ ptype::script_extensions, "Braille:Brai", 106 },	//  #258
	{ ptype::script_extensions, "Buginese:Bugi", 249 },	//  #259
	{ ptype::script_extensions, "Buhid:Buhd", 250 },	//  #260
	{ ptype::script_extensions, "Canadian_Aboriginal:Cans", 109 },	//  #261
	{ ptype::script_extensions, "Carian:Cari", 110 },	//  #262
	{ ptype::script_extensions, "Caucasian_Albanian:Aghb", 111 },	//  #263
	{ ptype::script_extensions, "Chakma:Cakm", 251 },	//  #264
	{ ptype::script_extensions, "Cham:Cham", 113 },	//  #265
	{ ptype::script_extensions, "Cherokee:Cher", 114 },	//  #266
	{ ptype::script_extensions, "Common:Zyyy", 252 },	//  #267
	{ ptype::script_extensions, "Coptic:Copt:Qaac", 253 },	//  #268
	{ ptype::script_extensions, "Cuneiform:Xsux", 117 },	//  #269
	{ ptype::script_extensions, "Cypriot:Cprt", 254 },	//  #270
	{ ptype::script_extensions, "Cyrillic:Cyrl", 255 },	//  #271
	{ ptype::script_extensions, "Deseret:Dsrt", 120 },	//  #272
	{ ptype::script_extensions, "Devanagari:Deva", 256 },	//  #273
	{ ptype::script_extensions, "Duployan:Dupl", 257 },	//  #274
	{ ptype::script_extensions, "Egyptian_Hieroglyphs:Egyp", 123 },	//  #275
	{ ptype::script_extensions, "Elbasan:Elba", 124 },	//  #276
	{ ptype::script_extensions, "Ethiopic:Ethi", 125 },	//  #277
	{ ptype::script_extensions, "Georgian:Geor", 258 },	//  #278
	{ ptype::script_extensions, "Glagolitic:Glag", 259 },	//  #279
	{ ptype::script_extensions, "Gothic:Goth", 128 },	//  #280
	{ ptype::script_extensions, "Grantha:Gran", 260 },	//  #281
	{ ptype::script_extensions, "Greek:Grek", 261 },	//  #282
	{ ptype::script_extensions, "Gujarati:Gujr", 262 },	//  #283
	{ ptype::script_extensions, "Gurmukhi:Guru", 263 },	//  #284
	{ ptype::script_extensions, "Han:Hani", 264 },	//  #285
	{ ptype::script_extensions, "Hangul:Hang", 265 },	//  #286
	{ ptype::script_extensions, "Hanunoo:Hano", 266 },	//  #287
	{ ptype::script_extensions, "Hatran:Hatr", 136 },	//  #288
	{ ptype::script_extensions, "Hebrew:Hebr", 137 },	//  #289
	{ ptype::script_extensions, "Hiragana:Hira", 267 },	//  #290
	{ ptype::script_extensions, "Imperial_Aramaic:Armi", 139 },	//  #291
	{ ptype::script_extensions, "Inherited:Zinh:Qaai", 268 },	//  #292
	{ ptype::script_extensions, "Inscriptional_Pahlavi:Phli", 141 },	//  #293
	{ ptype::script_extensions, "Inscriptional_Parthian:Prti", 142 },	//  #294
	{ ptype::script_extensions, "Javanese:Java", 269 },	//  #295
	{ ptype::script_extensions, "Kaithi:Kthi", 270 },	//  #296
	{ ptype::script_extensions, "Kannada:Knda", 271 },	//  #297
	{ ptype::script_extensions, "Katakana:Kana", 272 },	//  #298
	{ ptype::script_extensions, "Kayah_Li:Kali", 273 },	//  #299
	{ ptype::script_extensions, "Kharoshthi:Khar", 148 },	//  #300
	{ ptype::script_extensions, "Khmer:Khmr", 149 },	//  #301
	{ ptype::script_extensions, "Khojki:Khoj", 274 },	//  #302
	{ ptype::script_extensions, "Khudawadi:Sind", 275 },	//  #303
	{ ptype::script_extensions, "Lao:Laoo", 152 },	//  #304
	{ ptype::script_extensions, "Latin:Latn", 276 },	//  #305
	{ ptype::script_extensions, "Lepcha:Lepc", 154 },	//  #306
	{ ptype::script_extensions, "Limbu:Limb", 277 },	//  #307
	{ ptype::script_extensions, "Linear_A:Lina", 278 },	//  #308
	{ ptype::script_extensions, "Linear_B:Linb", 279 },	//  #309
	{ ptype::script_extensions, "Lisu:Lisu", 158 },	//  #310
	{ ptype::script_extensions, "Lycian:Lyci", 159 },	//  #311
	{ ptype::script_extensions, "Lydian:Lydi", 160 },	//  #312
	{ ptype::script_extensions, "Mahajani:Mahj", 280 },	//  #313
	{ ptype::script_extensions, "Malayalam:Mlym", 281 },	//  #314
	{ ptype::script_extensions, "Mandaic:Mand", 282 },	//  #315
	{ ptype::script_extensions, "Manichaean:Mani", 283 },	//  #316
	{ ptype::script_extensions, "Marchen:Marc", 165 },	//  #317
	{ ptype::script_extensions, "Masaram_Gondi:Gonm", 284 },	//  #318
	{ ptype::script_extensions, "Meetei_Mayek:Mtei", 167 },	//  #319
	{ ptype::script_extensions, "Mende_Kikakui:Mend", 168 },	//  #320
	{ ptype::script_extensions, "Meroitic_Cursive:Merc", 169 },	//  #321
	{ ptype::script_extensions, "Meroitic_Hieroglyphs:Mero", 170 },	//  #322
	{ ptype::script_extensions, "Miao:Plrd", 171 },	//  #323
	{ ptype::script_extensions, "Modi:Modi", 285 },	//  #324
	{ ptype::script_extensions, "Mongolian:Mong", 286 },	//  #325
	{ ptype::script_extensions, "Mro:Mroo", 174 },	//  #326
	{ ptype::script_extensions, "Multani:Mult", 287 },	//  #327
	{ ptype::script_extensions, "Myanmar:Mymr", 288 },	//  #328
	{ ptype::script_extensions, "Nabataean:Nbat", 177 },	//  #329
	{ ptype::script_extensions, "New_Tai_Lue:Talu", 178 },	//  #330
	{ ptype::script_extensions, "Newa:Newa", 179 },	//  #331
	{ ptype::script_extensions, "Nko:Nkoo", 180 },	//  #332
	{ ptype::script_extensions, "Nushu:Nshu", 181 },	//  #333
	{ ptype::script_extensions, "Ogham:Ogam", 182 },	//  #334
	{ ptype::script_extensions, "Ol_Chiki:Olck", 183 },	//  #335
	{ ptype::script_extensions, "Old_Hungarian:Hung", 184 },	//  #336
	{ ptype::script_extensions, "Old_Italic:Ital", 185 },	//  #337
	{ ptype::script_extensions, "Old_North_Arabian:Narb", 186 },	//  #338
	{ ptype::script_extensions, "Old_Permic:Perm", 289 },	//  #339
	{ ptype::script_extensions, "Old_Persian:Xpeo", 188 },	//  #340
	{ ptype::script_extensions, "Old_South_Arabian:Sarb", 189 },	//  #341
	{ ptype::script_extensions, "Old_Turkic:Orkh", 190 },	//  #342
	{ ptype::script_extensions, "Oriya:Orya", 290 },	//  #343
	{ ptype::script_extensions, "Osage:Osge", 192 },	//  #344
	{ ptype::script_extensions, "Osmanya:Osma", 193 },	//  #345
	{ ptype::script_extensions, "Pahawh_Hmong:Hmng", 194 },	//  #346
	{ ptype::script_extensions, "Palmyrene:Palm", 195 },	//  #347
	{ ptype::script_extensions, "Pau_Cin_Hau:Pauc", 196 },	//  #348
	{ ptype::script_extensions, "Phags_Pa:Phag", 291 },	//  #349
	{ ptype::script_extensions, "Phoenician:Phnx", 198 },	//  #350
	{ ptype::script_extensions, "Psalter_Pahlavi:Phlp", 292 },	//  #351
	{ ptype::script_extensions, "Rejang:Rjng", 200 },	//  #352
	{ ptype::script_extensions, "Runic:Runr", 201 },	//  #353
	{ ptype::script_extensions, "Samaritan:Samr", 202 },	//  #354
	{ ptype::script_extensions, "Saurashtra:Saur", 203 },	//  #355
	{ ptype::script_extensions, "Sharada:Shrd", 293 },	//  #356
	{ ptype::script_extensions, "Shavian:Shaw", 205 },	//  #357
	{ ptype::script_extensions, "Siddham:Sidd", 206 },	//  #358
	{ ptype::script_extensions, "SignWriting:Sgnw", 207 },	//  #359
	{ ptype::script_extensions, "Sinhala:Sinh", 294 },	//  #360
	{ ptype::script_extensions, "Sora_Sompeng:Sora", 209 },	//  #361
	{ ptype::script_extensions, "Soyombo:Soyo", 210 },	//  #362
	{ ptype::script_extensions, "Sundanese:Sund", 211 },	//  #363
	{ ptype::script_extensions, "Syloti_Nagri:Sylo", 295 },	//  #364
	{ ptype::script_extensions, "Syriac:Syrc", 296 },	//  #365
	{ ptype::script_extensions, "Tagalog:Tglg", 297 },	//  #366
	{ ptype::script_extensions, "Tagbanwa:Tagb", 298 },	//  #367
	{ ptype::script_extensions, "Tai_Le:Tale", 299 },	//  #368
	{ ptype::script_extensions, "Tai_Tham:Lana", 217 },	//  #369
	{ ptype::script_extensions, "Tai_Viet:Tavt", 218 },	//  #370
	{ ptype::script_extensions, "Takri:Takr", 300 },	//  #371
	{ ptype::script_extensions, "Tamil:Taml", 301 },	//  #372
	{ ptype::script_extensions, "Tangut:Tang", 221 },	//  #373
	{ ptype::script_extensions, "Telugu:Telu", 302 },	//  #374
	{ ptype::script_extensions, "Thaana:Thaa", 303 },	//  #375
	{ ptype::script_extensions, "Thai:Thai", 224 },	//  #376
	{ ptype::script_extensions, "Tibetan:Tibt", 225 },	//  #377
	{ ptype::script_extensions, "Tifinagh:Tfng", 226 },	//  #378
	{ ptype::script_extensions, "Tirhuta:Tirh", 304 },	//  #379
	{ ptype::script_extensions, "Ugaritic:Ugar", 228 },	//  #380
	{ ptype::script_extensions, "Vai:Vaii", 229 },	//  #381
	{ ptype::script_extensions, "Warang_Citi:Wara", 230 },	//  #382
	{ ptype::script_extensions, "Yi:Yiii", 305 },	//  #383
	{ ptype::script_extensions, "Zanabazar_Square:Zanb", 232 },	//  #384
	{ ptype::script_extensions, "Dogra:Dogr", 306 },	//  #385
	{ ptype::script_extensions, "Gunjala_Gondi:Gong", 307 },	//  #386
	{ ptype::script_extensions, "Hanifi_Rohingya:Rohg", 308 },	//  #387
	{ ptype::script_extensions, "Makasar:Maka", 236 },	//  #388
	{ ptype::script_extensions, "Medefaidrin:Medf", 237 },	//  #389
	{ ptype::script_extensions, "Old_Sogdian:Sogo", 238 },	//  #390
	{ ptype::script_extensions, "Sogdian:Sogd", 309 },	//  #391
	{ ptype::script_extensions, "Elymaic:Elym", 240 },	//  #392
	{ ptype::script_extensions, "Nandinagari:Nand", 310 },	//  #393
	{ ptype::script_extensions, "Nyiakeng_Puachue_Hmong:Hmnp", 242 },	//  #394
	{ ptype::script_extensions, "Wancho:Wcho", 243 },	//  #395
	{ ptype::unknown, "", 0 }
};
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
const T6 unicode_property_data<T1, T2, T3, T4, T5, T6>::positiontable[] =
{
	{ 0, 0 },	//  #0 unknown
	{ 0, 692 },	//  #1 gc=Other:C
	{ 0, 2 },	//  #2 gc=Control:Cc:cntrl
	{ 2, 20 },	//  #3 gc=Format:Cf
	{ 22, 666 },	//  #4 gc=Unassigned:Cn
	{ 688, 3 },	//  #5 gc=Private_Use:Co
	{ 691, 1 },	//  #6 gc=Surrogate:Cs
	{ 692, 1824 },	//  #7 gc=Letter:L
	{ 692, 1288 },	//  #8 gc=Cased_Letter:LC
	{ 692, 642 },	//  #9 gc=Lowercase_Letter:Ll
	{ 1334, 10 },	//  #10 gc=Titlecase_Letter:Lt
	{ 1344, 636 },	//  #11 gc=Uppercase_Letter:Lu
	{ 1980, 60 },	//  #12 gc=Modifier_Letter:Lm
	{ 2040, 476 },	//  #13 gc=Other_Letter:Lo
	{ 2516, 491 },	//  #14 gc=Mark:M:Combining_Mark
	{ 2516, 168 },	//  #15 gc=Spacing_Mark:Mc
	{ 2684, 5 },	//  #16 gc=Enclosing_Mark:Me
	{ 2689, 318 },	//  #17 gc=Nonspacing_Mark:Mn
	{ 3007, 141 },	//  #18 gc=Number:N
	{ 3007, 59 },	//  #19 gc=Decimal_Number:Nd:digit
	{ 3066, 12 },	//  #20 gc=Letter_Number:Nl
	{ 3078, 70 },	//  #21 gc=Other_Number:No
	{ 3148, 370 },	//  #22 gc=Punctuation:P:punct
	{ 3148, 6 },	//  #23 gc=Connector_Punctuation:Pc
	{ 3154, 17 },	//  #24 gc=Dash_Punctuation:Pd
	{ 3171, 72 },	//  #25 gc=Close_Punctuation:Pe
	{ 3243, 10 },	//  #26 gc=Final_Punctuation:Pf
	{ 3253, 11 },	//  #27 gc=Initial_Punctuation:Pi
	{ 3264, 179 },	//  #28 gc=Other_Punctuation:Po
	{ 3443, 75 },	//  #29 gc=Open_Punctuation:Ps
	{ 3518, 294 },	//  #30 gc=Symbol:S
	{ 3518, 21 },	//  #31 gc=Currency_Symbol:Sc
	{ 3539, 29 },	//  #32 gc=Modifier_Symbol:Sk
	{ 3568, 64 },	//  #33 gc=Math_Symbol:Sm
	{ 3632, 180 },	//  #34 gc=Other_Symbol:So
	{ 3812, 9 },	//  #35 gc=Separator:Z
	{ 3812, 1 },	//  #36 gc=Line_Separator:Zl
	{ 3813, 1 },	//  #37 gc=Paragraph_Separator:Zp
	{ 3814, 7 },	//  #38 gc=Space_Separator:Zs
	{ 3821, 1 },	//  #39 bp=ASCII
	{ 3822, 3 },	//  #40 bp=ASCII_Hex_Digit:AHex
	{ 3825, 679 },	//  #41 bp=Alphabetic:Alpha
	{ 4504, 1 },	//  #42 bp=Any
	{ 4505, 0 },	//  #43 bp=Assigned
	{ 4505, 4 },	//  #44 bp=Bidi_Control:Bidi_C
	{ 4509, 113 },	//  #45 bp=Bidi_Mirrored:Bidi_M
	{ 4622, 401 },	//  #46 bp=Case_Ignorable:CI
	{ 5023, 140 },	//  #47 bp=Cased
	{ 5163, 612 },	//  #48 bp=Changes_When_Casefolded:CWCF
	{ 5775, 123 },	//  #49 bp=Changes_When_Casemapped:CWCM
	{ 5898, 599 },	//  #50 bp=Changes_When_Lowercased:CWL
	{ 6497, 823 },	//  #51 bp=Changes_When_NFKC_Casefolded:CWKCF
	{ 7320, 615 },	//  #52 bp=Changes_When_Titlecased:CWT
	{ 7935, 616 },	//  #53 bp=Changes_When_Uppercased:CWU
	{ 8551, 21 },	//  #54 bp=Dash
	{ 8572, 17 },	//  #55 bp=Default_Ignorable_Code_Point:DI
	{ 8589, 8 },	//  #56 bp=Deprecated:Dep
	{ 8597, 171 },	//  #57 bp=Diacritic:Dia
	{ 8768, 151 },	//  #58 bp=Emoji
	{ 8919, 10 },	//  #59 bp=Emoji_Component
	{ 8929, 1 },	//  #60 bp=Emoji_Modifier
	{ 8930, 36 },	//  #61 bp=Emoji_Modifier_Base
	{ 8966, 81 },	//  #62 bp=Emoji_Presentation
	{ 9047, 31 },	//  #63 bp=Extender:Ext
	{ 9078, 819 },	//  #64 bp=Grapheme_Base:Gr_Base
	{ 9897, 335 },	//  #65 bp=Grapheme_Extend:Gr_Ext
	{ 10232, 6 },	//  #66 bp=Hex_Digit:Hex
	{ 10238, 2 },	//  #67 bp=IDS_Binary_Operator:IDSB
	{ 10240, 1 },	//  #68 bp=IDS_Trinary_Operator:IDST
	{ 10241, 713 },	//  #69 bp=ID_Continue:IDC
	{ 10954, 609 },	//  #70 bp=ID_Start:IDS
	{ 11563, 16 },	//  #71 bp=Ideographic:Ideo
	{ 11579, 1 },	//  #72 bp=Join_Control:Join_C
	{ 11580, 7 },	//  #73 bp=Logical_Order_Exception:LOE
	{ 11587, 649 },	//  #74 bp=Lowercase:Lower
	{ 12236, 138 },	//  #75 bp=Math
	{ 12374, 18 },	//  #76 bp=Noncharacter_Code_Point:NChar
	{ 12392, 28 },	//  #77 bp=Pattern_Syntax:Pat_Syn
	{ 12420, 5 },	//  #78 bp=Pattern_White_Space:Pat_WS
	{ 12425, 13 },	//  #79 bp=Quotation_Mark:QMark
	{ 12438, 3 },	//  #80 bp=Radical
	{ 12441, 1 },	//  #81 bp=Regional_Indicator:RI
	{ 12442, 74 },	//  #82 bp=Sentence_Terminal:STerm
	{ 12516, 31 },	//  #83 bp=Soft_Dotted:SD
	{ 12547, 102 },	//  #84 bp=Terminal_Punctuation:Term
	{ 12649, 14 },	//  #85 bp=Unified_Ideograph:UIdeo
	{ 12663, 641 },	//  #86 bp=Uppercase:Upper
	{ 13304, 3 },	//  #87 bp=Variation_Selector:VS
	{ 13307, 10 },	//  #88 bp=White_Space:space
	{ 13317, 720 },	//  #89 bp=XID_Continue:XIDC
	{ 14037, 616 },	//  #90 bp=XID_Start:XIDS
	{ 14653, 77 },	//  #91 bp=Extended_Pictographic
	{ 14730, 3 },	//  #92 sc=Adlam:Adlm
	{ 14733, 3 },	//  #93 sc=Ahom:Ahom scx=Ahom:Ahom
	{ 14736, 1 },	//  #94 sc=Anatolian_Hieroglyphs:Hluw scx=Anatolian_Hieroglyphs:Hluw
	{ 14737, 57 },	//  #95 sc=Arabic:Arab
	{ 14794, 5 },	//  #96 sc=Armenian:Armn
	{ 14799, 2 },	//  #97 sc=Avestan:Avst scx=Avestan:Avst
	{ 14801, 2 },	//  #98 sc=Balinese:Bali scx=Balinese:Bali
	{ 14803, 2 },	//  #99 sc=Bamum:Bamu scx=Bamum:Bamu
	{ 14805, 2 },	//  #100 sc=Bassa_Vah:Bass scx=Bassa_Vah:Bass
	{ 14807, 2 },	//  #101 sc=Batak:Batk scx=Batak:Batk
	{ 14809, 14 },	//  #102 sc=Bengali:Beng
	{ 14823, 4 },	//  #103 sc=Bhaiksuki:Bhks scx=Bhaiksuki:Bhks
	{ 14827, 3 },	//  #104 sc=Bopomofo:Bopo
	{ 14830, 3 },	//  #105 sc=Brahmi:Brah scx=Brahmi:Brah
	{ 14833, 1 },	//  #106 sc=Braille:Brai scx=Braille:Brai
	{ 14834, 2 },	//  #107 sc=Buginese:Bugi
	{ 14836, 1 },	//  #108 sc=Buhid:Buhd
	{ 14837, 2 },	//  #109 sc=Canadian_Aboriginal:Cans scx=Canadian_Aboriginal:Cans
	{ 14839, 1 },	//  #110 sc=Carian:Cari scx=Carian:Cari
	{ 14840, 2 },	//  #111 sc=Caucasian_Albanian:Aghb scx=Caucasian_Albanian:Aghb
	{ 14842, 2 },	//  #112 sc=Chakma:Cakm
	{ 14844, 4 },	//  #113 sc=Cham:Cham scx=Cham:Cham
	{ 14848, 3 },	//  #114 sc=Cherokee:Cher scx=Cherokee:Cher
	{ 14851, 172 },	//  #115 sc=Common:Zyyy
	{ 15023, 3 },	//  #116 sc=Coptic:Copt:Qaac
	{ 15026, 4 },	//  #117 sc=Cuneiform:Xsux scx=Cuneiform:Xsux
	{ 15030, 6 },	//  #118 sc=Cypriot:Cprt
	{ 15036, 8 },	//  #119 sc=Cyrillic:Cyrl
	{ 15044, 1 },	//  #120 sc=Deseret:Dsrt scx=Deseret:Dsrt
	{ 15045, 4 },	//  #121 sc=Devanagari:Deva
	{ 15049, 5 },	//  #122 sc=Duployan:Dupl
	{ 15054, 2 },	//  #123 sc=Egyptian_Hieroglyphs:Egyp scx=Egyptian_Hieroglyphs:Egyp
	{ 15056, 1 },	//  #124 sc=Elbasan:Elba scx=Elbasan:Elba
	{ 15057, 32 },	//  #125 sc=Ethiopic:Ethi scx=Ethiopic:Ethi
	{ 15089, 10 },	//  #126 sc=Georgian:Geor
	{ 15099, 7 },	//  #127 sc=Glagolitic:Glag
	{ 15106, 1 },	//  #128 sc=Gothic:Goth scx=Gothic:Goth
	{ 15107, 15 },	//  #129 sc=Grantha:Gran
	{ 15122, 36 },	//  #130 sc=Greek:Grek
	{ 15158, 14 },	//  #131 sc=Gujarati:Gujr
	{ 15172, 16 },	//  #132 sc=Gurmukhi:Guru
	{ 15188, 17 },	//  #133 sc=Han:Hani
	{ 15205, 14 },	//  #134 sc=Hangul:Hang
	{ 15219, 1 },	//  #135 sc=Hanunoo:Hano
	{ 15220, 3 },	//  #136 sc=Hatran:Hatr scx=Hatran:Hatr
	{ 15223, 9 },	//  #137 sc=Hebrew:Hebr scx=Hebrew:Hebr
	{ 15232, 5 },	//  #138 sc=Hiragana:Hira
	{ 15237, 2 },	//  #139 sc=Imperial_Aramaic:Armi scx=Imperial_Aramaic:Armi
	{ 15239, 28 },	//  #140 sc=Inherited:Zinh:Qaai
	{ 15267, 2 },	//  #141 sc=Inscriptional_Pahlavi:Phli scx=Inscriptional_Pahlavi:Phli
	{ 15269, 2 },	//  #142 sc=Inscriptional_Parthian:Prti scx=Inscriptional_Parthian:Prti
	{ 15271, 3 },	//  #143 sc=Javanese:Java
	{ 15274, 2 },	//  #144 sc=Kaithi:Kthi
	{ 15276, 13 },	//  #145 sc=Kannada:Knda
	{ 15289, 9 },	//  #146 sc=Katakana:Kana
	{ 15298, 2 },	//  #147 sc=Kayah_Li:Kali
	{ 15300, 8 },	//  #148 sc=Kharoshthi:Khar scx=Kharoshthi:Khar
	{ 15308, 4 },	//  #149 sc=Khmer:Khmr scx=Khmer:Khmr
	{ 15312, 2 },	//  #150 sc=Khojki:Khoj
	{ 15314, 2 },	//  #151 sc=Khudawadi:Sind
	{ 15316, 11 },	//  #152 sc=Lao:Laoo scx=Lao:Laoo
	{ 15327, 32 },	//  #153 sc=Latin:Latn
	{ 15359, 3 },	//  #154 sc=Lepcha:Lepc scx=Lepcha:Lepc
	{ 15362, 5 },	//  #155 sc=Limbu:Limb
	{ 15367, 3 },	//  #156 sc=Linear_A:Lina
	{ 15370, 7 },	//  #157 sc=Linear_B:Linb
	{ 15377, 1 },	//  #158 sc=Lisu:Lisu scx=Lisu:Lisu
	{ 15378, 1 },	//  #159 sc=Lycian:Lyci scx=Lycian:Lyci
	{ 15379, 2 },	//  #160 sc=Lydian:Lydi scx=Lydian:Lydi
	{ 15381, 1 },	//  #161 sc=Mahajani:Mahj
	{ 15382, 8 },	//  #162 sc=Malayalam:Mlym
	{ 15390, 2 },	//  #163 sc=Mandaic:Mand
	{ 15392, 2 },	//  #164 sc=Manichaean:Mani
	{ 15394, 3 },	//  #165 sc=Marchen:Marc scx=Marchen:Marc
	{ 15397, 7 },	//  #166 sc=Masaram_Gondi:Gonm
	{ 15404, 3 },	//  #167 sc=Meetei_Mayek:Mtei scx=Meetei_Mayek:Mtei
	{ 15407, 2 },	//  #168 sc=Mende_Kikakui:Mend scx=Mende_Kikakui:Mend
	{ 15409, 3 },	//  #169 sc=Meroitic_Cursive:Merc scx=Meroitic_Cursive:Merc
	{ 15412, 1 },	//  #170 sc=Meroitic_Hieroglyphs:Mero scx=Meroitic_Hieroglyphs:Mero
	{ 15413, 3 },	//  #171 sc=Miao:Plrd scx=Miao:Plrd
	{ 15416, 2 },	//  #172 sc=Modi:Modi
	{ 15418, 7 },	//  #173 sc=Mongolian:Mong
	{ 15425, 3 },	//  #174 sc=Mro:Mroo scx=Mro:Mroo
	{ 15428, 5 },	//  #175 sc=Multani:Mult
	{ 15433, 3 },	//  #176 sc=Myanmar:Mymr
	{ 15436, 2 },	//  #177 sc=Nabataean:Nbat scx=Nabataean:Nbat
	{ 15438, 4 },	//  #178 sc=New_Tai_Lue:Talu scx=New_Tai_Lue:Talu
	{ 15442, 3 },	//  #179 sc=Newa:Newa scx=Newa:Newa
	{ 15445, 2 },	//  #180 sc=Nko:Nkoo scx=Nko:Nkoo
	{ 15447, 2 },	//  #181 sc=Nushu:Nshu scx=Nushu:Nshu
	{ 15449, 1 },	//  #182 sc=Ogham:Ogam scx=Ogham:Ogam
	{ 15450, 1 },	//  #183 sc=Ol_Chiki:Olck scx=Ol_Chiki:Olck
	{ 15451, 3 },	//  #184 sc=Old_Hungarian:Hung scx=Old_Hungarian:Hung
	{ 15454, 2 },	//  #185 sc=Old_Italic:Ital scx=Old_Italic:Ital
	{ 15456, 1 },	//  #186 sc=Old_North_Arabian:Narb scx=Old_North_Arabian:Narb
	{ 15457, 1 },	//  #187 sc=Old_Permic:Perm
	{ 15458, 2 },	//  #188 sc=Old_Persian:Xpeo scx=Old_Persian:Xpeo
	{ 15460, 1 },	//  #189 sc=Old_South_Arabian:Sarb scx=Old_South_Arabian:Sarb
	{ 15461, 1 },	//  #190 sc=Old_Turkic:Orkh scx=Old_Turkic:Orkh
	{ 15462, 14 },	//  #191 sc=Oriya:Orya
	{ 15476, 2 },	//  #192 sc=Osage:Osge scx=Osage:Osge
	{ 15478, 2 },	//  #193 sc=Osmanya:Osma scx=Osmanya:Osma
	{ 15480, 5 },	//  #194 sc=Pahawh_Hmong:Hmng scx=Pahawh_Hmong:Hmng
	{ 15485, 1 },	//  #195 sc=Palmyrene:Palm scx=Palmyrene:Palm
	{ 15486, 1 },	//  #196 sc=Pau_Cin_Hau:Pauc scx=Pau_Cin_Hau:Pauc
	{ 15487, 1 },	//  #197 sc=Phags_Pa:Phag
	{ 15488, 2 },	//  #198 sc=Phoenician:Phnx scx=Phoenician:Phnx
	{ 15490, 3 },	//  #199 sc=Psalter_Pahlavi:Phlp
	{ 15493, 2 },	//  #200 sc=Rejang:Rjng scx=Rejang:Rjng
	{ 15495, 2 },	//  #201 sc=Runic:Runr scx=Runic:Runr
	{ 15497, 2 },	//  #202 sc=Samaritan:Samr scx=Samaritan:Samr
	{ 15499, 2 },	//  #203 sc=Saurashtra:Saur scx=Saurashtra:Saur
	{ 15501, 2 },	//  #204 sc=Sharada:Shrd
	{ 15503, 1 },	//  #205 sc=Shavian:Shaw scx=Shavian:Shaw
	{ 15504, 2 },	//  #206 sc=Siddham:Sidd scx=Siddham:Sidd
	{ 15506, 3 },	//  #207 sc=SignWriting:Sgnw scx=SignWriting:Sgnw
	{ 15509, 13 },	//  #208 sc=Sinhala:Sinh
	{ 15522, 2 },	//  #209 sc=Sora_Sompeng:Sora scx=Sora_Sompeng:Sora
	{ 15524, 1 },	//  #210 sc=Soyombo:Soyo scx=Soyombo:Soyo
	{ 15525, 2 },	//  #211 sc=Sundanese:Sund scx=Sundanese:Sund
	{ 15527, 1 },	//  #212 sc=Syloti_Nagri:Sylo
	{ 15528, 4 },	//  #213 sc=Syriac:Syrc
	{ 15532, 2 },	//  #214 sc=Tagalog:Tglg
	{ 15534, 3 },	//  #215 sc=Tagbanwa:Tagb
	{ 15537, 2 },	//  #216 sc=Tai_Le:Tale
	{ 15539, 5 },	//  #217 sc=Tai_Tham:Lana scx=Tai_Tham:Lana
	{ 15544, 2 },	//  #218 sc=Tai_Viet:Tavt scx=Tai_Viet:Tavt
	{ 15546, 2 },	//  #219 sc=Takri:Takr
	{ 15548, 18 },	//  #220 sc=Tamil:Taml
	{ 15566, 3 },	//  #221 sc=Tangut:Tang scx=Tangut:Tang
	{ 15569, 12 },	//  #222 sc=Telugu:Telu
	{ 15581, 1 },	//  #223 sc=Thaana:Thaa
	{ 15582, 2 },	//  #224 sc=Thai:Thai scx=Thai:Thai
	{ 15584, 7 },	//  #225 sc=Tibetan:Tibt scx=Tibetan:Tibt
	{ 15591, 3 },	//  #226 sc=Tifinagh:Tfng scx=Tifinagh:Tfng
	{ 15594, 2 },	//  #227 sc=Tirhuta:Tirh
	{ 15596, 2 },	//  #228 sc=Ugaritic:Ugar scx=Ugaritic:Ugar
	{ 15598, 1 },	//  #229 sc=Vai:Vaii scx=Vai:Vaii
	{ 15599, 2 },	//  #230 sc=Warang_Citi:Wara scx=Warang_Citi:Wara
	{ 15601, 2 },	//  #231 sc=Yi:Yiii
	{ 15603, 1 },	//  #232 sc=Zanabazar_Square:Zanb scx=Zanabazar_Square:Zanb
	{ 15604, 1 },	//  #233 sc=Dogra:Dogr
	{ 15605, 6 },	//  #234 sc=Gunjala_Gondi:Gong
	{ 15611, 2 },	//  #235 sc=Hanifi_Rohingya:Rohg
	{ 15613, 1 },	//  #236 sc=Makasar:Maka scx=Makasar:Maka
	{ 15614, 1 },	//  #237 sc=Medefaidrin:Medf scx=Medefaidrin:Medf
	{ 15615, 1 },	//  #238 sc=Old_Sogdian:Sogo scx=Old_Sogdian:Sogo
	{ 15616, 1 },	//  #239 sc=Sogdian:Sogd
	{ 15617, 1 },	//  #240 sc=Elymaic:Elym scx=Elymaic:Elym
	{ 15618, 3 },	//  #241 sc=Nandinagari:Nand
	{ 15621, 4 },	//  #242 sc=Nyiakeng_Puachue_Hmong:Hmnp scx=Nyiakeng_Puachue_Hmong:Hmnp
	{ 15625, 2 },	//  #243 sc=Wancho:Wcho scx=Wancho:Wcho
	{ 15627, 4 },	//  #244 scx=Adlam:Adlm
	{ 15631, 52 },	//  #245 scx=Arabic:Arab
	{ 15683, 4 },	//  #246 scx=Armenian:Armn
	{ 15687, 26 },	//  #247 scx=Bengali:Beng
	{ 15713, 12 },	//  #248 scx=Bopomofo:Bopo
	{ 15725, 3 },	//  #249 scx=Buginese:Bugi
	{ 15728, 2 },	//  #250 scx=Buhid:Buhd
	{ 15730, 4 },	//  #251 scx=Chakma:Cakm
	{ 15734, 146 },	//  #252 scx=Common:Zyyy
	{ 15880, 4 },	//  #253 scx=Coptic:Copt:Qaac
	{ 15884, 9 },	//  #254 scx=Cypriot:Cprt
	{ 15893, 8 },	//  #255 scx=Cyrillic:Cyrl
	{ 15901, 7 },	//  #256 scx=Devanagari:Deva
	{ 15908, 5 },	//  #257 scx=Duployan:Dupl
	{ 15913, 10 },	//  #258 scx=Georgian:Geor
	{ 15923, 11 },	//  #259 scx=Glagolitic:Glag
	{ 15934, 25 },	//  #260 scx=Grantha:Gran
	{ 15959, 38 },	//  #261 scx=Greek:Grek
	{ 15997, 17 },	//  #262 scx=Gujarati:Gujr
	{ 16014, 19 },	//  #263 scx=Gurmukhi:Guru
	{ 16033, 33 },	//  #264 scx=Han:Hani
	{ 16066, 21 },	//  #265 scx=Hangul:Hang
	{ 16087, 1 },	//  #266 scx=Hanunoo:Hano
	{ 16088, 16 },	//  #267 scx=Hiragana:Hira
	{ 16104, 17 },	//  #268 scx=Inherited:Zinh:Qaai
	{ 16121, 3 },	//  #269 scx=Javanese:Java
	{ 16124, 4 },	//  #270 scx=Kaithi:Kthi
	{ 16128, 21 },	//  #271 scx=Kannada:Knda
	{ 16149, 15 },	//  #272 scx=Katakana:Kana
	{ 16164, 1 },	//  #273 scx=Kayah_Li:Kali
	{ 16165, 4 },	//  #274 scx=Khojki:Khoj
	{ 16169, 4 },	//  #275 scx=Khudawadi:Sind
	{ 16173, 39 },	//  #276 scx=Latin:Latn
	{ 16212, 6 },	//  #277 scx=Limbu:Limb
	{ 16218, 4 },	//  #278 scx=Linear_A:Lina
	{ 16222, 10 },	//  #279 scx=Linear_B:Linb
	{ 16232, 3 },	//  #280 scx=Mahajani:Mahj
	{ 16235, 12 },	//  #281 scx=Malayalam:Mlym
	{ 16247, 3 },	//  #282 scx=Mandaic:Mand
	{ 16250, 3 },	//  #283 scx=Manichaean:Mani
	{ 16253, 8 },	//  #284 scx=Masaram_Gondi:Gonm
	{ 16261, 3 },	//  #285 scx=Modi:Modi
	{ 16264, 6 },	//  #286 scx=Mongolian:Mong
	{ 16270, 6 },	//  #287 scx=Multani:Mult
	{ 16276, 4 },	//  #288 scx=Myanmar:Mymr
	{ 16280, 2 },	//  #289 scx=Old_Permic:Perm
	{ 16282, 18 },	//  #290 scx=Oriya:Orya
	{ 16300, 3 },	//  #291 scx=Phags_Pa:Phag
	{ 16303, 4 },	//  #292 scx=Psalter_Pahlavi:Phlp
	{ 16307, 7 },	//  #293 scx=Sharada:Shrd
	{ 16314, 14 },	//  #294 scx=Sinhala:Sinh
	{ 16328, 3 },	//  #295 scx=Syloti_Nagri:Sylo
	{ 16331, 10 },	//  #296 scx=Syriac:Syrc
	{ 16341, 3 },	//  #297 scx=Tagalog:Tglg
	{ 16344, 4 },	//  #298 scx=Tagbanwa:Tagb
	{ 16348, 3 },	//  #299 scx=Tai_Le:Tale
	{ 16351, 4 },	//  #300 scx=Takri:Takr
	{ 16355, 25 },	//  #301 scx=Tamil:Taml
	{ 16380, 16 },	//  #302 scx=Telugu:Telu
	{ 16396, 7 },	//  #303 scx=Thaana:Thaa
	{ 16403, 6 },	//  #304 scx=Tirhuta:Tirh
	{ 16409, 7 },	//  #305 scx=Yi:Yiii
	{ 16416, 3 },	//  #306 scx=Dogra:Dogr
	{ 16419, 7 },	//  #307 scx=Gunjala_Gondi:Gong
	{ 16426, 7 },	//  #308 scx=Hanifi_Rohingya:Rohg
	{ 16433, 2 },	//  #309 scx=Sogdian:Sogd
	{ 16435, 9 }	//  #310 scx=Nandinagari:Nand
};
#define SRELL_UPDATA_VERSION 110
class unicode_property
{
public:
	typedef regex_internal::uchar21_t uchar21_t;
	typedef unsigned int property_type;
	typedef simple_array<char> pstring;
	static const property_type error_property = static_cast<property_type>(-1);
	unicode_property()
	{
	}
	unicode_property &operator=(const unicode_property &)
	{
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	unicode_property &operator=(unicode_property &&) SRELL_NOEXCEPT
	{
		return *this;
	}
#endif
	static property_type lookup_property(const pstring &name, const pstring &value)
	{
		pname_type ptype = name.size() ? lookup_property_name(name) : updata::ptype::general_category;
		property_type property_number = lookup_property_value(ptype, value);
		if (property_number == updata::unknown && name.size() == 0)
		{
			ptype = updata::ptype::binary;
			property_number = lookup_property_value(ptype, value);
		}
		return property_number != updata::unknown ? property_number : error_property;
	}
	static std::size_t ranges_offset(const property_type property_number)
	{
#if defined(SRELL_UPDATA_VERSION)
		return updata::positiontable[property_number].offset;
#else
		const offset_and_number *const postable = updata::position_table();
		return postable[property_number].offset;
#endif
	}
	static std::size_t number_of_ranges(const property_type property_number)
	{
#if defined(SRELL_UPDATA_VERSION)
		return updata::positiontable[property_number].number_of_pairs;
#else
		const offset_and_number *const postable = updata::position_table();
		return postable[property_number].number_of_pairs;
#endif
	}
	static const uchar21_t *ranges_address(const property_type property_number)
	{
#if defined(SRELL_UPDATA_VERSION)
		return &updata::rangetable[ranges_offset(property_number) << 1];
#else
		const uchar21_t *const ranges = updata::ranges();
		return &ranges[ranges_offset(property_number) << 1];
#endif
	}
private:
	typedef unsigned int pname_type;
	typedef const char *pname_string_type;
	struct pvalue_type
	{
		pname_type pname;
		pname_string_type csstrings;
		property_type pnumber;
	};
	struct offset_and_number
	{
		std::size_t offset;
		std::size_t number_of_pairs;
	};
	typedef unicode_property_data<property_type,
		pname_type,
		pname_string_type,
		uchar21_t,
		pvalue_type,
		offset_and_number
		>
		updata;
	static pname_type lookup_property_name(const pstring &name)
	{
#if defined(SRELL_UPDATA_VERSION)
		for (std::size_t pno = 0; *updata::propertynametable[pno]; ++pno)
		{
			if (check_if_included(name, updata::propertynametable[pno]))
				return static_cast<pname_type>(pno);
		}
#else
		const pname_string_type *const pname_table = updata::propertyname_table();
		for (std::size_t pno = 0; *pname_table[pno]; ++pno)
		{
			if (check_if_included(name, pname_table[pno]))
				return static_cast<pname_type>(pno);
		}
#endif
		return updata::ptype::unknown;
	}
	//  check if value is included in colon-separated strings.
	static bool check_if_included(const pstring &value, pname_string_type csstrings)
	{
		if (*csstrings != meta_char::mc_astrsk)	//  '*'
		{
			while (*csstrings)
			{
				const pname_string_type begin = csstrings;
				for (; *csstrings != meta_char::mc_colon && *csstrings != char_ctrl::cc_nul; ++csstrings);
				const std::size_t length = csstrings - begin;
				if (static_cast<std::size_t>(value.size()) == length)
					if (value.compare(0, value.size(), begin, length) == 0)
						return true;
				if (*csstrings == meta_char::mc_colon)
					++csstrings;
			}
		}
		return false;
	}
	static property_type lookup_property_value(const pname_type ptype, const pstring &value)
	{
#if defined(SRELL_UPDATA_VERSION)
		for (std::size_t pno = 0; *updata::rangenumbertable[pno].csstrings; ++pno)
		{
			const pvalue_type &pvalue = updata::rangenumbertable[pno];
			if (pvalue.pname == ptype && check_if_included(value, pvalue.csstrings))
				return pvalue.pnumber;
		}
#else
		const pvalue_type *const pvalue_table = updata::rangenumber_table();
		for (std::size_t pno = 0; *pvalue_table[pno].csstrings; ++pno)
		{
			const pvalue_type &pvalue = pvalue_table[pno];
			if (pvalue.pname == ptype && check_if_included(value, pvalue.csstrings))
				return pvalue.pnumber;
		}
#endif
		return updata::unknown;
	}
public:
	static const std::size_t number_of_properties = updata::last_property_number + 1;
	static const property_type gc_Zs = updata::gc_Space_Separator;
	static const property_type gc_Cn = updata::gc_Unassigned;
	static const property_type bp_Assigned = updata::bp_Assigned;
};
#endif	//  !defined(SRELL_NO_UNICODE_PROPERTY)
	}	//  namespace regex_internal
	namespace regex_internal
	{
struct range_pair	//  , public std::pair<charT, charT>
{
	uchar21_t first;
	uchar21_t second;
	bool is_range_valid() const
	{
		return first <= second;
	}
	bool operator==(const range_pair &right) const
	{
		return this->first == right.first && this->second == right.second;
	}
	bool operator<(const range_pair &right) const
	{
		return this->second < right.first;	//  This assumes that optimise() has been called.
	}
	void swap(range_pair &right)
	{
		const range_pair tmp = *this;
		*this = right;
		right = tmp;
	}
	bool unify_range(const range_pair &right)
	{
		range_pair &left = *this;
		if (right.first <= left.second || left.second + 1 == right.first)	//  r1 <= l2 || l2+1 == r1
		{
			//  l1 l2+1 < r1 r2 excluded.
			if (left.first <= right.second || right.second + 1 == left.first)	//  l1 <= r2 || r2+1 == l1
			{
				//  r1 r2+1 < l1 l2 excluded.
				if (left.first > right.first)
					left.first = right.first;
				if (left.second < right.second)
					left.second = right.second;
				return true;
			}
		}
		return false;
	}
};
struct range_pair_helper : public range_pair
{
	range_pair_helper(const uchar21_t &min, const uchar21_t &max)
	{
		this->first = min;
		this->second = max;
	}
	range_pair_helper(const uchar21_t &minmax)
	{
		this->first = minmax;
		this->second = minmax;
	}
#if 0
	range_pair_helper(const range_pair &right)
	{
		this->first = right.first;
		this->second = right.second;
	}
#endif
};
struct range_pairs	//  : public simple_array<range_pair>
{
public:
	typedef simple_array<range_pair> array_type;
	typedef array_type::size_type size_type;
	range_pairs()
	{
	}
	range_pairs(const range_pairs &rp) : rparray_(rp.rparray_)
	{
	}
	range_pairs &operator=(const range_pairs &rp)
	{
		rparray_.operator=(rp.rparray_);
		return *this;
	}
	range_pairs(const size_type initsize) : rparray_(initsize)
	{
	}
	range_pairs(const range_pairs &right, size_type pos, size_type size)
		: rparray_(right.rparray_, pos, size)
	{
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	range_pairs(range_pairs &&rp) SRELL_NOEXCEPT
		: rparray_(std::move(rp.rparray_))
	{
	}
	range_pairs &operator=(range_pairs &&rp) SRELL_NOEXCEPT
	{
		rparray_.operator=(std::move(rp.rparray_));
		return *this;
	}
#endif
	void clear()
	{
		rparray_.clear();
	}
	size_type size() const
	{
		return rparray_.size();
	}
	const range_pair &operator[](const size_type pos) const
	{
		return rparray_[pos];
	}
	range_pair &operator[](const size_type pos)
	{
		return rparray_[pos];
	}
	void resize(const size_type size)
	{
		rparray_.resize(size);
	}
	void replace(const size_type pos, const size_type count, const range_pairs &right)
	{
		rparray_.replace(pos, count, right.rparray_);
	}
	void swap(range_pairs &right)
	{
		rparray_.swap(right.rparray_);
	}
	void set_solerange(const range_pair &right)
	{
		rparray_.push_back(right);
	}
	void append_newclass(const range_pairs &right)
	{
		rparray_.append(right.rparray_);
	}
	void append_newpair(const range_pair &right)
	{
		rparray_.push_back(right);
	}
	void join(const range_pair &right)
	{
		size_type pos = 0;
		for (; pos < rparray_.size(); ++pos)
		{
			range_pair &curpair = rparray_[pos];
			if (curpair.unify_range(right))
			{
				for (++pos; pos < rparray_.size();)
				{
					if (curpair.unify_range(rparray_[pos]))
						rparray_.erase(pos);
					else
						break;
				}
				return;
			}
			if (right.second < curpair.first)
				break;
		}
		rparray_.insert(pos, right);
	}
	void merge(const range_pairs &right)
	{
		for (size_type i = 0; i < right.size(); ++i)
			join(right[i]);
	}
#if defined(SRELLDBG_NO_BITSET)
	bool is_included(const uchar21_t &ch) const
	{
#if 01
		const range_pair *const end = rparray_.data() + rparray_.size();
		for (const range_pair *cur = rparray_.data(); cur != end; ++cur)
		{
			//  This assumes that sort() has been called.
			if (ch <= cur->second)
				return ch >= cur->first;
#else
		for (size_type i = 0; i < rparray_.size(); ++i)
		{
			if (rparray_[i].is_included(ch))
				return true;
#endif
		}
		return false;
	}
#endif	//  defined(SRELLDBG_NO_BITSET)
	bool is_included(const uchar21_t &pos, uchar21_t count, const uchar21_t &c) const
	{
		const range_pair *base = &rparray_[pos];
		while (count)
		{
			uchar21_t mid = count >> 1;
			const range_pair &rp = base[mid];
			if (c >= rp.first)
			{
				if (c <= rp.second)
					return true;
				++mid;
				count -= mid;
				base += mid;
			}
			else
				count = mid;
		}
		return false;
	}
	bool same(uchar21_t pos, const uchar21_t &count, const range_pairs &right) const
	{
		if (count == right.size())
		{
			for (uchar21_t i = 0; i < count; ++i, ++pos)
				if (!(rparray_[pos] == right[i]))
					return false;
			return true;
		}
		return false;
	}
	void negation()
	{
		uchar21_t begin = 0;
		range_pairs newpairs;
#if 01	//  begin does not pass 0x10ffff.
		for (size_type i = 0;; ++i)
		{
			if (i == rparray_.size())
			{
				newpairs.join(range_pair_helper(begin, constants::unicode_max_codepoint));
				break;
			}
			else
			{
				const range_pair &range = rparray_[i];
				if (begin < range.first)
					newpairs.join(range_pair_helper(begin, range.first - 1));
				if (range.second == constants::unicode_max_codepoint)
					break;
				begin = range.second + 1;
			}
		}
#else	//  begin can pass 0x10ffff, but safe.
		for (size_type i = 0; i < rparray_.size(); ++i)
		{
			const range_pair &range = rparray_[i];
			if (begin < range.first)
				newpairs.push_back(range_pair_helper(begin, range.first - 1));
			begin = range.second + 1;
		}
		if (begin <= constants::unicode_max_codepoint)
			newpairs.push_back(range_pair_helper(begin, constants::unicode_max_codepoint));
#endif
		*this = newpairs;
	}
	bool is_overlap(const range_pairs &right) const
	{
		for (size_type i = 0; i < rparray_.size(); ++i)
		{
			const range_pair &leftrange = rparray_[i];
			for (size_type j = 0; j < right.size(); ++j)
			{
				const range_pair &rightrange = right[j];
				if (rightrange.first <= leftrange.second)	//  Excludes l1 l2 < r1 r2.
					if (leftrange.first <= rightrange.second)	//  Excludes r1 r2 < l1 l2.
						return true;
			}
		}
		return false;
	}
	void load_from_memory(const uchar21_t *array, size_type number_of_pairs)
	{
		for (; number_of_pairs; --number_of_pairs, array += 2)
			join(range_pair_helper(array[0], array[1]));
	}
	void make_caseunfoldedcharset()
	{
		uchar21_t table[unicode_case_folding::rev_maxset] = {};
		bitset<constants::unicode_max_codepoint + 1> bs;
		for (size_type i = 0; i < rparray_.size(); ++i)
		{
			const range_pair &range = rparray_[i];
			for (uchar21_t ucp = range.first; ucp <= range.second; ++ucp)
			{
				const uchar21_t setnum = unicode_case_folding::casefoldedcharset(table, ucp);
				for (uchar21_t j = 0; j < setnum; ++j)
					bs.set(table[j]);
			}
		}
		load_from_bitset(bs);
	}
	//  For updataout.hpp.
	void remove_range(const range_pair &right)
	{
		for (size_type pos = 0; pos < rparray_.size();)
		{
			range_pair &left = rparray_[pos];
			if (right.first <= left.first && left.first <= right.second)	//  r1 <= l1 <= r2.
			{
				if (left.second > right.second)	//  r1 <= l1 <= r2 < l2.
				{
					left.first = right.second + 1;	//  carry doesn't happen.
					++pos;
				}
				else	//  r1 <= l1 <= l2 <= r2.
					rparray_.erase(pos);
			}
			else if (right.first <= left.second && left.second <= right.second)	//  r1 <= l2 <= r2.
			{
				if (left.first < right.first)	//  l1 < r1 <= l2 <= r2.
				{
					left.second = right.first - 1;
					++pos;
				}
				else	//  r1 <= l1 <= l2 <= r2.
					rparray_.erase(pos);
			}
			else if (left.first < right.first && right.second < left.second)	//  l1 < r1 && r2 < l2.
			{
				range_pair newrange(left);
				left.second = right.first - 1;
				newrange.first = right.second + 1;
				rparray_.insert(++pos, newrange);
				++pos;
			}
			else
				++pos;
		}
	}
	uchar21_t consists_of_one_character(const bool icase) const
	{
		if (rparray_.size() >= 1)
		{
			uchar21_t (*const casefolding_func)(const uchar21_t) = !icase ? do_nothing : unicode_case_folding::do_casefolding;
			const uchar21_t ucp1st = casefolding_func(rparray_[0].first);
			for (size_type no = 0; no < rparray_.size(); ++no)
			{
				const range_pair &cr = rparray_[no];
				for (uchar21_t ucp = cr.first;; ++ucp)
				{
					if (ucp1st != casefolding_func(ucp))
						return constants::invalid_u21value;
					if (ucp == cr.second)
						break;
				}
			}
			return ucp1st;
		}
		return constants::invalid_u21value;
	}
private:
	static uchar21_t do_nothing(const uchar21_t cp)
	{
		return cp;
	}
	template <typename BitSetT>
	void load_from_bitset(const BitSetT &bs)
	{
		uchar21_t begin = constants::invalid_u21value;
		range_pairs newranges;
		for (uchar21_t ucp = 0;; ++ucp)
		{
#if 01	//  ucp does not pass 0x10ffff.
			if (ucp == constants::unicode_max_codepoint)
			{
				if (bs.test(ucp))
				{
					if (begin == constants::invalid_u21value)
						begin = ucp;
				}
				else
					--ucp;
				if (begin != constants::invalid_u21value)
				{
					newranges.join(range_pair_helper(begin, ucp));
				}
				break;
			}
			else if (!bs.test(ucp))
			{
				if (begin != constants::invalid_u21value)
				{
					newranges.join(range_pair_helper(begin, ucp - 1));
					begin = constants::invalid_u21value;
				}
			}
			else if (begin == constants::invalid_u21value)
				begin = ucp;
#else	//  ucp can pass 0x10ffff, but safe.
			if (ucp > constants::unicode_max_codepoint || !bs.test(ucp))
			{
				if (begin != constants::invalid_u21value)
				{
					newranges.push_back(range_pair_helper(begin, ucp - 1));
					begin = constants::invalid_u21value;
				}
				if (ucp > constants::unicode_max_codepoint)
					break;
			}
			else if (begin == constants::invalid_u21value && bs.test(ucp))
				begin = ucp;
#endif
		}
		rparray_.swap(newranges.rparray_);
	}
	array_type rparray_;
public:	//  for debug.
	void print_pairs(const bool, const char *const = NULL, const char *const = NULL) const;
};
class re_character_class
{
public:
	enum
	{	//    0       1      2      3     4           5                    6
		newline, dotall, space, digit, word, icase_word, number_of_predefcls
	};
	static const unsigned int error_property = static_cast<unsigned int>(-1);
#if !defined(SRELL_NO_UNICODE_PROPERTY)
	typedef unicode_property::pstring pstring;
#endif
	re_character_class()
	{
		setup_predefinedclass();
	}
	re_character_class &operator=(const re_character_class &that)
	{
		if (this != &that)
		{
			this->char_class_ = that.char_class_;
			this->char_class_pos_ = that.char_class_pos_;
		}
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	re_character_class &operator=(re_character_class &&that) SRELL_NOEXCEPT
	{
		if (this != &that)
		{
			this->char_class_ = std::move(that.char_class_);
			this->char_class_pos_ = std::move(that.char_class_pos_);
		}
		return *this;
	}
#endif
	bool is_included(const unsigned int &class_number, const uchar21_t &c) const
	{
		const range_pair &rp = char_class_pos_[class_number];
		return char_class_.is_included(rp.first, rp.second, c);
	}
#if !defined(SRELLDBG_NO_CCPOS)
	bool is_included(const uchar21_t &pos, const uchar21_t &len, const uchar21_t &c) const
	{
		return char_class_.is_included(pos, len, c);
	}
#endif
	bool setup_icase_word()
	{
		range_pair &icase_pos = char_class_pos_[icase_word];
		if (icase_pos.second == char_class_pos_[word].second)
		{
			range_pairs icasewordclass(char_class_, icase_pos.first, icase_pos.second);
			icasewordclass.make_caseunfoldedcharset();
				//  Includes 017f and 212a so that they and their case-folded
				//  characters 's' and 'k' will be excluded from the character
				//  set that /[\W]/i matches.
			char_class_.replace(icase_pos.first, icase_pos.second, icasewordclass);
			if (icase_pos.second < static_cast<uchar21_t>(icasewordclass.size()))
			{
				const uchar21_t delta = static_cast<uchar21_t>(icasewordclass.size() - icase_pos.second);
				for (int i = number_of_predefcls; i < static_cast<int>(char_class_pos_.size()); ++i)
					char_class_pos_[i].first += delta;
			}
			icase_pos.second = static_cast<uchar21_t>(icasewordclass.size());
		}
		return true;
	}
	void clear()
	{
		char_class_pos_.resize(number_of_predefcls);
		uchar21_t basesize = 0;
		for (int i = 0; i < number_of_predefcls; ++i)
			basesize += char_class_pos_[i].second;
		char_class_.resize(basesize);
	}
	unsigned int register_newclass(const range_pairs &rps)
	{
		for (range_pairs::size_type no = 0; no < char_class_pos_.size(); ++no)
		{
			const range_pair &rp = char_class_pos_[no];
			if (char_class_.same(rp.first, rp.second, rps))
				return static_cast<unsigned int>(no);
		}
		append_charclass(rps);
		return static_cast<unsigned int>(char_class_pos_.size() - 1);
	}
	range_pairs operator[](const unsigned int no) const
	{
		const range_pair &ccpos = char_class_pos_[no];
		range_pairs rp(ccpos.second);
		for (uchar21_t i = 0; i < ccpos.second; ++i)
			rp[i] = char_class_[ccpos.first + i];
		return rp;
	}
#if !defined(SRELLDBG_NO_CCPOS)
	const range_pair &charclasspos(const unsigned int no) const
	{
		return char_class_pos_[no];
	}
#endif
	void optimise()
	{
	}
#if !defined(SRELL_NO_UNICODE_PROPERTY)
	unsigned int lookup_property(const pstring &pname, const pstring &pvalue, const bool icase)
	{
		const unsigned int property_number = static_cast<unsigned int>(unicode_property::lookup_property(pname, pvalue));
		if (property_number != unicode_property::error_property)
		{
			const unsigned int charclass_number = register_property_as_charclass(property_number, icase);
			return charclass_number;
		}
		return error_property;
	}
#endif
	void swap(re_character_class &right)
	{
		if (this != &right)
		{
			this->char_class_.swap(right.char_class_);
			this->char_class_pos_.swap(right.char_class_pos_);
		}
	}
private:
#if !defined(SRELL_NO_UNICODE_PROPERTY)
	unsigned int register_property_as_charclass(const unsigned int property_number, const bool icase)
	{
		if (property_number == unicode_property::bp_Assigned)
		{
			//  \p{Assigned} == \P{Cn}
			return load_updata_and_register_as_charclass(unicode_property::gc_Cn, false, true);
		}
		return load_updata_and_register_as_charclass(property_number, icase, false);
	}
	unsigned int load_updata_and_register_as_charclass(const unsigned int property_number, const bool icase, const bool negation)
	{
		const uchar21_t *const address = unicode_property::ranges_address(property_number);
		const std::size_t number = unicode_property::number_of_ranges(property_number);
		range_pairs newranges;
		newranges.load_from_memory(address, number);
		if (icase)
			newranges.make_caseunfoldedcharset();
		if (negation)
			newranges.negation();
		return register_newclass(newranges);
	}
#endif	//  !defined(SRELL_NO_UNICODE_PROPERTY)
	void append_charclass(const range_pairs &rps)
	{
		char_class_pos_.push_back(range_pair_helper(static_cast<uchar21_t>(char_class_.size()), static_cast<uchar21_t>(rps.size())));
		char_class_.append_newclass(rps);
	}
	void setup_predefinedclass()
	{
#if !defined(SRELL_NO_UNICODE_PROPERTY)
		const uchar21_t *const Zs_address = unicode_property::ranges_address(unicode_property::gc_Zs);
		const std::size_t Zs_number = unicode_property::number_of_ranges(unicode_property::gc_Zs);
#else
		static const uchar21_t Zs[] = {
			0x1680, 0x1680, 0x2000, 0x200a,	// 0x2028, 0x2029,
			0x202f, 0x202f, 0x205f, 0x205f, 0x3000, 0x3000
		};
#endif	//  defined(SRELL_NO_UNICODE_PROPERTY)
		static const uchar21_t allranges[] = {
			//  dotall.
			0x0000, 0x10ffff,
			//  newline.
			0x0a, 0x0a, 0x0d, 0x0d,	//  \n \r
			//  newline, space.
			0x2028, 0x2029,
			//  space.
			0x09, 0x0d,	//  \t \n \v \f \r
			0x20, 0x20,	//  ' '
			0xa0, 0xa0,	//  <NBSP>
			0xfeff, 0xfeff,	//  <BOM>
			//  digit, word.
			0x30, 0x39,	//  '0'-'9'
			0x41, 0x5a, 0x5f, 0x5f, 0x61, 0x7a	//  'A'-'Z' '_' 'a'-'z'
		};
		range_pairs ranges;
		//  newline
		ranges.load_from_memory(&allranges[2], 3);
		append_charclass(ranges);
		//  dotall
		ranges.clear();
		ranges.load_from_memory(&allranges[0], 1);
		append_charclass(ranges);
		//  space
		ranges.clear();
		ranges.load_from_memory(&allranges[6], 5);
#if !defined(SRELL_NO_UNICODE_PROPERTY)
		ranges.load_from_memory(Zs_address, Zs_number);
#else
		ranges.load_from_memory(Zs, 5);
#endif
		append_charclass(ranges);
		//  digit
		ranges.clear();
		ranges.load_from_memory(&allranges[16], 1);
		append_charclass(ranges);
		//  word
		ranges.clear();
		ranges.load_from_memory(&allranges[16], 4);
		append_charclass(ranges);
		//  reservation for icase_word.
		append_charclass(ranges);
	}
private:
	range_pairs char_class_;
	range_pairs::array_type char_class_pos_;
public:	//  for debug.
	void print_classes(const bool, const bool) const;
};
	}	//  namespace regex_internal
	namespace regex_internal
	{
#if !defined(SRELL_NO_NAMEDCAPTURE)
template <typename numberT>
class groupname_and_backrefnumber_mapper
{
public:
	typedef simple_array<uchar21_t> u21string;
	typedef typename u21string::size_type size_type;
	static const numberT notfound = static_cast<numberT>(-1);
	groupname_and_backrefnumber_mapper()
	{
	}
	groupname_and_backrefnumber_mapper(const groupname_and_backrefnumber_mapper &right)
		: names_(right.names_)
	{
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	groupname_and_backrefnumber_mapper(groupname_and_backrefnumber_mapper &&right) SRELL_NOEXCEPT
		: names_(std::move(right.names_))
	{
	}
#endif
	groupname_and_backrefnumber_mapper &operator=(const groupname_and_backrefnumber_mapper &right)
	{
		if (this != &right)
			names_ = right.names_;
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	groupname_and_backrefnumber_mapper &operator=(groupname_and_backrefnumber_mapper &&right) SRELL_NOEXCEPT
	{
		if (this != &right)
			names_ = std::move(right.names_);
		return *this;
	}
#endif
	void clear()
	{
		names_.clear();
	}
	bool push_back(const u21string &gname, const numberT class_number)
	{
		const numberT num = operator[](gname);
		if (num == notfound)
		{
			if (gname.size() < 0x1fffff)
			{
				names_.append(1, static_cast<uchar21_t>(gname.size()));
				names_.append(gname);
				names_.append(1, static_cast<uchar21_t>(class_number));
				return true;
			}
			//  overflow.
		}
		return false;	//  already exists.
	}
	numberT operator[](const u21string &gname) const
	{
		for (size_type i = 0; i < names_.size(); ++i)
		{
			const numberT keysize = static_cast<numberT>(names_[i++]);
			if (keysize == static_cast<numberT>(gname.size()) && sameseq(i, gname))
				return *reinterpret_cast<const numberT *>(&names_[i + keysize]);
			i += keysize;
		}
		return notfound;
	}
	u21string operator[](const numberT indexno) const
	{
		for (size_type i = 0; i < names_.size(); ++i)
		{
			const numberT keysize = static_cast<numberT>(names_[i++]);
			const numberT classno = static_cast<numberT>(names_[i + keysize]);
			if (classno == indexno)
				return u21string(names_, i, keysize);
			i += keysize;
		}
		return u21string();
	}
	size_type size() const
	{
		size_type count = 0;
		for (size_type i = 0; i < names_.size(); ++count)
			i += names_[i] + 2;
		return count;
	}
	void swap(groupname_and_backrefnumber_mapper &right)
	{
		this->names_.swap(right.names_);
	}
private:
	bool sameseq(size_type pos, const u21string &gname) const
	{
		for (size_type i = 0; i < gname.size(); ++i, ++pos)
			if (pos >= names_.size() || names_[pos] != gname[i])
				return false;
		return true;
	}
	u21string names_;
public:
	void print_mappings() const;	//  DEBUG.
};
typedef groupname_and_backrefnumber_mapper<unsigned int> groupname_mapper;
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
	}	//  namespace regex_internal
	namespace regex_internal
	{
struct re_quantifier
{
	static const unsigned int infinity = static_cast<unsigned int>(~0);
	//  atleast and atmost: for check_counter.
	//  offset and length: for charcter_class.
	//  (special case 1) in roundbracket_open atleast and atmost represent the
	//    minimum and maximum bracket numbers respectively inside the brackets itself.
	//  (special case 2) in repeat_in atleast and atmost represent the minimum and
	//    maximum bracket numbers respectively inside the repetition.
	union
	{
		unsigned int atleast;
		//  (special case 3: v1) in lookaround_open represents the number of characters to be rewound.
		//  (special case 3: v2) in lookaround_open represents whether lookaheads (0) or lookbehinds (1).
		uchar21_t offset;
	};
	union
	{
		unsigned int atmost;
		uchar21_t length;
	};
	union
	{
		bool is_greedy;
		unsigned int padding_;
	};
	void reset(const unsigned int len = 1)
	{
		atleast = atmost = len;
		is_greedy = true;
	}
	void set(const unsigned int min, const unsigned int max)
	{
		atleast = min;
		atmost = max;
	}
	void setccpos(const uchar21_t o, const uchar21_t l)
	{
		offset = o;
		length = l;
	}
	bool is_valid() const
	{
		return atleast <= atmost && atmost > 0;
	}
	void set_infinity()
	{
		atmost = infinity;
	}
	bool is_infinity() const
	{
		return atmost == infinity;
	}
	bool is_same() const
	{
		return atleast == atmost;
	}
	bool is_default() const
	{
		return atleast == 1 && atmost == 1;
	}
	bool is_asterisk() const
	{
		return atleast == 0 && atmost == infinity;
	}
	bool is_plus() const
	{
		return atleast == 1 && atmost == infinity;
	}
	bool is_asterisk_or_plus() const
	{
		return atleast <= 1 && atmost == infinity;
	}
	bool has_simple_equivalence() const
	{
		return (atleast <= 1 && atmost <= 3) || (atleast == 2 && atmost <= 4) || (atleast == atmost && atmost <= 6);
	}
	void multiply(const re_quantifier &q)
	{
		if (atleast != infinity)
		{
			if (q.atleast != infinity)
				atleast *= q.atleast;
			else
				atleast = infinity;
		}
		if (atmost != infinity)
		{
			if (q.atmost != infinity)
				atmost *= q.atmost;
			else
				atmost = infinity;
		}
	}
	void add(const re_quantifier &q)
	{
		if (atleast != infinity)
		{
			if (q.atleast != infinity && (atleast + q.atleast) >= atleast)
				atleast += q.atleast;
			else
				atleast = infinity;
		}
		if (atmost != infinity)
		{
			if (q.atmost != infinity && (atmost + q.atmost) >= atmost)
				atmost += q.atmost;
			else
				atmost = infinity;
		}
	}
};
struct re_state
{
	union
	{
		uchar21_t character;	//  for character.
		unsigned int number;	//  for character_class, brackets, counter, repeat, backreference.
	};
	re_state_type type;
	union
	{
		std::ptrdiff_t next1;
		re_state *next_state1;
		//  points to the next state.
		//  (Special Case 1) in lookaround_open points to the next of lookaround_close.
		//  (Special Case 2) in lookaround_pop points to the content of brackets instead of lookaround_open.
	};
	union
	{
		std::ptrdiff_t next2;
		re_state *next_state2;
		//  character and character_class: points to another possibility, non-backtracking.
		//  epsilon: points to another possibility, backtracking.
		//  increment_counter, save_and_reset_counter, roundbracket_open, repeat_in_push,
		//    and lookaround_open: points to a restore state, backtracking.
		//  check_counter: complementary to next1 based on quantifier.is_greedy.
		//  (Special Case) roundbracket_close, check_0_width_repeat, and backreference:
		//    points to the next state as an exit after 0 width match.
	};
	re_quantifier quantifier;	//  for check_counter, roundbrackets, repeasts, (?<=...) and (?<!...),
		//  and character_class.
	union
	{
		bool is_not;	//  for \B, (?!...) and (?<!...).
		bool dont_push;	//  for check_counter.
		bool backrefnumber_unresolved;	//  for backreference (used only in compiler).
		unsigned int padding_;
	};
	//  st_character,               //  0x00
		//  char/number:        character
		//  next1:              gen.
		//  next2:              +1 (exit. used only when '*')
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_character_class,         //  0x01
		//  char/number:        character class number
		//  next1:              gen.
		//  next2:              +1 (exit. used only when '*')
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_epsilon,                 //  0x02
		//  char/number:        -
		//  next1:              gen.
		//  next2:              alt.
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_check_counter,           //  0x03
		//  char/number:        counter number
		//  next1:              greedy: increment_counter or repeat_in_push
		//                      not-greedy: out-of-loop
		//  next2:              complementary to next1
		//  q.atleast:          gen.
		//  q.atmost:           gen.
		//  q.greedy:           gen.
		//  is_not/dont_push:   dont_push (don't push backtracking data)
	//  st_increment_counter,       //  0x04
		//  char/number:        counter number
		//  next1:              +2 (next of decrement_counter, atom)
		//  next2:              +1 (decrement_counter)
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_decrement_counter,       //  0x05
		//  char/number:        counter number
		//  next1:              0 (always treated as "not matched")
		//  next2:              0
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_save_and_reset_counter,  //  0x06
		//  char/number:        counter number
		//  next1:              +2 (check_counter)
		//  next2:              +1 (restore_counter)
		//  quantifiers:        -
		//  is_not/dont_push:   - (was dont_push)
	//  st_restore_counter,         //  0x07
		//  char/number:        counter number
		//  next1:              0 (always treated as "not matched")
		//  next2:              0
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_roundbracket_open,       //  0x08
		//  char/number:        bracket number
		//  next1:              +2 (next of roundbracket_pop, atom)
		//  next2:              +1 (roundbracket_pop)
		//  q.atleast:          min bracket number inside this bracket (i.e., myself's number)
		//  q.atmost:           max bracket number inside this bracket
		//  q.greedy:           -
		//  is_not/dont_push:   - (was dont_push)
	//  st_roundbracket_pop,        //  0x09
		//  char/number:        bracket number
		//  next1:              0 (always treated as "not matched")
		//  next2:              0
		//  q.atleast:          min bracket number inside this bracket (i.e., myself's number)
		//  q.atmost:           max bracket number inside this bracket
		//  q.greedy:           -
		//  is_not/dont_push:   - (was dont_push)
	//  st_roundbracket_close,      //  0x0a
		//  char/number:        bracket number
		//  next1:              gen.
		//  next2:              +1 (exit for 0 width loop)
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_repeat_in_push,          //  0x0b
		//  char/number:        repeat counter
		//  next1:              +2 (next of repeat_in_pop, atom)
		//  next2:              +1 (repeat_in_pop)
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_repeat_in_pop,           //  0x0c
		//  char/number:        repeat counter
		//  next1:              0 (always treated as "not matched")
		//  next2:              0
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_check_0_width_repeat,    //  0x0d
		//  char/number:        repeat counter
		//  next1:              gen. (epsilon or check_counter)
		//  next2:              +1 (exit for 0 width loop)
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_backreference,           //  0x0e
		//  char/number:        bracket number
		//  next1:              gen.
		//  next2:              +1 (exit for 0 width match)
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_lookaround_open,         //  0x0f
		//  char/number:        character class number for nocase-word or icase-word
		//  next1:              next of lookaround_close (to where jumps after lookaround assertion)
		//  next2:              +1 (lookaround_pop)
		//  q.atleast:          <fixed-width> number of chars to be rewound (for (?<=...) (?<!...))
		//                      <variable-width> whether lookbehind or not
		//  q.atmost:           -
		//  q.greedy:           -
		//  is_not/dont_push:   not
	//  st_lookaround_pop,          //  0x10
		//  char/number:        -
		//  next1:              +1 (used by lookaround_open. this type is treated
		//                          as "not unmatched" and does not use this value)
		//  next2:              0
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_bol,                     //  0x11
		//  char/number:        -
		//  next1/next2:        -
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_eol,                     //  0x12
		//  char/number:        -
		//  next1/next2:        -
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_boundary,                //  0x13
		//  char/number:        -
		//  next1/next2:        -
		//  quantifiers:        -
		//  is_not/dont_push:   not
	//  st_success,                 //  0x14
		//  char/number:        -
		//  next1/next2:        -
		//  quantifiers:        -
		//  is_not/dont_push:   -
	//  st_move_nextpos,            //  0x15
		//  char/number:        -
		//  next1/next2:        -
		//  quantifiers:        -
		//  is_not/dont_push:   -
	void reset()
	{
		number = 0;
		type   = st_character;
		next1  = 1;
		next2  = 0;
		is_not = false;
		quantifier.reset();
	}
	bool is_character_or_class() const
	{
		return type == st_character || type == st_character_class;
	}
	bool has_quantifier() const
	{
		//  1. character:  size == 1 && type == character,
		//  2. [...]:      size == 1 && type == character_class,
		//  3. (...):      size == ? && type == roundbracket_open,
		//  4. (?:...):    size == ? && type == epsilon && character == ':',
		//  5. backref:    size == ? && type == backreference,
		//  -- assertions boundary --
		//  6. lookaround: size == ? && type == lookaround,
		//  7. assertion:  size == 0 && type == one of assertions (^, $, \b and \B).
#if !defined(SRELL_ENABLE_GT)
		return type < st_zero_width_boundary;
#else
		//  5.5. independent: size == ? && type == lookaround && character == '>',
		return type < st_zero_width_boundary || (type == st_lookaround_open && character == meta_char::mc_gt);
#endif
	}
	bool is_noncapturinggroup() const
	{
		return type == st_epsilon && character == meta_char::mc_colon;
	}
	bool has_0widthchecker() const
	{
		return type == st_roundbracket_open || type == st_backreference;
	}
	bool is_negcharclass() const
	{
		return type == st_character_class && is_not;
	}
};
struct re_compiler_state
{
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
	bool back;
#endif
	simple_array<unsigned int> atleast_widths_of_brackets;
#if !defined(SRELL_NO_NAMEDCAPTURE)
	groupname_mapper unresolved_gnames;
#endif
	void reset(const regex_constants::syntax_option_type & /* flags */)
	{
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
		back = false;
#endif
		atleast_widths_of_brackets.clear();
#if !defined(SRELL_NO_NAMEDCAPTURE)
		unresolved_gnames.clear();
#endif
	}
	void restore_from(const re_compiler_state &backup)
	{
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
		back = backup.back;
#endif
	}
};
	}	//  namespace regex_internal
template <typename BidirectionalIterator>
class sub_match /* : std::pair<BidirectionalIterator, BidirectionalIterator> */;
	namespace regex_internal
	{
struct re_state;
template </* typename charT, */typename BidirectionalIterator>
struct re_search_state_core
{
	const re_state/* <charT> */ *in_NFA_states;
	BidirectionalIterator in_string;
};
template <typename BidirectionalIterator>
struct re_submatch_core
{
	BidirectionalIterator open_at;
	BidirectionalIterator close_at;
};
template <typename BidirectionalIterator>
struct re_submatch_type
{
	re_submatch_core<BidirectionalIterator> core;
	unsigned int counter;
};
template </*typename charT, */typename BidirectionalIterator>
struct re_search_state_types
{
public:
	typedef re_submatch_core<BidirectionalIterator> submatch_core;
	typedef re_submatch_type<BidirectionalIterator> submatch_type;
	typedef BidirectionalIterator position_type;
	typedef unsigned int counter_type;
	typedef std::vector<submatch_type> submatch_array;
	typedef re_search_state_core</*charT, */BidirectionalIterator> search_core_state;
public:
	typedef std::vector<search_core_state> backtracking_array;
	typedef std::vector<submatch_core> capture_array;
	typedef std::vector<position_type> repeat_array;
	typedef simple_array<counter_type> counter_array;
};
template </*typename charT1, */typename charT2>
struct re_search_state_types</*charT1, */const charT2 *>
{
public:
	typedef re_submatch_core<const charT2 *> submatch_core;
	typedef re_submatch_type<const charT2 *> submatch_type;
	typedef const charT2 *position_type;
	typedef unsigned int counter_type;
	typedef simple_array<submatch_type> submatch_array;
	typedef re_search_state_core</*charT1, */const charT2 *> search_core_state;
public:
	typedef simple_array<search_core_state> backtracking_array;
	typedef simple_array<submatch_core> capture_array;
	typedef simple_array<position_type> repeat_array;
	typedef simple_array<counter_type> counter_array;
};
template </*typename charT, */typename BidirectionalIterator>
class re_search_state : public re_search_state_types</*charT, */BidirectionalIterator>
{
private:
	typedef re_search_state_types</*charT, */BidirectionalIterator> base_type;
public:
	typedef typename base_type::submatch_core submatch_core;
	typedef typename base_type::submatch_type submatch_type;
	typedef typename base_type::position_type position_type;
	typedef typename base_type::counter_type counter_type;
	typedef typename base_type::submatch_array submatch_array;
	typedef typename base_type::search_core_state search_core_state;
public:
	typedef typename base_type::backtracking_array backtracking_array;
	typedef typename base_type::capture_array capture_array;
	typedef typename base_type::repeat_array repeat_array;
	typedef typename base_type::counter_array counter_array;
	typedef typename backtracking_array::size_type btstack_size_type;
public:
	struct bottom_state
	{
		btstack_size_type btstack_size;
		typename capture_array::size_type capturestack_size;
		typename counter_array::size_type counterstack_size;
		typename repeat_array::size_type repeatstack_size;
		bottom_state(
			const btstack_size_type &bt,
			const typename capture_array::size_type &h,
			const typename counter_array::size_type &c,
			const typename repeat_array::size_type &r)
			: btstack_size(bt)
			, capturestack_size(h)
			, counterstack_size(c)
			, repeatstack_size(r)
		{
		}
	};
public:
	search_core_state nth;
#if !defined(SRELL_NO_LIMIT_COUNTER)
	std::size_t failure_counter;
#endif
	BidirectionalIterator lblim;
	BidirectionalIterator last;
	backtracking_array bt_stack;
	capture_array capture_stack;
	counter_array counter_stack;
	repeat_array repeat_stack;
	submatch_array bracket;
	counter_array counter;
	repeat_array repeat;
	btstack_size_type btstack_size;
	BidirectionalIterator nextpos;
	BidirectionalIterator safebase;
	BidirectionalIterator realbase;
public:
	template <typename utf_traits>
	void init
	(
		const BidirectionalIterator &lookbehindlimit,
		const BidirectionalIterator &begin,
		const BidirectionalIterator &end,
		const regex_constants::match_flag_type &flags,
		unsigned int num_of_submatches
	)
	{
		lblim = (flags & regex_constants::match_lblim_avail) ? lookbehindlimit : begin;
		realbase = safebase = begin;
		last = end;
		flags_ = flags & ~regex_constants::match_last_tried_;
		bracket.resize(num_of_submatches);
		while (num_of_submatches)
		{
			submatch_type &br = bracket[--num_of_submatches];
			br.core.open_at = br.core.close_at = this->last;
			br.counter = 0;
			//  15.10.2.9; AtomEscape:
			//  If the regular expression has n or more capturing parentheses
			//  but the nth one is undefined because it hasn't captured anything,
			//  then the backreference always succeeds.
			//  C.f., table 27 and 28 on TR1, table 142 and 143 on C++11.
		}
		utf_traits::seek_charboundary(safebase, last);
		nextpos = safebase;
		if (safebase != realbase)	//  No longer real bol.
		{
			if (flags_ & (regex_constants::match_match_ | regex_constants::match_continuous))
				flags_ |= regex_constants::match_last_tried_;
		}
	}
	void init_for_automaton
	(
		const re_state/*<charT>*/ *const entry,
		const unsigned int &num_of_counters,
		const unsigned int &num_of_repeats
	)
	{
		entry_state_ = entry;
		counter.resize(num_of_counters);
		repeat.resize(num_of_repeats);
		clear_stacks();
	}
#if defined(SRELL_NO_LIMIT_COUNTER)
	void reset(const BidirectionalIterator &start)
#else
	void reset(const BidirectionalIterator &start, const std::size_t &limit)
#endif
	{
		nth.in_NFA_states = this->entry_state_;
		nth.in_string = start;
		bracket[0].core.open_at = start;
#if !defined(SRELL_NO_LIMIT_COUNTER)
		failure_counter = limit;
#endif
	}
	bool is_base() const
	{
		return nth.in_string == this->safebase;
	}
	bool is_lookbehindlimit() const
	{
		return nth.in_string == this->lblim;
	}
	bool is_last() const
	{
		return nth.in_string == this->last;
	}
	bool is_null() const
	{
		return nth.in_string == bracket[0].core.open_at;
	}
	bool match_not_bol_flag() const
	{
		if (this->flags_ & regex_constants::match_not_bol)
			return true;
		return false;
	}
	bool match_not_eol_flag() const
	{
		if (this->flags_ & regex_constants::match_not_eol)
			return true;
		return false;
	}
	bool match_not_bow_flag() const
	{
		if (this->flags_ & regex_constants::match_not_bow)
			return true;
		return false;
	}
	bool match_not_eow_flag() const
	{
		if (this->flags_ & regex_constants::match_not_eow)
			return true;
		return false;
	}
	bool match_prev_avail_flag() const
	{
		if (this->flags_ & regex_constants::match_prev_avail)
			return true;
		return false;
	}
	bool match_not_null_flag() const
	{
		if (this->flags_ & regex_constants::match_not_null)
			return true;
		return false;
	}
	bool match_continuous_flag() const
	{
		if (this->flags_ & regex_constants::match_continuous)
			return true;
		return false;
	}
	bool match_match_flag() const
	{
		if (this->flags_ & regex_constants::match_match_)
			return true;
		return false;
	}
	bool is_last_tried()
	{
		if (this->flags_ & regex_constants::match_last_tried_)
			return true;
		this->flags_ |= regex_constants::match_last_tried_;
		return false;
	}
	void set_submatch(sub_match<BidirectionalIterator> &sm, const unsigned int no) const
	{
		const submatch_type &br = bracket[no];
		sm.first   = br.core.open_at;
		sm.second  = br.core.close_at;
		sm.matched = br.counter != 0;
	}
	bool set_bracket0(const BidirectionalIterator &begin, const BidirectionalIterator &end)
	{
		bracket[0].core.open_at = begin;
		nth.in_string = end;
		return true;
	}
	void clear_stacks()
	{
		btstack_size = 0;
		bt_stack.clear();
		capture_stack.clear();
		repeat_stack.clear();
		counter_stack.clear();
	}
	btstack_size_type size() const	//  for debug.
	{
		return bt_stack.size();
	}
	bool is_empty() const	//  for debug.
	{
		if (btstack_size == 0
			&& bt_stack.size() == 0
			&& capture_stack.size() == 0
			&& repeat_stack.size() == 0
			&& counter_stack.size() == 0)
			return true;
		return false;
	}
	re_search_state &operator=(const re_search_state &)
	{
		throw std::runtime_error("do not copy an object of class `re_search_state'.");
		return *this;
	}
private:
	/* const */regex_constants::match_flag_type flags_;
	const re_state/* <charT> */ * /* const */entry_state_;
};
	}	//  namespace regex_internal
	namespace regex_internal
	{
#if !defined(SRELLDBG_NO_BMH)
template <typename charT, typename utf_traits>
class re_bmh
{
public:
	re_bmh()
	{
	}
	re_bmh(const re_bmh &right)
	{
		operator=(right);
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	re_bmh(re_bmh &&right) SRELL_NOEXCEPT
	{
		operator=(std::move(right));
	}
#endif
	re_bmh &operator=(const re_bmh &that)
	{
		if (this != &that)
		{
			this->u21string_ = that.u21string_;
			this->bmtable_ = that.bmtable_;
			this->repseq_ = that.repseq_;
		}
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	re_bmh &operator=(re_bmh &&that) SRELL_NOEXCEPT
	{
		if (this != &that)
		{
			this->u21string_ = std::move(that.u21string_);
			this->bmtable_ = std::move(that.bmtable_);
			this->repseq_ = std::move(that.repseq_);
		}
		return *this;
	}
#endif
	void clear()
	{
		u21string_.clear();
		bmtable_.clear();
		repseq_.clear();
	}
	void setup(const simple_array<uchar21_t> &u21s, const bool icase)
	{
		u21string_ = u21s;
		setup_();
		if (!icase)
			setup_for_casesensitive();
		else
			setup_for_icase();
	}
	bool is_ready() const
	{
		return u21string_.size() != 0;
	}
	template <typename BidirectionalIterator, const bool>
	struct search_proxy
	{
		static bool do_search(re_search_state<BidirectionalIterator> &sstate, const re_bmh *const ptr)
		{
			return ptr->do_casesensitivesearch(sstate, typename std::iterator_traits<BidirectionalIterator>::iterator_category());
		}
	};
	template <typename BidirectionalIterator>
	struct search_proxy<BidirectionalIterator, true>
	{
		static bool do_search(re_search_state<BidirectionalIterator> &sstate, const re_bmh *const ptr)
		{
			return ptr->do_icasesearch(sstate, typename std::iterator_traits<BidirectionalIterator>::iterator_category());
		}
	};
	template <typename BidirectionalIterator, const bool>
	struct match_proxy
	{
		static bool do_match(re_search_state<BidirectionalIterator> &sstate, const re_bmh *const ptr)
		{
			return ptr->do_casesensitivematch(sstate);
		}
	};
	template <typename BidirectionalIterator>
	struct match_proxy<BidirectionalIterator, true>
	{
		static bool do_match(re_search_state<BidirectionalIterator> &sstate, const re_bmh *const ptr)
		{
			return ptr->do_icasematch(sstate);
		}
	};
private:
	template <typename BidirectionalIterator>
	bool do_casesensitivesearch(re_search_state<BidirectionalIterator> &sstate, const std::random_access_iterator_tag) const
	{
		BidirectionalIterator begin = sstate.safebase;
		const BidirectionalIterator end = sstate.last;
		const std::size_t textsize = std::distance(begin, end);
		std::size_t offset = static_cast<std::size_t>(repseq_.size() - 1);
		const charT *const relastchar = &repseq_[offset];
		for (std::size_t cur = offset; cur < textsize; cur += offset)
		{
			std::advance(begin, offset);
			if (*begin == *relastchar)
			{
				const charT *re = relastchar;
				BidirectionalIterator tail = begin;
				for (; *--re == *--tail;)
				{
					if (re == repseq_.data())
						return sstate.set_bracket0(tail, ++begin);
				}
			}
			offset = bmtable_[*begin & 0xff];
		}
		return false;
	}
	template <typename BidirectionalIterator>
	bool do_casesensitivesearch(re_search_state<BidirectionalIterator> &sstate, const std::bidirectional_iterator_tag) const
	{
		BidirectionalIterator begin = sstate.safebase;
		const BidirectionalIterator end = sstate.last;
		std::size_t offset = static_cast<std::size_t>(repseq_.size() - 1);
		const charT *const relastchar = &repseq_[offset];
		for (;;)
		{
			for (; offset; --offset, ++begin)
				if (begin == end)
					return false;
			if (*begin == *relastchar)
			{
				const charT *re = relastchar;
				BidirectionalIterator tail = begin;
				for (; *--re == *--tail;)
				{
					if (re == repseq_.data())
						return sstate.set_bracket0(tail, ++begin);
				}
			}
			offset = bmtable_[*begin & 0xff];
		}
	}
	template <typename BidirectionalIterator>
	bool do_icasesearch(re_search_state<BidirectionalIterator> &sstate, const std::random_access_iterator_tag) const
	{
		const BidirectionalIterator begin = sstate.safebase;
		const BidirectionalIterator end = sstate.last;
		const std::size_t textsize = std::distance(begin, end);
		std::size_t offset = repseq_.size() - 1;
		const uchar21_t *const relastchar = &u21string_[u21string_.size() - 2];
		BidirectionalIterator curpos = begin;
		const uchar21_t entrychar = u21string_[u21string_.size() - 1];
		for (std::size_t curlen = offset; curlen < textsize; curlen += offset)
		{
			std::advance(curpos, offset);
			for (; utf_traits::is_trailing(curpos); ++curpos)
				if (++curlen >= textsize)
					return false;
			const uchar21_t txtlastchar = utf_traits::codepoint(curpos, end);
			if (txtlastchar == entrychar || unicode_case_folding::do_casefolding(txtlastchar) == entrychar)
			{
				const uchar21_t *re = relastchar;
				BidirectionalIterator tail = curpos;
				for (; *re == unicode_case_folding::do_casefolding(utf_traits::dec_codepoint(tail)); --re)
				{
					if (re == u21string_.data())
					{
						utf_traits::advance(curpos, end, 1);
						return sstate.set_bracket0(tail, curpos);
					}
					if (tail == begin)
						break;
				}
			}
			offset = bmtable_[txtlastchar & 0xff];
			//  In a multibyte encoding, this value may be insufficient to points to a leading byte
			//  correctly, but it is okay. At least, it does not pass the character to which it
			//  really wants to point.
			//  As of Unicode 12.1, case folding [CS] changes the lengths of the following
			//  characters when they are represented in UTF-8:
			//   * 023A -> 2C65; 2 octets -> 3 octets.
			//   * 023E -> 2C66; 2 octets -> 3 octets.
			//  Theoretically, by reversing "from"s and "to"s of them and guaranteeing that
			//  case folding does never increase the number of code units of a character, it
			//  can be avoided to pass accidentally a character that needs to be compared.
		}
		return false;
	}
	template <typename BidirectionalIterator>
	bool do_icasesearch(re_search_state<BidirectionalIterator> &sstate, const std::bidirectional_iterator_tag) const
	{
		BidirectionalIterator begin = sstate.safebase;
		const BidirectionalIterator end = sstate.last;
		if (begin != end)
		{
			std::size_t offset = static_cast<std::size_t>(u21string_.size() - 1);
			const uchar21_t *const relastchar = &u21string_[u21string_.size() - 2];
			const uchar21_t entrychar = u21string_[u21string_.size() - 1];
			for (; utf_traits::advance(begin, end, offset);)
			{
				const uchar21_t txtlastchar = utf_traits::codepoint(begin, end);
				if (txtlastchar == entrychar || unicode_case_folding::do_casefolding(txtlastchar) == entrychar)
				{
					const uchar21_t *re = relastchar;
					BidirectionalIterator tail = begin;
					for (; *re == unicode_case_folding::do_casefolding(utf_traits::dec_codepoint(tail)); --re)
					{
						if (re == u21string_.data())
						{
							utf_traits::advance(begin, end, 1);
							return sstate.set_bracket0(tail, begin);
						}
					}
				}
				offset = bmtable_[txtlastchar & 0xff];
			}
		}
		return false;
	}
	template <typename BidirectionalIterator>
	bool do_casesensitivematch(re_search_state<BidirectionalIterator> &sstate) const
	{
		BidirectionalIterator begin = sstate.realbase;
		const BidirectionalIterator end = sstate.last;
		for (std::size_t index = 0;; ++index, ++begin)
		{
			if (index == static_cast<std::size_t>(repseq_.size()))
			{
				sstate.nextpos = begin;
				return true;
			}
			if (begin == end || repseq_[index] != *begin)
				break;
		}
		return false;
	}
	template <typename BidirectionalIterator>
	bool do_icasematch(re_search_state<BidirectionalIterator> &sstate) const
	{
		BidirectionalIterator begin = sstate.realbase;
		const BidirectionalIterator end = sstate.last;
		for (std::size_t index = 0;; ++index)
		{
			if (index == static_cast<std::size_t>(u21string_.size()))
			{
				sstate.nextpos = begin;
				return true;
			}
			if (begin == end || u21string_[index] != unicode_case_folding::do_casefolding(utf_traits::codepoint_inc(begin, end)))
				break;
		}
		return false;
	}
	void setup_()
	{
		charT mbstr[utf_traits::maxseqlen];
		const std::size_t u21str_lastcharpos_ = static_cast<std::size_t>(u21string_.size() - 1);
		repseq_.clear();
		for (std::size_t i = 0; i <= u21str_lastcharpos_; ++i)
		{
			const uchar21_t seqlen = utf_traits::to_codeunits(mbstr, u21string_[i]);
			for (uchar21_t j = 0; j < seqlen; ++j)
				repseq_.push_back(mbstr[j]);
		}
		bmtable_.resize(256);
	}
	void setup_for_casesensitive()
	{
		for (std::size_t i = 0; i < 256; ++i)
			bmtable_[i] = static_cast<std::size_t>(repseq_.size());
		const std::size_t repseq_lastcharpos_ = static_cast<std::size_t>(repseq_.size() - 1);
		for (std::size_t i = 0; i < repseq_lastcharpos_; ++i)
			bmtable_[repseq_[i] & 0xff] = repseq_lastcharpos_ - i;
	}
	void setup_for_icase()
	{
		uchar21_t u21table[unicode_case_folding::rev_maxset];
		for (std::size_t i = 0; i < 256; ++i)
			bmtable_[i] = static_cast<std::size_t>(u21string_.size());
		const std::size_t u21str_lastcharpos_ = static_cast<std::size_t>(u21string_.size() - 1);
		for (std::size_t i = 0; i < u21str_lastcharpos_; ++i)
		{
			const uchar21_t &u21c = u21string_[i];
			const uchar21_t setnum = unicode_case_folding::casefoldedcharset(u21table, u21c);
			for (uchar21_t j = 0; j < setnum; ++j)
				bmtable_[u21table[j] & 0xff] = u21str_lastcharpos_ - i;
		}
	}
public:	//  for debug.
	void print_table() const;
	void print_seq() const;
private:
	simple_array<uchar21_t> u21string_;
	simple_array<std::size_t> bmtable_;
	simple_array<charT> repseq_;	//  replicate sequence.
};
#endif	//  !defined(SRELLDBG_NO_BMH)
	}	//  namespace regex_internal
	namespace regex_internal
	{
template <typename charT, typename traits>
struct re_object_core
{
protected:
	typedef re_state/*<charT>*/ state_type;
	typedef simple_array<state_type> state_array;
	state_array NFA_states;
	re_character_class character_class;
#if !defined(SRELLDBG_NO_1STCHRCLS)
	#if !defined(SRELLDBG_NO_BITSET)
	bitset<constants::unicode_max_codepoint + 1> firstchar_class_bs;	//  136 KiB.
	#else
	range_pairs firstchar_class;
	#endif
#endif
#if !defined(SRELL_NO_LIMIT_COUNTER)
public:
	std::size_t limit_counter;
protected:
#endif
	typedef typename traits::utf_traits utf_traits;
	unsigned int number_of_brackets;
	unsigned int number_of_counters;
	unsigned int number_of_repeats;
	regex_constants::syntax_option_type soflags;
#if !defined(SRELL_NO_NAMEDCAPTURE)
	groupname_mapper namedcaptures;
	typedef typename groupname_mapper::u21string gname_u21string;
#endif
#if !defined(SRELLDBG_NO_BMH)
	re_bmh<charT, utf_traits> *bmdata;
#endif
#if !defined(SRELL_NO_LIMIT_COUNTER)
private:
	static const std::size_t lcounter_defnum_ = 16777216;
#endif
protected:
	re_object_core()
#if !defined(SRELL_NO_LIMIT_COUNTER)
		: limit_counter(lcounter_defnum_)
	#if !defined(SRELLDBG_NO_BMH)
		, bmdata(NULL)
	#endif
#elif !defined(SRELLDBG_NO_BMH)
		: bmdata(NULL)
#endif
	{
	}
	re_object_core(const re_object_core &right)
#if !defined(SRELLDBG_NO_BMH)
		: bmdata(NULL)
#endif
	{
		operator=(right);
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	re_object_core(re_object_core &&right) SRELL_NOEXCEPT
#if !defined(SRELLDBG_NO_BMH)
		: bmdata(NULL)
#endif
	{
		operator=(std::move(right));
	}
#endif
#if !defined(SRELLDBG_NO_BMH)
	~re_object_core()
	{
		if (bmdata)
			delete bmdata;
	}
#endif
	void reset(const regex_constants::syntax_option_type flags)
	{
		NFA_states.clear();
		character_class.clear();
#if !defined(SRELLDBG_NO_1STCHRCLS)
	#if !defined(SRELLDBG_NO_BITSET)
		firstchar_class_bs.reset();
	#else
		firstchar_class.clear();
	#endif
#endif
#if !defined(SRELL_NO_LIMIT_COUNTER)
		limit_counter = lcounter_defnum_;
#endif
		number_of_brackets = 1;
		number_of_counters = 0;
		number_of_repeats  = 0;
		soflags = flags;	//  regex_constants::ECMAScript;
#if !defined(SRELL_NO_NAMEDCAPTURE)
		namedcaptures.clear();
#endif
#if !defined(SRELLDBG_NO_BMH)
		if (bmdata)
			delete bmdata;
		bmdata = NULL;
#endif
	}
	re_object_core &operator=(const re_object_core &that)
	{
		if (this != &that)
		{
			this->NFA_states = that.NFA_states;
			this->character_class = that.character_class;
#if !defined(SRELLDBG_NO_1STCHRCLS)
	#if !defined(SRELLDBG_NO_BITSET)
			this->firstchar_class_bs = that.firstchar_class_bs;
	#else
			this->firstchar_class = that.firstchar_class;
	#endif
#endif
#if !defined(SRELL_NO_LIMIT_COUNTER)
			this->limit_counter = that.limit_counter;
#endif
			this->number_of_brackets = that.number_of_brackets;
			this->number_of_counters = that.number_of_counters;
			this->number_of_repeats = that.number_of_repeats;
			this->soflags = that.soflags;
#if !defined(SRELL_NO_NAMEDCAPTURE)
			this->namedcaptures = that.namedcaptures;
#endif
#if !defined(SRELLDBG_NO_BMH)
			if (that.bmdata)
			{
				if (this->bmdata)
					*this->bmdata = *that.bmdata;
				else
					this->bmdata = new re_bmh<charT, utf_traits>(*that.bmdata);
			}
			else if (this->bmdata)
			{
				delete this->bmdata;
				this->bmdata = NULL;
			}
#endif
			if (that.NFA_states.size())
				repair_nextstates(&that.NFA_states[0]);
		}
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	re_object_core &operator=(re_object_core &&that) SRELL_NOEXCEPT
	{
		if (this != &that)
		{
			this->NFA_states = std::move(that.NFA_states);
			this->character_class = std::move(that.character_class);
#if !defined(SRELLDBG_NO_1STCHRCLS)
	#if !defined(SRELLDBG_NO_BITSET)
			this->firstchar_class_bs = std::move(that.firstchar_class_bs);
	#else
			this->firstchar_class = std::move(that.firstchar_class);
	#endif
#endif
#if !defined(SRELL_NO_LIMIT_COUNTER)
			this->limit_counter = that.limit_counter;
#endif
			this->number_of_brackets = that.number_of_brackets;
			this->number_of_counters = that.number_of_counters;
			this->number_of_repeats = that.number_of_repeats;
			this->soflags = that.soflags;
#if !defined(SRELL_NO_NAMEDCAPTURE)
			this->namedcaptures = std::move(that.namedcaptures);
#endif
#if !defined(SRELLDBG_NO_BMH)
			if (this->bmdata)
				delete this->bmdata;
			this->bmdata = that.bmdata;
			that.bmdata = NULL;
#endif
		}
		return *this;
	}
#endif	//  defined(SRELL_CPP11_MOVE_ENABLED)
	void swap(re_object_core &right)
	{
		if (this != &right)
		{
			this->NFA_states.swap(right.NFA_states);
			this->character_class.swap(right.character_class);
#if !defined(SRELLDBG_NO_1STCHRCLS)
	#if !defined(SRELLDBG_NO_BITSET)
			this->firstchar_class_bs.swap(right.firstchar_class_bs);
	#else
			this->firstchar_class.swap(right.firstchar_class);
	#endif
#endif
#if !defined(SRELL_NO_LIMIT_COUNTER)
			{
				const std::size_t tmp_limit_counter = this->limit_counter;
				this->limit_counter = right.limit_counter;
				right.limit_counter = tmp_limit_counter;
			}
#endif
			{
				const unsigned int tmp_numof_brackets = this->number_of_brackets;
				this->number_of_brackets = right.number_of_brackets;
				right.number_of_brackets = tmp_numof_brackets;
			}
			{
				const unsigned int tmp_numof_counters = this->number_of_counters;
				this->number_of_counters = right.number_of_counters;
				right.number_of_counters = tmp_numof_counters;
			}
			{
				const unsigned int tmp_numof_repeats = this->number_of_repeats;
				this->number_of_repeats = right.number_of_repeats;
				right.number_of_repeats = tmp_numof_repeats;
			}
			{
				const regex_constants::syntax_option_type tmp_soflags = this->soflags;
				this->soflags = right.soflags;
				right.soflags = tmp_soflags;
			}
#if !defined(SRELL_NO_NAMEDCAPTURE)
			this->namedcaptures.swap(right.namedcaptures);
#endif
#if !defined(SRELLDBG_NO_BMH)
			{
				re_bmh<charT, utf_traits> *const tmp_bmdata = this->bmdata;
				this->bmdata = right.bmdata;
				right.bmdata = tmp_bmdata;
			}
#endif
		}
	}
	void throw_error(const regex_constants::error_type &e)
	{
		NFA_states.clear();
#if !defined(SRELLDBG_NO_BMH)
		if (bmdata)
			delete bmdata;
		bmdata = NULL;
#endif
		throw regex_error(e);
	}
private:
	void repair_nextstates(const state_type *const oldbase)
	{
		state_type *const newbase = &this->NFA_states[0];
		for (typename state_array::size_type i = 0; i < this->NFA_states.size(); ++i)
		{
			state_type &state = this->NFA_states[i];
			if (state.next_state1)
				state.next_state1 = state.next_state1 - oldbase + newbase;
			if (state.next_state2)
				state.next_state2 = state.next_state2 - oldbase + newbase;
		}
	}
};
template <typename charT, typename traits>
class re_compiler : public re_object_core<charT, traits>
{
protected:
	template <typename ForwardIterator>
	bool compile(ForwardIterator begin, const ForwardIterator &end, const regex_constants::syntax_option_type flags /* = regex_constants::ECMAScript */)
	{
		simple_array<uchar21_t> u21;
		while (begin != end)
			u21.push_back(utf_traits::codepoint_inc(begin, end));
		return compile_core(u21.data(), u21.data() + u21.size(), flags);
	}
	bool is_icase() const
	{
		if (this->soflags & regex_constants::icase)
			return true;
		return false;
	}
	bool is_multiline() const
	{
		if (this->soflags & regex_constants::multiline)
			return true;
		return false;
	}
	bool is_dotall() const
	{
		return (this->soflags & regex_constants::dotall) ? true : false;
	}
private:
	typedef re_object_core<charT, traits> base_type;
	typedef typename traits::utf_traits utf_traits;
	typedef typename base_type::state_type state_type;
	typedef typename base_type::state_array state_array;
#if !defined(SRELL_NO_NAMEDCAPTURE)
	typedef typename base_type::gname_u21string gname_u21string;
#endif
#if !defined(SRELL_NO_UNICODE_PROPERTY)
	typedef typename re_character_class::pstring pstring;
#endif
	bool compile_core(const uchar21_t *begin, const uchar21_t *const end, const regex_constants::syntax_option_type flags)
	{
		re_quantifier piececharlen;
		re_compiler_state cstate;
		state_type atom;
		this->reset(flags);
		cstate.reset(flags);
		atom.reset();
		atom.type = st_epsilon;
		this->NFA_states.push_back(atom);
		if (!make_nfa_states(this->NFA_states, piececharlen, begin, end, cstate))
		{
#if defined(SRELLDBG_TRACE)
			std::fprintf(stdout, "Failed near %c\n", *begin);
#endif
			return false;
		}
		if (begin != end)
			this->throw_error(regex_constants::error_paren);	//  ')'s are too many.
		if (!check_backreferences(cstate))
			this->throw_error(regex_constants::error_backref);
		check_if_really_needs_icase_search();
#if !defined(SRELLDBG_NO_BMH)
		if (!needs_to_run_automaton())
			return true;
#endif
		atom.type = st_success;
		atom.next1 = 0;
		this->NFA_states.push_back(atom);
		optimise();
		relativejump_to_absolutejump();
		return true;
	}
	bool make_nfa_states(state_array &NFA_states, re_quantifier &piececharlen, const uchar21_t *&curpos, const uchar21_t *const end, re_compiler_state &cstate)
	{
		typename state_array::size_type prevbranch_end = 0;
		state_type atom;
		state_array branch;
		re_quantifier branchsize;
		piececharlen.reset(0);
		for (;;)
		{
			branch.clear();
			if (!make_branch(branch, branchsize, curpos, end, cstate))
				return false;
			//  For piececharlen.atleast, 0 as the initial value and 0 as an
			//  actual value must be distinguished.
			if (piececharlen.atmost == 0 || piececharlen.atleast > branchsize.atleast)
				piececharlen.atleast = branchsize.atleast;
			if (piececharlen.atmost < branchsize.atmost)
				piececharlen.atmost = branchsize.atmost;
			if (curpos != end && static_cast<uchar21_t>(*curpos) == meta_char::mc_bar)
			{
				atom.reset();
				atom.character = meta_char::mc_bar;
				atom.type = st_epsilon;
				atom.next2 = static_cast<std::ptrdiff_t>(branch.size()) + 2;
				branch.insert(0, atom);
			}
			if (prevbranch_end)
				NFA_states[prevbranch_end].next1 = static_cast<std::ptrdiff_t>(branch.size()) + 1;
			NFA_states += branch;
				//  end or ')'
			if (curpos == end || static_cast<uchar21_t>(*curpos) == meta_char::mc_rbracl)
				break;
			//  *curpos == '|'
			prevbranch_end = NFA_states.size();
			atom.reset();
			atom.type = st_epsilon;
			NFA_states.push_back(atom);
			++curpos;
		}
		return true;
	}
	bool make_branch(state_array &branch, re_quantifier &branchsize, const uchar21_t *&curpos, const uchar21_t *const end, re_compiler_state &cstate)
	{
		state_array piece;
		state_array piece_with_quantifier;
		re_quantifier quantifier;
		branchsize.reset(0);
		for (;;)
		{
			re_quantifier piececharlen;
			if (curpos == end)
				return true;
			piece.clear();
			piece_with_quantifier.clear();
			switch (*curpos)
			{
			case meta_char::mc_bar:	//  '|':
			case meta_char::mc_rbracl:	//  ')':
				return true;
			default:
				if (!get_atom(piece, piececharlen, curpos, end, cstate))
					return false;
			}
			if (piece.size())
			{
				const state_type &firstatom = piece[0];
				quantifier.reset();	//  quantifier.atleast = quantifier.atmost = 1;
				if (firstatom.has_quantifier())
				{
					if (curpos != end && !get_quantifier(quantifier, curpos, end))
						return false;
				}
				if (piece.size() == 2 && firstatom.is_noncapturinggroup() && piece[1].is_noncapturinggroup())
				{
					//  (?:) alone or followed by a quantifier.
					;	//  do nothing.
				}
				else
					combine_piece_with_quantifier(piece_with_quantifier, piece, quantifier, piececharlen);
#if 01
				piececharlen.multiply(quantifier);
				branchsize.add(piececharlen);
#else
				branchsize.atleast += piececharlen.atleast * quantifier.atleast;
				if (!branchsize.is_infinity())
				{
					if (piececharlen.is_infinity() || quantifier.is_infinity())
						branchsize.set_infinity();
					else
						branchsize.atmost += piececharlen.atmost * quantifier.atmost;
				}
#endif
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
				if (!cstate.back)
					branch += piece_with_quantifier;
				else
					branch.insert(0, piece_with_quantifier);
#else
				branch += piece_with_quantifier;
#endif
			}
		}
	}
	bool get_atom(state_array &piece, re_quantifier &atomsize, const uchar21_t *&curpos, const uchar21_t *const end, re_compiler_state &cstate)
	{
		state_type atom;
		atom.reset();
		atom.character = *curpos++;
		switch (atom.character)
		{
		case meta_char::mc_rbraop:	//  '(':
			return get_piece_in_roundbrackets(piece, atomsize, curpos, end, cstate);
		case meta_char::mc_sbraop:	//  '[':
			if (!register_character_class(atom, curpos, end, cstate))
				return false;
			break;
		case meta_char::mc_escape:	//  '\\':
			if (!translate_atom_escape(atom, curpos, end, cstate))
				return false;
			break;
		case meta_char::mc_period:	//  '.':
			atom.type = st_character_class;
#if !defined(SRELL_NO_SINGLELINE)
			if (this->is_dotall())
			{
				atom.number = static_cast<unsigned int>(re_character_class::dotall);
			}
			else
#endif
			{
				atom.number = static_cast<unsigned int>(re_character_class::newline);
				atom.is_not = true;
				register_if_negatedcharclass(atom);
			}
			break;
		case meta_char::mc_caret:	//  '^':
			atom.type = st_bol;
			atom.quantifier.reset(0);
			break;
		case meta_char::mc_dollar:	//  '$':
			atom.type = st_eol;
			atom.quantifier.reset(0);
			break;
		case meta_char::mc_astrsk:	//  '*':
		case meta_char::mc_plus:	//  '+':
		case meta_char::mc_query:	//  '?':
		case meta_char::mc_cbraop:	//  '{'
			this->throw_error(regex_constants::error_badrepeat);
		default:;
		}
		if (atom.type == st_character)
		{
			if (this->is_icase())
				atom.character = unicode_case_folding::do_casefolding(atom.character);
		}
		piece.push_back(atom);
		atomsize = atom.quantifier;
		return true;
	}
	//  '('.
	bool get_piece_in_roundbrackets(state_array &piece, re_quantifier &piececharlen, const uchar21_t *&curpos, const uchar21_t *const end, re_compiler_state &cstate)
	{
		const re_compiler_state original_cstate(cstate);
		state_type atom;
		if (curpos == end)
			this->throw_error(regex_constants::error_paren);
		atom.reset();
		atom.type = st_roundbracket_open;
		if (static_cast<uchar21_t>(*curpos) == meta_char::mc_query)	//  '?'
		{
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
			if (!extended_roundbrackets(piece, atom, ++curpos, end, cstate))
#else
			if (!extended_roundbrackets(piece, atom, ++curpos, end))
#endif
				return false;
		}
		if (atom.type == st_roundbracket_open)
		{
			push_bracket_open(piece, atom);
		}
		if (!make_nfa_states(piece, piececharlen, curpos, end, cstate))
			return false;
		//  end or ')'?
		if (curpos == end)
			this->throw_error(regex_constants::error_paren);
		++curpos;
		cstate.restore_from(original_cstate);
		switch (atom.type)
		{
		case st_epsilon:
			if (piece.size() == 2)	//  ':' + something.
			{
				piece.erase(0);
				return true;
			}
			piece[0].quantifier.atmost = this->number_of_brackets - 1;
			break;
		case st_lookaround_pop:
			{
				state_type &firstatom = piece[0];
#if defined(SRELL_FIXEDWIDTHLOOKBEHIND)
				if (firstatom.quantifier.atleast)	//  Marked as lookbehind.
				{
					if (!piececharlen.is_same() || piececharlen.is_infinity())
						this->throw_error(regex_constants::error_lookbehind);
					firstatom.quantifier = piececharlen;
				}
#endif
#if defined(SRELL_ENABLE_GT)
				if (firstatom.character != meta_char::mc_gt)
#endif
					piececharlen.reset(0);
				firstatom.next1 = static_cast<std::ptrdiff_t>(piece.size()) + 1;
				atom.type  = st_lookaround_close;
				atom.next1 = 0;
			}
			break;
		default:
			set_bracket_close(piece, atom, piececharlen, cstate);
		}
		piece.push_back(atom);
		return true;
	}
#if !defined(NO_REVERSE) && !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
	bool extended_roundbrackets(state_array &piece, state_type &atom, const uchar21_t *&curpos, const uchar21_t *const end, re_compiler_state &cstate)
#else
	bool extended_roundbrackets(state_array &piece, state_type &atom, const uchar21_t *&curpos, const uchar21_t *const end)
#endif
	{
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
		bool lookbehind = false;
#endif
		if (curpos == end)
			this->throw_error(regex_constants::error_paren);
		atom.character = static_cast<uchar21_t>(*curpos);
		if (atom.character == meta_char::mc_lt)	//  '<'
		{
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
			lookbehind = true;
#endif
			if (++curpos == end)
				this->throw_error(regex_constants::error_paren);
			atom.character = static_cast<uchar21_t>(*curpos);
			if (atom.character != meta_char::mc_eq && atom.character != meta_char::mc_exclam)
			{
#if !defined(SRELL_NO_NAMEDCAPTURE)
				return parse_groupname(curpos, end);
#else
				this->throw_error(regex_constants::error_paren);
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
			}
		}
		else
			atom.quantifier.reset(0);
			//  sets atleast & atmost to 0 other assertions than lookbehinds.
			//  The automaton checks atleast to know whether lookbehinds or other assertions.
		switch (atom.character)
		{
		case meta_char::mc_colon:
			atom.type = st_epsilon;
			atom.quantifier.atleast = this->number_of_brackets;
			break;
		case meta_char::mc_exclam:	//  '!':
			atom.is_not = true;
		case meta_char::mc_eq:	//  '=':
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
			cstate.back = lookbehind;
#else
#endif
#if defined(SRELL_ENABLE_GT)
		case meta_char::mc_gt:
#endif
			atom.type = st_lookaround_open;
			atom.next2 = 1;
			piece.push_back(atom);
			atom.next1 = 1;
			atom.next2 = 0;
			atom.type = st_lookaround_pop;
			break;
		default:
			this->throw_error(regex_constants::error_paren);
		}
		++curpos;
		piece.push_back(atom);
		return true;
	}
	void push_bracket_open(state_array &piece, state_type &atom)
	{
		atom.number = this->number_of_brackets;
		atom.next1  = 2;
		atom.next2  = 1;
		piece.push_back(atom);
		++this->number_of_brackets;
		atom.type  = st_roundbracket_pop;
		atom.next1 = 0;
		atom.next2 = 0;
		piece.push_back(atom);
	}
	void set_bracket_close(state_array &piece, state_type &atom, const re_quantifier &piececharlen, re_compiler_state &cstate)
	{
		atom.type = st_roundbracket_close;
		atom.next1 = 1;
		atom.next2 = 1;
#if 0
		for (typename state_array::size_type i = 0; i < piece.size(); ++i)
		{
			const state_type &state = piece[i];
			if (state.type == st_roundbracket_open && max_bracketno < state.number)
				max_bracketno = state.number;
		}
#endif
		re_quantifier &rb_open = piece[0].quantifier;
		re_quantifier &rb_pop = piece[1].quantifier;
		rb_open.atleast = rb_pop.atleast = atom.number;
		rb_open.atmost = rb_pop.atmost = this->number_of_brackets - 1;	//  max_bracketno;
		if (cstate.atleast_widths_of_brackets.size() < atom.number)
			cstate.atleast_widths_of_brackets.resize(atom.number, 0);
		cstate.atleast_widths_of_brackets[atom.number - 1] = piececharlen.atleast;
	}
	void combine_piece_with_quantifier(state_array &piece_with_quantifier, state_array &piece, const re_quantifier &quantifier, const re_quantifier &piececharlen)
	{
		state_type &firstatom = piece[0];
		const bool piece_has_0widthchecker = firstatom.has_0widthchecker();
		const bool piece_is_noncapturinggroup_contaning_capturinggroup = firstatom.is_noncapturinggroup() && firstatom.quantifier.is_valid();
		state_type atom;
		if (quantifier.atmost == 0)
			return;
		atom.reset();
		atom.quantifier = quantifier;
		if (firstatom.is_character_or_class())
			atom.character = char_other::co_sp;	//  marked for nextpos_optimisation3().
		if (quantifier.atmost == 1)
		{
			if (quantifier.atleast == 0)
			{
				atom.type  = st_epsilon;
				atom.next2 = static_cast<std::ptrdiff_t>(piece.size()) + 1;
				if (!quantifier.is_greedy)
				{
					atom.next1 = atom.next2;
					atom.next2 = 1;
				}
				piece_with_quantifier.push_back(atom);
				//      (push)
			}
			piece_with_quantifier += piece;
			return;
		}
		//  atmost >= 2
#if !defined(SRELLDBG_NO_SIMPLEEQUIV)
		//  The counter requires at least 6 states: save, restore, check, inc, dec, atom(s).
		//  A character or charclass quantified by one of these has a simple equivalent representation:
		//  a{0,2}  1.epsilon(2|5), 2.CHorCL(3), 3.epsilon(4|5), 4.CHorCL(5), [5].
		//  a{0,3}  1.epsilon(2|7), 2.CHorCL(3), 3.epsilon(4|7), 4.CHorCL(5), 5.epsilon(6|7), 6.CHorCL(7), [7].
		//  a{1,2}  1.CHorCL(2), 2.epsilon(3|4), 3.CHorCL(4), [4].
		//  a{1,3}  1.CHorCL(2), 2.epsilon(3|6), 3.CHorCL(4), 4.epsilon(5|6), 5.CHorCL(6), [6].
		//  a{2,3}  1.CHorCL(2), 2.CHorCL(3), 3.epsilon(4|5), 4.CHorCL(5), [5].
		//  a{2,4}  1.CHorCL(2), 2.CHorCL(3), 3.epsilon(4|7), 4.CHorCL(5), 5.epsilon(6|7), 6.CHorCL(7), [7].
		if (piece.size() == 1 && firstatom.is_character_or_class() && quantifier.has_simple_equivalence())
		{
			for (unsigned int i = 0; i < quantifier.atleast; ++i)
				piece_with_quantifier += piece;
			atom.type = st_epsilon;
			atom.next2 = (quantifier.atmost - quantifier.atleast) * 2;
			if (!quantifier.is_greedy)
			{
				atom.next1 = atom.next2;
				atom.next2 = 1;
			}
			for (unsigned int i = quantifier.atleast; i < quantifier.atmost; ++i)
			{
				piece_with_quantifier.push_back(atom);
				piece_with_quantifier += piece;
				quantifier.is_greedy ? (atom.next2 -= 2) : (atom.next1 -= 2);
			}
			return;
		}
#endif	//  !defined(SRELLDBG_NO_SIMPLEEQUIV)
		atom.type = st_epsilon;
		if (quantifier.is_asterisk())	//  {0,}
		{
			//  greedy:  1.epsilon(2|4), 2.piece, 3.LAorC0WR(1|0), 4.OutOfLoop.
			//  !greedy: 1.epsilon(4|2), 2.piece, 3.LAorC0WR(1|0), 4.OutOfLoop.
			//  LAorC0WR: LastAtomOfPiece or Check0WidthRepeat.
			//  atom.type points to 1.
		}
		else if (quantifier.is_plus())	//  {1,}
		{
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
			if (piece.size() == 1 && firstatom.is_character_or_class())
			{
				piece_with_quantifier += piece;
				--atom.quantifier.atleast;	//  /.+/ -> /..*/.
			}
			else
#endif
			{
				atom.next1 = 2;
				atom.next2 = 0;
				piece_with_quantifier.push_back(atom);
				//  greedy:  1.epsilon(3), 2.epsilon(3|5), 3.piece, 4.LAorC0WR(2|0), 5.OutOfLoop.
				//  !greedy: 1.epsilon(3), 2.epsilon(5|3), 3.piece, 4.LAorC0WR(2|0), 5.OutOfLoop.
				//  atom.type points to 2.
			}
		}
		else
		{
			atom.number = this->number_of_counters;
			++this->number_of_counters;
			atom.type = st_save_and_reset_counter;
			atom.next1 = 2;
			atom.next2 = 1;
			piece_with_quantifier.push_back(atom);
			atom.type  = st_restore_counter;
			atom.next1 = 0;
			atom.next2 = 0;
			piece_with_quantifier.push_back(atom);
			//  1.save_and_reset_counter(3|2), 2.restore_counter(0|0),
			atom.next1 = 0;
			atom.next2 = 0;
			atom.type = st_decrement_counter;
			piece.insert(0, atom);
			atom.next1 = 2;
			atom.next2 = 1;
			atom.type = st_increment_counter;
			piece.insert(0, atom);
			atom.type = st_check_counter;
			//  greedy:  3.check_counter(4|6), 4.piece, 5.LAorC0WR(3|0), 6.OutOfLoop.
			//  !greedy: 3.check_counter(6|4), 4.piece, 5.LAorC0WR(3|0), 6.OutOfLoop.
			//  4.piece = { 4a.increment_counter(4c|4b), 4b.decrement_counter(0|0), 4c.OriginalPiece }.
		}
		//  atom.type is epsilon or check_counter.
		//  Its "next"s point to piece and OutOfLoop.
		if (!piece_is_noncapturinggroup_contaning_capturinggroup && (piececharlen.atleast || piece_has_0widthchecker))
		{
			const typename state_array::size_type piece_size = piece.size();
			state_type &lastatom = piece[piece_size - 1];
			lastatom.quantifier = atom.quantifier;
			lastatom.next1 = 0 - static_cast<std::ptrdiff_t>(piece_size);
				//  Points to the one immediately before piece, which will be pushed last in this block.
			//  atom.type has already been set. epsilon or check_counter.
			atom.next1 = 1;
			atom.next2 = static_cast<std::ptrdiff_t>(piece_size) + 1;
			if (!quantifier.is_greedy)
			{
				atom.next1 = atom.next2;
				atom.next2 = 1;
			}
			piece_with_quantifier.push_back(atom);
		}
		else
		{
			//  atom.type has already been set. epsilon or check_counter.
			atom.next1 = 1;
			atom.next2 = static_cast<std::ptrdiff_t>(piece.size()) + 4;	//  to OutOfLoop.
				//  The reason for +3 than above is that push, pop, and check_0_width are added below.
			if (!quantifier.is_greedy)
			{
				atom.next1 = atom.next2;
				atom.next2 = 1;
			}
			piece_with_quantifier.push_back(atom);	//  *1
			atom.number = this->number_of_repeats;
			++this->number_of_repeats;
			if (piece_is_noncapturinggroup_contaning_capturinggroup)
				atom.quantifier = firstatom.quantifier;
			else
				atom.quantifier.set(1, 0);
			atom.type  = st_repeat_in_push;	//  '{':
			atom.next1 = 2;
			atom.next2 = 1;
			piece_with_quantifier.push_back(atom);
			atom.type  = st_repeat_in_pop;
			atom.next1 = 0;
			atom.next2 = 0;
			piece_with_quantifier.push_back(atom);
			atom.type  = st_check_0_width_repeat;
			atom.next1 = 0 - static_cast<std::ptrdiff_t>(piece.size()) - 3;	//  3 for *1, push, and pop.
			atom.next2 = 1;
			piece.push_back(atom);
				//  greedy:  1.epsilon or check_counter(2|6),
				//  !greedy: 1.epsilon or check_counter(6|2),
				//    2.repeat_in_push(4|3), 3.repeat_in_pop(0|0), 4.piece,
				//    5.check_0_width_repeat(1|0), 6.OutOfLoop.
		}
		piece_with_quantifier += piece;
	}
#if !defined(SRELL_NO_NAMEDCAPTURE)
	bool parse_groupname(const uchar21_t *&curpos, const uchar21_t *const end)
	{
		const gname_u21string groupname = get_groupname(curpos, end);
		if (!this->namedcaptures.push_back(groupname, this->number_of_brackets))
			this->throw_error(regex_constants::error_backref);
		return true;
	}
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
	//  '['.
	bool register_character_class(state_type &atom, const uchar21_t *&curpos, const uchar21_t *const end, const re_compiler_state & /* cstate */)
	{
		range_pair code_range;
		range_pairs ranges;
		state_type classatom;
		if (curpos == end)
			this->throw_error(regex_constants::error_brack);
		atom.type = st_character_class;
		if (static_cast<uchar21_t>(*curpos) == meta_char::mc_caret)	//  '^'
		{
			atom.is_not = true;
			++curpos;
		}
		for (;;)
		{
			if (curpos == end)
				this->throw_error(regex_constants::error_brack);
			if (static_cast<uchar21_t>(*curpos) == meta_char::mc_sbracl)	//   ']'
				break;
			classatom.reset();
			if (!get_character_in_class(classatom, curpos, end))
				return false;
			if (classatom.type == st_character_class)
			{
				add_predefclass_to_charclass(ranges, classatom);
				continue;
			}
			code_range.first = code_range.second = classatom.character;
			if (curpos == end)
				this->throw_error(regex_constants::error_brack);
			if (static_cast<uchar21_t>(*curpos) == meta_char::mc_minus)	//  '-'
			{
				++curpos;
				if (curpos == end)
					this->throw_error(regex_constants::error_brack);
				if (static_cast<uchar21_t>(*curpos) == meta_char::mc_sbracl)
				{
					PUSH_SEPARATELY:
					ranges.join(code_range);
					code_range.first = code_range.second = meta_char::mc_minus;
				}
				else
				{
					if (!get_character_in_class(classatom, curpos, end))
						return false;
					if (classatom.type == st_character_class)
					{
						add_predefclass_to_charclass(ranges, classatom);
						goto PUSH_SEPARATELY;
					}
					code_range.second = classatom.character;
					if (!code_range.is_range_valid())
						this->throw_error(regex_constants::error_range);
				}
			}
			ranges.join(code_range);
		}
		//  *curpos == ']'
		++curpos;
		if (this->is_icase())
			ranges.make_caseunfoldedcharset();
		if (atom.is_not)
		{
			ranges.negation();
			atom.is_not = false;
		}
		atom.character = ranges.consists_of_one_character(this->is_icase());
		if (atom.character != constants::invalid_u21value)
		{
			atom.type = st_character;
			return true;
		}
		atom.number = this->character_class.register_newclass(ranges);
		return true;
	}
	bool get_character_in_class(state_type &atom /* uchar21_t &unichar */, const uchar21_t *&curpos, const uchar21_t *const end /* , const re_compiler_state &cstate */)
	{
		atom.character = *curpos++;
		return atom.character != meta_char::mc_escape	//  '\\'
			|| translate_escseq(atom, curpos, end);
	}
	void add_predefclass_to_charclass(range_pairs &cls, const state_type &classatom)
	{
		range_pairs predefclass = this->character_class[classatom.number];
		if (classatom.is_not)
			predefclass.negation();
		cls.merge(predefclass);
	}
	//  Escape characters which appear both in and out of [] pairs.
	bool translate_escseq(state_type &atom, const uchar21_t *&curpos, const uchar21_t *const end)
	{
		if (curpos == end)
			this->throw_error(regex_constants::error_escape);
		atom.character = *curpos++;
		switch (atom.character)
		{
		//  predefined classes.
		case char_alnum::ch_D:	//  'D':
			atom.is_not = true;
		case char_alnum::ch_d:	//  'd':
			atom.number = static_cast<unsigned int>(re_character_class::digit);	//  \d, \D.
			atom.type = st_character_class;
			break;
		case char_alnum::ch_S:	//  'S':
			atom.is_not = true;
		case char_alnum::ch_s:	//  's':
			atom.number = static_cast<unsigned int>(re_character_class::space);	//  \s, \S.
			atom.type = st_character_class;
			break;
		case char_alnum::ch_W:	//  'W':
			atom.is_not = true;
		case char_alnum::ch_w:	//  'w':
			if (this->is_icase())
			{
				this->character_class.setup_icase_word();
				atom.number = static_cast<unsigned int>(re_character_class::icase_word);
			}
			else
				atom.number = static_cast<unsigned int>(re_character_class::word);	//  \w, \W.
			atom.type = st_character_class;
			break;
#if !defined(SRELL_NO_UNICODE_PROPERTY)
		//  prepared for Unicode properties and script names.
		case char_alnum::ch_P:	//  \P{...}
			atom.is_not = true;
		case char_alnum::ch_p:	//  \p{...}
			atom.number = get_property_number(curpos, end);
			atom.type = st_character_class;
			break;
#endif	//  !defined(SRELL_NO_UNICODE_PROPERTY)
#if 0
		case char_alnum::ch_a:
			atom.character = char_ctrl::cc_bel;	//  '\a' 0x07:BEL
			break;
#endif
		case char_alnum::ch_b:
			atom.character = char_ctrl::cc_bs;	//  '\b' 0x08:BS
			break;
		case char_alnum::ch_t:
			atom.character = char_ctrl::cc_htab;	//  '\t' 0x09:HT
			break;
		case char_alnum::ch_n:
			atom.character = char_ctrl::cc_nl;	//  '\n' 0x0a:LF
			break;
		case char_alnum::ch_v:
			atom.character = char_ctrl::cc_vtab;	//  '\v' 0x0b:VT
			break;
		case char_alnum::ch_f:
			atom.character = char_ctrl::cc_ff;	//  '\f' 0x0c:FF
			break;
		case char_alnum::ch_r:
			atom.character = char_ctrl::cc_cr;	//  '\r' 0x0d:CR
			break;
#if 0
		case char_alnum::ch_e:	//  \e
			atom.character = char_ctrl::cc_esc;	//  '\x1b' 0x1b:ESC
			break;
#endif
		case char_alnum::ch_c:	//  \cX
			if (curpos != end)
			{
				atom.character = static_cast<uchar21_t>(*curpos | 0x20);
				if (atom.character >= char_alnum::ch_a && atom.character <= char_alnum::ch_z)
					atom.character = static_cast<uchar21_t>(*curpos++ & 0x1f);
				else
				{
					this->throw_error(regex_constants::error_escape);	//  strict.
				}
			}
			break;
		case char_alnum::ch_0:
			atom.character = char_ctrl::cc_nul;	//  '\0' 0x00:NUL
			break;
		case char_alnum::ch_u:	//  \uhhhh, \u{h~hhhhhh}
			atom.character = parse_escape_u(curpos, end);
			break;
		case char_alnum::ch_x:	//  \xhh
			atom.character = translate_numbers(curpos, end, 16, 2, 2, 0xff, false);
			break;
		//  SyntaxCharacter, '/', and '-'.
		case meta_char::mc_caret:	//  '^'
		case meta_char::mc_dollar:	//  '$'
		case meta_char::mc_escape:	//  '\\'
		case meta_char::mc_period:	//  '.'
		case meta_char::mc_astrsk:	//  '*'
		case meta_char::mc_plus:	//  '+'
		case meta_char::mc_query:	//  '?'
		case meta_char::mc_rbraop:	//  '('
		case meta_char::mc_rbracl:	//  ')'
		case meta_char::mc_sbraop:	//  '['
		case meta_char::mc_sbracl:	//  ']'
		case meta_char::mc_cbraop:	//  '{'
		case meta_char::mc_cbracl:	//  '}'
		case meta_char::mc_bar:		//  '|'
		case char_other::co_slash:	//  '/'
		case meta_char::mc_minus:	//  '-' allowed only in charclass.
			break;
		default:
			atom.character = constants::invalid_u21value;
		}
		if (atom.character == constants::invalid_u21value)	//  static_cast<uchar21_t>(~0))
			this->throw_error(regex_constants::error_escape);
		return true;
	}
	uchar21_t parse_escape_u(const uchar21_t *&curpos, const uchar21_t *const end) const
	{
		uchar21_t ucp;
		if (curpos == end)
			return constants::invalid_u21value;
		if (static_cast<uchar21_t>(*curpos) == meta_char::mc_cbraop)
			ucp = translate_numbers(++curpos, end, 16, 1, 0, constants::unicode_max_codepoint, true);
		else
		{
			ucp = translate_numbers(curpos, end, 16, 4, 4, 0xffff, false);
			if (ucp >= 0xd800 && ucp <= 0xdbff)
			{
				const uchar21_t * prefetch = curpos;
				if (prefetch != end && static_cast<uchar21_t>(*prefetch) == meta_char::mc_escape && ++prefetch != end && static_cast<uchar21_t>(*prefetch) == char_alnum::ch_u)
				{
					const uchar21_t nextucp = translate_numbers(++prefetch, end, 16, 4, 4, 0xffff, false);
					if (nextucp >= 0xdc00 && nextucp <= 0xdfff)
					{
						curpos = prefetch;
						ucp = (((ucp << 10) & 0xffc00) | (nextucp & 0x3ff)) + 0x10000;
					}
				}
			}
		}
		return ucp;
	}
#if !defined(SRELL_NO_UNICODE_PROPERTY)
	unsigned int get_property_number(const uchar21_t *&curpos, const uchar21_t *const end)
	{
		if (curpos == end || static_cast<uchar21_t>(*curpos) != meta_char::mc_cbraop)	//  '{'
			this->throw_error(regex_constants::error_escape);
		pstring pname;
		pstring pvalue(get_property_name_or_value(++curpos, end));
		if (!pvalue.size())
			this->throw_error(regex_constants::error_escape);
		if (pvalue[pvalue.size() - 1] != char_other::co_sp)	//  ' ', not marked as value.
		{
			if (curpos == end)
				this->throw_error(regex_constants::error_escape);
			if (static_cast<uchar21_t>(*curpos) == meta_char::mc_eq)	//  '='
			{
				pname = pvalue;
				pvalue = get_property_name_or_value(++curpos, end);
				if (!pvalue.size())
					this->throw_error(regex_constants::error_escape);
			}
		}
		if (curpos == end || static_cast<uchar21_t>(*curpos) != meta_char::mc_cbracl)	//  '}'
			this->throw_error(regex_constants::error_escape);
		if (pvalue[pvalue.size() - 1] == char_other::co_sp)	//  ' ', marked as value.
			pvalue.resize(pvalue.size() - 1);
		++curpos;
		const unsigned int class_number = this->character_class.lookup_property(pname, pvalue, this->is_icase());
		if (class_number == re_character_class::error_property)
			this->throw_error(regex_constants::error_escape);
		return class_number;
	}
	pstring get_property_name_or_value(const uchar21_t *&curpos, const uchar21_t *const end) const
	{
		pstring name_or_value;
		bool number_found = false;
		for (;; ++curpos)
		{
			if (curpos == end)
				break;
			const uchar21_t curchar = static_cast<uchar21_t>(*curpos);
			if (curchar >= char_alnum::ch_A && curchar <= char_alnum::ch_Z)
				;
			else if (curchar >= char_alnum::ch_a && curchar <= char_alnum::ch_z)
				;
			else if (curchar == char_other::co_ll)	//  '_'
				;
			else if (curchar >= char_alnum::ch_0 && curchar <= char_alnum::ch_9)
				number_found = true;
			else
				break;
			name_or_value.append(1, static_cast<typename pstring::value_type>(curchar));
		}
		if (number_found)
			name_or_value.append(1, char_other::co_sp);	//  ' '
		return name_or_value;
	}
#endif	//  !defined(SRELL_NO_UNICODE_PROPERTY)
	//  Escape characters which do not appear in [] pairs.
	bool translate_atom_escape(state_type &atom, const uchar21_t *&curpos, const uchar21_t *const end, /* const */ re_compiler_state &cstate)
	{
		if (curpos == end)
			this->throw_error(regex_constants::error_escape);
		atom.character = static_cast<uchar21_t>(*curpos);
		switch (atom.character)
		{
		case meta_char::mc_minus:	//  '-'
			this->throw_error(regex_constants::error_escape);
		case char_alnum::ch_B:	//  'B':
			atom.is_not = true;
		case char_alnum::ch_b:	//  'b':
			atom.type   = st_boundary;	//  \b, \B.
			atom.quantifier.reset(0);
			if (this->is_icase())
			{
				this->character_class.setup_icase_word();
				atom.number = re_character_class::icase_word;
			}
			else
				atom.number = re_character_class::word;	//  \w, \W.
			break;
		//  backreferences.
#if !defined(SRELL_NO_NAMEDCAPTURE)
		//  prepared for named captures.
		case char_alnum::ch_k:	//  'k':
			return parse_backreference_name(atom, curpos, end, cstate);	//  \k.
#endif
		default:
			if (atom.character >= char_alnum::ch_1 && atom.character <= char_alnum::ch_9)	//  \1, \9.
				return parse_backreference_number(atom, curpos, end, cstate);
			return translate_escseq(atom, curpos, end) && register_if_negatedcharclass(atom);
		}
		++curpos;
		return true;
	}
	bool register_if_negatedcharclass(state_type &atom)
	{
		if (atom.is_negcharclass())
		{
			range_pairs ranges;
			add_predefclass_to_charclass(ranges, atom);
			atom.number = this->character_class.register_newclass(ranges);
			atom.is_not = false;
		}
		return true;
	}
	bool parse_backreference_number(state_type &atom, const uchar21_t *&curpos, const uchar21_t *const end, const re_compiler_state &cstate)
	{
		atom.number = static_cast<unsigned int>(translate_numbers(curpos, end, 10, 0, 0, 0, false));
		if (atom.number == static_cast<unsigned int>(constants::invalid_u21value))	//  ~0))
			this->throw_error(regex_constants::error_escape);
		atom.backrefnumber_unresolved = false;
		return backreference_postprocess(atom, cstate);
	}
	bool backreference_postprocess(state_type &atom, const re_compiler_state & /* cstate */) const
	{
		atom.next2 = 1;
		atom.type = st_backreference;
			//  Moved to check_backreferences().
		return true;
	}
#if !defined(SRELL_NO_NAMEDCAPTURE)
	bool parse_backreference_name(state_type &atom, const uchar21_t *&curpos, const uchar21_t *const end, re_compiler_state &cstate)
	{
		if (++curpos == end || *curpos != meta_char::mc_lt)
			this->throw_error(regex_constants::error_escape);
		const gname_u21string groupname = get_groupname(++curpos, end);
		atom.number = this->namedcaptures[groupname];
		if (atom.number != groupname_mapper::notfound)
			atom.backrefnumber_unresolved = false;
		else
		{
			atom.backrefnumber_unresolved = true;
			atom.number = static_cast<unsigned int>(cstate.unresolved_gnames.size());
			cstate.unresolved_gnames.push_back(groupname, atom.number);
		}
		return backreference_postprocess(atom, cstate);
	}
	gname_u21string get_groupname(const uchar21_t *&curpos, const uchar21_t *const end)
	{
		gname_u21string groupname;
		for (;;)
		{
			if (curpos == end)
				this->throw_error(regex_constants::error_escape);
			uchar21_t curchar = *curpos++;
			if (curchar == meta_char::mc_gt)	//  '>'
				break;
			if (curchar == meta_char::mc_escape)
			{
				if (curpos != end && static_cast<uchar21_t>(*curpos) == char_alnum::ch_u)	//  '\\', 'u'.
					curchar = parse_escape_u(++curpos, end);
				else
					curchar = constants::invalid_u21value;
				if (curchar == constants::invalid_u21value)
					this->throw_error(regex_constants::error_escape);
			}
			groupname.append(1, curchar);
		}
		if (!groupname.size())
			this->throw_error(regex_constants::error_escape);
		return groupname;
	}
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
	bool get_quantifier(re_quantifier &quantifier, const uchar21_t *&curpos, const uchar21_t *const end)
	{
		switch (*curpos)
		{
		case meta_char::mc_astrsk:	//  '*':
			--quantifier.atleast;
		case meta_char::mc_plus:	//  '+':
			quantifier.set_infinity();
			break;
		case meta_char::mc_query:	//  '?':
			--quantifier.atleast;
			break;
		case meta_char::mc_cbraop:	//  '{':
			if (!get_brace_with_quantifier(quantifier, curpos, end))
				return false;
			break;
		default:
			return true;
		}
		if (++curpos != end && static_cast<uchar21_t>(*curpos) == meta_char::mc_query)	//  '?'
		{
			quantifier.is_greedy = false;
			++curpos;
		}
		return true;
	}
	bool get_brace_with_quantifier(re_quantifier &quantifier, const uchar21_t *&curpos, const uchar21_t *const end)
	{
		++curpos;
		quantifier.atleast = static_cast<unsigned int>(translate_numbers(curpos, end, 10, 1, 0, 0, false));
		if (quantifier.atleast == static_cast<unsigned int>(constants::invalid_u21value))
			this->throw_error(regex_constants::error_brace);
		quantifier.atmost = quantifier.atleast;
		if (curpos == end)
			this->throw_error(regex_constants::error_brace);
		if (static_cast<uchar21_t>(*curpos) == meta_char::mc_comma)	//  ','
		{
			++curpos;
			quantifier.atmost = static_cast<unsigned int>(translate_numbers(curpos, end, 10, 1, 0, 0, false));
			if (quantifier.atmost == static_cast<unsigned int>(constants::invalid_u21value))
				quantifier.set_infinity();
			if (!quantifier.is_valid())
				this->throw_error(regex_constants::error_badbrace);
		}
		if (curpos == end || static_cast<uchar21_t>(*curpos) != meta_char::mc_cbracl)	//  '}'
			this->throw_error(regex_constants::error_brace);
		//  *curpos == '}'
		return true;
	}
	uchar21_t translate_numbers(const uchar21_t *&curpos, const uchar21_t *const end, const int radix, const std::size_t minsize, const std::size_t maxsize, const uchar21_t maxcodepoint, const bool needs_closecurlybracket) const
	{
		uchar21_t univalue = 0;
		int num;
		for (std::size_t count = 0; !maxsize || count < maxsize; ++curpos, ++count)
		{
			if (curpos == end || (num = tonumber(*curpos, radix)) == -1)
			{
				if (count >= minsize)
					break;	//  OK.
				return constants::invalid_u21value;
			}
			univalue *= radix;
			univalue += num;
		}
		if (needs_closecurlybracket)
		{
			if (curpos == end || static_cast<uchar21_t>(*curpos) != meta_char::mc_cbracl)
				return constants::invalid_u21value;
			++curpos;
		}
		if (!maxcodepoint || univalue <= maxcodepoint)
			return univalue;
		return constants::invalid_u21value;
	}
	int tonumber(const uchar21_t ch, const int radix) const
	{
		if ((ch >= char_alnum::ch_0 && ch <= char_alnum::ch_7) || (radix >= 10 && (ch == char_alnum::ch_8 || ch == char_alnum::ch_9)))
			return static_cast<int>(ch - char_alnum::ch_0);
		if (radix == 16)
		{
			if (ch >= char_alnum::ch_a && ch <= char_alnum::ch_f)
				return static_cast<int>(ch - char_alnum::ch_a + 10);
			if (ch >= char_alnum::ch_A && ch <= char_alnum::ch_F)
				return static_cast<int>(ch - char_alnum::ch_A + 10);
		}
		return -1;
	}
	bool check_backreferences(const re_compiler_state &cstate)
	{
		for (typename state_array::size_type backrefpos = 0; backrefpos < this->NFA_states.size(); ++backrefpos)
		{
			state_type &brs = this->NFA_states[backrefpos];
			if (brs.type == st_backreference)
			{
				unsigned int &backrefno = brs.number;
#if !defined(SRELL_NO_NAMEDCAPTURE)
				if (brs.backrefnumber_unresolved)
				{
					if (backrefno >= cstate.unresolved_gnames.size())
						return false;	//  Internal error.
					brs.number = this->namedcaptures[cstate.unresolved_gnames[backrefno]];
					if (backrefno == groupname_mapper::notfound)
						return false;
					brs.backrefnumber_unresolved = false;
				}
#endif
				for (typename state_array::size_type roundbracket_closepos = 0;; ++roundbracket_closepos)
				{
					if (roundbracket_closepos < this->NFA_states.size())
					{
						const state_type &rbcs = this->NFA_states[roundbracket_closepos];
						if (rbcs.type == st_roundbracket_close && rbcs.number == backrefno)
						{
							if (roundbracket_closepos < backrefpos)
								brs.quantifier.atleast = cstate.atleast_widths_of_brackets[backrefno - 1];
							else
							{
								brs.type = st_epsilon;
								brs.next2 = 0;
							}
							break;
						}
					}
					else
						return false;
				}
			}
		}
		return true;
	}
#if !defined(SRELLDBG_NO_1STCHRCLS)
	void create_firstchar_class()
	{
#if !defined(SRELLDBG_NO_BITSET)
		range_pairs fcc;
#else
		range_pairs &fcc = this->firstchar_class;
#endif
		simple_array<bool> checked;
		checked.resize(this->NFA_states.size(), false);
		gather_nextchars(fcc, static_cast<typename state_array::size_type>(this->NFA_states[0].next1), checked, 0);
		if (fcc.size() == 0)
		{
			fcc.set_solerange(range_pair_helper(0, constants::unicode_max_codepoint));
			//  Expressions would consist of assertions only, such as /^$/.
			//  We cannot but accept every codepoint.
		}
		else if (this->is_icase())
			fcc.make_caseunfoldedcharset();
#if !defined(SRELLDBG_NO_BITSET)
		set_bitset_table(fcc);
#endif
	}
#if !defined(SRELLDBG_NO_BITSET)
	void set_bitset_table(const range_pairs &fcc)
	{
		this->firstchar_class_bs.reset();
		for (typename range_pairs::size_type i = 0; i < fcc.size(); ++i)
		{
			const range_pair &range = fcc[i];
			for (uchar21_t ucp = range.first; ucp <= constants::unicode_max_codepoint; ++ucp)
			{
				this->firstchar_class_bs.set(ucp);
				if (ucp == range.second)
					break;
			}
		}
	}
#endif	//  !defined(SRELLDBG_NO_BITSET)
#endif	//  !defined(SRELLDBG_NO_1STCHRCLS)
	bool gather_nextchars(range_pairs &nextcharclass, typename state_array::size_type pos, simple_array<bool> &checked, const unsigned int bracket_number) const
	{
		bool nullmatch = false;
		for (;;)
		{
			const state_type &state = this->NFA_states[pos];
			if (checked[pos])
				break;
			checked[pos] = true;
			if (state.next2 && (state.type != st_check_counter || !state.quantifier.is_greedy || state.quantifier.atleast == 0) && (state.type != st_roundbracket_close || bracket_number == 0) && (state.type != st_backreference || state.quantifier.atleast == 0))
				if (gather_nextchars(nextcharclass, pos + state.next2, checked, bracket_number))
					nullmatch = true;
			//  /a{0,3}b/ a-b OK.
			//  /a{1,3}b/ a OK.
			//  /a{0,3}?b/ a-b OK.
			//  /a{1,3}?b/ a OK.
			switch (state.type)
			{
			case st_character:
				nextcharclass.join(range_pair_helper(state.character));
				return nullmatch;
			case st_character_class:
				{
					range_pairs array = this->character_class[state.number];
					nextcharclass.merge(array);
					if (nextcharclass.size() == 0)
						nextcharclass.join(range_pair_helper(constants::invalid_u21value));
				}
				return nullmatch;
			case st_backreference:
				{
					const typename state_array::size_type nextpos = find_next_of_bracketopen(state.number);
					if (!check_if_wrapped_in_negative_lookaround(nextpos))
					{
						if (gather_nextchars(nextcharclass, nextpos, checked, state.number))
							nullmatch = true;
						if (nextcharclass.size())
							return nullmatch;
					}
				}
				break;
			case st_lookaround_open:
				if (!state.is_not && state.quantifier.atleast == 0)
					if (gather_nextchars(nextcharclass, pos + 2, checked, 0))
						nullmatch = true;
				break;
			case st_roundbracket_close:
				if (/* bracket_number == 0 || */ state.number != bracket_number)
					break;
			case st_lookaround_pop:
			case st_success:	//  == st_lookaround_close.
				return true;
			case st_check_counter:
				if (!state.quantifier.is_greedy && state.quantifier.atleast >= 1)
					return nullmatch;
			default:;
			}
			if (state.next1)
				pos += state.next1;
			else
				break;
		}
		return nullmatch;
	}
	bool gather_nextchars(range_pairs &nextcharclass, const typename state_array::size_type pos, const unsigned int bracket_number) const
	{
		simple_array<bool> checked;
		checked.resize(this->NFA_states.size(), false);
		return gather_nextchars(nextcharclass, pos, checked, bracket_number);
	}
	typename state_array::size_type find_next_of_bracketopen(const unsigned int bracketno) const
	{
		for (typename state_array::size_type no = 0; no < this->NFA_states.size(); ++no)
		{
			const state_type &state = this->NFA_states[no];
			if (state.type == st_roundbracket_open && state.number == bracketno)
				return no + state.next1;
		}
		return 0;
	}
	bool check_if_wrapped_in_negative_lookaround(const typename state_array::size_type end) const
	{
		bool wrapped_in_negative_assertion = false;
		unsigned int depth = 0;
		for (typename state_array::size_type cur = 0; cur != end; ++cur)
		{
			const state_type &state = this->NFA_states[cur];
			if (state.type == st_lookaround_open)
			{
				++depth;
				if (state.is_not)
					wrapped_in_negative_assertion = true;
			}
			else if (state.type == st_lookaround_close)
			{
				if (--depth == 0)
					wrapped_in_negative_assertion = false;
			}
		}
		return wrapped_in_negative_assertion;
	}
	void relativejump_to_absolutejump()
	{
		for (typename state_array::size_type pos = 0; pos < this->NFA_states.size(); ++pos)
		{
			state_type &state = this->NFA_states[pos];
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
			if (state.next1 || state.type == st_character || state.type == st_character_class)
#else
			if (state.next1)
#endif
				state.next_state1 = &this->NFA_states[pos + state.next1];
			else
				state.next_state1 = NULL;
			if (state.next2)
				state.next_state2 = &this->NFA_states[pos + state.next2];
			else
				state.next_state2 = NULL;
		}
	}
	void optimise()
	{
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
		asterisk_optimisation();
#endif
#if !defined(SRELLDBG_NO_NEXTPOS_OPT)
		if (!check_if_backref_presents(0, 0))
		{
	#if !defined(SRELLDBG_NO_NEXTPOS_OPT1) && !defined(SRELLDBG_NO_ASTERISK_OPT)
			nextpos_optimisation();
	#endif
	#if defined(SRELLTEST_NEXTPOS_OPT2)
			nextpos_optimisation2();
	#endif
	#if !defined(SRELLDBG_NO_NEXTPOS_OPT3)
			nextpos_optimisation3();
	#endif
		}
#endif
#if !defined(SRELLDBG_NO_BRANCH_OPT)
		branch_optimisation();
#endif
#if !defined(SRELLDBG_NO_1STCHRCLS)
		create_firstchar_class();
#endif
#if !defined(SRELLDBG_NO_SKIP_EPSILON)
		skip_epsilon();
#endif
#if !defined(SRELLDBG_NO_CCPOS)
		set_charclass_posinfo();
#endif
	}
#if !defined(SRELLDBG_NO_SKIP_EPSILON)
	void skip_epsilon()
	{
		for (typename state_array::size_type pos = 0; pos < this->NFA_states.size(); ++pos)
		{
			state_type &state = this->NFA_states[pos];
			if (state.next1)
				state.next1 = static_cast<std::ptrdiff_t>(skip_nonbranch_epsilon(pos + state.next1) - pos);
			if (state.next2)
				state.next2 = static_cast<std::ptrdiff_t>(skip_nonbranch_epsilon(pos + state.next2) - pos);
		}
	}
	typename state_array::size_type skip_nonbranch_epsilon(typename state_array::size_type pos) const
	{
		for (;;)
		{
			const state_type &state = this->NFA_states[pos];
			if (state.type == st_epsilon && state.next2 == 0)
			{
				pos += state.next1;
				continue;
			}
			break;
		}
		return pos;
	}
#endif
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
	void asterisk_optimisation()
	{
		for (typename state_array::size_type cur = 0; cur != this->NFA_states.size(); ++cur)
		{
			state_type &curstate = this->NFA_states[cur];
			switch (curstate.type)
			{
			case st_character:
			case st_character_class:
				if (curstate.quantifier.atleast == 0 && curstate.quantifier.is_infinity())
				{
					if (is_exclusive_sequence(cur))
					{
						state_type &prevstate = this->NFA_states[cur - 1];
						prevstate.next1 = 1;
						prevstate.next2 = 0;
						curstate.next1 = 0;
						curstate.next2 = 1;
					}
				}
				break;
#if !defined(SRELLDBG_NO_SPLIT_COUNTER)
				//  check_counter, increment_counter, decrement_counter, char_or_class?
			case st_check_counter:
				if (!curstate.quantifier.is_same() && is_exclusive_sequence(cur + 3))
					split_counter(cur);
				break;
#endif
			default:;
			}
		}
	}
	bool is_exclusive_sequence(const typename state_array::size_type cur) const
	{
		const state_type &curstate = this->NFA_states[cur];
		range_pairs curchar_class;
		range_pairs nextchar_class;
		simple_array<bool> checked;
		checked.resize(this->NFA_states.size(), false);
		if (curstate.type == st_character)
		{
			curchar_class.join(range_pair_helper(curstate.character));
		}
		else if (curstate.type == st_character_class)
		{
			curchar_class = this->character_class[curstate.number];
		}
		else
		{
			return false;
		}
		const bool nullmatch = gather_nextchars(nextchar_class, cur + 1, checked, 0);
		if (nextchar_class.size() && !curchar_class.is_overlap(nextchar_class))
		{
			return !nullmatch || curstate.quantifier.is_greedy;
		}
		else if (nextchar_class.size() == 0 && only_success_left(cur + 1, checked))
		{
			return curstate.quantifier.is_greedy;
		}
		return false;
	}
	bool only_success_left(typename state_array::size_type pos, simple_array<bool> &checked) const
	{
		for (;;)
		{
			const state_type &state = this->NFA_states[pos];
			switch (state.type)
			{
			case st_success:
				return true;
			case st_roundbracket_close:
			case st_backreference:
				if (state.next2 != 0 && state.next1 != state.next2)
					return false;
				break;
			case st_epsilon:
				if (state.next2 != 0 && !only_success_left(pos + state.next2, checked))
					return false;
				break;
			case st_roundbracket_open:
				break;	//  /a*()/
			default:
				return false;
			}
			if (state.next1)
				pos += state.next1;
			else
				return false;
		}
	}
#endif	//  !defined(SRELLDBG_NO_ASTERISK_OPT)
	void insert_at(const typename state_array::size_type pos, const std::ptrdiff_t len)
	{
		state_type newstate;
		for (typename state_array::size_type cur = 0; cur < pos; ++cur)
		{
			state_type &state = this->NFA_states[cur];
			if (state.next1 && (cur + state.next1) >= pos)
				state.next1 += len;
			if (state.next2 && (cur + state.next2) >= pos)
				state.next2 += len;
		}
		for (typename state_array::size_type cur = pos; cur < this->NFA_states.size(); ++cur)
		{
			state_type &state = this->NFA_states[cur];
			if ((cur + state.next1) < pos)
				state.next1 -= len;
			if ((cur + state.next2) < pos)
				state.next2 -= len;
		}
		newstate.reset();
		newstate.type = st_epsilon;
		for (std::ptrdiff_t count = 0; count < len; ++count)
			this->NFA_states.insert(pos, newstate);
	}
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
	void split_counter(typename state_array::size_type &cur)
	{
		insert_at(cur + 1, 4);
			//  check_counter, epsilon x 4, increment_counter, decrement_counter, char_or_class
		state_type &cur_chkcnt = this->NFA_states[cur];	//  check_counter.
		state_type &new_inccnt = this->NFA_states[cur + 1];	//  copy of increment_counter (cur_inccnt).
		state_type &new_deccnt = this->NFA_states[cur + 2];	//  copy of decrement_counter (cur_deccnt).
		state_type &new_chorcl = this->NFA_states[cur + 3];	//  copy of char or class (cur_chorcl).
		state_type &new_chkcnt = this->NFA_states[cur + 4];	//  copy of check_counter (cur).
		state_type &cur_inccnt = this->NFA_states[cur + 5];	//  increment_counter.
		state_type &cur_deccnt = this->NFA_states[cur + 6];	//  decrement_counter.
		state_type &cur_chorcl = this->NFA_states[cur + 7];	//  character or class.
		cur_chorcl.next1 += 4;
		cur_chkcnt.next1 = 1;
		cur_chkcnt.next2 = 4;
		cur_chkcnt.quantifier.is_greedy = true;
		new_chkcnt = cur_chkcnt;
		if (new_chkcnt.quantifier.atleast <= 4)
		{
			if (new_chkcnt.quantifier.atleast > 0)
			{
				cur_chkcnt = cur_chorcl;
				cur_chkcnt.next1 = 1;
				cur_chkcnt.quantifier.reset();
				if (new_chkcnt.quantifier.atleast > 1)
				{
					new_inccnt = cur_chkcnt;
					if (new_chkcnt.quantifier.atleast > 2)
					{
						new_deccnt = cur_chkcnt;
						if (new_chkcnt.quantifier.atleast > 3)
							new_chorcl = cur_chkcnt;
					}
				}
			}
			else
			{
				cur_chkcnt.reset();
				cur_chkcnt.type = st_epsilon;
			}
			if (!new_chkcnt.quantifier.is_infinity())
				new_chkcnt.quantifier.atmost -= new_chkcnt.quantifier.atleast;
			new_chkcnt.quantifier.atleast = 0;
		}
		else
		{
			cur_chkcnt.quantifier.atmost = cur_chkcnt.quantifier.atleast;
			new_inccnt = cur_inccnt;	//  increment_counter.
			new_deccnt = cur_deccnt;	//  decrement_counter.
			new_chorcl = cur_chorcl;	//  character or character_class.
		}
		new_chkcnt.dont_push = true;	//  Disables backtracking.
		cur_chorcl.next2 = 1;
		cur += 4;
	}
#endif	//  !defined(SRELLDBG_NO_ASTERISK_OPT)
	bool check_if_backref_presents(typename state_array::size_type begin /* = 0 */, const unsigned int number /* = 0 */) const
	{
		for (; begin < this->NFA_states.size(); ++begin)
		{
			const state_type &state = this->NFA_states[begin];
			if (state.type == st_backreference && (number == 0 || state.number == number))
				return true;
		}
		return false;
	}
#if !defined(SRELLDBG_NO_NEXTPOS_OPT)
#if !defined(SRELLDBG_NO_NEXTPOS_OPT1)
	void nextpos_optimisation()
	{
		typename state_array::size_type cur = 0;
		state_type *prevstate = NULL;
		for (;;)
		{
			state_type &curstate = this->NFA_states[cur];
			switch (curstate.type)
			{
			case st_character:
			case st_character_class:
				if (prevstate && !is_sequence(prevstate, curstate))
					break;
				//  !prevstate || is_sequence()
				if (curstate.next1 == 0)
				{
					if (this->NFA_states[++cur].type != st_success)
					{
						insert_at(cur, 1);
						{
							state_type &newstate = this->NFA_states[cur];
							newstate.type = st_move_nextpos;
							newstate.next1 = curstate.next2 - 1;
							curstate.next2 = 1;
						}
					}
					return;
				}
				prevstate = &curstate;
				cur += curstate.next1;
				continue;
			case st_save_and_reset_counter:
			case st_success:
				break;
			case st_epsilon:
				if (curstate.next2)
					break;
			default:
				cur += curstate.next1;
				continue;
			}
			break;
		}
	}
	bool is_sequence(const state_type *prevstate, const state_type &curstate) const
	{
		if (prevstate->type == curstate.type)
		{
			if (prevstate->type == st_character && prevstate->character == curstate.character)
				return true;
			if (prevstate->type == st_character_class && prevstate->number == curstate.number)
				return true;
		}
		return false;
	}
#endif	//  !defined(SRELLDBG_NO_NEXTPOS_OPT1)
#if defined(SRELLTEST_NEXTPOS_OPT2)
	void nextpos_optimisation2()
	{
		typename state_array::size_type cur = 1;
		range_pairs firstchar_class;
		for (; cur < this->NFA_states.size();)
		{
			const state_type &curstate = this->NFA_states[cur++];
			if (curstate.type == st_character)
			{
				firstchar_class.push_back(range_pair_helper(curstate.character));
				break;
			}
			else if (curstate.type == st_character_class)
			{
				firstchar_class = this->character_class[curstate.number];
				break;
			}
			else if (curstate.type == st_roundbracket_open || curstate.type == st_roundbracket_pop)
			{
				//  continue;
			}
			else
				return;
		}
		if (firstchar_class.size() == 0)
			return;
		for (; cur < this->NFA_states.size(); ++cur)
		{
			state_type &curstate = this->NFA_states[cur];
			range_pairs nextchar_class;
			if (curstate.type == st_character)
			{
				nextchar_class.push_back(range_pair_helper(curstate.character));
			}
			else if (curstate.type == st_character_class)
			{
				nextchar_class = this->character_class[curstate.number];
			}
			else if (curstate.type == st_roundbracket_open || curstate.type == st_roundbracket_pop || curstate.type == st_roundbracket_close)
			{
				continue;
			}
			else
				break;
			if (nextchar_class.size() == 0 || firstchar_class.is_overlap(nextchar_class))
				break;
			insert_at(++cur, 1);
			{
				state_type &newstate = this->NFA_states[cur];
				newstate.type = st_move_nextpos;
				--curstate.next1;
			}
		}
	}
#endif	//  defined(SRELLTEST_NEXTPOS_OPT2)
#if !defined(SRELLDBG_NO_NEXTPOS_OPT3)
	void nextpos_optimisation3()
	{
		typename state_array::size_type cur = 1;
		const state_type *prev = NULL;
		for (;; ++cur)
		{
			if (cur >= this->NFA_states.size())
				return;
			const state_type &curstate = this->NFA_states[cur];
			if (curstate.type == st_character || curstate.type == st_character_class)
			{
				if (!curstate.quantifier.is_default() && !curstate.quantifier.is_asterisk_or_plus())
					return;
				if (prev)
				{
					if (curstate.type == st_character && prev->character != curstate.character)
						return;
					else if (/* curstate.type == st_character_class && */ prev->number != curstate.number)
						return;
				}
				if (curstate.quantifier.is_infinity())
					break;
				prev = &curstate;	//  is_default().
			}
			else if (curstate.type == st_epsilon)
			{
				if (curstate.next2 != 0 && curstate.character != char_other::co_sp)
					return;
			}
			else if (curstate.type == st_roundbracket_open || curstate.type == st_roundbracket_pop || curstate.type == st_roundbracket_close)
			{
			}
			else
				return;
		}
		if (this->NFA_states[cur].next2 == 0)
		{
			insert_at(cur, 1);
			{
				state_type &newstate = this->NFA_states[cur];
				newstate.type = st_move_nextpos;
				newstate.next1 = -1;
				++this->NFA_states[cur + 1].next1;
			}
		}
	}
#endif	//  !defined(SRELLDBG_NO_NEXTPOS_OPT3)
#endif	//  !defined(SRELLDBG_NO_NEXTPOS_OPT)
#if !defined(SRELLDBG_NO_BRANCH_OPT)
	typename state_array::size_type gather_if_char_or_charclass(range_pairs &charclass, typename state_array::size_type pos) const
	{
		charclass.clear();
		for (; pos < this->NFA_states.size(); ++pos)
		{
			const state_type &curstate = this->NFA_states[pos];
			if (curstate.type == st_character && curstate.next2 == 0)
			{
				charclass.join(range_pair_helper(curstate.character));
				return pos;
			}
			else if (curstate.type == st_character_class && curstate.next2 == 0)
			{
				charclass = this->character_class[curstate.number];
				return pos;
			}
			else if (curstate.type == st_epsilon && curstate.next2 == 0)
			{
				continue;
			}
			else
				break;
		}
		return 0;
	}
	void branch_optimisation()
	{
		for (typename state_array::size_type pos = 0; pos < this->NFA_states.size(); ++pos)
		{
			const state_type &state = this->NFA_states[pos];
			if (state.type == st_epsilon)
			{
				if (state.next2 && state.character == meta_char::mc_bar)
				{
					{
						range_pairs nextcharclass1;
						const typename state_array::size_type nextcharpos = gather_if_char_or_charclass(nextcharclass1, pos + state.next1);
						if (nextcharpos)
						{
							range_pairs nextcharclass2;
							gather_nextchars(nextcharclass2, pos + state.next2, 0 /* bracket_number */);
							if (!nextcharclass1.is_overlap(nextcharclass2))
							{
								state_type &branch = this->NFA_states[pos];
								state_type &next1 = this->NFA_states[nextcharpos];
								next1.next2 = pos + branch.next2 - nextcharpos;
								branch.next2 = 0;
							}
						}
					}
				}
			}
#if 0
			else if (state.type == st_roundbracket_open)
			{
				pos = branch_optimisation(pos + 1, state.number);
			}
			else if (state.type == st_roundbracket_close && state.number == bracket_number)
			{
				return pos;
			}
#endif
		}
	}
#endif	//  !defined(SRELLDBG_NO_BRANCH_OPT)
	bool check_if_really_needs_icase_search()
	{
		uchar21_t u21chars[unicode_case_folding::rev_maxset];
		for (typename state_array::size_type i = 0; i < this->NFA_states.size(); ++i)
		{
			const state_type &state = this->NFA_states[i];
			if (state.type == st_character)
			{
				if (unicode_case_folding::casefoldedcharset(u21chars, state.character) > 1)
					return true;
			}
			else if (state.type == st_backreference)
				return true;
		}
		this->soflags &= ~regex_constants::icase;
		return false;
	}
#if !defined(SRELLDBG_NO_BMH)
	bool needs_to_run_automaton()
	{
		simple_array<uchar21_t> u21s;
		for (typename state_array::size_type i = 1; i < this->NFA_states.size(); ++i)
		{
			const state_type &state = this->NFA_states[i];
			if (state.type == st_character)
				u21s.push_back(state.character);
			else
			{
				u21s.clear();
				break;
			}
		}
		if (u21s.size() > 1)
		{
			if (this->bmdata)
				this->bmdata->clear();
			else
				this->bmdata = new re_bmh<charT, utf_traits>;
			this->bmdata->setup(u21s, this->is_icase());
			this->NFA_states.clear();
			return false;
		}
		if (this->bmdata)
			delete this->bmdata;
		this->bmdata = NULL;
		return true;
	}
#endif	//  !defined(SRELLDBG_NO_BMH)
#if !defined(SRELLDBG_NO_CCPOS)
	void set_charclass_posinfo()
	{
		for (typename state_array::size_type i = 1; i < this->NFA_states.size(); ++i)
		{
			state_type &state = this->NFA_states[i];
			if (state.type == st_character_class)
			{
				const range_pair &posinfo = this->character_class.charclasspos(state.number);
				state.quantifier.setccpos(posinfo.first, posinfo.second);
			}
		}
	}
#endif	//  !defined(SRELLDBG_NO_CCPOS)
public:	//  for debug.
	void print_NFA_states(const bool) const;
};
	}	//  namespace regex_internal
template <class BidirectionalIterator>
class sub_match : public std::pair<BidirectionalIterator, BidirectionalIterator>
{
public:
	typedef typename std::iterator_traits<BidirectionalIterator>::value_type value_type;
	typedef typename std::iterator_traits<BidirectionalIterator>::difference_type difference_type;
	typedef BidirectionalIterator iterator;
	typedef std::basic_string<value_type> string_type;
	bool matched;
	sub_match() : matched(false)
	{
	}
	difference_type length() const
	{
		return matched ? std::distance(this->first, this->second) : 0;
	}
	operator string_type() const
	{
		return matched ? string_type(this->first, this->second) : string_type();
	}
	string_type str() const
	{
		return matched ? string_type(this->first, this->second) : string_type();
	}
	int compare(const sub_match &s) const
	{
		return str().compare(s.str());
	}
	int compare(const string_type &s) const
	{
		return str().compare(s);
	}
	int compare(const value_type *const s) const
	{
		return str().compare(s);
	}
};
template <class BiIter>
bool operator==(const sub_match<BiIter> &lhs, const sub_match<BiIter> &rhs)
{
	return lhs.compare(rhs) == 0;	//  1
}
template <class BiIter>
bool operator!=(const sub_match<BiIter> &lhs, const sub_match<BiIter> &rhs)
{
	return lhs.compare(rhs) != 0;	//  2
}
template <class BiIter>
bool operator<(const sub_match<BiIter> &lhs, const sub_match<BiIter> &rhs)
{
	return lhs.compare(rhs) < 0;	//  3
}
template <class BiIter>
bool operator<=(const sub_match<BiIter> &lhs, const sub_match<BiIter> &rhs)
{
	return lhs.compare(rhs) <= 0;	//  4
}
template <class BiIter>
bool operator>=(const sub_match<BiIter> &lhs, const sub_match<BiIter> &rhs)
{
	return lhs.compare(rhs) >= 0;	//  5
}
template <class BiIter>
bool operator>(const sub_match<BiIter> &lhs, const sub_match<BiIter> &rhs)
{
	return lhs.compare(rhs) > 0;	//  6
}
template <class BiIter, class ST, class SA>
bool operator==(
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs.compare(lhs.c_str()) == 0;	//  7
}
template <class BiIter, class ST, class SA>
bool operator!=(
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(lhs == rhs);	//  8
}
template <class BiIter, class ST, class SA>
bool operator<(
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs.compare(lhs.c_str()) > 0;	//  9
}
template <class BiIter, class ST, class SA>
bool operator>(
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs < lhs;	//  10
}
template <class BiIter, class ST, class SA>
bool operator>=(
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(lhs < rhs);	//  11
}
template <class BiIter, class ST, class SA>
bool operator<=(
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(rhs < lhs);	//  12
}
template <class BiIter, class ST, class SA>
bool operator==(
	const sub_match<BiIter> &lhs,
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &rhs
)
{
	return lhs.compare(rhs.c_str()) == 0;	//  13
}
template <class BiIter, class ST, class SA>
bool operator!=(
	const sub_match<BiIter> &lhs,
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &rhs
)
{
	return !(lhs == rhs);	//  14
}
template <class BiIter, class ST, class SA>
bool operator<(
	const sub_match<BiIter> &lhs,
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &rhs
)
{
	return lhs.compare(rhs.c_str()) < 0;	//  15
}
template <class BiIter, class ST, class SA>
bool operator>(
	const sub_match<BiIter> &lhs,
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &rhs
)
{
	return rhs < lhs;	//  16
}
template <class BiIter, class ST, class SA>
bool operator>=(
	const sub_match<BiIter> &lhs,
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &rhs
)
{
	return !(lhs < rhs);	//  17
}
template <class BiIter, class ST, class SA>
bool operator<=(
	const sub_match<BiIter> &lhs,
	const std::basic_string<typename std::iterator_traits<BiIter>::value_type, ST, SA> &rhs
)
{
	return !(rhs < lhs);	//  18
}
template <class BiIter>
bool operator==(
	typename std::iterator_traits<BiIter>::value_type const *lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs.compare(lhs) == 0;	//  19
}
template <class BiIter>
bool operator!=(
	typename std::iterator_traits<BiIter>::value_type const *lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(lhs == rhs);	//  20
}
template <class BiIter>
bool operator<(
	typename std::iterator_traits<BiIter>::value_type const *lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs.compare(lhs) > 0;	//  21
}
template <class BiIter>
bool operator>(
	typename std::iterator_traits<BiIter>::value_type const *lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs < lhs;	//  22
}
template <class BiIter>
bool operator>=(
	typename std::iterator_traits<BiIter>::value_type const *lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(lhs < rhs);	//  23
}
template <class BiIter>
bool operator<=(
	typename std::iterator_traits<BiIter>::value_type const *lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(rhs < lhs);	//  24
}
template <class BiIter>
bool operator==(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const *rhs
)
{
	return lhs.compare(rhs) == 0;	//  25
}
template <class BiIter>
bool operator!=(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const *rhs
)
{
	return !(lhs == rhs);	//  26
}
template <class BiIter>
bool operator<(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const *rhs
)
{
	return lhs.compare(rhs) < 0;	//  27
}
template <class BiIter>
bool operator>(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const *rhs
)
{
	return rhs < lhs;	//  28
}
template <class BiIter>
bool operator>=(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const *rhs
)
{
	return !(lhs < rhs);	//  29
}
template <class BiIter>
bool operator<=(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const *rhs
)
{
	return !(rhs < lhs);	//  30
}
template <class BiIter>
bool operator==(
	typename std::iterator_traits<BiIter>::value_type const &lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs.compare(typename sub_match<BiIter>::string_type(1, lhs)) == 0;	//  31
}
template <class BiIter>
bool operator!=(
	typename std::iterator_traits<BiIter>::value_type const &lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(lhs == rhs);	//  32
}
template <class BiIter>
bool operator<(
	typename std::iterator_traits<BiIter>::value_type const &lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs.compare(typename sub_match<BiIter>::string_type(1, lhs)) > 0;	//  33
}
template <class BiIter>
bool operator>(
	typename std::iterator_traits<BiIter>::value_type const &lhs,
	const sub_match<BiIter> &rhs
)
{
	return rhs < lhs;	//  34
}
template <class BiIter>
bool operator>=(
	typename std::iterator_traits<BiIter>::value_type const &lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(lhs < rhs);	//  35
}
template <class BiIter>
bool operator<=(
	typename std::iterator_traits<BiIter>::value_type const &lhs,
	const sub_match<BiIter> &rhs
)
{
	return !(rhs < lhs);	//  36
}
template <class BiIter>
bool operator==(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const &rhs
)
{
	return lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) == 0;	//  37
}
template <class BiIter>
bool operator!=(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const &rhs
)
{
	return !(lhs == rhs);	//  38
}
template <class BiIter>
bool operator<(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const &rhs
)
{
	return lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) < 0;	//  39
}
template <class BiIter>
bool operator>(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const &rhs
)
{
	return rhs < lhs;	//  40
}
template <class BiIter>
bool operator>=(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const &rhs
)
{
	return !(lhs < rhs);	//  41
}
template <class BiIter>
bool operator<=(
	const sub_match<BiIter> &lhs,
	typename std::iterator_traits<BiIter>::value_type const &rhs
)
{
	return !(rhs < lhs);	//  42
}
template <class charT, class ST, class BiIter>
std::basic_ostream<charT, ST> &operator<<(std::basic_ostream<charT, ST> &os, const sub_match<BiIter> &m)
{
	return (os << m.str());
}
typedef sub_match<const char *> csub_match;
typedef sub_match<const wchar_t *> wcsub_match;
typedef sub_match<std::string::const_iterator> ssub_match;
typedef sub_match<std::wstring::const_iterator> wssub_match;
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
	typedef sub_match<const char16_t *> u16csub_match;
	typedef sub_match<const char32_t *> u32csub_match;
	typedef sub_match<std::u16string::const_iterator> u16ssub_match;
	typedef sub_match<std::u32string::const_iterator> u32ssub_match;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef sub_match<const char8_t *> u8csub_match;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED) && SRELL_CPP20_CHAR8_ENABLED >= 2
	typedef sub_match<std::u8string::const_iterator> u8ssub_match;
#endif
typedef csub_match u8ccsub_match;
typedef ssub_match u8cssub_match;
#if !defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef u8ccsub_match u8csub_match;
#endif
#if !defined(SRELL_CPP20_CHAR8_ENABLED) || SRELL_CPP20_CHAR8_ENABLED < 2
	typedef u8cssub_match u8ssub_match;
#endif
#if defined(WCHAR_MAX)
	#if WCHAR_MAX >= 0x10ffff
		typedef wcsub_match u32wcsub_match;
		typedef wssub_match u32wssub_match;
	#elif WCHAR_MAX >= 0xffff
		typedef wcsub_match u16wcsub_match;
		typedef wssub_match u16wssub_match;
	#endif
#endif
template <class BidirectionalIterator, class Allocator = std::allocator<sub_match<BidirectionalIterator> > >
class match_results
{
public:
	typedef sub_match<BidirectionalIterator> value_type;
	typedef const value_type & const_reference;
	typedef const_reference reference;
	typedef typename std::vector<value_type, Allocator>::const_iterator const_iterator;
	typedef const_iterator iterator;
	typedef typename std::iterator_traits<BidirectionalIterator>::difference_type difference_type;
#if defined(__cplusplus) && __cplusplus >= 201103L
	typedef typename std::allocator_traits<Allocator>::size_type size_type;
#else
	typedef typename Allocator::size_type size_type;	//  TR1.
#endif
	typedef Allocator allocator_type;
	typedef typename std::iterator_traits<BidirectionalIterator>::value_type char_type;
	typedef std::basic_string<char_type> string_type;
public:
	//  28.10.1, construct/copy/destroy:
	//  [7.10.1] construct/copy/destroy
	explicit match_results(const Allocator &a = Allocator()) : ready_(false), sub_matches_(a)
	{
	}
	match_results(const match_results &m) : ready_(false)
	{
		operator=(m);
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	match_results(match_results &&m) SRELL_NOEXCEPT
	{
		operator=(std::move(m));
	}
#endif
	match_results &operator=(const match_results &m)
	{
		if (this != &m)
		{
			this->ready_ = m.ready_;
			this->sub_matches_ = m.sub_matches_;
			this->prefix_ = m.prefix_;
			this->suffix_ = m.suffix_;
			this->base_ = m.base_;
#if !defined(SRELL_NO_NAMEDCAPTURE)
			this->gnames_ = m.gnames_;
#endif
		}
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	match_results &operator=(match_results &&m) SRELL_NOEXCEPT
	{
		if (this != &m)
		{
			this->ready_ = m.ready_;
			this->sub_matches_ = std::move(m.sub_matches_);
			this->prefix_ = std::move(m.prefix_);
			this->suffix_ = std::move(m.suffix_);
			this->base_ = m.base_;
#if !defined(SRELL_NO_NAMEDCAPTURE)
			this->gnames_ = std::move(m.gnames_);
#endif
		}
		return *this;
	}
#endif
	//  28.10.2, state:
	bool ready() const
	{
		return ready_;
	}
	//  28.10.3, size:
	//  [7.10.2] size
	size_type size() const
	{
		return sub_matches_.size();
	}
	size_type max_size() const
	{
		return sub_matches_.max_size();
	}
	bool empty() const
	{
		return size() == 0;
	}
	//  28.10.4, element access:
	//  [7.10.3] element access
	difference_type length(const size_type sub = 0) const
	{
		return (*this)[sub].length();
	}
	difference_type position(const size_type sub = 0) const
	{
		const_reference ref = (*this)[sub];
		return std::distance(base_, ref.first);
	}
	string_type str(const size_type sub = 0) const
	{
		return string_type((*this)[sub]);
	}
	const_reference operator[](const size_type n) const
	{
		return sub_matches_[n];
	}
#if !defined(SRELL_NO_NAMEDCAPTURE)
	//  Minimal support for access to captured sequences by name.
	difference_type length(const string_type &sub) const
	{
		return (*this)[sub].length();
	}
	difference_type position(const string_type &sub) const
	{
		const_reference ref = (*this)[sub];
		return std::distance(base_, ref.first);
	}
	string_type str(const string_type &sub) const
	{
		return string_type((*this)[sub]);
	}
	const_reference operator[](const string_type &sub) const
	{
		const unsigned int backrefno = lookup_backref_number(sub);
		return sub_matches_[backrefno];
	}
#if 0
	//  Overload functions that takes a pointer type as the first parameter
	//  are commented out because when a null pointer is passed, compilers
	//  are thrown into confusion between "size_type n" above and
	//  "char_type *sub" here.
	difference_type length(const char_type *sub) const
	{
		return (*this)[sub].length();
	}
	difference_type position(const char_type *sub) const
	{
		const_reference ref = (*this)[sub];
		return std::distance(base_, ref.first);
	}
	string_type str(const char_type *sub) const
	{
		return string_type((*this)[sub]);
	}
	const_reference operator[](const char_type *sub) const
	{
		const unsigned int backrefno = lookup_backref_number(sub);
		return sub_matches_[backrefno];
	}
#endif
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
	const_reference prefix() const
	{
		return prefix_;
	}
	const_reference suffix() const
	{
		return suffix_;
	}
	const_iterator begin() const
	{
		return sub_matches_.begin();
	}
	const_iterator end() const
	{
		return sub_matches_.end();
	}
	const_iterator cbegin() const
	{
		return sub_matches_.begin();
	}
	const_iterator cend() const
	{
		return sub_matches_.end();
	}
	//  28.10.5, format:
	//  [7.10.4] format
	template <class OutputIter>
	OutputIter format(
		OutputIter out,
		const char_type *fmt_first,
		const char_type *const fmt_last,
		regex_constants::match_flag_type /* flags */ = regex_constants::format_default
	) const
	{
		if (this->ready() && !this->empty())
		{
#if !defined(SRELL_NO_NAMEDCAPTURE)
			const bool no_groupnames = gnames_.size() == 0;
#endif
			const value_type &m0 = (*this)[0];
			while (fmt_first != fmt_last)
			{
				if (*fmt_first != static_cast<char_type>(regex_internal::meta_char::mc_dollar))	//  '$'
				{
					*out++ = *fmt_first++;
				}
				else
				{
					++fmt_first;
					if (fmt_first == fmt_last)
					{
						*out++ = regex_internal::meta_char::mc_dollar;	//  '$';
					}
					else if (*fmt_first == static_cast<char_type>(regex_internal::char_other::co_amp))	//  '&', $&
					{
						out = std::copy(m0.first, m0.second, out);
						++fmt_first;
					}
					else if (*fmt_first == static_cast<char_type>(regex_internal::char_other::co_grav))	//  '`', $`, prefix.
					{
						out = std::copy(this->prefix().first, this->prefix().second, out);
						++fmt_first;
					}
					else if (*fmt_first == static_cast<char_type>(regex_internal::char_other::co_apos))	//  '\'', $', suffix.
					{
						out = std::copy(this->suffix().first, this->suffix().second, out);
						++fmt_first;
					}
#if !defined(SRELL_NO_NAMEDCAPTURE)
					else if (*fmt_first == static_cast<char_type>(regex_internal::meta_char::mc_lt) && !no_groupnames)	//  '<', $<
					{
						const char_type *const current_backup = fmt_first;
						bool replaced = false;
						if (++fmt_first == fmt_last)
							;	//  do nothing.
						else
						{
							const char_type *const name_begin = fmt_first;
							for (;; ++fmt_first)
							{
								if (*fmt_first == static_cast<char_type>(regex_internal::meta_char::mc_gt))
								{
									const unsigned int backref_number = lookup_backref_number(name_begin, fmt_first);
									if (backref_number != regex_internal::groupname_mapper::notfound)
									{
										const value_type &mn = (*this)[backref_number];
										if (mn.matched)
											out = std::copy(mn.first, mn.second, out);
										replaced = true;
									}
									++fmt_first;
									break;
								}
								if (fmt_first == fmt_last)
									break;
							}
						}
						if (!replaced)
						{
							fmt_first = current_backup;
							*out++ = regex_internal::meta_char::mc_dollar;	//  '$';
						}
					}
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
					else
					{
						const char_type *const backup_pos = fmt_first;
						size_type backref_number = 0;
						if (fmt_first != fmt_last && *fmt_first >= static_cast<char_type>(regex_internal::char_alnum::ch_0) && *fmt_first <= static_cast<char_type>(regex_internal::char_alnum::ch_9))	//  '0'-'9'
						{
							backref_number += *fmt_first - regex_internal::char_alnum::ch_0;	//  '0';
							if (++fmt_first != fmt_last && *fmt_first >= static_cast<char_type>(regex_internal::char_alnum::ch_0) && *fmt_first <= static_cast<char_type>(regex_internal::char_alnum::ch_9))	//  '0'-'9'
							{
								backref_number *= 10;
								backref_number += *fmt_first - regex_internal::char_alnum::ch_0;	//  '0';
								++fmt_first;
							}
						}
						if (backref_number && backref_number < this->size())
						{
							const value_type &mn = (*this)[backref_number];
							if (mn.matched)
								out = std::copy(mn.first, mn.second, out);
						}
						else
						{
							*out++ = regex_internal::meta_char::mc_dollar;	//  '$';
							fmt_first = backup_pos;
							if (*fmt_first == static_cast<char_type>(regex_internal::meta_char::mc_dollar))
								++fmt_first;
						}
					}
				}
			}
		}
		return out;
	}
	template <class OutputIter, class ST, class SA>
	OutputIter format(
		OutputIter out,
		const std::basic_string<char_type, ST, SA> &fmt,
		regex_constants::match_flag_type flags = regex_constants::format_default
	) const
	{
		return format(out, fmt.data(), fmt.data() + fmt.size(), flags);
	}
	template <class ST, class SA>
	std::basic_string<char_type, ST, SA> format(
		const string_type &fmt,
		regex_constants::match_flag_type flags = regex_constants::format_default
	) const
	{
		std::basic_string<char_type, ST, SA> result;
		format(std::back_inserter(result), fmt, flags);
		return result;
	}
	string_type format(const char_type *fmt, regex_constants::match_flag_type flags = regex_constants::format_default) const
	{
		string_type result;
		format(std::back_inserter(result), fmt, fmt + std::char_traits<char_type>::length(fmt), flags);
		return result;
	}
	//  28.10.6, allocator:
	//  [7.10.5] allocator
	allocator_type get_allocator() const
	{
		return allocator_type();
	}
	//  28.10.7, swap:
	//  [7.10.6] swap
	void swap(match_results &that)
	{
		const match_results tmp(that);
		that = *this;
		*this = tmp;
	}
public:	//  for internal.
	typedef match_results<BidirectionalIterator> match_results_type;
	typedef typename match_results_type::size_type match_results_size_type;
	typedef typename regex_internal::re_search_state</*charT, */BidirectionalIterator> search_state_type;
	search_state_type sstate_;
	void clear_()
	{
		ready_ = false;
		sub_matches_.clear();
#if !defined(SRELL_NO_NAMEDCAPTURE)
		gnames_.clear();
#endif
	}
#if !defined(SRELL_NO_NAMEDCAPTURE)
	bool set_match_results_(const regex_internal::groupname_mapper &gnames)
#else
	bool set_match_results_()
#endif
	{
		unsigned int numofbrackets = static_cast<unsigned int>(sstate_.bracket.size());
		sub_matches_.resize(numofbrackets);
		while (numofbrackets)
		{
			value_type &sm = sub_matches_[--numofbrackets];
			sstate_.set_submatch(sm, numofbrackets);
		}
		sub_matches_[0].second  = sstate_.nth.in_string;
		sub_matches_[0].matched = true;
		prefix_.first   = base_ = sstate_.realbase;
		prefix_.second  = sub_matches_[0].first;
		prefix_.matched = prefix_.first != prefix_.second;
		//  The spec says prefix().first != prefix().second
		suffix_.first   = sub_matches_[0].second;
		suffix_.second  = sstate_.last;
		suffix_.matched = suffix_.first != suffix_.second;
		//  The spec says suffix().first != suffix().second
#if !defined(SRELL_NO_NAMEDCAPTURE)
		gnames_ = gnames;
#endif
		ready_ = true;
		return true;
	}
	void set_base_(const BidirectionalIterator &base)
	{
		base_ = base;
	}
	bool mark_as_failed_()
	{
		ready_ = true;
		return false;
	}
private:
#if !defined(SRELL_NO_NAMEDCAPTURE)
	unsigned int lookup_backref_number(const char_type *begin, const char_type *const end) const
	{
		typedef typename regex_internal::utf_translator<char_type> utftranslator;
		typename regex_internal::groupname_mapper::u21string key;
		for (; begin != end;)
		{
			key.append(1, utftranslator::codepoint_inc(begin, end));
		}
		return gnames_[key];
	}
	unsigned int lookup_backref_number(const char_type *const begin) const
	{
		const char_type *end = begin;
		for (; *end; ++end);
		return lookup_backref_number(begin, end);
	}
	unsigned int lookup_backref_number(const string_type &s) const
	{
		return lookup_backref_number(s.c_str(), s.c_str() + s.size());
	}
#endif	//  !defined(SRELL_NO_NAMEDCAPTURE)
public:	//  for debug.
	template <typename BasicRegexT>
	void print_sub_matches(const BasicRegexT &, const bool) const;
	void print_addresses(const value_type &, const char *const) const;
public:
	BidirectionalIterator lookbehind_limit;
private:
	typedef std::vector<value_type, Allocator> sub_match_array;
	bool ready_;
	sub_match_array sub_matches_;
	value_type prefix_;
	value_type suffix_;
	BidirectionalIterator base_;
#if !defined(SRELL_NO_NAMEDCAPTURE)
	regex_internal::groupname_mapper gnames_;
#endif
};
template <class BidirectionalIterator, class Allocator>
void swap(
	match_results<BidirectionalIterator, Allocator> &m1,
	match_results<BidirectionalIterator, Allocator> &m2
)
{
	m1.swap(m2);
}
template <class BidirectionalIterator, class Allocator>
bool operator==(
	const match_results<BidirectionalIterator, Allocator> &m1,
	const match_results<BidirectionalIterator, Allocator> &m2
)
{
	if (!m1.ready() && !m2.ready())
		return true;
	if (m1.ready() && m2.ready())
	{
		if (m1.empty() && m2.empty())
			return true;
		if (!m1.empty() && !m2.empty())
		{
			return m1.prefix() == m2.prefix() && m1.size() == m2.size() && std::equal(m1.begin(), m1.end(), m2.begin()) && m1.suffix() == m2.suffix();
		}
	}
	return false;
}
template <class BidirectionalIterator, class Allocator>
bool operator!=(
	const match_results<BidirectionalIterator, Allocator> &m1,
	const match_results<BidirectionalIterator, Allocator> &m2
)
{
	return !(m1 == m2);
}
typedef match_results<const char *> cmatch;
typedef match_results<const wchar_t *> wcmatch;
typedef match_results<std::string::const_iterator> smatch;
typedef match_results<std::wstring::const_iterator> wsmatch;
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
	typedef match_results<const char16_t *> u16cmatch;
	typedef match_results<const char32_t *> u32cmatch;
	typedef match_results<std::u16string::const_iterator> u16smatch;
	typedef match_results<std::u32string::const_iterator> u32smatch;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef match_results<const char8_t *> u8cmatch;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED) && SRELL_CPP20_CHAR8_ENABLED >= 2
	typedef match_results<std::u8string::const_iterator> u8smatch;
#endif
typedef cmatch u8ccmatch;
typedef smatch u8csmatch;
#if !defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef u8ccmatch u8cmatch;
#endif
#if !defined(SRELL_CPP20_CHAR8_ENABLED) || SRELL_CPP20_CHAR8_ENABLED < 2
	typedef u8csmatch u8smatch;
#endif
#if defined(WCHAR_MAX)
	#if WCHAR_MAX >= 0x10ffff
		typedef wcmatch u32wcmatch;
		typedef wsmatch u32wsmatch;
	#elif WCHAR_MAX >= 0xffff
		typedef wcmatch u16wcmatch;
		typedef wsmatch u16wsmatch;
	#endif
#endif
	namespace regex_internal
	{
template <typename charT, typename traits>
class regex_object : public re_compiler<charT, traits>
{
public:
	template <typename BidirectionalIterator>
	bool search
	(
		BidirectionalIterator first,
		const BidirectionalIterator &last,
		match_results<BidirectionalIterator> &results,
		const regex_constants::match_flag_type &flags /* = regex_constants::match_default */
	) const
	{
		results.clear_();
		results.sstate_.template init<utf_traits>(results.lookbehind_limit, first, last, flags, this->number_of_brackets);
		if (!this->is_icase() ? do_search<false>(results, flags) : do_search<true>(results, flags))
		{
#if !defined(SRELL_NO_NAMEDCAPTURE)
			return results.set_match_results_(this->namedcaptures);
#else
			return results.set_match_results_();
#endif
		}
		return results.mark_as_failed_();
	}
private:
	template <const bool icase, typename BidirectionalIterator>
	bool do_search
	(
		match_results<BidirectionalIterator> &results,
		const regex_constants::match_flag_type &flags
	) const
	{
		re_search_state</*charT, */BidirectionalIterator> &sstate = results.sstate_;
		if (this->NFA_states.size())
		{
			const BidirectionalIterator searchend = (flags & regex_constants::match_continuous) ? sstate.safebase : sstate.last;
			BidirectionalIterator first;
			sstate.init_for_automaton(this->NFA_states[0].next_state1, this->number_of_counters, this->number_of_repeats);
			while (sstate.nextpos != searchend)
			{
				first = sstate.nextpos;
#ifdef SRELLDBG_NO_1STCHRCLS
				utf_traits::codepoint_inc(sstate.nextpos, sstate.last);
#else
				{
					const uchar21_t firstchar = utf_traits::codepoint_inc(sstate.nextpos, sstate.last);
	#if !defined(SRELLDBG_NO_BITSET)
					if (firstchar > constants::unicode_max_codepoint || !this->firstchar_class_bs.test(firstchar))
	#else
					if (!this->firstchar_class.is_included(firstchar))
	#endif
						continue;
				}
#endif
				FINAL_TRY:
#if defined(SRELL_NO_LIMIT_COUNTER)
				sstate.reset(first);
#else
				sstate.reset(first, this->limit_counter);
#endif
				if (run_automaton<icase, false>(sstate, false))
					return true;
			}
			//  We are here because (flags & regex_constants::match_continuous) == true
			//  or first == last. Even in the latter case, we have to try once more
			//  for such expressions as "" =~ /^$/ or "..." =~ /$/.
			if (!sstate.is_last_tried())
			{
				first = sstate.nextpos;
				goto FINAL_TRY;
			}
				//  28.11.2: Postconditions: m.ready() == true in all cases.
				//  28.11.3: Postconditions: m.ready() == true in all cases.
		}
#if !defined(SRELLDBG_NO_BMH)
		else if (this->bmdata)
		{
			if (!sstate.match_continuous_flag())
				return re_bmh<charT, utf_traits>::template search_proxy<BidirectionalIterator, icase>::do_search(sstate, this->bmdata);
			//  match_continous or regex_match.
			if (re_bmh<charT, utf_traits>::template match_proxy<BidirectionalIterator, icase>::do_match(sstate, this->bmdata))
			{
				if (!sstate.match_match_flag())	//  match_continous.
					return sstate.set_bracket0(sstate.realbase, sstate.nextpos);
				//  regex_match.
				if (sstate.nextpos == sstate.last)
					return sstate.set_bracket0(sstate.realbase, sstate.last);
			}
		}
#endif
		return false;
	}
private:
	typedef typename traits::utf_traits utf_traits;
	template <typename T, const bool>
	struct canonicaliser
	{
		static T canonicalise(const T &t)
		{
			return t;
		}
	};
	template <typename T>
	struct canonicaliser<T, true>
	{
		static T canonicalise(const T &t)
		{
			return unicode_case_folding::do_casefolding(t);
		}
	};
	template <const bool icase, const bool reverse, typename BidirectionalIterator>
	bool run_automaton
	(
		re_search_state</*charT, */BidirectionalIterator> &sstate
		, const bool is_recursive /* = false */
	) const
	{
		typedef canonicaliser<uchar21_t, icase> canonicaliser_type;
		typedef typename re_object_core<charT, traits>::state_type state_type;
		typedef re_search_state</*charT, */BidirectionalIterator> ss_type;
		bool is_matched;
		for (;;)
		{
			const state_type &current_NFA = *sstate.nth.in_NFA_states;
			switch (current_NFA.type)
			{
			case st_character:
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(push)
#pragma warning(disable:4127)
#endif
				if (!reverse)
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(pop)
#endif
				{
					if (!sstate.is_last())
					{
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						const BidirectionalIterator prevpos = sstate.nth.in_string;
#endif
						const uchar21_t uchar = utf_traits::codepoint_inc(sstate.nth.in_string, sstate.last);
						if (current_NFA.character == canonicaliser_type::canonicalise(uchar))
							goto MATCHED;
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						if (current_NFA.next_state2)
						{
							sstate.nth.in_string = prevpos;
							sstate.nth.in_NFA_states = current_NFA.next_state2;
							continue;
						}
#endif
					}
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
					else if (current_NFA.next_state2)
					{
						sstate.nth.in_NFA_states = current_NFA.next_state2;
						continue;
					}
#endif
				}
				else	//  reverse == true.
				{
					if (!sstate.is_lookbehindlimit())
					{
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						const BidirectionalIterator prevpos = sstate.nth.in_string;
#endif
						const uchar21_t uchar = utf_traits::dec_codepoint(sstate.nth.in_string, sstate.lblim);
						if (current_NFA.character == canonicaliser_type::canonicalise(uchar))
							goto MATCHED;
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						if (current_NFA.next_state2)
						{
							sstate.nth.in_string = prevpos;
							sstate.nth.in_NFA_states = current_NFA.next_state2;
							continue;
						}
#endif
					}
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
					else if (current_NFA.next_state2)
					{
						sstate.nth.in_NFA_states = current_NFA.next_state2;
						continue;
					}
#endif
				}
				goto NOT_MATCHED;
			case st_character_class:
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(push)
#pragma warning(disable:4127)
#endif
				if (!reverse)
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(pop)
#endif
				{
					if (!sstate.is_last())
					{
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						const BidirectionalIterator prevpos = sstate.nth.in_string;
#endif
						const uchar21_t uchar = utf_traits::codepoint_inc(sstate.nth.in_string, sstate.last);
#if !defined(SRELLDBG_NO_CCPOS)
						if (this->character_class.is_included(current_NFA.quantifier.offset, current_NFA.quantifier.length, uchar))
#else
						if (this->character_class.is_included(current_NFA.number, uchar))
#endif
							goto MATCHED;
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						if (current_NFA.next_state2)
						{
							sstate.nth.in_string = prevpos;
							sstate.nth.in_NFA_states = current_NFA.next_state2;
							continue;
						}
#endif
					}
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
					else if (current_NFA.next_state2)
					{
						sstate.nth.in_NFA_states = current_NFA.next_state2;
						continue;
					}
#endif
				}
				else	//  reverse == true.
				{
					if (!sstate.is_lookbehindlimit())
					{
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						const BidirectionalIterator prevpos = sstate.nth.in_string;
#endif
						const uchar21_t uchar = utf_traits::dec_codepoint(sstate.nth.in_string, sstate.lblim);
#if !defined(SRELLDBG_NO_CCPOS)
						if (this->character_class.is_included(current_NFA.quantifier.offset, current_NFA.quantifier.length, uchar))
#else
						if (this->character_class.is_included(current_NFA.number, uchar))
#endif
							goto MATCHED;
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
						if (current_NFA.next_state2)
						{
							sstate.nth.in_string = prevpos;
							sstate.nth.in_NFA_states = current_NFA.next_state2;
							continue;
						}
#endif
					}
#if !defined(SRELLDBG_NO_ASTERISK_OPT)
					else if (current_NFA.next_state2)
					{
						sstate.nth.in_NFA_states = current_NFA.next_state2;
						continue;
					}
#endif
				}
				goto NOT_MATCHED;
			case st_epsilon:
#if defined(SRELLDBG_NO_SKIP_EPSILON)
				if (current_NFA.next_state2)
#endif
				{
					sstate.bt_stack.push_back(sstate.nth);	//	sstate.push();
				}
				sstate.nth.in_NFA_states = current_NFA.next_state1;
				continue;
			default:
				switch (current_NFA.type)
				{
			case st_check_counter:
				{
					const unsigned int &counter = sstate.counter[current_NFA.number];
					if (counter < current_NFA.quantifier.atmost || current_NFA.quantifier.is_infinity())
					{
						if (counter >= current_NFA.quantifier.atleast)
						{
#if !defined(SRELLDBG_NO_ASTERISK_OPT) && !defined(SRELLDBG_NO_SPLIT_COUNTER)
							if (!current_NFA.dont_push)
#endif
								sstate.bt_stack.push_back(sstate.nth);
							sstate.nth.in_NFA_states = current_NFA.next_state1;
						}
						else
						{
							sstate.nth.in_NFA_states
								= current_NFA.quantifier.is_greedy
								? current_NFA.next_state1
								: current_NFA.next_state2;
						}
					}
					else
					{
						sstate.nth.in_NFA_states
							= current_NFA.quantifier.is_greedy
							? current_NFA.next_state2
							: current_NFA.next_state1;
					}
				}
				continue;
			case st_increment_counter:
				sstate.bt_stack.push_back(sstate.nth);
				++sstate.counter[current_NFA.number];
				goto MATCHED;
			case st_decrement_counter:
				--sstate.counter[current_NFA.number];
				goto NOT_MATCHED;
			case st_save_and_reset_counter:
				{
					typename ss_type::counter_type &c = sstate.counter[current_NFA.number];
					sstate.counter_stack.push_back(c);
					sstate.bt_stack.push_back(sstate.nth);
					c = 0;
				}
				goto MATCHED;
			case st_restore_counter:
				sstate.counter[current_NFA.number] = sstate.counter_stack.back();
				sstate.counter_stack.pop_back();
				goto NOT_MATCHED;
			case st_roundbracket_open:	//  '(':
				{
					typename ss_type::submatch_type &bracket = sstate.bracket[current_NFA.number];
					sstate.capture_stack.push_back(bracket.core);
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(push)
#pragma warning(disable:4127)
#endif
					if (!reverse)
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(pop)
#endif
					{
						bracket.core.open_at = sstate.nth.in_string;
					}
					else
						bracket.core.close_at = sstate.nth.in_string;
					++bracket.counter;
					for (unsigned int brno = current_NFA.quantifier.atleast + 1; brno <= current_NFA.quantifier.atmost; ++brno)
					{
						typename ss_type::submatch_type &inner_bracket = sstate.bracket[brno];
						sstate.capture_stack.push_back(inner_bracket.core);
						sstate.counter_stack.push_back(inner_bracket.counter);
						inner_bracket.core.open_at = inner_bracket.core.close_at = sstate.last;
						inner_bracket.counter = 0;
						//  ECMAScript spec (3-5.1) 15.10.2.5, NOTE 3.
						//  ECMAScript 2018 (ES9) 21.2.2.5.1, Note 3.
					}
					sstate.bt_stack.push_back(sstate.nth);
				}
				goto MATCHED;
			case st_roundbracket_pop:	//  '/':
				{
					for (unsigned int brno = current_NFA.quantifier.atmost; brno > current_NFA.quantifier.atleast; --brno)
					{
						typename ss_type::submatch_type &inner_bracket = sstate.bracket[brno];
						inner_bracket.counter = sstate.counter_stack.back();
						inner_bracket.core = sstate.capture_stack.back();
						sstate.counter_stack.pop_back();
						sstate.capture_stack.pop_back();
					}
					typename ss_type::submatch_type &bracket = sstate.bracket[current_NFA.number];
					bracket.core = sstate.capture_stack.back();
					sstate.capture_stack.pop_back();
					--bracket.counter;
				}
				goto NOT_MATCHED;
			case st_roundbracket_close:	//  ')':
				{
					typename ss_type::submatch_type &bracket = sstate.bracket[current_NFA.number];
					typename ss_type::submatch_core &brc = bracket.core;
					if ((!reverse ? brc.open_at : brc.close_at) != sstate.nth.in_string)
					{
						sstate.nth.in_NFA_states = current_NFA.next_state1;
					}
					else	//  0 width match, breaks from the loop.
					{
						if (current_NFA.next_state1->type != st_check_counter)
						{
							if (bracket.counter > 1)
								goto NOT_MATCHED;	//  ECMAScript spec 15.10.2.5, note 4.
							sstate.nth.in_NFA_states = current_NFA.next_state2;
								//  Accepts 0 width match and exits.
						}
						else
						{
							//  A pair with check_counter.
							const typename ss_type::counter_type &counter = sstate.counter[current_NFA.next_state1->number];
							if (counter > current_NFA.quantifier.atleast)
								goto NOT_MATCHED;	//  Takes a captured string in the previous loop.
							sstate.nth.in_NFA_states = current_NFA.next_state1;
								//  Accepts 0 width match and continues.
						}
					}
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(push)
#pragma warning(disable:4127)
#endif
					if (!reverse)
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(pop)
#endif
					{
						brc.close_at = sstate.nth.in_string;
					}
					else	//  reverse == true.
					{
						brc.open_at  = sstate.nth.in_string;
					}
				}
				continue;
			case st_repeat_in_push:
				{
					typename ss_type::position_type &r = sstate.repeat[current_NFA.number];
					sstate.repeat_stack.push_back(r);
					sstate.bt_stack.push_back(sstate.nth);
					r = sstate.nth.in_string;
					for (unsigned int brno = current_NFA.quantifier.atleast; brno <= current_NFA.quantifier.atmost; ++brno)
					{
						typename ss_type::submatch_type &inner_bracket = sstate.bracket[brno];
						sstate.capture_stack.push_back(inner_bracket.core);
						sstate.counter_stack.push_back(inner_bracket.counter);
						inner_bracket.core.open_at = inner_bracket.core.close_at = sstate.last;
						inner_bracket.counter = 0;
						//  ECMAScript 2019 (ES10) 21.2.2.5.1, Note 3.
					}
				}
				goto MATCHED;
			case st_repeat_in_pop:
				for (unsigned int brno = current_NFA.quantifier.atmost; brno >= current_NFA.quantifier.atleast; --brno)
				{
					typename ss_type::submatch_type &inner_bracket = sstate.bracket[brno];
					inner_bracket.counter = sstate.counter_stack.back();
					inner_bracket.core = sstate.capture_stack.back();
					sstate.counter_stack.pop_back();
					sstate.capture_stack.pop_back();
				}
				sstate.repeat[current_NFA.number] = sstate.repeat_stack.back();
				sstate.repeat_stack.pop_back();
				goto NOT_MATCHED;
			case st_check_0_width_repeat:
				if (sstate.nth.in_string != sstate.repeat[current_NFA.number])
					goto MATCHED;
				sstate.nth.in_NFA_states = current_NFA.next_state2;
				continue;
			case st_backreference:	//  '\\':
				{
					const typename ss_type::submatch_type &bracket = sstate.bracket[current_NFA.number];
					if (!bracket.counter)	//  Undefined.
					{
						ESCAPE_FROM_ZERO_WIDTH_MATCH:
						sstate.nth.in_NFA_states = current_NFA.next_state2;
						continue;
					}
					else
					{
						const typename ss_type::submatch_core &brc = bracket.core;
						if (brc.open_at == brc.close_at)
						{
							goto ESCAPE_FROM_ZERO_WIDTH_MATCH;
						}
						else
						{
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(push)
#pragma warning(disable:4127)
#endif
							if (!reverse)
#if defined(_MSC_VER) && _MSC_VER >= 1400
#pragma warning(pop)
#endif
							{
								for (BidirectionalIterator backrefpos = brc.open_at; backrefpos != brc.close_at;)
								{
									if (!sstate.is_last())
									{
										const uchar21_t uchartxt = utf_traits::codepoint_inc(sstate.nth.in_string, sstate.last);
										const uchar21_t ucharref = utf_traits::codepoint_inc(backrefpos, brc.close_at);
										if (canonicaliser_type::canonicalise(uchartxt) == canonicaliser_type::canonicalise(ucharref))
											continue;
									}
									goto NOT_MATCHED;
								}
							}
							else	//  reverse == true.
							{
								for (BidirectionalIterator backrefpos = brc.close_at; backrefpos != brc.open_at;)
								{
									if (!sstate.is_lookbehindlimit())
									{
										const uchar21_t uchartxt = utf_traits::dec_codepoint(sstate.nth.in_string, sstate.lblim);
										const uchar21_t ucharref = utf_traits::dec_codepoint(backrefpos, brc.open_at);
										if (canonicaliser_type::canonicalise(uchartxt) == canonicaliser_type::canonicalise(ucharref))
											continue;
									}
									goto NOT_MATCHED;
								}
							}
						}
					}
				}
				goto MATCHED;
			case st_lookaround_open:
				{
					for (unsigned int i = 1; i < this->number_of_brackets; ++i)
					{
						const typename ss_type::submatch_type &sm = sstate.bracket[i];
						sstate.capture_stack.push_back(sm.core);
						sstate.counter_stack.push_back(sm.counter);
					}
					for (unsigned int i = 0; i < this->number_of_counters; ++i)
						sstate.counter_stack.push_back(sstate.counter[i]);
					for (unsigned int i = 0; i < this->number_of_repeats; ++i)
						sstate.repeat_stack.push_back(sstate.repeat[i]);
					const typename ss_type::bottom_state backup_bottom(sstate.btstack_size, sstate.capture_stack.size(), sstate.counter_stack.size(), sstate.repeat_stack.size());
					sstate.bt_stack.push_back(sstate.nth);
					sstate.btstack_size = sstate.bt_stack.size();
#if defined(SRELL_FIXEDWIDTHLOOKBEHIND)
					{
						for (unsigned int i = 0; i < current_NFA.quantifier.atleast; ++i)
						{
							if (!sstate.is_lookbehindlimit())
							{
								utf_traits::dec_codepoint(sstate.nth.in_string, sstate.lblim);
								continue;
							}
							is_matched = false;
							goto AFTER_LOOKAROUND;
						}
					}
#endif
					++sstate.nth.in_NFA_states;	//  Moves to lookaround_pop,
					sstate.nth.in_NFA_states = sstate.nth.in_NFA_states->next_state1;
						//  Due to shortage of "next_state"s of lookaround_open!
#if !defined(SRELL_FIXEDWIDTHLOOKBEHIND)
					is_matched = current_NFA.quantifier.atleast == 0 ? run_automaton<icase, false>(sstate, true) : run_automaton<icase, true>(sstate, true);
#else
					is_matched = run_automaton<icase, false>(sstate, true);
#endif
#if defined(SRELL_FIXEDWIDTHLOOKBEHIND)
					AFTER_LOOKAROUND:	//  DO NOT USE current_NFA IN THIS BLOCK.
#endif
					{
						const typename ss_type::search_core_state &lookaround_open_pair = sstate.bt_stack[sstate.btstack_size - 1];
						sstate.nth.in_NFA_states = lookaround_open_pair.in_NFA_states;
#if defined(SRELL_ENABLE_GT)
						if (sstate.nth.in_NFA_states->character != meta_char::mc_gt)	//  '>'
#endif
						{
							sstate.nth.in_string = lookaround_open_pair.in_string;
						}
						sstate.bt_stack.resize(sstate.btstack_size);
						sstate.btstack_size = backup_bottom.btstack_size;
						sstate.capture_stack.resize(backup_bottom.capturestack_size);
						sstate.counter_stack.resize(backup_bottom.counterstack_size);
						sstate.repeat_stack.resize(backup_bottom.repeatstack_size);
						is_matched ^= sstate.nth.in_NFA_states->is_not;
					}
				}
				break;
			case st_lookaround_pop:
				for (unsigned int i = this->number_of_repeats; i;)
				{
					sstate.repeat[--i] = sstate.repeat_stack.back();
					sstate.repeat_stack.pop_back();
				}
				for (unsigned int i = this->number_of_counters; i;)
				{
					sstate.counter[--i] = sstate.counter_stack.back();
					sstate.counter_stack.pop_back();
				}
				for (unsigned int i = this->number_of_brackets; i > 1;)
				{
					typename ss_type::submatch_type &sm = sstate.bracket[--i];
					sm.counter = sstate.counter_stack.back();
					sm.core = sstate.capture_stack.back();
					sstate.counter_stack.pop_back();
					sstate.capture_stack.pop_back();
				}
				goto NOT_MATCHED;
			case st_bol:	//  '^':
				if (sstate.is_lookbehindlimit() && !sstate.match_prev_avail_flag())
				{
					if (!sstate.match_not_bol_flag())
						goto MATCHED;
				}
					//  !sstate.is_lookbehindlimit() || sstate.match_prev_avail_flag()
				else if (this->is_multiline())
				{
					const uchar21_t prevchar = utf_traits::prevcodepoint(sstate.nth.in_string);
					if (this->character_class.is_included(re_character_class::newline, prevchar))
						goto MATCHED;
				}
				goto NOT_MATCHED;
			case st_eol:	//  '$':
				if (sstate.is_last())
				{
					if (!sstate.match_not_eol_flag())
						goto MATCHED;
				}
				else if (this->is_multiline())
				{
					const uchar21_t nextchar = utf_traits::codepoint(sstate.nth.in_string, sstate.last);
					if (this->character_class.is_included(re_character_class::newline, nextchar))
						goto MATCHED;
				}
				goto NOT_MATCHED;
			case st_boundary:	//  '\b' '\B'
				is_matched = current_NFA.is_not;
				//  First, suppose the previous character is not \w.
				if (sstate.is_last())
				{
					if (sstate.match_not_eow_flag())
						is_matched = !is_matched;
				}
				else if (this->character_class.is_included(current_NFA.number, utf_traits::codepoint(sstate.nth.in_string, sstate.last)))
				{
					is_matched = !is_matched;
				}
				//      \W/last     \w
				//  \b  false       true
				//  \B  true        false
				//  Second, if the actual previous character is \w, inverse is_matched.
				if (sstate.is_lookbehindlimit() && !sstate.match_prev_avail_flag())
				{
					if (sstate.match_not_bow_flag())
						is_matched = !is_matched;
				}
					//  !sstate.is_lookbehindlimit() || sstate.match_prev_avail_flag()
				else if (this->character_class.is_included(current_NFA.number, utf_traits::prevcodepoint(sstate.nth.in_string)))
				{
					is_matched = !is_matched;
				}
				//  \b                          \B
				//  pre cur \W/last \w          pre cur \W/last \w
				//  \W/base false   true        \W/base true    false
				//  \w      true    false       \w      false   true
				break;
			case st_success:	//  == lookaround_close.
				if (is_recursive)
					return true;
				if
				(	//  check if null_match,
					(!sstate.match_not_null_flag() || !sstate.is_null())
					&&
					//  check if regex_match.
					(!sstate.match_match_flag() || sstate.is_last())
				)
					return true;
				goto NOT_MATCHED;
#if !defined(SRELLDBG_NO_NEXTPOS_OPT)
			case st_move_nextpos:
				if (sstate.nth.in_string != sstate.bracket[0].core.open_at)
					sstate.nextpos = sstate.nth.in_string;
				goto MATCHED;
#endif
			default:
				throw regex_error(regex_constants::error_internal);
				}
			}
			if (is_matched)
			{
				MATCHED:
				sstate.nth.in_NFA_states = sstate.nth.in_NFA_states->next_state1;
			}
			else
			{
				NOT_MATCHED:
#if !defined(SRELL_NO_LIMIT_COUNTER)
				if (--sstate.failure_counter)
				{
#endif
					if (sstate.bt_stack.size() > sstate.btstack_size)
					{
						sstate.nth = sstate.bt_stack.back();
						sstate.bt_stack.pop_back();
						sstate.nth.in_NFA_states = sstate.nth.in_NFA_states->next_state2;
					}
					else
					{
						return false;
					}
#if !defined(SRELL_NO_LIMIT_COUNTER)
				}
				else
					throw regex_error(regex_constants::error_complexity);
#endif
			}
		}
	}
};
	}	//  namespace regex_internal
template <class charT, class traits = regex_traits<charT> >
class basic_regex : public regex_internal::regex_object<charT, traits>
{
public:
	//  types:
	typedef charT value_type;
	typedef traits traits_type;
	typedef typename traits::string_type string_type;
	typedef regex_constants::syntax_option_type flag_type;
	typedef typename traits::locale_type locale_type;
	//  28.8.1, constants:
	//  [7.8.1] constants
	static const regex_constants::syntax_option_type icase = regex_constants::icase;
	static const regex_constants::syntax_option_type nosubs = regex_constants::nosubs;
	static const regex_constants::syntax_option_type optimize = regex_constants::optimize;
	static const regex_constants::syntax_option_type collate = regex_constants::collate;
	static const regex_constants::syntax_option_type ECMAScript = regex_constants::ECMAScript;
	static const regex_constants::syntax_option_type basic = regex_constants::basic;
	static const regex_constants::syntax_option_type extended = regex_constants::extended;
	static const regex_constants::syntax_option_type awk = regex_constants::awk;
	static const regex_constants::syntax_option_type grep = regex_constants::grep;
	static const regex_constants::syntax_option_type egrep = regex_constants::egrep;
	static const regex_constants::syntax_option_type multiline = regex_constants::multiline;
	static const regex_constants::syntax_option_type dotall = regex_constants::dotall;
	//  28.8.2, construct/copy/destroy:
	//  [7.8.2] construct/copy/destroy
	basic_regex()
	{
	}
	explicit basic_regex(const charT *const p, const flag_type f = regex_constants::ECMAScript)
	{
		assign(p, p + std::char_traits<charT>::length(p), f);
	}
	basic_regex(const charT *const p, const std::size_t len, const flag_type f = regex_constants::ECMAScript)
	{
		assign(p, p + len, f);
	}
	basic_regex(const basic_regex &e)
	{
		assign(e);
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	basic_regex(basic_regex &&e) SRELL_NOEXCEPT
	{
		assign(std::move(e));
	}
#endif
	template <class ST, class SA>
	explicit basic_regex(const std::basic_string<charT, ST, SA> &p, const flag_type f = regex_constants::ECMAScript)
	{
		assign(p, f);
	}
	template <class ForwardIterator>
	basic_regex(ForwardIterator first, ForwardIterator last, const flag_type f = regex_constants::ECMAScript)
	{
		assign(first, last, f);
	}
#if defined(SRELL_CPP11_INITIALIZER_LIST_ENABLED)
	basic_regex(std::initializer_list<charT> il, const flag_type f = regex_constants::ECMAScript)
	{
		assign(il, f);
	}
#endif
	basic_regex &operator=(const basic_regex &right)
	{
		return assign(right);
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	basic_regex &operator=(basic_regex &&e) SRELL_NOEXCEPT
	{
		return assign(std::move(e));
	}
#endif
	basic_regex &operator=(const charT *const ptr)
	{
		return assign(ptr);
	}
#if defined(SRELL_CPP11_INITIALIZER_LIST_ENABLED)
	basic_regex &operator=(std::initializer_list<charT> il)
	{
		return assign(il.begin(), il.end());
	}
#endif
	template <class ST, class SA>
	basic_regex &operator=(const std::basic_string<charT, ST, SA> &p)
	{
		return assign(p);
	}
	//  28.8.3, assign:
	//  [7.8.3] assign
	basic_regex &assign(const basic_regex &right)
	{
		regex_internal::re_object_core<charT, traits>::operator=(right);
		return *this;
	}
#if defined(SRELL_CPP11_MOVE_ENABLED)
	basic_regex &assign(basic_regex &&right) SRELL_NOEXCEPT
	{
		regex_internal::re_object_core<charT, traits>::operator=(std::move(right));
		return *this;
	}
#endif
	basic_regex &assign(const charT *const ptr, const flag_type f = regex_constants::ECMAScript)
	{
		this->compile(ptr, ptr + std::char_traits<charT>::length(ptr), f);
		return *this;
	}
	basic_regex &assign(const charT *const p, std::size_t len, const flag_type f = regex_constants::ECMAScript)
	{
		this->compile(p, p + len, f);
		return *this;
	}
	template <class string_traits, class A>
	basic_regex &assign(const std::basic_string<charT, string_traits, A> &s, const flag_type f = regex_constants::ECMAScript)
	{
		this->compile(s.c_str(), s.c_str() + s.size(), f);
		return *this;
	}
	template <class InputIterator>
	basic_regex &assign(InputIterator first, InputIterator last, const flag_type f = regex_constants::ECMAScript)
	{
		return assign(string_type(first, last), f);
	}
#if defined(SRELL_CPP11_INITIALIZER_LIST_ENABLED)
	basic_regex &assign(std::initializer_list<charT> il, const flag_type f = regex_constants::ECMAScript)
	{
		return assign(il.begin(), il.end(), f);
	}
#endif
	//  28.8.4, const operations:
	//  [7.8.4] const operations
	unsigned mark_count() const
	{
		return this->number_of_brackets - 1;
	}
	flag_type flags() const
	{
		return this->soflags;
	}
	//  28.8.5, locale:
	//  [7.8.5] locale
	locale_type imbue(locale_type loc)
	{
		return this->traits_inst.imbue(loc);
	}
	locale_type getloc() const
	{
		return this->traits_inst.getloc();
	}
	//  28.8.6, swap:
	//  [7.8.6] swap
	void swap(basic_regex &e)
	{
		regex_internal::re_object_core<charT, traits>::swap(e);
	}
};
template <class charT, class traits>
void swap(basic_regex<charT, traits> &lhs, basic_regex<charT, traits> &rhs)
{
	lhs.swap(rhs);
}
typedef basic_regex<char> regex;
typedef basic_regex<wchar_t> wregex;
#if defined(WCHAR_MAX)
	#if WCHAR_MAX >= 0x10ffff
		typedef wregex u32wregex;
	#elif WCHAR_MAX >= 0xffff
		typedef basic_regex<wchar_t, u16regex_traits<wchar_t> > u16wregex;
	#endif
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef basic_regex<char8_t, u8regex_traits<char8_t> > u8regex;
#endif
typedef basic_regex<char, u8regex_traits<char> > u8cregex;
#if !defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef u8cregex u8regex;
#endif
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
	typedef basic_regex<char16_t, u16regex_traits<char16_t> > u16regex;
	typedef basic_regex<char32_t> u32regex;
#endif
template <class BidirectionalIterator, class charT = typename std::iterator_traits<BidirectionalIterator>::value_type, class traits = regex_traits<charT> >
class regex_iterator
{
public:
	typedef basic_regex<charT, traits> regex_type;
	typedef match_results<BidirectionalIterator> value_type;
	typedef std::ptrdiff_t difference_type;
	typedef const value_type * pointer;
	typedef const value_type & reference;
	typedef std::forward_iterator_tag iterator_category;
	regex_iterator()
	{
		//  28.12.1.1: Constructs an end-of-sequence iterator.
	}
	regex_iterator(
		const BidirectionalIterator a,
		const BidirectionalIterator b,
		const regex_type &re,
		const regex_constants::match_flag_type m = regex_constants::match_default)
		: begin(a), end(b), pregex(&re), flags(m)
	{
		match.lookbehind_limit = begin;
		regex_search(begin, end, match, *pregex, flags);
			//  28.12.1.1: If this call returns false the constructor
			//    sets *this to the end-of-sequence iterator.
	}
	regex_iterator(const regex_iterator &that)
	{
		operator=(that);
	}
	regex_iterator &operator=(const regex_iterator &that)
	{
		if (this != &that)
		{
			this->begin = that.begin;
			this->end = that.end;
			this->pregex = that.pregex;
			this->flags = that.flags;
			this->match = that.match;
			this->utf_traits_inst_ = that.utf_traits_inst_;
		}
		return *this;
	}
	bool operator==(const regex_iterator &right) const
	{
		//  It is probably safe to assume that match.size() == 0 means
		//  end-of-sequence, because it happens only when 1) never tried
		//  regex_search, or 2) regex_search returned false.
		if (this->match.size() == 0 || right.match.size() == 0)
			return this->match.size() == right.match.size();
		return
			this->begin == right.begin
			&&
			this->end == right.end
			&&
			this->pregex == right.pregex
			&&
			this->flags == right.flags
			&&
			this->match[0] == right.match[0];
	}
	bool operator!=(const regex_iterator &right) const
	{
		return !(*this == right);
	}
	const value_type &operator*() const
	{
		return match;
	}
	const value_type *operator->() const
	{
		return &match;
	}
	regex_iterator &operator++()
	{
		if (this->match.size())
		{
			BidirectionalIterator start = match[0].second;
			if (match[0].first == start)	//  The iterator holds a 0-length match.
			{
				if (start == end)
				{
					match.clear_();
					return *this;
					//    28.12.1.4.2: If the iterator holds a zero-length match and
					//  start == end the operator sets *this to the end-ofsequence
					//  iterator and returns *this.
				}
				//    28.12.1.4.3: Otherwise, if the iterator holds a zero-length match
				//  the operator calls regex_search(start, end, match, *pregex, flags
				//  | regex_constants::match_not_null | regex_constants::match_continuous).
				//  If the call returns true the operator returns *this. [Cont...]
				if (!regex_search(start, end, match, *pregex, flags | regex_constants::match_not_null | regex_constants::match_continuous))
				{
					//  [...Cont] Otherwise the operator increments start and continues
					//  as if the most recent match was not a zero-length match.
					utf_traits_inst_.codepoint_inc(start, end);
					goto ASIF_NOT_NULLMATCH;
				}
			}
			else
			{
				ASIF_NOT_NULLMATCH:
				//    28.12.1.4.4: If the most recent match was not a zero-length match,
				//  the operator sets flags to flags | regex_constants::match_prev_avail
				//  and calls regex_search(start, end, match, *pregex, flags). [Cont...]
				flags |= regex_constants::match_prev_avail;
				if (!regex_search(start, end, match, *pregex, flags))
				{
					return *this;
					//  [...Cont] If the call returns false the iterator sets *this to
					//  the end-of-sequence iterator. The iterator then returns *this.
				}
			}
			//  We are here since operator succeeded.
			//    28.12.1.4.5: In all cases in which the call to regex_search
			//  returns true, match.prefix().first shall be equal to the previous
			//  value of match[0].second, ...
			//  This condition is automatically satisfied by passing 'start' as
			//  a 'begin' argument to regex_search.
			//  28.12.1.4.5: ... match[i].position() shall return distance(begin, match[i].first).
			//  To satisfy this:
			match.set_base_(begin);
		}
		return *this;
	}
	regex_iterator operator++(int)
	{
		const regex_iterator tmp = *this;
		++(*this);
		return tmp;
	}
private:
	BidirectionalIterator                begin;
	BidirectionalIterator                end;
	const regex_type                    *pregex;
	regex_constants::match_flag_type     flags;
	match_results<BidirectionalIterator> match;
	typedef typename traits::utf_traits utf_traits;
	utf_traits utf_traits_inst_;
};
typedef regex_iterator<const char *> cregex_iterator;
typedef regex_iterator<const wchar_t *> wcregex_iterator;
typedef regex_iterator<std::string::const_iterator> sregex_iterator;
typedef regex_iterator<std::wstring::const_iterator> wsregex_iterator;
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
	typedef regex_iterator<const char16_t *> u16cregex_iterator;
	typedef regex_iterator<const char32_t *> u32cregex_iterator;
	typedef regex_iterator<std::u16string::const_iterator> u16sregex_iterator;
	typedef regex_iterator<std::u32string::const_iterator> u32sregex_iterator;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef regex_iterator<const char8_t *> u8cregex_iterator;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED) && SRELL_CPP20_CHAR8_ENABLED >= 2
	typedef regex_iterator<std::u8string::const_iterator> u8sregex_iterator;
#endif
typedef regex_iterator<const char *, std::iterator_traits<const char *>::value_type, u8regex_traits<std::iterator_traits<const char *>::value_type> > u8ccregex_iterator;
typedef regex_iterator<std::string::const_iterator, std::iterator_traits<std::string::const_iterator>::value_type, u8regex_traits<std::iterator_traits<std::string::const_iterator>::value_type> > u8csregex_iterator;
#if !defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef u8ccregex_iterator u8cregex_iterator;
#endif
#if !defined(SRELL_CPP20_CHAR8_ENABLED) || SRELL_CPP20_CHAR8_ENABLED < 2
	typedef u8csregex_iterator u8sregex_iterator;
#endif
#if defined(WCHAR_MAX)
	#if WCHAR_MAX >= 0x10ffff
		typedef wcregex_iterator u32wcregex_iterator;
		typedef wsregex_iterator u32wsregex_iterator;
	#elif WCHAR_MAX >= 0xffff
		typedef regex_iterator<const wchar_t *, std::iterator_traits<const wchar_t *>::value_type, u16regex_traits<std::iterator_traits<const wchar_t *>::value_type> > u16wcregex_iterator;
		typedef regex_iterator<std::wstring::const_iterator, std::iterator_traits<std::wstring::const_iterator>::value_type, u16regex_traits<std::iterator_traits<std::wstring::const_iterator>::value_type> > u16wsregex_iterator;
	#endif
#endif
template <class BidirectionalIterator, class Allocator, class charT, class traits>
bool regex_match(
	const BidirectionalIterator first,
	const BidirectionalIterator last,
	match_results<BidirectionalIterator, Allocator> &m,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return e.search(first, last, m, flags | regex_constants::match_continuous | regex_constants::match_match_);
}
template <class BidirectionalIterator, class charT, class traits>
bool regex_match(
	const BidirectionalIterator first,
	const BidirectionalIterator last,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	match_results<BidirectionalIterator> what;
	return regex_match(first, last, what, e, flags);
}
template <class charT, class Allocator, class traits>
bool regex_match(
	const charT *const str,
	match_results<const charT *, Allocator> &m,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_match(str, str + std::char_traits<charT>::length(str), m, e, flags);
}
template <class ST, class SA, class Allocator, class charT, class traits>
bool regex_match(
	const std::basic_string<charT, ST, SA> &s,
	match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator> &m,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_match(s.begin(), s.end(), m, e, flags);
}
template <class charT, class traits>
bool regex_match(
	const charT *const str,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_match(str, str + std::char_traits<charT>::length(str), e, flags);
}
template <class ST, class SA, class charT, class traits>
bool regex_match(
	const std::basic_string<charT, ST, SA> &s,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_match(s.begin(), s.end(), e, flags);
}
template <class BidirectionalIterator, class Allocator, class charT, class traits>
bool regex_search(
	const BidirectionalIterator first,
	const BidirectionalIterator last,
	match_results<BidirectionalIterator, Allocator> &m,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return e.search(first, last, m, flags);
}
template <class BidirectionalIterator, class charT, class traits>
bool regex_search(
	const BidirectionalIterator first,
	const BidirectionalIterator last,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	match_results<BidirectionalIterator> what;
	return regex_search(first, last, what, e, flags);
}
template <class charT, class Allocator, class traits>
bool regex_search(
	const charT *const str,
	match_results<const charT *, Allocator> &m,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_search(str, str + std::char_traits<charT>::length(str), m, e, flags);
}
template <class charT, class traits>
bool regex_search(
	const charT *const str,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_search(str, str + std::char_traits<charT>::length(str), e, flags);
}
template <class ST, class SA, class charT, class traits>
bool regex_search(
	const std::basic_string<charT, ST, SA> &s,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_search(s.begin(), s.end(), e, flags);
}
template <class ST, class SA, class Allocator, class charT, class traits>
bool regex_search(
	const std::basic_string<charT, ST, SA> &s,
	match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator> &m,
	const basic_regex<charT, traits> &e,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	return regex_search(s.begin(), s.end(), m, e, flags);
}
template <class OutputIterator, class BidirectionalIterator, class traits, class charT, class ST, class SA>
OutputIterator regex_replace(
	OutputIterator out,
	const BidirectionalIterator first,
	const BidirectionalIterator last,
	const basic_regex<charT, traits> &e,
	const std::basic_string<charT, ST, SA> &fmt,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	typedef regex_iterator<BidirectionalIterator, charT, traits> iterator_type;
	const bool do_copy = !(flags & regex_constants::format_no_copy);
	const iterator_type eos;
	iterator_type i(first, last, e, flags);
	typename iterator_type::value_type::value_type last_m_suffix;
	last_m_suffix.first = first;
	last_m_suffix.second = last;
	for (; i != eos; ++i)
	{
		if (do_copy)
			out = std::copy(i->prefix().first, i->prefix().second, out);
		out = i->format(out, fmt, flags);
		last_m_suffix = i->suffix();
		if (flags & regex_constants::format_first_only)
			break;
	}
	if (do_copy)
		out = std::copy(last_m_suffix.first, last_m_suffix.second, out);
	return out;
}
template <class OutputIterator, class BidirectionalIterator, class traits, class charT>
OutputIterator regex_replace(
	OutputIterator out,
	const BidirectionalIterator first,
	const BidirectionalIterator last,
	const basic_regex<charT, traits> &e,
	const charT *const fmt,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	//  Strictly speaking, this should be implemented as a version different
	//  from the above with changing the line i->format(out, fmt, flags) to
	//  i->format(out, fmt, fmt + char_traits<charT>::length(fmt), flags).
	const std::basic_string<charT> fs(fmt, fmt + std::char_traits<charT>::length(fmt));
	return regex_replace(out, first, last, e, fs, flags);
}
template <class traits, class charT, class ST, class SA, class FST, class FSA>
std::basic_string<charT, ST, SA> regex_replace(
	const std::basic_string<charT, ST, SA> &s,
	const basic_regex<charT, traits> &e,
	const std::basic_string<charT, FST, FSA> &fmt,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	std::basic_string<charT, ST, SA> result;
	regex_replace(std::back_inserter(result), s.begin(), s.end(), e, fmt, flags);
	return result;
}
template <class traits, class charT, class ST, class SA>
std::basic_string<charT, ST, SA> regex_replace(
	const std::basic_string<charT, ST, SA> &s,
	const basic_regex<charT, traits> &e,
	const charT *const fmt,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	std::basic_string<charT, ST, SA> result;
	regex_replace(std::back_inserter(result), s.begin(), s.end(), e, fmt, flags);
	return result;
}
template <class traits, class charT, class ST, class SA>
std::basic_string<charT> regex_replace(
	const charT *const s,
	const basic_regex<charT, traits> &e,
	const std::basic_string<charT, ST, SA> &fmt,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	std::basic_string<charT> result;
	regex_replace(std::back_inserter(result), s, s + std::char_traits<charT>::length(s), e, fmt, flags);
	return result;
}
template <class traits, class charT>
std::basic_string<charT> regex_replace(
	const charT *const s,
	const basic_regex<charT, traits> &e,
	const charT *const fmt,
	const regex_constants::match_flag_type flags = regex_constants::match_default
)
{
	std::basic_string<charT> result;
	regex_replace(std::back_inserter(result), s, s + std::char_traits<charT>::length(s), e, fmt, flags);
	return result;
}
template <class BidirectionalIterator, class charT = typename std::iterator_traits<BidirectionalIterator>::value_type, class traits = regex_traits<charT> >
class regex_token_iterator
{
public:
	typedef basic_regex<charT, traits> regex_type;
	typedef sub_match<BidirectionalIterator> value_type;
	typedef std::ptrdiff_t difference_type;
	typedef const value_type * pointer;
	typedef const value_type & reference;
	typedef std::forward_iterator_tag iterator_category;
	regex_token_iterator() : result(NULL)
	{
		//  Constructs the end-of-sequence iterator.
	}
	regex_token_iterator(
		const BidirectionalIterator a,
		const BidirectionalIterator b,
		const regex_type &re,
		int submatch = 0,
		regex_constants::match_flag_type m = regex_constants::match_default
	) : position(a, b, re, m), result(NULL), subs(1, submatch)
	{
		post_constructor(a, b);
	}
	regex_token_iterator(
		const BidirectionalIterator a,
		const BidirectionalIterator b,
		const regex_type &re,
		const std::vector<int> &submatches,
		regex_constants::match_flag_type m = regex_constants::match_default
	) : position(a, b, re, m), result(NULL), subs(submatches)
	{
		post_constructor(a, b);
	}
#if defined(SRELL_CPP11_INITIALIZER_LIST_ENABLED)
	regex_token_iterator(
		const BidirectionalIterator a,
		const BidirectionalIterator b,
		const regex_type &re,
		std::initializer_list<int> submatches,
		regex_constants::match_flag_type m = regex_constants::match_default
	) : position(a, b, re, m), result(NULL), subs(submatches)
	{
		post_constructor(a, b);
	}
#endif
	template <std::size_t N>	//  was R in TR1.
	regex_token_iterator(
		const BidirectionalIterator a,
		const BidirectionalIterator b,
		const regex_type &re,
		const int (&submatches)[N],
		regex_constants::match_flag_type m = regex_constants::match_default
	) : position(a, b, re, m), result(NULL), subs(submatches, submatches + N)
	{
		post_constructor(a, b);
	}
	regex_token_iterator(const regex_token_iterator &that)
	{
		operator=(that);
	}
	regex_token_iterator &operator=(const regex_token_iterator &that)
	{
		if (this != &that)
		{
			this->position = that.position;
			this->result = that.result;
			this->suffix = that.suffix;
			this->N = that.N;
			this->subs = that.subs;
		}
		return *this;
	}
	bool operator==(const regex_token_iterator &right)
	{
		if (this->result == NULL || right.result == NULL)
			return this->result == right.result;
		if (this->result == &this->suffix || right.result == &right.suffix)
			return this->suffix == right.suffix;
		return
			this->position == right.position
			&&
			this->N == right.N
			&&
			this->subs == right.subs;
	}
	bool operator!=(const regex_token_iterator &right)
	{
		return !(*this == right);
	}
	const value_type &operator*()
	{
		return *result;
	}
	const value_type *operator->()
	{
		return result;
	}
	regex_token_iterator &operator++()
	{
		position_iterator prev(position);
		position_iterator eos_iterator;
		if (result != NULL)
			//  To avoid inifinite loop. The specification does not require, though.
		{
			if (result == &suffix)
			{
				result = NULL;	//  end-of-sequence.
			}
			else
			{
				++this->N;
				for (;;)
				{
					if (this->N < subs.size())
					{
						result = subs[this->N] != -1 ? &((*position)[subs[this->N]]) : &((*position).prefix());
						break;
					}
					this->N = 0;
					++position;
					if (position == eos_iterator)
					{
						if (this->N < subs.size() && prev->suffix().length() && minus1_in_subs())
						{
							suffix = prev->suffix();
							result = &suffix;
						}
						else
						{
							result = NULL;
						}
						break;
					}
				}
			}
		}
		return *this;
	}
	regex_token_iterator operator++(int)
	{
		const regex_token_iterator tmp(*this);
		++(*this);
		return tmp;
	}
private:
	void post_constructor(const BidirectionalIterator a, const BidirectionalIterator b)
	{
		position_iterator eos_iterator;
		this->N = 0;
		if (position != eos_iterator && subs.size())
		{
			result = subs[this->N] != -1 ? &((*position)[subs[this->N]]) : &((*position).prefix());
		}
		else if (minus1_in_subs())	//  end-of-sequence.
		{
			suffix.first   = a;
			suffix.second  = b;
			suffix.matched = a != b;
			//  28.1.2.7: In a suffix iterator the member result holds a pointer
			//  to the data member suffix, the value of the member suffix.match is true,
			if (suffix.matched)
				result = &suffix;
			else
				result = NULL;	//  which means end-of-sequence.
		}
	}
	bool minus1_in_subs() const
	{
		for (std::size_t i = 0; i < subs.size(); ++i)
			if (subs[i] == -1)
				return true;
		return false;
	}
private:
	typedef regex_iterator<BidirectionalIterator, charT, traits> position_iterator;
	position_iterator position;
	const value_type *result;
	value_type suffix;
	std::size_t N;
	std::vector<int> subs;
};
typedef regex_token_iterator<const char *> cregex_token_iterator;
typedef regex_token_iterator<const wchar_t *> wcregex_token_iterator;
typedef regex_token_iterator<std::string::const_iterator> sregex_token_iterator;
typedef regex_token_iterator<std::wstring::const_iterator> wsregex_token_iterator;
#if defined(SRELL_CPP11_CHAR1632_ENABLED)
	typedef regex_token_iterator<const char16_t *> u16cregex_token_iterator;
	typedef regex_token_iterator<const char32_t *> u32cregex_token_iterator;
	typedef regex_token_iterator<std::u16string::const_iterator> u16sregex_token_iterator;
	typedef regex_token_iterator<std::u32string::const_iterator> u32sregex_token_iterator;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef regex_token_iterator<const char8_t *> u8cregex_token_iterator;
#endif
#if defined(SRELL_CPP20_CHAR8_ENABLED) && SRELL_CPP20_CHAR8_ENABLED >= 2
	typedef regex_token_iterator<std::u8string::const_iterator> u8sregex_token_iterator;
#endif
typedef regex_token_iterator<const char *, std::iterator_traits<const char *>::value_type, u8regex_traits<std::iterator_traits<const char *>::value_type> > u8ccregex_token_iterator;
typedef regex_token_iterator<std::string::const_iterator, std::iterator_traits<std::string::const_iterator>::value_type, u8regex_traits<std::iterator_traits<std::string::const_iterator>::value_type> > u8csregex_token_iterator;
#if !defined(SRELL_CPP20_CHAR8_ENABLED)
	typedef u8ccregex_token_iterator u8cregex_token_iterator;
#endif
#if !defined(SRELL_CPP20_CHAR8_ENABLED) || SRELL_CPP20_CHAR8_ENABLED < 2
	typedef u8csregex_token_iterator u8sregex_token_iterator;
#endif
#if defined(WCHAR_MAX)
	#if WCHAR_MAX >= 0x10ffff
		typedef wcregex_token_iterator u32wcregex_token_iterator;
		typedef wsregex_token_iterator u32wsregex_token_iterator;
	#elif WCHAR_MAX >= 0xffff
		typedef regex_token_iterator<const wchar_t *, std::iterator_traits<const wchar_t *>::value_type, u16regex_traits<std::iterator_traits<const wchar_t *>::value_type> > u16wcregex_token_iterator;
		typedef regex_token_iterator<std::wstring::const_iterator, std::iterator_traits<std::wstring::const_iterator>::value_type, u16regex_traits<std::iterator_traits<std::wstring::const_iterator>::value_type> > u16wsregex_token_iterator;
	#endif
#endif
}		//  namespace srell
#ifdef SRELL_NOEXCEPT
#undef SRELL_NOEXCEPT
#endif
#ifdef SRELL_CPP20_CHAR8_ENABLED
#undef SRELL_CPP20_CHAR8_ENABLED
#endif
#ifdef SRELL_CPP11_CHAR1632_ENABLED
#undef SRELL_CPP11_CHAR1632_ENABLED
#endif
#ifdef SRELL_CPP11_INITIALIZER_LIST_ENABLED
#undef SRELL_CPP11_INITIALIZER_LIST_ENABLED
#endif
#ifdef SRELL_CPP11_MOVE_ENABLED
#undef SRELL_CPP11_MOVE_ENABLED
#endif
#endif	//  SRELL_REGEX_TEMPLATE_LIBRARY
namespace wl
{
struct _returns_function_tag {};
struct _returns_value_tag {};
template<typename... Ts>
struct _branch_type_check_impl;
template<typename T1, typename... Ts>
struct _branch_type_check_impl<T1, Ts...>
{
    static constexpr auto value = is_value_type_v<T1> ?
        std::conjunction_v<std::is_same<T1, Ts>...> :
        std::conjunction_v<std::bool_constant<!is_value_type_v<Ts>>...>;
};
template<typename... Ts>
struct _branch_type_check : _branch_type_check_impl<remove_cvref_t<Ts>...> {};
template<typename T1, typename...>
struct _branch_returns_value :
    std::bool_constant<is_value_type_v<remove_cvref_t<T1>>> {};
template<typename T, typename...>
struct _get_first_type
{
    using type = T;
};
template<typename... Ts>
using _get_first_type_t = typename _get_first_type<Ts...>::type;
template<typename A, typename B>
WL_INLINE auto branch_if(const boolean cond, A&& a, B&& b)
{
    WL_TRY_BEGIN()
    using AT = decltype(val(std::declval<A&&>()()));
    using BT = decltype(val(std::declval<B&&>()()));
    static_assert(_branch_type_check<AT, BT>::value, WL_ERROR_BRANCH_RETURN);
    if constexpr (_branch_returns_value<AT>::value)
    {
        return cond ? val(std::forward<decltype(a)>(a)()) :
            val(std::forward<decltype(b)>(b)());
    }
    else
    {
        return
            [cond,
            a = std::forward<decltype(a)>(a)(),
            b = std::forward<decltype(b)>(b)()
            ](auto&&... args)
        {
            auto ra = [&, a] {
                return a(std::forward<decltype(args)>(args)...); };
            auto rb = [&, b] {
                return b(std::forward<decltype(args)>(args)...); };
            return branch_if(cond, std::move(ra), std::move(rb));
        };
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename... Conds>
auto _which_conditions(Conds&&... conds)
{
    static_assert(std::conjunction_v<std::is_same<
        remove_cvref_t<decltype(conds())>, boolean>...>,
        WL_ERROR_BRANCH_RETURN);
    size_t n = 0u;
    [[maybe_unused]] auto _1 = ((conds() ? true : (++n, false)) || ...);
    return n;
}
template<typename Ret, size_t... Is, typename... Cases>
auto _which_impl(const size_t n, _returns_value_tag,
    std::index_sequence<Is...>, Cases&&... cases)
{
    if constexpr (std::is_same_v<Ret, void_type>)
    {
        [[maybe_unused]] auto _1 = ((n == Is ?
            (std::forward<decltype(cases)>(cases)(), true) : false
            ) || ...);
        return const_null;
    }
    else
    {
        Ret ret;
        if (n >= sizeof...(Cases))
            throw std::logic_error(WL_ERROR_INTERNAL);
        [[maybe_unused]] auto _1 = ((n == Is ?
            (ret = val(std::forward<decltype(cases)>(cases)()), true) : false
            ) || ...);
        return ret;
    }
}
template<size_t... Is, typename... Cases>
auto _which_impl(const size_t n, _returns_function_tag,
    std::index_sequence<Is...>, Cases&&... cases)
{
    return
        [n,
        cases = std::make_tuple(std::forward<decltype(cases)>(cases)()...)
        ](auto&&... args)
    {
        return _which_impl(n, std::get<Is>(cases)...);
    };
}
template<typename... Cases>
auto which(const size_t n, Cases&&... cases)
{
    WL_TRY_BEGIN()
    static_assert(_branch_type_check<
        decltype(val(std::declval<Cases&&>()()))...>::value,
        WL_ERROR_BRANCH_RETURN);
    using FirstType =
        decltype(val(std::declval<_get_first_type_t<Cases&&...>>()()));
    if constexpr (_branch_returns_value<FirstType>::value)
    {
        return _which_impl<remove_cvref_t<FirstType>>(
            n, _returns_value_tag{},
            std::make_index_sequence<sizeof...(Cases)>{},
            std::forward<decltype(cases)>(cases)...);
    }
    else
    {
        return _which_impl(
            n, _returns_function_tag{},
            std::make_index_sequence<sizeof...(Cases)>{},
            std::forward<decltype(cases)>(cases)...);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Test, typename Incr, typename Body>
auto loop_for(Test test, Incr incr, Body body)
{
    WL_TRY_BEGIN()
    static_assert(is_boolean_v<remove_cvref_t<decltype(test())>>,
        WL_ERROR_LOOP_TEST);
    try
    {
        for (;;)
        {
            for (int64_t i = 0; i < WL_CHECK_ABORT_LENGTH; ++i)
            {
                if (!test())
                    return const_null;
                body();
                incr();
            }
            WL_THROW_IF_ABORT()
        }
    }
    catch (const loop_break&)
    {
    }
    return const_null;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Test, typename Body>
auto loop_while(Test test, Body body)
{
    WL_TRY_BEGIN()
    static_assert(is_boolean_v<remove_cvref_t<decltype(test())>>,
        WL_ERROR_LOOP_TEST);
    try
    {
        for (;;)
        {
            for (int64_t i = 0; i < WL_CHECK_ABORT_LENGTH; ++i)
            {
                if (!test())
                    return const_null;
                body();
            }
            WL_THROW_IF_ABORT()
        }
    }
    catch (const loop_break&)
    {
    }
    return const_null;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
template<typename Fn, typename First, typename... Rest>
auto _iterator_apply_first(Fn fn, const First& first, const Rest&... rest)
{
    if constexpr (sizeof...(Rest) == 0u)
    {
        if constexpr (First::has_variable)
            return val(fn(first[0]));
        else
            return val(fn());
    }
    else
    {
        if constexpr (First::has_variable)
        {
            const auto& arg1 = first[0];
            return _iterator_apply_first(
                [&](const auto&... args) { return fn(arg1, args...); },
                rest...);
        }
        else
            return _iterator_apply_first(fn, rest...);
    }
}
template<typename Skip, typename Fn, typename First, typename... Rest>
auto _clause_impl(Skip& skip_flag,
    Fn fn, const First& first, const Rest&... rest)
{
    if constexpr (sizeof...(Rest) == 0u)
    {
        WL_CHECK_ABORT_LOOP_BEGIN(first.length())
            for (auto i = _loop_begin; i < _loop_end; ++i)
            {
                if constexpr (std::is_same_v<Skip, bool>)
                    if (skip_flag)
                    {
                        skip_flag = false;
                        continue;
                    }
                if constexpr (First::has_variable)
                    fn(first[i]);
                else
                    fn();
            }
        WL_CHECK_ABORT_LOOP_END();
    }
    else
    {
        for (size_t i = 0; i < first.length(); ++i)
        {
            if constexpr (First::has_variable)
            {
                const auto& arg1 = first[i];
                _clause_impl(skip_flag,
                    [&](const auto&... args) { return fn(arg1, args...); },
                    rest...);
            }
            else
                _clause_impl(skip_flag, fn, rest...);
        }
    }
}
template<typename Fn, typename... Iters>
auto clause_do(Fn fn, const Iters&... iters)
{
    WL_TRY_BEGIN()
    static_assert(sizeof...(Iters) >= 1u, WL_ERROR_INTERNAL);
    wl::void_type skip_flag;    // skip flag is not used
    try
    {
        _clause_impl(skip_flag, fn, iters...);
    }
    catch (const loop_break&)
    {
    }
    return const_null;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Fn, typename... Iters>
auto clause_table(Fn fn, const Iters&... iters)
{
    WL_TRY_BEGIN()
    constexpr auto outer_rank = sizeof...(iters);
    static_assert(outer_rank >= 1u, WL_ERROR_INTERNAL);
    using InnerType = remove_cvref_t<
        decltype(_iterator_apply_first(fn, iters...))>;
    auto outer_dims = std::array<size_t, outer_rank>{iters.length()...};
    auto outer_size = utils::size_of_dims(outer_dims);
    if (outer_size == 0u)
    {
        if constexpr (array_rank_v<InnerType> == 0u)
            return ndarray<InnerType, outer_rank>{};
        else
        {
            return ndarray<value_type_t<InnerType>,
                outer_rank + array_rank_v<InnerType>>{};
        }
    }
    else
    {
        if constexpr (array_rank_v<InnerType> == 0u)
        {
            ndarray<InnerType, outer_rank> ret(outer_dims);
            auto ret_iter = ret.begin();
            wl::void_type skip_flag;    // skip flag is not used
            _clause_impl(skip_flag,
                [&](const auto&... args) { *ret_iter++ = fn(args...); },
                iters...);
            return ret;
        }
        else
        {
            using ValueType = typename InnerType::value_type;
            constexpr auto inner_rank = array_rank_v<InnerType>;
            auto first_item = _iterator_apply_first(fn, iters...);
            auto inner_dims = first_item.dims();
            auto all_dims = utils::dims_join(outer_dims, inner_dims);
            ndarray<ValueType, outer_rank + inner_rank> ret(all_dims);
            auto ret_iter = ret.template view_begin<outer_rank>();
            first_item.copy_to(ret_iter.begin());
            ++ret_iter;
            bool skip_flag = true;      // skip flag is used
            _clause_impl(skip_flag,
                [&](const auto&... args)
                {
                    auto item = fn(args...);
                    if (!utils::check_dims(ret_iter.dims(), item.dims()))
                        throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
                    item.copy_to(ret_iter.begin());
                    ++ret_iter;
                },
                iters...);
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Fn, typename... Iters>
auto clause_sum(Fn fn, const Iters&... iters)
{
    WL_TRY_BEGIN()
    constexpr auto outer_rank = sizeof...(iters);
    static_assert(outer_rank >= 1u, WL_ERROR_INTERNAL);
    using InnerType = remove_cvref_t<
        decltype(_iterator_apply_first(fn, iters...))>;
    static_assert(is_numerical_type_v<InnerType>, WL_ERROR_SUM_ELEMENT);
    auto outer_dims = std::array<size_t, outer_rank>{iters.length()...};
    auto outer_size = utils::size_of_dims(outer_dims);
    if (outer_size == 0u)
    {
        if constexpr (is_arithmetic_v<InnerType>)
            return InnerType{};
        else
            throw std::logic_error(WL_ERROR_SUM_ZERO_SIZE);
    }
    else
    {
        auto ret = _iterator_apply_first(fn, iters...);
        bool skip_flag = true;      // skip flag is not used
        if constexpr (array_rank_v<InnerType> >= 1u)
        {
            _clause_impl(skip_flag,
                [&](const auto&... args)
                {
                    add_to(ret, fn(args...));
                },
                iters...);
        }
        else
        {
            _clause_impl(skip_flag,
                [&](const auto&... args) { add_to(ret, fn(args...)); },
                iters...);
        }
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Fn, typename... Iters>
auto clause_product(Fn fn, const Iters&... iters)
{
    WL_TRY_BEGIN()
    constexpr auto outer_rank = sizeof...(iters);
    static_assert(outer_rank >= 1u, WL_ERROR_INTERNAL);
    using InnerType = remove_cvref_t<
        decltype(_iterator_apply_first(fn, iters...))>;
    static_assert(is_numerical_type_v<InnerType>, WL_ERROR_SUM_ELEMENT);
    auto outer_dims = std::array<size_t, outer_rank>{iters.length()...};
    auto outer_size = utils::size_of_dims(outer_dims);
    if (outer_size == 0u)
    {
        if constexpr (is_arithmetic_v<InnerType>)
            return InnerType(int8_t(1));
        else
            throw std::logic_error(WL_ERROR_PRODUCT_ZERO_SIZE);
    }
    else
    {
        auto ret = _iterator_apply_first(fn, iters...);
        bool skip_flag = true;      // skip flag is not used
        _clause_impl(skip_flag,
            [&](const auto&... args)
            {
                times_by(ret, fn(args...));
            },
            iters...);
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
template<typename Re, typename Im>
auto make_complex(const Re& re, const Im& im)
{
    WL_TRY_BEGIN()
    static_assert(is_real_v<Re> && is_real_v<Im>, WL_ERROR_REAL_TYPE_ARG);
    using C = common_type_t<Re, Im>;
    using T = std::conditional_t<std::is_same_v<C, float>, float, double>;
    return complex<T>(T(re), T(im));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto re(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto scalar_re = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_complex_v<XV>)
            return x.real();
        else
            return x;
    };
    return utils::listable_function(scalar_re, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto im(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto scalar_im = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_complex_v<XV>)
            return x.imag();
        else
            return XV(0);
    };
    return utils::listable_function(scalar_im, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto arg(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto scalar_arg = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_complex_v<XV>)
        {
            return std::arg(x);
        }
        else if constexpr (is_integral_v<XV>)
        {
            if constexpr (std::is_unsigned_v<XV>)
                return double(0);
            else
                return x >= XV(0) ? double(0) : const_pi;
        }
        else
            return x >= XV(0) ? XV(0) : XV(const_pi);
    };
    return utils::listable_function(scalar_arg, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto conjugate(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto scalar_conjugate = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_complex_v<XV>)
            return std::conj(x);
        else
            return x;
    };
    return utils::listable_function(scalar_conjugate,
        std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto re_im(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    static_assert(is_numerical_type_v<XT>, WL_ERROR_NUMERIC_ONLY);
    constexpr auto rank = array_rank_v<XT>;
    if constexpr (rank == 0)
    {
        using XV = value_type_t<XT>;
        ndarray<XV, 1u> ret(std::array<size_t, 1u>{2});
        auto iter = ret.data();
        iter[0] = re(x);
        iter[1] = im(x);
        return ret;
    }
    else
    {
        using XV = value_type_t<value_type_t<XT>>;
        auto dims = utils::dims_join(x.dims(), std::array<size_t, 1u>{2});
        ndarray<XV, rank + 1u> ret(dims);
        auto iter = ret.data();
        x.for_each([&](const auto& a)
            { *iter++ = re(a), *iter++ = im(a); });
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto abs_arg(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    static_assert(is_numerical_type_v<XT>,
        WL_ERROR_NUMERIC_ONLY);
    constexpr auto rank = array_rank_v<XT>;
    if constexpr (rank == 0)
    {
        using XV = value_type_t<XT>;
        ndarray<XV, 1u> ret(std::array<size_t, 1u>{2});
        auto iter = ret.data();
        iter[0] = XV(abs(x));
        iter[1] = XV(arg(x));
        return ret;
    }
    else
    {
        using XV = promote_integral_t<value_type_t<value_type_t<XT>>>;
        auto dims = utils::dims_join(x.dims(), std::array<size_t, 1u>{2});
        ndarray<XV, rank + 1u> ret(dims);
        auto iter = ret.begin();
        x.for_each([&](const auto& a)
            { *iter++ = XV(abs(a)), *iter++ = XV(arg(a)); });
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
#define WL_DEFINE_UNARY_MATH_FUNCTION(name, expr)                           \
template<typename X>                                                        \
WL_INLINE auto name(X&& x)                                                  \
{                                                                           \
    WL_TRY_BEGIN()                                                          \
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,                   \
        WL_ERROR_NUMERIC_ONLY);                                             \
    return utils::listable_function([](auto x) {                            \
            using PX = promote_integral_t<decltype(x)>;                     \
            return expr;                                                    \
        }, std::forward<decltype(x)>(x));                                   \
    WL_TRY_END(__func__, __FILE__, __LINE__)                                \
}
#define WL_DEFINE_BINARY_MATH_FUNCTION(name, expr)                          \
template<typename X, typename Y>                                            \
WL_INLINE auto name(X&& x, Y&& y)                                           \
{                                                                           \
    WL_TRY_BEGIN()                                                          \
    static_assert(is_numerical_type_v<remove_cvref_t<X>> &&                 \
        is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);     \
    return utils::listable_function([](auto x, auto y)                      \
        {                                                                   \
            using PX = promote_integral_t<decltype(x)>;                     \
            using PY = promote_integral_t<decltype(y)>;                     \
            using PC = promote_integral_t<                                  \
                common_type_t<decltype(x), decltype(y)>>;                   \
            return expr;                                                    \
        }, std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));     \
    WL_TRY_END(__func__, __FILE__, __LINE__)                                \
}
template<typename X>
WL_INLINE auto _scalar_square(const X x)
{
    return X(x * x);
}
template<typename X, typename Y>
WL_INLINE auto _scalar_power(const X& x, const Y& y)
{
    if constexpr (is_integral_v<Y>)
    {
        auto tmp = x;
        auto count = y < 0 ? uint64_t(0) - uint64_t(y) :  uint64_t(y);
        auto ret = X(1);
        for (;; tmp *= tmp)
        {
            if ((count & uint64_t(1)) != 0u)
                ret *= tmp;
            if ((count >>= 1) == 0u)
                return y < 0 ? X(1) / ret : ret;
        }
    }
    else
    {
        return std::pow(x, y);
    }
}
template<typename X, int64_t y>
WL_INLINE auto _scalar_power(const X& x, const_int<y>)
{
    if constexpr (y < 0)
        return X(1) / _scalar_power(x, const_int<-y>{});
    else if constexpr (y == 0)
        return X(1);
    else if constexpr (y == 1)
        return x;
    else if constexpr (y == 2)
        return X(x * x);
    else if (y < 16)
    {
        X ret = _scalar_power(x, const_int<(y / 2)>{});
        ret *= ret;
        if constexpr ((y & int64_t(1)) != 0)
            ret *= x;
        return ret;
    }
    else
        return _scalar_power(x, y);
}
template<typename X, int64_t I>
WL_INLINE auto power(X&& x, const_int<I>)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    return utils::listable_function([](auto x)
        {
            using PC = promote_integral_t<common_type_t<decltype(x), int64_t>>;
            return _scalar_power(PC(x), const_int<I>{});
        }, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
WL_INLINE X _scalar_gamma(const X& x)
{
    static_assert(is_float_v<X>, WL_ERROR_INTERNAL);
    return X(std::tgamma(x));
}
template<typename X>
complex<X> _scalar_gamma(const complex<X>& x)
{
    constexpr size_t data_size = 9;
    static const std::array<double, data_size> data ={
        0.99999999999980993, 676.5203681218851, -1259.1392167224028,
        771.32342877765313, -176.61502916214059, 12.507343278686905,
        -0.13857109526572012, 9.9843695780195716e-6,
        1.5056327351493116e-7};
    if (std::real(x) < X(0.5))
    {
        return X(const_pi) / (
            std::sin(X(const_pi) * x) * _scalar_gamma(X(1) - x));
    }
    else
    {
        complex<X> z = x - X(1);
        complex<X> y = data[0];
        for (size_t i = 1; i < data_size; ++i)
            y += data[i] / (z + X(i));
        complex<X> t = z + X(7.5);
        return std::sqrt(X(2 * const_pi)) *
            std::pow(t, z + X(0.5)) * std::exp(-t) * y;
    }
}
WL_DEFINE_UNARY_MATH_FUNCTION(log, std::log(x))
WL_DEFINE_BINARY_MATH_FUNCTION(log, std::log(PC(y)) / std::log(PC(x)))
WL_DEFINE_UNARY_MATH_FUNCTION(log2, PX(1.4426950408889634074) * std::log(x))
WL_DEFINE_UNARY_MATH_FUNCTION(log10, PX(0.43429448190325182765) * std::log(x))
WL_DEFINE_UNARY_MATH_FUNCTION(exp, std::exp(x))
WL_DEFINE_UNARY_MATH_FUNCTION(sqrt, std::sqrt(x))
WL_DEFINE_BINARY_MATH_FUNCTION(power, _scalar_power(PC(x), y))
WL_DEFINE_UNARY_MATH_FUNCTION(sin, std::sin(x))
WL_DEFINE_UNARY_MATH_FUNCTION(cos, std::cos(x))
WL_DEFINE_UNARY_MATH_FUNCTION(tan, std::tan(x))
WL_DEFINE_UNARY_MATH_FUNCTION(cot, PX(1) / std::tan(x))
WL_DEFINE_UNARY_MATH_FUNCTION(sec, PX(1) / std::cos(x))
WL_DEFINE_UNARY_MATH_FUNCTION(csc, PX(1) / std::sin(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arcsin, std::asin(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arccos, std::acos(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arctan, std::atan(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arccot, std::atan(PX(1) / x))
WL_DEFINE_UNARY_MATH_FUNCTION(arcsec, std::acos(PX(1) / x))
WL_DEFINE_UNARY_MATH_FUNCTION(arccsc, std::asin(PX(1) / x))
WL_DEFINE_UNARY_MATH_FUNCTION(sinh, std::sinh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(cosh, std::cosh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(tanh, std::tanh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(coth, PX(1) / std::tanh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(sech, PX(1) / std::cosh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(csch, PX(1) / std::sinh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arcsinh, std::asinh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arccosh, std::acosh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arctanh, std::atanh(x))
WL_DEFINE_UNARY_MATH_FUNCTION(arccoth, std::atanh(PX(1) / x))
WL_DEFINE_UNARY_MATH_FUNCTION(arcsech, std::acosh(PX(1) / x))
WL_DEFINE_UNARY_MATH_FUNCTION(arccsch, std::asinh(PX(1) / x))
WL_DEFINE_UNARY_MATH_FUNCTION(sinc, (x == PX(0) ? PX(1) : std::sin(x) / PX(x)))
WL_DEFINE_BINARY_MATH_FUNCTION(arctan, std::atan2(PC(x), PC(y)))
WL_DEFINE_UNARY_MATH_FUNCTION(haversine,
    _scalar_square(std::sin(PX(0.5) * x)))
WL_DEFINE_UNARY_MATH_FUNCTION(inverse_haversine,
    PX(2) * std::asin(std::sqrt(x)))
WL_DEFINE_UNARY_MATH_FUNCTION(gudermannian,
    PX(2) * std::atan(std::exp(x)) - PX(1.5707963267948966192))
WL_DEFINE_UNARY_MATH_FUNCTION(inverse_gudermannian,
    std::log(std::tan(PX(0.5) * x + PX(0.78539816339744830962))))
WL_DEFINE_UNARY_MATH_FUNCTION(logistic_sigmoid,
    PX(1) / (PX(1) + std::exp(-PX(x))))
WL_DEFINE_UNARY_MATH_FUNCTION(gamma, _scalar_gamma(x))
WL_DEFINE_UNARY_MATH_FUNCTION(log_gamma, std::lgamma(x))
WL_DEFINE_UNARY_MATH_FUNCTION(erf, std::erf(x))
WL_DEFINE_UNARY_MATH_FUNCTION(erfc, std::erfc(x))
WL_DEFINE_BINARY_MATH_FUNCTION(beta, std::beta(x, y))
WL_DEFINE_UNARY_MATH_FUNCTION(zeta, std::riemann_zeta(x))
}
namespace wl
{
template<typename X>
auto even_q(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_integral_v<XV>)
            return boolean((x & XV(1)) == XV(0));
        else if constexpr (is_float_v<XV>)
            return boolean(std::fmod(x, XV(2)) == XV(0));
        else
            return const_false;
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto odd_q(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_integral_v<XV>)
            return boolean((x & XV(1)) == XV(1));
        else if constexpr (is_float_v<XV>)
            return boolean(std::fmod(x, XV(2)) == std::copysign(XV(1), x));
        else
            return const_false;
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto divisible(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>> &&
        is_numerical_type_v<remove_cvref_t<Y>>, WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x, const auto& y)
    {
        using XV = remove_cvref_t<decltype(x)>;
        using YV = remove_cvref_t<decltype(y)>;
        static_assert(is_real_v<XV> && is_real_v<YV>, WL_ERROR_REAL_TYPE_ARG);
        if constexpr (is_integral_v<XV> && is_integral_v<YV>)
        {
            using C = std::conditional_t<
                std::is_signed_v<XV> || std::is_signed_v<YV>,
                make_signed_t<common_type_t<XV, YV>>,
                common_type_t<XV, YV>>;
            return boolean(y != YV(0) && C(x) % C(y) == C(0));
        }
        else
        {
            using C = common_type_t<XV, YV>;
            return boolean(std::fmod(C(x), C(y)) == C(0));
        }
    };
    return utils::listable_function(pure,
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
inline uint64_t _fibonacci_impl(uint64_t n, uint64_t* prev)
{
    constexpr size_t data_size = 94;
    static const std::array<uint64_t, data_size> data ={
        0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,
        10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,
        1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,
        63245986,102334155,165580141,267914296,433494437,701408733,1134903170,
        1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,
        32951280099,53316291173,86267571272,139583862445,225851433717,
        365435296162,591286729879,956722026041,1548008755920,2504730781961,
        4052739537881,6557470319842,10610209857723,17167680177565,
        27777890035288,44945570212853,72723460248141,117669030460994,
        190392490709135,308061521170129,498454011879264,806515533049393,
        1304969544928657,2111485077978050,3416454622906707,5527939700884757,
        8944394323791464,14472334024676221,23416728348467685,37889062373143906,
        61305790721611591,99194853094755497,160500643816367088,
        259695496911122585,420196140727489673,679891637638612258,
        1100087778366101931,1779979416004714189,2880067194370816120,
        4660046610375530309,7540113804746346429,12200160415121876738u};
    if (n < data_size)
    {
        *prev = n == 0u ? uint64_t(1) : data[n - 1];
        return data[n];
    }
    auto lzcnt = utils::lzcnt_u64(n);
    uint64_t leading = n >> (58 - lzcnt);
    uint64_t mask = uint64_t(1) << (57 - lzcnt);
    uint64_t a = data[leading - 1];
    uint64_t b = data[leading];
    uint64_t c = 0u;
    for (; mask; mask >>= 1)
    {
        c = a * a + b * b;
        b *= (2 * a + b);
        a = c;
        if (n & mask)
        {
            c = b;
            b += a;
            a = c;
        }
    }
    *prev = a;
    return b;
}
inline uint64_t _fibonacci(uint64_t n)
{
    uint64_t n1;
    return _fibonacci_impl(n, &n1);
}
inline uint64_t _lucas_l(uint64_t n)
{
    uint64_t n1;
    uint64_t n2 = _fibonacci_impl(n - 1u, &n1);
    return n2 * 3u + n1;
}
template<typename X>
auto fibonacci(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_integral_v<XV>)
        {
            if constexpr (std::is_unsigned_v<XV>)
                return XV(_fibonacci(x));
            else if (x >= XV(0))
                return XV(_fibonacci(x));
            else // x < 0
            {
                auto val = XV(_fibonacci(-x));
                return (x & XV(1)) ? val : -val;
            }
        }
        else
        {
            XV phi_x = std::pow(XV(1.6180339887498948482), x);
            XV cos_pi_x = std::cos(XV(const_pi) * x);
            return XV(0.44721359549995793928) * (phi_x - cos_pi_x / phi_x);
        }
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto lucas_l(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_integral_v<XV>)
        {
            if (x == XV(0))
                return XV(2);
            else if constexpr (std::is_unsigned_v<XV>)
                return XV(_lucas_l(x));
            else if (x > XV(0))
                return XV(_lucas_l(x));
            else // x < 0
            {
                auto val = XV(_lucas_l(-x));
                return (x & XV(1)) ? -val : val;
            }
        }
        else
        {
            XV phi_x = std::pow(XV(1.6180339887498948482), x);
            XV cos_pi_x = std::cos(XV(const_pi) * x);
            return phi_x + cos_pi_x / phi_x;
        }
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
inline uint64_t _factorial(uint64_t n)
{
    constexpr size_t data_size = 66;
    static const std::array<uint64_t, data_size> data ={
        1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,
        6227020800,87178291200,1307674368000,20922789888000,355687428096000,
        6402373705728000,121645100408832000,2432902008176640000u,
        14197454024290336768u,17196083355034583040u,8128291617894825984u,
        10611558092380307456u,7034535277573963776u,16877220553537093632u,
        12963097176472289280u,12478583540742619136u,11390785281054474240u,
        9682165104862298112u,4999213071378415616u,12400865694432886784u,
        3400198294675128320u,4926277576697053184u,6399018521010896896u,
        9003737871877668864u,1096907932701818880u,4789013295250014208u,
        2304077777655037952u,18376134811363311616u,15551764317513711616u,
        7538058755741581312u,10541877243825618944u,2673996885588443136u,
        9649395409222631424u,1150331055211806720u,17172071447535812608u,
        12602690238498734080u,8789267254022766592u,15188249005818642432u,
        18284192274659147776u,9994050523088551936u,13175843659825807360u,
        10519282829630636032u,6711489344688881664u,6908521828386340864u,
        6404118670120845312u,2504001392817995776u,162129586585337856u,
        9727775195120271360u,3098476543630901248u,7638104968020361216u,
        1585267068834414592u,9223372036854775808u,9223372036854775808u};
    if (n < data_size)
        return data[n];
    else
        return uint64_t(0);
}
inline uint64_t _factorial2(uint64_t n)
{
    constexpr size_t data_size = 66;
    static const std::array<uint64_t, data_size> data ={
        1,1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,
        10321920,34459425,185794560,654729075,3715891200,13749310575,
        81749606400,316234143225,1961990553600,7905853580625,51011754393600,
        213458046676875,1428329123020800,6190283353629375,42849873690624000,
        191898783962510625,1371195958099968000,6332659870762850625u,
        9727174427979808768u,282166592185152483u,18136886080501186560u,
        10440163910850641871u,6672140331791679488u,1338022901564897417u,
        8631196239733456896u,17965450816741690865u,12022104668323708928u,
        16197878097801090939u,12463771342375747584u,9481495526376579231u,
        1484415464288288768u,2908431970669985073u,15911710064709206016u,
        13385958046862407265u,2375508065949581312u,154329662729360723u,
        12845954987120918528u,8179472124656118319u,11152038577276190720u,
        7149109087057268761u,15771605895051476992u,1670848340654183825u,
        10862682301217636352u,6346331730049087595u,6124895493223874560u,
        18191354058803310975u,10808639105689190400u,2357173134616391233u,
        9223372036854775808u,5642301160389017217u};
    if (n < data_size)
        return data[n];
    else if (n % 2u == 0u)
        return uint64_t(0);
    else
    {
        uint64_t res = 1u;
        for (;;)
        {
            res *= n;
            n -= 2u;
            if (n < data_size)
                return uint64_t(res * data[n]);
        }
    }
}
template<typename X>
auto factorial(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_integral_v<XV>)
        {
            if constexpr (std::is_unsigned_v<XV>)
                return XV(_factorial(x));
            else if (x >= XV(0))
                return XV(_factorial(x));
            else // x < 0
                throw std::logic_error(WL_ERROR_FACTORIAL_NEGATIVE);
        }
        else
        {
            return XV(wl::gamma(XV(1) + x));
        }
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto factorial2(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<remove_cvref_t<X>>,
        WL_ERROR_NUMERIC_ONLY);
    auto pure = [](const auto& x)
    {
        using XV = remove_cvref_t<decltype(x)>;
        if constexpr (is_integral_v<XV>)
        {
            if constexpr (std::is_unsigned_v<XV>)
                return XV(_factorial2(x));
            else if (x >= XV(0))
                return XV(_factorial2(x));
            else // x < 0
            {
                if (x == XV(-1))
                    return XV(1);
                else if (x == XV(-3))
                    return XV(-1);
                else
                    throw std::logic_error(WL_ERROR_FACTORIAL2_DOMAIN);
            }
        }
        else
        {
            // x!!:=exp((log(2)/2)*x+(log(pi/2)/4)*(cos(pi*x)-1))*gamma(1+x/2)
            const auto log_2_2 = XV(0.34657359027997265471);
            const auto log_pi_2_4 = XV(0.11289567632236371618);
            XV t1 = log_2_2 * x;
            XV t2 = log_pi_2_4 * (std::cos(XV(const_pi) * x) - XV(1));
            XV t3 = wl::gamma(XV(1) + XV(0.5) * x);
            return XV(std::exp(t1 + t2) * t3);
        }
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
constexpr auto bool_not(boolean x)
{
    return !x;
}
constexpr auto implies(boolean x, boolean y)
{
    return !x || y;
}
template<typename X, typename Y>
auto bool_and(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    WL_VARIADIC_FUNCTION_DEFAULT_IF_PARAMETER_PACK(bool_and)
    {
        static_assert(is_boolean_v<remove_cvref_t<X>> &&
            is_boolean_v<remove_cvref_t<Y>>, WL_ERROR_BOOLEAN_ARG);
        return x && y;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Iter, bool HasStride>
auto _variadic_bool_and(const argument_pack<Iter, HasStride>& args)
{
    boolean ret = val(args.get(0));
    WL_CHECK_ABORT_LOOP_BEGIN(args.size() - 1u)
        for (auto i = _loop_begin; i < _loop_end && ret; ++i)
            ret = bool_and(ret, args.get(i + 1, dim_checked{}));
    WL_CHECK_ABORT_LOOP_END()
    return ret;
}
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(bool_and, const_true)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(bool_and)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(bool_and)
template<typename X, typename Y>
auto bool_or(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    WL_VARIADIC_FUNCTION_DEFAULT_IF_PARAMETER_PACK(bool_or)
    {
        static_assert(is_boolean_v<remove_cvref_t<X>> &&
            is_boolean_v<remove_cvref_t<Y>>, WL_ERROR_BOOLEAN_ARG);
        return x || y;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Iter, bool HasStride>
auto _variadic_bool_or(const argument_pack<Iter, HasStride>& args)
{
    boolean ret = val(args.get(0));
    WL_CHECK_ABORT_LOOP_BEGIN(args.size() - 1u)
        for (auto i = _loop_begin; i < _loop_end && !ret; ++i)
            ret = bool_or(ret, args.get(i + 1, dim_checked{}));
    WL_CHECK_ABORT_LOOP_END()
    return ret;
}
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(bool_or, const_false)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(bool_or)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(bool_or)
template<typename X, typename Y>
auto bool_xor(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    WL_VARIADIC_FUNCTION_DEFAULT_IF_PARAMETER_PACK(bool_xor)
    {
        static_assert(is_boolean_v<remove_cvref_t<X>> &&
            is_boolean_v<remove_cvref_t<Y>>, WL_ERROR_BOOLEAN_ARG);
        return x ^ y;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_VARIADIC(bool_xor)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(bool_xor, const_false)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(bool_xor)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(bool_xor)
template<typename... Args>
auto bool_nand(Args&&... args)
{
    WL_TRY_BEGIN()
    return !bool_and(std::forward<decltype(args)>(args)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename... Args>
auto bool_nor(Args&&... args)
{
    WL_TRY_BEGIN()
    return !bool_or(std::forward<decltype(args)>(args)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename... Args>
auto bool_xnor(Args&&... args)
{
    WL_TRY_BEGIN()
    return !bool_xor(std::forward<decltype(args)>(args)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto boole(X&& x)
{
    WL_TRY_BEGIN()
    static_assert(is_boolean_type_v<remove_cvref_t<X>>, WL_ERROR_BOOLEAN_ARG);
    static_assert(is_arithmetic_v<Ret>, WL_ERROR_BAD_RETURN);
    auto pure = [](boolean x) { return Ret(x); };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto bit_not(X&& x)
{
    WL_TRY_BEGIN()
    auto pure = [](auto x)
    {
        using XV = decltype(x);
        static_assert(is_integral_v<XV>, WL_ERROR_INTEGRAL_TYPE_ARG);
        return XV(~x);
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto bit_length(X&& x)
{
    WL_TRY_BEGIN()
    auto pure = [](auto x)
    {
        using XV = decltype(x);
        static_assert(is_integral_v<XV>, WL_ERROR_INTEGRAL_TYPE_ARG);
        if constexpr (std::is_unsigned_v<XV>)
            return Ret(64) - Ret(utils::lzcnt_u64(x));
        else
            return Ret(64) - Ret(utils::lzcnt_u64(
                std::make_unsigned_t<XV>(x >= XV(0) ? x : ~x)));
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
#define WL_DEFINE_BITWISE_OPERATION(name, expr)                             \
template<typename X, typename Y>                                            \
auto name(X&& x, Y&& y)                                                     \
{                                                                           \
    WL_TRY_BEGIN()                                                          \
    WL_VARIADIC_FUNCTION_DEFAULT_IF_PARAMETER_PACK(bit_and)                 \
    {                                                                       \
        auto pure = [](const auto& x, const auto& y)                        \
        {                                                                   \
            using XV = remove_cvref_t<decltype(x)>;                         \
            using YV = remove_cvref_t<decltype(y)>;                         \
            static_assert(is_integral_v<XV> && is_integral_v<YV>,           \
                WL_ERROR_INTEGRAL_TYPE_ARG);                                \
            using C = common_type_t<XV, YV>;                                \
            return expr;                                                    \
        };                                                                  \
        return utils::listable_function(pure,                               \
            std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));    \
    }                                                                       \
    WL_TRY_END(__func__, __FILE__, __LINE__)                                \
}                                                                           \
template<typename X, typename Y>                                            \
void _##name##_assignment(X& x, const Y& y)                                 \
{                                                                           \
    x = X(name(x, y));                                                      \
}                                                                           \
template<typename XV, typename YV, size_t R>                                \
void _##name##_assignment(ndarray<XV, R>& x, const ndarray<YV, R>& y)       \
{                                                                           \
    assert(x.dims() == y.dims());                                           \
    x.for_each(                                                             \
        [](auto& a, const auto& b) { _##name##_assignment(a, b); },         \
        y.data());                                                          \
}                                                                           \
template<typename Iter, bool HasStride>                                     \
auto _variadic_##name(const argument_pack<Iter, HasStride>& args)           \
{                                                                           \
    auto ret = val(args.get(0));                                            \
    WL_CHECK_ABORT_LOOP_BEGIN(args.size() - 1u)                             \
        for (auto i = _loop_begin; i < _loop_end; ++i)                      \
            _##name##_assignment(ret, args.get(i + 1, dim_checked{}));      \
    WL_CHECK_ABORT_LOOP_END()                                               \
    return ret;                                                             \
}
WL_DEFINE_BITWISE_OPERATION(bit_and, C(C(x) & C(y)))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(bit_and, int64_t(-1))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(bit_and)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(bit_and)
WL_DEFINE_BITWISE_OPERATION(bit_or, C(C(x) | C(y)))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(bit_or, int64_t(0))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(bit_or)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(bit_or)
WL_DEFINE_BITWISE_OPERATION(bit_xor, C(C(x) ^ C(y)))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NULLARY(bit_xor, int64_t(0))
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_UNARY(bit_xor)
WL_VARIADIC_FUNCTION_DEFINE_DEFAULT_NARY(bit_xor)
template<bool ShiftLeft, typename X, typename Y>
auto _bit_shift_impl(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    auto pure = [](auto x, auto y)
    {
        using XV = decltype(x);
        using YV = decltype(y);
        static_assert(is_integral_v<XV> && is_integral_v<YV>,
            WL_ERROR_INTEGRAL_TYPE_ARG);
        if constexpr (ShiftLeft)
        {
            return (std::is_unsigned_v<YV> || y >= YV(0)) ? XV(x << y) :
                (std::is_unsigned_v<XV> || x >= XV(0)) ? XV(x >> -y) :
                XV(-(-x >> -y));
        }
        else
        {
            return (std::is_signed_v<YV> && y < YV(0)) ? XV(x << -y) :
                (std::is_unsigned_v<XV> || x >= XV(0)) ? XV(x >> y) :
                XV(-(-x >> y));
        }
    };
    return utils::listable_function(pure,
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto bit_shift_left(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    return _bit_shift_impl<true>(
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto bit_shift_right(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    return _bit_shift_impl<false>(
        std::forward<decltype(x)>(x), std::forward<decltype(y)>(y));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
struct random_engine
{
    using _base_engine_t = WL_BASE_RANDOM_ENGINE;
    static_assert(uint64_t(_base_engine_t::max()) -
        uint64_t(_base_engine_t::min()) == uint64_t(-1),
        "64-bit random engine is required.");
    static constexpr size_t bits_width = 64u;
    using result_type = uint64_t;
    _base_engine_t base_engine_{};
    uint64_t active_bits_{};
    uint64_t reserved_bits_{};
    size_t n_bits_active_{};
    random_engine()
    {
        update_all_bits();
    }
    static constexpr auto max()
    {
        return _base_engine_t::max();
    }
    static constexpr auto min()
    {
        return _base_engine_t::min();
    }
    WL_INLINE auto base_engine_get_bits()
    {
        return uint64_t(base_engine_());
    }
    auto get_bits(size_t n)
    {
        if (n >= 64u)
            return base_engine_get_bits();
        else if (n > 32u)
            return base_engine_get_bits() >> (64u - n);
        uint64_t ret = active_bits_ >> (bits_width - n);
        if (n <= n_bits_active_)
        {
            active_bits_ <<= n;
            n_bits_active_ -= n;
        }
        else
        {
            size_t n_bits_short = n - n_bits_active_;
            ret |= reserved_bits_ >> (bits_width - n_bits_short);
            active_bits_ = reserved_bits_ << n_bits_short;
            n_bits_active_ = (bits_width - n_bits_short);
            reserved_bits_ = base_engine_get_bits();
        }
        return ret;
    }
    void update_all_bits()
    {
        active_bits_ = base_engine_get_bits();
        reserved_bits_ = base_engine_get_bits();
        n_bits_active_ = bits_width;
    }
    template<typename Any>
    void seed(Any&& any)
    {
        base_engine_.seed(std::forward<decltype(any)>(any));
        update_all_bits();
    }
    WL_INLINE auto operator()()
    {
        return base_engine_get_bits();
    }
};
extern random_engine global_random_engine;
namespace distribution
{
template<typename T>
void adjust_bounds(T& min, T& max)
{
    if (min > max)
        std::swap(min, max);
}
template<typename T>
void adjust_bounds(complex<T>& min, complex<T>& max)
{
    auto min_real = min.real();
    auto min_imag = min.imag();
    auto max_real = max.real();
    auto max_imag = max.imag();
    adjust_bounds(min_real, max_real);
    adjust_bounds(min_imag, max_imag);
    min = complex<T>(min_real, min_imag);
    max = complex<T>(max_real, max_imag);
}
template<typename T, bool Multiple = false>
struct uniform
{
    static_assert(is_real_v<T>, WL_ERROR_INTERNAL);
    using value_type = T;
    static constexpr size_t rank = 0;
    T min_;
    T max_;
    uint64_t range_{};
    size_t n_bits_{};
    uniform(T a, T b) : min_{a}, max_{b}
    {
        adjust_bounds(min_, max_);
        if constexpr (is_integral_v<T> && Multiple)
        {
            const auto diff = uint64_t(max_) - uint64_t(min_);
            n_bits_ = size_t(64u - utils::lzcnt_u64(diff));
            range_ = diff + 1u; // could be zero
        }
    }
    T generate_int()
    {
        if (range_ == 0u)
            return T(global_random_engine());
        if constexpr (Multiple)
        {
            for (;;)
            {
                uint64_t rand = global_random_engine.get_bits(n_bits_);
                if (rand <= uint64_t(range_ - 1u))
                    return T(rand + std::make_unsigned_t<T>(min_));
            }
        }
        else
        {
            for (;;)
            {
                uint64_t rand = global_random_engine();
                uint64_t mask = uint64_t(-1);
                if (rand / range_ < mask / range_ ||
                    mask % range_ == (range_ - 1u)) {
                    return T((rand % range_) + std::make_unsigned_t<T>(min_));
                }
            }
        }
    }
    void generate(T* res)
    {
        if constexpr (is_integral_v<T>)
            *res = generate_int();
        else
            *res = std::uniform_real_distribution<T>(
                min_, max_)(global_random_engine);
    }
};
template<typename T, bool Multiple>
struct uniform<complex<T>, Multiple>
{
    static_assert(is_float_v<T>, WL_ERROR_INTERNAL);
    using value_type = complex<T>;
    static constexpr size_t rank = 0;
    complex<T> min_;
    complex<T> max_;
    uniform(const complex<T>& a, const complex<T>& b) : min_{a}, max_{b}
    {
        adjust_bounds(min_, max_);
    }
    void generate(complex<T>* res)
    {
        using dist_type = std::uniform_real_distribution<T>;
        auto re_dist = dist_type(min_.real(), max_.real());
        auto im_dist = dist_type(min_.imag(), max_.imag());
        *res = complex<T>(re_dist(global_random_engine),
            im_dist(global_random_engine));
    }
};
template<typename T>
struct multi_uniform
{
    static_assert(is_arithmetic_v<T>, WL_ERROR_INTERNAL);
    using value_type = T;
    static constexpr size_t rank = 1;
    ndarray<T, 2u> bounds_;
    multi_uniform(const ndarray<T, 2u>& bounds) : bounds_(bounds)
    {
        _initialize();
    }
    multi_uniform(ndarray<T, 2u>&& bounds) : bounds_(std::move(bounds))
    {
        _initialize();
    }
    void _initialize()
    {
        if (!(bounds_.dims()[0] >= 1u && bounds_.dims()[1] == 2u))
            throw std::logic_error(WL_ERROR_INTERNAL);
        const auto length = bounds_.dims()[0];
        auto iter = bounds_.data();
        for (size_t i = 0; i < length; ++i, iter += 2)
            adjust_bounds(iter[0], iter[1]);
    }
    size_t length() const
    {
        return bounds_.dims()[0];
    }
    void _single_generate(T* res, T* bounds)
    {
        if constexpr (is_complex_v<T>)
        {
            using dist_type = std::uniform_real_distribution<T>;
            auto re_dist = dist_type(bounds[0].real(), bounds[1].real());
            auto im_dist = dist_type(bounds[0].imag(), bounds[1].imag());
            res->real() = re_dist(global_random_engine);
            res->imag() = im_dist(global_random_engine);
        }
        else
        {
            using dist_type = std::conditional_t<is_integral_v<T>,
                std::uniform_int_distribution<T>,
                std::uniform_real_distribution<T>>;
            auto dist = dist_type(bounds[0], bounds[1]);
            *res = dist(global_random_engine);
        }
    }
    void generate(T* res)
    {
        const auto length = this->length();
        auto bounds_ptr = bounds_.data();
        for (size_t i = 0; i < length; ++i, ++res, bounds_ptr += 2)
            _single_generate(res, bounds_ptr);
    }
};
template<typename T>
struct default_multi_uniform
{
    static_assert(is_float_v<T>, WL_ERROR_INTERNAL);
    using value_type = T;
    static constexpr size_t rank = 1;
    size_t length_;
    default_multi_uniform(size_t length) : length_{length}
    {
        if (!(length >= 1u))
            throw std::logic_error(WL_ERROR_INTERNAL);
    }
    size_t length() const
    {
        return length_;
    }
    void generate(T* res)
    {
        for (size_t i = 0; i < length_; ++i, ++res)
        {
            auto dist = std::uniform_real_distribution<T>();
            *res = dist(global_random_engine);
        }
    }
};
template<typename RT, template<typename> typename Dist, typename... Params>
struct scalar_distribution
{
    using value_type = RT;
    static constexpr size_t rank = 0;
    Dist<RT> dist_;
    scalar_distribution(const Params&... params) : dist_(params...)
    {
    }
    void generate(RT* res)
    {
        *res = dist_(global_random_engine);
    }
};
#define WL_DEFINE_DISTRIBUTION_TYPE(name, stdname)          \
template<typename ReturnType, typename... Params>           \
using name = scalar_distribution<                           \
    ReturnType, std::stdname##_distribution, Params...>;
WL_DEFINE_DISTRIBUTION_TYPE(log_normal, lognormal)
WL_DEFINE_DISTRIBUTION_TYPE(normal, normal)
WL_DEFINE_DISTRIBUTION_TYPE(chi_square, chi_squared)
WL_DEFINE_DISTRIBUTION_TYPE(cauchy, cauchy)
WL_DEFINE_DISTRIBUTION_TYPE(student_t_nu, student_t)
WL_DEFINE_DISTRIBUTION_TYPE(f_ratio, fisher_f)
WL_DEFINE_DISTRIBUTION_TYPE(exponential, exponential)
WL_DEFINE_DISTRIBUTION_TYPE(poisson, poisson)
WL_DEFINE_DISTRIBUTION_TYPE(gamma, gamma)
WL_DEFINE_DISTRIBUTION_TYPE(weibull, weibull)
WL_DEFINE_DISTRIBUTION_TYPE(extreme_value, extreme_value)
WL_DEFINE_DISTRIBUTION_TYPE(geometric, geometric)
WL_DEFINE_DISTRIBUTION_TYPE(binomial, binomial)
WL_DEFINE_DISTRIBUTION_TYPE(negative_binomial, negative_binomial)
template<typename RT, typename Mu, typename Sigma, typename Nu>
struct student_t
{
    using value_type = RT;
    static constexpr size_t rank = 0;
    RT mu_;
    RT sigma_;
    std::student_t_distribution<RT> dist_;
    student_t(const Mu& mu, const Sigma& sigma, const Nu& nu) :
        mu_{RT(mu)}, sigma_{RT(sigma)}, dist_(nu)
    {
    }
    void generate(RT* res)
    {
        *res = dist_(global_random_engine) * sigma_ + mu_;
    }
};
template<typename RT, typename P>
struct bernoulli
{
    using value_type = RT;
    static constexpr size_t rank = 0;
    double p_;
    bernoulli(const P& p) : p_{double(p)}
    {
    }
    void generate(RT* res)
    {
        double rand = std::uniform_real_distribution<>()(global_random_engine);
        *res = RT(rand < double(p_));
    }
};
}
inline auto uniform_distribution()
{
    return distribution::uniform<double>(0., 1.);
}
template<typename X>
auto uniform_distribution(const X& x)
{
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR <= 2u, WL_ERROR_UNIFORM_BOUNDS_SPEC);
    
    if constexpr (XR == 0u)
    {
        static_assert(is_integral_v<X>, WL_ERROR_UNIFORM_BOUNDS_SPEC);
        if (x <= X(0))
            throw std::logic_error(WL_ERROR_UNIFORM_BOUNDS_SPEC);
        return distribution::default_multi_uniform<double>(x);
    }
    else
    {
        using XV = value_type_t<X>;
        static_assert(is_arithmetic_v<XV>, WL_ERROR_UNIFORM_BOUNDS_SPEC);
        using RV = promote_integral_t<XV>;
        if constexpr (XR == 1u)
        {
            if (x.dims()[0] != 2u)
                throw std::logic_error(WL_ERROR_UNIFORM_BOUNDS_SPEC);
            std::array<RV, 2u> bounds;
            x.copy_to(bounds.data());
            return distribution::uniform<RV>(bounds[0], bounds[1]);
        }
        else // XR == 2u
        {
            static_assert(is_arithmetic_v<XV>, WL_ERROR_UNIFORM_BOUNDS_SPEC);
            if (!(x.dims()[0] >= 1u && x.dims()[1] == 2u))
                throw std::logic_error(WL_ERROR_UNIFORM_BOUNDS_SPEC);
            auto bounds = cast<ndarray<RV, 2u>>(x);
            return distribution::multi_uniform<RV>(bounds);
        }
    }
}
template<typename Nu>
auto chi_square_distribution(const Nu& nu)
{
    static_assert(is_real_v<Nu>, WL_ERROR_REAL_TYPE_ARG);
    if (!(nu > Nu(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::chi_square<promote_integral_t<Nu>, Nu>(nu);
}
template<typename Mean, typename Dev>
auto normal_distribution(const Mean& mean, const Dev& dev)
{
    static_assert(all_is_real_v<Mean, Dev>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<Mean, Dev>>;
    if (!(dev > Dev(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::normal<P, Mean, Dev>(mean, dev);
}
inline auto normal_distribution()
{
    return normal_distribution(0., 1.);
}
template<typename Mean, typename Dev>
auto log_normal_distribution(const Mean& mean, const Dev& dev)
{
    static_assert(all_is_real_v<Mean, Dev>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<Mean, Dev>>;
    if (!(dev > Dev(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::log_normal<P, Mean, Dev>(mean, dev);
}
template<typename A, typename B>
auto cauchy_distribution(const A& a, const B& b)
{
    static_assert(all_is_real_v<A, B>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<A, B>>;
    if (!(b > B(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::cauchy<P, A, B>(a, b);
}
inline auto cauchy_distribution()
{
    return cauchy_distribution(0., 1.);
}
template<typename Mean, typename Scale, typename Nu>
auto student_t_distribution(const Mean& mean, const Scale& scale, const Nu& nu)
{
    static_assert(all_is_real_v<Mean, Scale, Nu>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<Mean, Scale, Nu>>;
    if (!(scale > Scale(0) && nu > Nu(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::student_t<P, Mean, Scale, Nu>(mean, scale, nu);
}
template<typename Nu>
auto student_t_distribution(const Nu& nu)
{
    static_assert(is_real_v<Nu>, WL_ERROR_REAL_TYPE_ARG);
    if (!(nu > Nu(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::student_t_nu<promote_integral_t<Nu>, Nu>(nu);
}
template<typename N, typename M>
auto f_ratio_distribution(const N& n, const M& m)
{
    static_assert(all_is_real_v<N, M>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<N, M>>;
    if (!(n > N(0) && m > M(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::f_ratio<P, N, M>(n, m);
}
template<typename Mean>
auto poisson_distribution(const Mean& mean)
{
    static_assert(is_real_v<Mean>, WL_ERROR_REAL_TYPE_ARG);
    if (!(mean > Mean(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::poisson<int64_t, Mean>(mean);
}
template<typename Lambda>
auto exponential_distribution(const Lambda& lambda)
{
    static_assert(is_real_v<Lambda>, WL_ERROR_REAL_TYPE_ARG);
    if (!(lambda > Lambda(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::exponential<
        promote_integral_t<Lambda>, Lambda>(lambda);
}
template<typename Ret = int64_t, typename P>
auto bernoulli_distribution(const P& p)
{
    static_assert(is_real_v<P>, WL_ERROR_REAL_TYPE_ARG);
    static_assert(is_arithmetic_v<Ret>, WL_ERROR_BAD_RETURN);
    if (!(P(0) <= p && p <= P(1)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::bernoulli<Ret, P>(p);
}
template<typename Alpha, typename Beta>
auto gamma_distribution(const Alpha& alpha, const Beta& beta)
{
    static_assert(all_is_real_v<Alpha, Beta>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<Alpha, Beta>>;
    if (!(alpha > Alpha(0) && beta > Beta(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::gamma<P, Alpha, Beta>(alpha, beta);
}
template<typename Alpha, typename Beta>
auto weibull_distribution(const Alpha& alpha, const Beta& beta)
{
    static_assert(all_is_real_v<Alpha, Beta>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<Alpha, Beta>>;
    if (!(alpha > Alpha(0) && beta > Beta(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::weibull<P, Alpha, Beta>(alpha, beta);
}
template<typename Alpha, typename Beta>
auto extreme_value_distribution(const Alpha& alpha, const Beta& beta)
{
    static_assert(all_is_real_v<Alpha, Beta>, WL_ERROR_REAL_TYPE_ARG);
    using P = promote_integral_t<common_type_t<Alpha, Beta>>;
    if (!(beta > Beta(0)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::extreme_value<P, Alpha, Beta>(alpha, beta);
}
inline auto extreme_value_distribution()
{
    return extreme_value_distribution(0., 1.);
}
template<typename P>
auto geometric_distribution(const P& p)
{
    static_assert(is_real_v<P>, WL_ERROR_REAL_TYPE_ARG);
    if (!(P(0) < p && p < P(1)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::geometric<int64_t, P>(p);
}
template<typename N, typename P>
auto binomial_distribution(const N& n, const P& p)
{
    static_assert(is_integral_v<N>, WL_ERROR_INTEGRAL_TYPE_ARG);
    static_assert(is_real_v<P>, WL_ERROR_REAL_TYPE_ARG);
    if (!(n >= N(0) && P(0) <= p && p <= P(1)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::binomial<N, N, P>(n, p);
}
template<typename N, typename P>
auto negative_binomial_distribution(const N& n, const P& p)
{
    static_assert(is_integral_v<N>, WL_ERROR_INTEGRAL_TYPE_ARG);
    static_assert(is_real_v<P>, WL_ERROR_REAL_TYPE_ARG);
    if (!(n > N(0) && P(0) < p && p <= P(1)))
        throw std::logic_error(WL_ERROR_DIST_PARAMETER_DOMAIN);
    return distribution::negative_binomial<N, N, P>(n, p);
}
template<typename Dist, typename... Dims>
auto _random_variate_impl(Dist dist, const Dims&... dims)
{
    using T = typename Dist::value_type;
    constexpr size_t R1 = Dist::rank;
    constexpr size_t R2 = sizeof...(dims);
    static_assert(R1 <= 1u, WL_ERROR_INTERNAL);
    if constexpr (R2 == 0u)
    {
        if constexpr (R1 == 0u)
        {
            T ret;
            dist.generate(&ret);
            return ret;
        }
        else
        {
            ndarray<T, 1u> ret(std::array<size_t, 1u>{dist.length()});
            dist.generate(ret.data());
            return ret;
        }
    }
    else
    {
        if constexpr (R1 == 0u)
        {
            wl::ndarray<T, R2> ret(utils::get_dims_array(dims...));
            auto iter = ret.data();
            WL_CHECK_ABORT_LOOP_BEGIN(ret.size())
                for (auto i = _loop_zero; i < _loop_size; ++i, ++iter)
                    dist.generate(iter);
            WL_CHECK_ABORT_LOOP_END()
            return ret;
        }
        else
        {
            const auto length = dist.length();
            wl::ndarray<T, R2 + 1u> ret(
                utils::get_dims_array(dims..., length));
            const auto outer_size = utils::size_of_dims<R2>(ret.dims().data());
            auto iter = ret.data();
            WL_CHECK_ABORT_LOOP_BEGIN(outer_size)
                for (auto i = _loop_zero; i < _loop_size; ++i, iter += length)
                    dist.generate(iter);
            WL_CHECK_ABORT_LOOP_END()
            return ret;
        }
    }
}
template<typename Dist, typename... Dims>
auto random_variate(Dist dist, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    return _random_variate_impl(dist, dims...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Min, typename Max, typename... Dims>
auto random_integer(const Min& min, const Max& max, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(all_is_integral_v<Min, Max>, WL_ERROR_RANDOM_BOUNDS);
    using T = common_type_t<Min, Max>;
    auto dist = distribution::uniform<T, true>(T(min), T(max));
    return _random_variate_impl(dist, dims...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Max, typename... Dims>
auto random_integer(const Max& max, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(is_integral_v<Max>, WL_ERROR_RANDOM_BOUNDS);
    return random_integer(Max{}, max, varg_tag{}, dims...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Min, typename Max, typename... Dims>
auto random_real(const Min& min, const Max& max, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(all_is_real_v<Min, Max>, WL_ERROR_RANDOM_BOUNDS);
    using P = promote_integral_t<common_type_t<Min, Max>>;
    auto dist = distribution::uniform<P>(min, max);
    return _random_variate_impl(dist, dims...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Max, typename... Dims>
auto random_real(const Max& max, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(is_real_v<Max>, WL_ERROR_RANDOM_BOUNDS);
    return random_real(Max{}, max, varg_tag{}, dims...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Min, typename Max, typename... Dims>
auto random_complex(const Min& min, const Max& max, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(is_arithmetic_v<Min> && is_arithmetic_v<Max>,
        WL_ERROR_RANDOM_BOUNDS);
    using C = common_type_t<value_type_t<Min>, value_type_t<Max>>;
    using T = std::conditional_t<std::is_same_v<C, float>,
        complex<float>, complex<double>>;
    auto dist = distribution::uniform<T>(cast<T>(min), cast<T>(max));
    return _random_variate_impl(dist, dims...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Max, typename... Dims>
auto random_complex(const Max& max, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(is_arithmetic_v<Max>, WL_ERROR_RANDOM_BOUNDS);
    return random_complex(Max{}, max, varg_tag{}, dims...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Random, typename X, size_t OuterRank>
auto _random_choice_batch_impl(Random&& random, const X& x,
    const std::array<size_t, OuterRank>& outer_dims)
{
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<X>;
    const auto& valx = allows<view_category::Regular>(x);
    const auto x_iter = valx.begin();
    const auto outer_size = utils::size_of_dims(outer_dims);
    if constexpr (XR == 1u)
    {
        ndarray<XV, OuterRank> ret(outer_dims);
        auto ret_iter = ret.data();
        for (size_t i = 0; i < outer_size; ++i, ++ret_iter)
            *ret_iter = *(x_iter + random());
        return ret;
    }
    else
    {
        auto item_dims = utils::dims_take<2u, XR>(x.dims());
        auto item_size = utils::size_of_dims(item_dims);
        ndarray<XV, OuterRank + XR - 1u> ret(
            utils::dims_join(outer_dims, item_dims));
        auto base_iter = ret.data();
        for (size_t i = 0u; i < outer_size; ++i, base_iter += item_size)
            utils::restrict_copy_n(
                x_iter + item_size * random(),
                item_size, base_iter);
        return ret;
    }
}
template<typename Random, typename X>
auto _random_choice_single_impl(const Random& random, const X& x)
{
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<X>;
    const auto& valx = allows<view_category::Regular>(x);
    const auto x_iter = valx.begin();
    if constexpr (XR == 1u)
    {
        return *(x_iter + random());
    }
    else
    {
        auto item_dims = utils::dims_take<2u, XR>(x.dims());
        auto item_size = utils::size_of_dims(item_dims);
        ndarray<XV, XR - 1u> ret(item_dims);
        utils::restrict_copy_n(
            x_iter + item_size * random(), item_size, ret.data());
        return ret;
    }
}
inline auto _random_choice_prepare_uniform(const size_t x_length)
{
    if (!(x_length >= 1u))
        throw std::logic_error(WL_ERROR_RANDOM_ELEM_LENGTH);
    return [max = size_t(x_length - 1u)]
    {
        auto dist = std::uniform_int_distribution<size_t>(0u, max);
        return dist(global_random_engine);
    };
}
template<typename W>
auto _random_choice_prepare_binary(const W& w, const size_t x_length)
{
    static_assert(array_rank_v<W> == 1u && is_real_v<value_type_t<W>>,
        WL_ERROR_RANDOM_WEIGHTS_TYPE);
    if (!(x_length == w.dims()[0] && x_length >= 1u))
        throw std::logic_error(WL_ERROR_RANDOM_WEIGHTS_LENGTH);
    const auto& valw = allows<view_category::Regular>(w);
    const auto w_size = valw.size();
    auto ret = ndarray<double, 1u>(valw.dims());
    auto w_iter = valw.begin();
    auto ret_iter = ret.data();
    double accumulate = 0.0;
    WL_IGNORE_DEPENDENCIES
    for (size_t i = 0; i < w_size; ++i, ++w_iter, ++ret_iter)
    {
        const auto weight = double(*w_iter);
        if (weight < 0.)
            throw std::logic_error(WL_ERROR_NEGATIVE_WEIGHT);
        accumulate += weight;
        *ret_iter = accumulate;
    }
    return [weights = std::move(ret), sum = accumulate]
    {
        auto w_begin = weights.begin();
        auto w_end = weights.end();
        auto dist = std::uniform_real_distribution<>(0., sum);
        return size_t(std::lower_bound(
            w_begin, w_end, dist(global_random_engine)) - w_begin);
    };
}
template<typename W>
auto _random_choice_prepare_walker74(const W& w, const size_t x_length)
{
    // Walker, A.J. (1974), Electronics Letters, 10(8), 127
    static_assert(array_rank_v<W> == 1u && is_real_v<value_type_t<W>>,
        WL_ERROR_RANDOM_WEIGHTS_TYPE);
    if (!(x_length == w.dims()[0] && x_length >= 1u))
        throw std::logic_error(WL_ERROR_RANDOM_WEIGHTS_LENGTH);
    const size_t n = x_length;
    std::vector<double> p(n);
    w.copy_to(p.data());
    struct alias_t { double prob; uint64_t index; };
    std::vector<alias_t> alias_vec(n);
    auto small_base = new alias_t[n];
    auto large_base = new alias_t[n];
    auto* alias = alias_vec.data();
    auto* small = small_base;
    auto* large = large_base;
    auto push = [](auto*& ptr, alias_t elem) { *(ptr++) = elem; };
    auto pop = [](auto*& ptr) { return *(--ptr); };
    double normalize = 0.0;
    for (const auto& prob : p)
    {
        if (prob < 0.)
            throw std::logic_error(WL_ERROR_NEGATIVE_WEIGHT);
        normalize += prob;
    }
    const double factor = double(x_length) / normalize;
    for (uint64_t i = 0; i < n; ++i)
    {
        const double prob = p[i] * factor;
        push(prob <= 1. ? small : large, alias_t{prob, i});
    }
    while (small > small_base && large > large_base)
    {
        auto l = pop(small);
        auto g = pop(large);
        alias[l.index].prob = l.prob;
        alias[l.index].index = g.index;
        g.prob += l.prob - 1.;
        push(g.prob <= 1. ? small : large, g);
    }
    while (large > large_base)
    {
        alias[pop(large).index].prob = 1.;
    }
    while (small > small_base)
    {
        alias[pop(small).index].prob = 1.;
    }
    delete[] small_base;
    delete[] large_base;
    return[alias_vec = std::move(alias_vec), max = double(n)]
    {
        auto dist = std::uniform_real_distribution<>(0.0, max);
        double rand = dist(global_random_engine);
        double index = std::floor(rand);
        const auto& a = alias_vec[size_t(index)];
        return (rand - index <= a.prob) ? size_t(index) : a.index;
    };
}
template<typename X>
auto random_choice(const X& x)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    return _random_choice_single_impl(
        _random_choice_prepare_uniform(x.dims()[0]), x);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename... Dims>
auto random_choice(const X& x, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    return _random_choice_batch_impl(
        _random_choice_prepare_uniform(x.dims()[0]),
        x, utils::get_dims_array(dims...));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename W, typename X>
auto random_choice(const W& w, const X& x, varg_tag)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    return _random_choice_single_impl(
        _random_choice_prepare_binary(w, x.dims()[0]), x);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename W, typename X, typename... Dims>
auto random_choice(const W& w, const X& x, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto x_length = x.dims()[0];
    const auto outer_dims = utils::get_dims_array(dims...);
    const auto outer_size = utils::size_of_dims(outer_dims);
    // automatically select between binary and walker74
    if ((outer_size >= 50u) && (outer_size * 5u >= x_length))
        return _random_choice_batch_impl(
            _random_choice_prepare_walker74(w, x_length), x, outer_dims);
    else
        return _random_choice_batch_impl(
            _random_choice_prepare_binary(w, x_length), x, outer_dims);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
inline auto _random_sample_prepare_uniform(const size_t x_length)
{
    if (!(x_length >= 1u))
        throw std::logic_error(WL_ERROR_RANDOM_ELEM_LENGTH);
    ndarray<size_t, 1u> idx_vec(std::array<size_t, 1u>{x_length});
    auto* const idx = idx_vec.data();
    for (size_t i = 0; i < x_length; ++i)
        idx[i] = i;
    return [idx_vec = std::move(idx_vec), remain = x_length]() mutable
    {
        if (remain == 0u)
            throw std::logic_error(WL_ERROR_RANDOM_SAMPLE_NO_ELEM);
        else if (remain == 1u)
            return idx_vec.data()[0];
        auto* const idx = idx_vec.data();
        const auto this_idx = std::uniform_int_distribution<size_t>(
            0u, remain - 1u)(global_random_engine);
        const auto picked_idx = idx[this_idx];
        if (this_idx + 1u < remain) // did not pick the last element
            idx[this_idx] = idx[remain - 1u];
        --remain;
        return picked_idx;
    };
}
inline auto _random_sample_prepare_short_uniform(const size_t x_length)
{
    if (!(x_length >= 1u))
        throw std::logic_error(WL_ERROR_RANDOM_ELEM_LENGTH);
    return [idx_vec = ndarray<size_t, 1u>{}, x_length]() mutable
    {
        const auto n_taken = idx_vec.size();
        auto* const idx_begin = idx_vec.data();
        auto* const idx_end = idx_begin + n_taken;
        if (x_length == n_taken)
            throw std::logic_error(WL_ERROR_RANDOM_SAMPLE_NO_ELEM);
        if (n_taken >= 2u)
        { // move the last element to its place
            auto* ins = std::lower_bound(
                idx_begin, idx_end - 1, idx_end[-1]);
            std::rotate(ins, idx_end - 1, idx_end);
        }
        auto this_idx = std::uniform_int_distribution<size_t>(
            0u, x_length - n_taken - 1u)(global_random_engine);
        idx_vec.for_each([&](const auto& taken)
            {
                if (this_idx >= taken)
                    ++this_idx;
            });
        idx_vec.append(size_t(this_idx));
        return this_idx;
    };
}
template<typename W>
auto _random_sample_prepare_binary(const W& w, const size_t x_length)
{
    static_assert(array_rank_v<W> == 1u && is_real_v<value_type_t<W>>,
        WL_ERROR_RANDOM_WEIGHTS_TYPE);
    if (!(x_length == w.dims()[0] && x_length >= 1u))
        throw std::logic_error(WL_ERROR_RANDOM_WEIGHTS_LENGTH);
    const size_t n = x_length;
    if (n <= 3u)
        throw std::logic_error(WL_ERROR_INTERNAL);
    ndarray<double, 1u> probs_vec(std::array<size_t, 1>{n});
    ndarray<uint64_t, 1u> uint_probs_vec(std::array<size_t, 1>{n});
    auto* const probs = probs_vec.data();
    auto* const uint_probs = uint_probs_vec.data();
    w.copy_to(probs);
    double sum_prob = 0.0;
    for (const auto& prob : probs_vec)
    {
        if (prob < 0.)
            throw std::logic_error(WL_ERROR_NEGATIVE_WEIGHT);
        sum_prob += prob;
    }
    constexpr double target_sum_prob = 1.0e+19; // ~2^63
    const double factor = target_sum_prob / sum_prob;
    WL_IGNORE_DEPENDENCIES
    for (size_t i = 0; i < n; ++i)
    {
        const auto prob = uint64_t(std::floor(probs[i] * factor + 0.5));
        // each element should have a probability of at least ~2^-63
        uint_probs[i] = (prob > 0u) ? prob : uint64_t(1);
    }
    const auto lzcnt = utils::lzcnt_u64(uint64_t(n - 1u));
    const auto max_jump = size_t(1) << (63u - lzcnt);
    // fold the ragged part
    for (size_t i = max_jump; i < n; ++i)
        uint_probs[i - max_jump] += uint_probs[i];
    // fold the regular parts
    for (auto jump = max_jump >> 1; jump > 0u; jump >>= 1)
    {
        for (size_t i = 0; i < jump; ++i)
            uint_probs[i] += uint_probs[jump + i];
    }
    
    return [uint_probs_vec = std::move(uint_probs_vec), n, max_jump]() mutable
    {
        auto* uint_probs = uint_probs_vec.data();
        if (uint_probs[0] == 0u)
            throw std::logic_error(WL_ERROR_RANDOM_SAMPLE_NO_ELEM);
        auto rand = std::uniform_int_distribution<uint64_t>(
            0u, uint_probs[0] - 1u)(global_random_engine);
        // pick the index
        auto index = uint64_t(0);
        auto weight = uint_probs[0]; // to be removed from uint_probs
        for (size_t jump = 1u; jump <= max_jump; jump <<= 1)
        {
            if (index + jump >= n)
                break;
            else
            {
                const auto proposed = uint_probs[index + jump];
                if (rand >= proposed)
                {
                    rand -= proposed;
                    weight -= proposed;
                }
                else
                {
                    index += jump;
                    weight = proposed;
                }
            }
        }
        const auto ret_index = size_t(index);
        // remove weight from the uint_probs
        uint_probs[index] -= weight;
        for (size_t jump = max_jump; true; jump >>= 1)
        {
            if (jump <= index)
            {
                index -= jump;
                uint_probs[index] -= weight;
            }
            if (index == 0u)
                break;
        }
        return ret_index;
    };
}
template<typename W>
auto _random_sample_prepare_linear(const W& w, const size_t x_length)
{
    static_assert(array_rank_v<W> == 1u && is_real_v<value_type_t<W>>,
        WL_ERROR_RANDOM_WEIGHTS_TYPE);
    if (!(x_length == w.dims()[0] && x_length >= 1u))
        throw std::logic_error(WL_ERROR_RANDOM_WEIGHTS_LENGTH);
    const size_t n = x_length;
    if (n <= 1u)
        throw std::logic_error(WL_ERROR_INTERNAL);
    ndarray<double, 1u> pmf_vec(std::array<size_t, 1u>{n});
    ndarray<double, 1u> cmf_vec(std::array<size_t, 1u>{n});
    auto* const pmf = pmf_vec.data();
    auto* const cmf = cmf_vec.data();
    w.copy_to(pmf);
    if (std::any_of(pmf, pmf + n, [](auto p) { return p < 0.; }))
        throw std::logic_error(WL_ERROR_NEGATIVE_WEIGHT);
    std::partial_sum(pmf, pmf + n, cmf);
    return [cmf_vec = std::move(cmf_vec), n, last_index = n]() mutable
    {
        auto* const cmf = cmf_vec.data();
        if (last_index < n)
        { // if not the last element, update pmf and cmf
            const auto diff = last_index == 0u ? cmf[0u] :
                (cmf[last_index] - cmf[last_index - 1u]);
            for (auto i = last_index; i < n; ++i)
                cmf[i] -= diff;
        }
        if (cmf[n - 1u] <= 0.)
            throw std::logic_error(WL_ERROR_RANDOM_SAMPLE_ZERO_WEIGHTS);
        const auto rand = std::uniform_real_distribution<>(
            0., cmf[n - 1u])(global_random_engine);
        size_t index = size_t(std::lower_bound(cmf, cmf + n, rand) - cmf);
        last_index = index;
        return index;
    };
}
template<typename W, typename X, typename Size>
auto random_sample(const W& w, const X& x, varg_tag, const Size& size)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto x_length = x.dims()[0];
    const auto outer_dims = utils::get_dims_array(size);
    const auto outer_size = utils::size_of_dims(outer_dims);
    if (size > x_length)
        throw std::logic_error(WL_ERROR_RANDOM_SAMPLE_NO_ELEM);
    // automatically select between binary and linear
    if (outer_size > 5u && x_length > 35u)
        return _random_choice_batch_impl(
            _random_sample_prepare_binary(w, x_length), x, outer_dims);
    else
        return _random_choice_batch_impl(
            _random_sample_prepare_linear(w, x_length), x, outer_dims);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename W, typename X>
auto random_sample(const W& w, const X& x, varg_tag)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto x_length = x.dims()[0];
    return random_sample(w, x, x_length);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Size>
auto random_sample(const X& x, const Size& size)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto x_length = x.dims()[0];
    const auto outer_dims = utils::get_dims_array(size);
    const auto outer_size = utils::size_of_dims(outer_dims);
    if (size > x_length)
        throw std::logic_error(WL_ERROR_RANDOM_SAMPLE_NO_ELEM);
    // automatically select between two methods
    if (x_length == 1u && size == 1u)
        return val(x);
    else if (size <= 2u || 10 * size * size <= x_length)
        return _random_choice_batch_impl(
            _random_sample_prepare_short_uniform(x_length), x, outer_dims);
    else
        return _random_choice_batch_impl(
            _random_sample_prepare_uniform(x_length), x, outer_dims);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto random_sample(const X& x)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto x_length = x.dims()[0];
    return random_sample(x, x_length);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
template<typename Dst, typename Src>
auto set(Dst&& dst, Src&& src) -> decltype(auto)
{
    WL_TRY_BEGIN()
    using DstType = remove_cvref_t<Dst>;
    using SrcType = remove_cvref_t<Src>;
    constexpr auto dst_rank = array_rank_v<DstType>;
    constexpr auto src_rank = array_rank_v<SrcType>;
    using DstValue = value_type_t<DstType>;
    using SrcValue = value_type_t<SrcType>;
    static_assert(std::is_lvalue_reference_v<Dst&&> ||
        is_array_view_v<DstType>, WL_ERROR_MODIFY_TARGET);
    if constexpr (src_rank == 0u)
    {
        if constexpr (dst_rank == 0u)
        { // scalar -> scalar
            static_assert(is_convertible_v<SrcType, DstType>,
                WL_ERROR_ASSIGN_TYPE);
            dst = DstType(src);
            return std::forward<decltype(src)>(src);
        }
        else
        { // scalar -> ndarray / array_view
            static_assert(is_convertible_v<SrcType, DstValue>,
                WL_ERROR_ASSIGN_TYPE);
            dst.copy_from(make_scalar_view_iterator(DstValue(src)));
            return std::forward<decltype(src)>(src);
        }
    }
    else
    {
        static_assert(dst_rank == src_rank, WL_ERROR_ASSIGN_RANK);
        static_assert(is_convertible_v<SrcValue, DstValue>,
            WL_ERROR_ASSIGN_TYPE);
        if constexpr (is_array_v<DstType>)
        {
            if constexpr (std::is_same_v<SrcValue, DstValue>)
                dst = std::forward<decltype(src)>(src).to_array();
            else
            {
                dst.uninitialized_resize(src.dims(), src.size());
                src.copy_to(dst.data());
            }
            return dst; // returns an l-value reference
        }
        else // dst is an array view
        {
            if (!utils::check_dims(src.dims(), dst.dims()))
                throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
            if (!has_aliasing(src, dst))
            {
                if constexpr (SrcType::category != view_category::General)
                    dst.copy_from(src.begin());
                else if constexpr (DstType::category != view_category::General)
                    src.copy_to(dst.begin());
                else // general_view -> general_view
                    indirect_view_copy(dst, src);
                return std::forward<decltype(src)>(src);
            }
            else // has aliasing
            {
                indirect_view_copy(dst, src);
                return std::forward<decltype(src)>(src);
            }
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Iter, size_t R>
void _copy_list_array_elements(Iter&, const std::array<size_t, R>&)
{
}
template<typename Iter, size_t R, typename First, typename... Rest>
void _copy_list_array_elements(Iter& ret_iter,
    const std::array<size_t, R>& dims, First&& first, Rest&&... rest)
{
    using FirstType = remove_cvref_t<First>;
    using T = value_type_t<remove_cvref_t<decltype(*ret_iter)>>;
    if constexpr (is_argument_pack_v<FirstType>)
    {
        using ItemType = value_type_t<FirstType>;
        static_assert(array_rank_v<ItemType> == R, WL_ERROR_LIST_ELEM_RANK);
        using ValueType = value_type_t<ItemType>;
        static_assert(is_convertible_v<ValueType, T>, WL_ERROR_LIST_ELEM_TYPE);
        const auto size = first.size();
        for (size_t i = 0u; i < size; ++i, ++ret_iter)
        {
            const auto& item = first.get(i);
            if (!utils::check_dims(item.dims(), dims))
                throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
            item.copy_to(ret_iter.begin());
        }
    }
    else
    {
        static_assert(array_rank_v<FirstType> == R, WL_ERROR_LIST_ELEM_RANK);
        using ValueType = value_type_t<FirstType>;
        static_assert(is_convertible_v<ValueType, T>, WL_ERROR_LIST_ELEM_TYPE);
        if (!utils::check_dims(first.dims(), dims))
            throw std::logic_error(WL_ERROR_LIST_ELEM_DIMS);
        first.copy_to(ret_iter.begin());
        ++ret_iter;
    }
    _copy_list_array_elements(ret_iter, dims,
        std::forward<decltype(rest)>(rest)...);
}
template<typename T>
void _copy_list_scalar_elements(T*&)
{
}
template<typename T, typename First, typename... Rest>
void _copy_list_scalar_elements(T*& ret_iter, First&& first, Rest&&... rest)
{
    using FirstType = remove_cvref_t<First>;
    if constexpr (is_argument_pack_v<FirstType>)
    {
        using ItemType = value_type_t<FirstType>;
        static_assert(is_convertible_v<ItemType, T>, WL_ERROR_LIST_ELEM_TYPE);
        WL_CHECK_ABORT_LOOP_BEGIN(first.size())
            for (auto i = _loop_begin; i < _loop_end; ++i, ++ret_iter)
                *ret_iter = cast<T>(first.get(i, dim_checked{}));
        WL_CHECK_ABORT_LOOP_END()
    }
    else
    {
        static_assert(is_convertible_v<FirstType, T>, WL_ERROR_LIST_ELEM_TYPE);
        *ret_iter = cast<T>(std::forward<decltype(first)>(first));
        ++ret_iter;
    }
    _copy_list_scalar_elements(ret_iter,
        std::forward<decltype(rest)>(rest)...);
}
template<typename Any>
auto _list_length_by_args_impl(const Any& any)
{
    return size_t(1);
}
template<typename Iter, bool HasStride>
auto _list_length_by_args_impl(const argument_pack<Iter, HasStride>& args)
{
    return args.size();
}
template<typename... Elems>
auto _list_length_by_args(const Elems&... elems)
{
    return (_list_length_by_args_impl(elems) + ...);
};
template<typename First, typename... Rest>
auto list(First&& first, Rest&&... rest)
{
    WL_TRY_BEGIN()
    using FirstType = remove_cvref_t<First>;
    if constexpr (is_argument_pack_v<FirstType>)
    {
        if (first.size() == 0u)
        {
            if constexpr (sizeof...(rest) > 0u)
                return list(std::forward<decltype(rest)>(rest)...);
            else
            {
                using ItemType = value_type_t<FirstType>;
                constexpr auto rank = array_rank_v<ItemType> +1u;
                using ValueType = std::conditional_t<
                    rank == 0u, ItemType, value_type_t<ItemType>>;
                return ndarray<value_type_t<ItemType>, rank>{};
            }
        }
        else
            return list(first.get(0), first.get_pack(1),
                std::forward<decltype(rest)>(rest)...);
    }
    else
    {
        constexpr auto first_rank = array_rank_v<FirstType>;
        const auto dim0 = _list_length_by_args(first, rest...);
        if constexpr (first_rank == 0)
        {
            ndarray<FirstType, 1u> ret(std::array<size_t, 1u>{dim0});
            auto ret_iter = ret.data();
            _copy_list_scalar_elements(ret_iter,
                std::forward<decltype(first)>(first),
                std::forward<decltype(rest)>(rest)...);
            return ret;
        }
        else
        {
            constexpr auto rank = first_rank + 1u;
            const auto dims = utils::dims_join(
                std::array<size_t, 1u>{dim0}, first.dims());
            using FirstValueType = value_type_t<FirstType>;
            ndarray<FirstValueType, rank> ret(dims);
            auto ret_iter = ret.template view_begin<1u>();
            _copy_list_array_elements(ret_iter, first.dims(),
                std::forward<decltype(first)>(first),
                std::forward<decltype(rest)>(rest)...);
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename T, typename... Dims>
auto constant_array(const T& val, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    constexpr auto val_rank = array_rank_v<T>;
    constexpr auto rep_rank = sizeof...(dims);
    constexpr auto all_rank = val_rank + rep_rank;
    if constexpr (val_rank > 0)
    {
        using ValueType = value_type_t<T>;
        const auto ret_dims = utils::dims_join(
            utils::get_dims_array(dims...), val.dims());
        ndarray<ValueType, all_rank> ret(ret_dims);
        const auto& valx = allows<view_category::Simple>(val);
        const size_t valx_size = valx.size();
        const auto* valx_iter = valx.data();
        auto* ret_iter = ret.data();
        auto* ret_end = ret_iter + ret.size();
        for (; ret_iter != ret_end; ret_iter += valx_size)
            valx.copy_to(ret_iter);
        return ret;
    }
    else
    {
        ndarray<T, all_rank> ret(
            std::array<int64_t, all_rank>{int64_t(dims)...}, val);
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<size_t>
using make_all_type = all_type;
template<typename Array, typename... Indexers>
auto _part_impl3(Array&& a, Indexers&&... indexers) -> decltype(auto)
{
    using ArrayType = remove_cvref_t<Array>;
    using ValueType = typename ArrayType::value_type;
    constexpr auto is_const = array_is_const_v<Array&&>;
    static_assert(sizeof...(Indexers) <= array_rank_v<ArrayType>,
        WL_ERROR_INTERNAL);
    using return_type = typename view_detail::view_type<Indexers...>::
        template return_type<ValueType, is_const, Indexers...>;
    if constexpr (is_array_view_v<return_type>)
    {
        auto view = return_type(a.identifier(), a.data(), a.dims(),
            std::forward<decltype(indexers)>(indexers)...);
        if constexpr (is_movable_v<Array&&>)
            return std::move(view).to_array();
        else
            return view;
    }
    else
    {
        auto& data_ref = a.data()[
            utils::linear_position(a.dims(), indexers.offset()...)];
        if constexpr (is_movable_v<Array&&>)
            return static_cast<remove_cvref_t<decltype(data_ref)>>(data_ref);
        else
            return data_ref;
    }
}
template<typename Array, size_t... Is, typename... Specs>
auto _part_impl2(Array&& a, std::index_sequence<Is...>,
    Specs&&... specs) -> decltype(auto)
{
    return _part_impl3(std::forward<decltype(a)>(a),
        make_indexer(std::forward<decltype(specs)>(specs), a.dims_[Is])...);
}
template<size_t R, typename Array, size_t... Is, typename... Specs>
auto _part_impl1(Array&& a, std::index_sequence<Is...>,
    Specs&&... specs) -> decltype(auto)
{
    return _part_impl2(std::forward<decltype(a)>(a),
        std::make_index_sequence<R>{},
        std::forward<decltype(specs)>(specs)...,
        make_all_type<Is>{}...);
}
template<typename Array, typename... Specs>
auto part(Array&& a, Specs&&... specs) -> decltype(auto)
{
    WL_TRY_BEGIN()
    using ArrayType = remove_cvref_t<Array>;
    constexpr auto R = array_rank_v<ArrayType>;
    static_assert(sizeof...(Specs) <= R, WL_ERROR_PART_DEPTH);
    if constexpr (R == 0u)
        return std::forward<decltype(a)>(a);
    else if constexpr (
        ArrayType::category == view_category::Array ||
        ArrayType::category == view_category::Simple)
    {
        return _part_impl1<R>(std::forward<decltype(a)>(a),
            std::make_index_sequence<R - sizeof...(Specs)>{},
            std::forward<decltype(specs)>(specs)...);
    }
    else
        return part(a.to_array(), std::forward<decltype(specs)>(specs)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Array>
auto first(Array&& a)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<remove_cvref_t<Array>> >= 1u,
        WL_ERROR_REQUIRE_ARRAY);
    return part(a, cidx(0));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Array>
auto last(Array&& a)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<remove_cvref_t<Array>> >= 1u,
        WL_ERROR_REQUIRE_ARRAY);
    return part(a, int64_t(-1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto most(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<XT>;
    const auto length = x.dims()[0];
    if (length == 0u)
        throw std::logic_error(WL_ERROR_REQUIRE_NON_EMPTY);
    else if (length == 1u)
        return ndarray<XV, XR>{};
    else
        return val(part(x, make_span(const_all, int64_t(-2))));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto rest(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<XT>;
    const auto length = x.dims()[0];
    if (length == 0u)
        throw std::logic_error(WL_ERROR_REQUIRE_NON_EMPTY);
    else if (length == 1u)
        return ndarray<XV, XR>{};
    else
        return val(part(x, make_span(int64_t(2), const_all)));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Begin, typename End, typename Step>
auto range(Begin begin, End end, Step step)
{
    WL_TRY_BEGIN()
    static_assert(is_real_v<Begin> && is_real_v<End> && is_real_v<Step>,
        WL_ERROR_ITERATOR_TYPE);
    using T = common_type_t<Begin, Step>;
    if constexpr (is_integral_v<T>)
    {
        if (step != Step(0))
        {
            auto diff = ptrdiff_t(wl::integer_part(end - begin));
            if ((step > Step(0) && diff < 0) || (step < Step(0) && diff > 0))
                return ndarray<T, 1u>(std::array<size_t, 1>{0u});
            else
            {
                size_t length = size_t(diff / ptrdiff_t(step)) + 1u;
                ndarray<T, 1u> ret(std::array<size_t, 1>{length});
                auto* ret_iter = ret.data();
                WL_CHECK_ABORT_LOOP_BEGIN(length)
                    for (auto i = _loop_zero; i < _loop_size;
                        ++i, begin += step, ++ret_iter)
                    {
                        *ret_iter = begin;
                    }
                WL_CHECK_ABORT_LOOP_END()
                return ret;
            }
        }
        else // step = 0
            throw std::logic_error(WL_ERROR_ITERATOR_ZERO_STEP);
    }
    else
    {
        if (step != Step(0))
        {
            auto diff = T(end - begin);
            if ((step > Step(0) && diff < 0) || (step < Step(0) && diff > 0))
                return ndarray<T, 1u>(std::array<size_t, 1>{0u});
            else
            {
                size_t length = wl::integer_part(diff / step) + 1u;
                auto remain = T(begin + (length - 1u) * step) - T(end);
                if (step * remain > T(0))
                    --length;
                ndarray<T, 1u> ret(std::array<size_t, 1>{length});
                auto* ret_iter = ret.data();
                WL_CHECK_ABORT_LOOP_BEGIN(length)
                    for (auto i = _loop_begin; i < _loop_end; ++i, ++ret_iter)
                        *ret_iter = T(begin + i * step);
                WL_CHECK_ABORT_LOOP_END()
                return ret;
            }
        }
        else // step = 0
            throw std::logic_error(WL_ERROR_ITERATOR_ZERO_STEP);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Begin, typename End>
auto range(Begin begin, End end)
{
    WL_TRY_BEGIN()
    static_assert(is_real_v<Begin> && is_real_v<End>, WL_ERROR_ITERATOR_TYPE);
    return range(begin, end, int8_t(1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename End>
auto range(End end)
{
    WL_TRY_BEGIN()
    static_assert(is_real_v<End>, WL_ERROR_ITERATOR_TYPE);
    return range(End(1), end, int8_t(1));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Array, int64_t I1, int64_t I2>
auto total(const Array& a, const_int<I1>, const_int<I2>)
{
    WL_TRY_BEGIN()
    constexpr auto rank = array_rank_v<Array>;
    static_assert(rank >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<Array>;
    constexpr int64_t L1 = I1 >= 0 ? I1 : I1 + int64_t(rank) + 1;
    constexpr int64_t L2 = I2 >= 0 ? I2 : I2 + int64_t(rank) + 1;
    static_assert(1 <= L1 && L1 <= L2 && L2 <= int64_t(rank),
        WL_ERROR_BAD_LEVEL);
    if constexpr (Array::category == view_category::General)
        return total(a.to_array(), const_int<I1>{}, const_int<I2>{});
    else
    {
        WL_THROW_IF_ABORT()
        if constexpr (L1 == 1)
        {
            if constexpr (L2 == rank)
            {
                const auto inter_size = a.size();
                auto a_iter = a.begin();
                auto ret = XV{};
                for (size_t j = 0; j < inter_size; ++j, ++a_iter)
                    ret += *a_iter;
                return ret;
            }
            else
            {
                auto ret_dims = utils::dims_take<L2 + 1, rank>(a.dims());
                ndarray<XV, rank - L2> ret(ret_dims, XV{});
                const auto inter_size = utils::size_of_dims(
                    utils::dims_take<L1, L2>(a.dims()));
                const auto inner_size = ret.size();
                auto a_iter = a.begin();
                auto ret_iter = ret.begin();
                for (size_t j = 0; j < inter_size; ++j)
                    for (size_t k = 0; k < inner_size; ++k, ++a_iter)
                        ret_iter[k] += *a_iter;
                return ret;
            }
        }
        else // L1 > 1
        {
            if constexpr (L2 == rank)
            {
                auto ret_dims = utils::dims_take<1, L1 - 1>(a.dims());
                ndarray<XV, L1 - 1> ret(ret_dims);
                const auto outer_size = ret.size();
                const auto inter_size = utils::size_of_dims(
                    utils::dims_take<L1, L2>(a.dims()));
                auto a_iter = a.begin();
                auto ret_iter = ret.begin();
                for (size_t i = 0; i < outer_size; ++i, ++ret_iter)
                {
                    auto sum = XV{};
                    for (size_t j = 0; j < inter_size; ++j, ++a_iter)
                        sum += *a_iter;
                    *ret_iter = sum;
                }
                return ret;
            }
            else
            {
                auto outer_dims = utils::dims_take<1, L1 - 1>(a.dims());
                auto inter_dims = utils::dims_take<L1, L2>(a.dims());
                auto inner_dims = utils::dims_take<L2 + 1, rank>(a.dims());
                auto ret_dims = utils::dims_join(outer_dims, inner_dims);
                ndarray<XV, rank - (L2 - L1 + 1)> ret(ret_dims, XV{});
                auto a_iter = a.begin();
                auto ret_iter = ret.begin();
                const auto outer_size = utils::size_of_dims(outer_dims);
                const auto inter_size = utils::size_of_dims(inter_dims);
                const auto inner_size = utils::size_of_dims(inner_dims);
                for (size_t i = 0; i < outer_size; ++i, ret_iter += inner_size)
                    for (size_t j = 0; j < inter_size; ++j)
                        for (size_t k = 0; k < inner_size; ++k, ++a_iter)
                            ret_iter[k] += *a_iter;
                return ret;
            }
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Array, int64_t I>
auto total(const Array& a, const_int<I>)
{
    WL_TRY_BEGIN()
    return total(a, const_int<1>{}, const_int<I>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Array>
auto total(const Array& a)
{
    WL_TRY_BEGIN()
    if constexpr (array_rank_v<Array> == 0u)
        return a;
    else
    return total(a, const_int<1>{}, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Array>
auto mean(const Array& a)
{
    WL_TRY_BEGIN()
    return divide(total(a), a.template dimension<1>());
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename Array>
auto dimensions(const Array& a)
{
    WL_TRY_BEGIN()
    static_assert(is_integral_v<Ret>, WL_ERROR_BAD_RETURN);
    constexpr auto rank = array_rank_v<Array>;
    if constexpr (rank == 0u)
        return ndarray<Ret, 1u>{};
    else
        return ndarray<Ret, 1u>(std::array<size_t, 1u>{rank},
            a.dims_ptr(), a.dims_ptr() + rank);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Array>
auto length(const Array& a)
{
    constexpr auto rank = array_rank_v<Array>;
    if constexpr (rank == 0u)
        return int64_t(0);
    else
        return int64_t(a.dims()[0]);
}
template<typename Any>
auto array_depth(const Any& any)
{
    return int64_t(array_rank_v<Any>);
}
template<typename T, size_t R>
void _reverse_inplace(ndarray<T, R>& a,
    size_t outer_size, size_t inter_size, size_t inner_size)
{
    WL_THROW_IF_ABORT()
    if (inner_size == 1u)
    {
        auto base = a.data();
        for (size_t i = 0u; i < outer_size; ++i, base += inter_size)
        {
            auto forward = base;
            auto reverse = base + inter_size;
            for (; forward != reverse && forward != --reverse; ++forward)
                std::iter_swap(forward, reverse);
        }
    }
    else
    {
        auto base = a.data();
        auto outer_step = inter_size * inner_size;
        for (size_t i = 0u; i < outer_size; ++i, base += outer_step)
        {
            size_t forward = 0u;
            size_t reverse = inter_size;
            for (; forward != reverse && forward != --reverse; ++forward)
                std::swap_ranges(
                    base + forward * inner_size,
                    base + forward * inner_size + inner_size,
                    base + reverse * inner_size);
        }
    }
}
template<typename X, int64_t I>
auto reverse(X&& x, const_int<I>)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto rank = array_rank_v<XT>;
    static_assert(rank >= 1, WL_ERROR_REQUIRE_ARRAY);
    constexpr int64_t Level = I >= 0 ? I : I + int64_t(rank) + 1;
    static_assert(1 <= Level && Level <= int64_t(rank), WL_ERROR_BAD_LEVEL);
    size_t outer_size = utils::size_of_dims(
        utils::dims_take<1u, Level - 1u>(x.dims()));
    size_t inter_size = utils::size_of_dims(
        utils::dims_take<Level, Level>(x.dims()));
    size_t inner_size = utils::size_of_dims(
        utils::dims_take<Level + 1u, rank>(x.dims()));
    if constexpr (is_movable_v<X&&>)
    {
        _reverse_inplace(x, outer_size, inter_size, inner_size);
        return x;
    }
    else
    {
        auto x2 = x.to_array();
        _reverse_inplace(x2, outer_size, inter_size, inner_size);
        return x2;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto reverse(X&& x)
{
    WL_TRY_BEGIN()
    return reverse(std::forward<decltype(x)>(x), const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Pad, typename... Dims>
auto array_reshape(X&& x, const Pad& padding, varg_tag, const Dims&... dims)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    static_assert(array_rank_v<XT> >= 1, WL_ERROR_REQUIRE_ARRAY);
    constexpr auto rank = sizeof...(dims);
    ndarray<XV, rank> ret(utils::get_dims_array(dims...));
    WL_THROW_IF_ABORT()
    const size_t x_size = x.size();
    const size_t ret_size = ret.size();
    if (x_size <= ret_size)
    {
        x.copy_to(ret.begin());
        if constexpr (!std::is_same_v<Pad, void_type>)
        {
            static_assert(is_convertible_v<Pad, XV>,
                WL_ERROR_ARRAY_RESHAPE_PAD_TYPE);
            std::fill(ret.begin() + x_size, ret.end(), cast<XV>(padding));
        }
        else if (ret.is_static()) // only std::array needs initialization
            std::fill(ret.begin() + x_size, ret.end(), XV{});
    }
    else
    {
        auto ret_iter = ret.begin();
        auto ret_end = ret.end();
        x.for_each([&](const auto& src)
            { *ret_iter++ = src; return (ret_iter == ret_end); });
    }
    return ret;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename... Dims>
auto array_reshape(X&& x, varg_tag, const Dims&... dims)
{
    static_assert(array_rank_v<remove_cvref_t<X>> >= 1,
        WL_ERROR_REQUIRE_ARRAY);
    return array_reshape(std::forward<decltype(x)>(x),
        void_type{}, varg_tag{}, dims...);
}
template<size_t R, size_t... Is>
struct _is_valid_transpose
{
    static constexpr auto between = ((1u <= Is && Is <= R) && ...);
    static constexpr auto mask = ((uint64_t(1) << (Is - 1u)) | ...);
    static constexpr auto value = between && ((mask & (mask + 1u)) == 0);
};
template<size_t... Is>
struct _transpose_max_level;
template<size_t I1, size_t I2, size_t... Is>
struct _transpose_max_level<I1, I2, Is...> :
    _transpose_max_level<(I1 > I2 ? I1 : I2), Is...> {};
template<size_t I>
struct _transpose_max_level<I> : std::integral_constant<size_t, I> {};
template<typename T, size_t... Is>
struct _padded_transpose_levels_impl;
template<size_t... Is, size_t... Pads>
struct _padded_transpose_levels_impl<std::index_sequence<Pads...>, Is...>
{
    static constexpr auto max_level = _transpose_max_level<Is...>::value;
    using type = std::index_sequence<Is..., (Pads + max_level + 1u)...>;
};
template<size_t R, size_t... Is>
struct _padded_transpose_levels :
    _padded_transpose_levels_impl<
    std::make_index_sequence<R - sizeof...(Is)>, Is...> {};
template<size_t L, typename T>
void _transpose_fill(const T* src, T*& dst,
    const size_t* dims, const size_t* strides)
{
    const size_t dim = *dims;
    const size_t stride = *strides;
    if constexpr (L > 1u)
    {
        WL_IGNORE_DEPENDENCIES
        for (size_t i = 0u; i < dim; ++i, src += stride)
            _transpose_fill<L - 1u>(src, dst, dims + 1, strides + 1);
    }
    else if (stride == 1u)
    {
        WL_IGNORE_DEPENDENCIES
        for (size_t i = 0u; i < dim; ++i, ++src, ++dst)
            *dst = *src;
    }
    else
    {
        WL_IGNORE_DEPENDENCIES
        for (size_t i = 0u; i < dim; ++i, src += stride, ++dst)
            *dst = *src;
    }
}
template<typename T, size_t R, typename Output, size_t... Is, size_t... Cs>
auto _transpose_impl(const ndarray<T, R>& a, Output ptr,
    std::index_sequence<Is...>, std::index_sequence<Cs...>)
{
    constexpr auto RetRank = _transpose_max_level<size_t(Is)...>::value;
    auto a_dims = a.dims().data();
    std::array<size_t, R> strides;
    std::array<size_t, RetRank> ret_dims{};
    std::array<size_t, RetRank> ret_strides{};
    strides[R - 1u] = 1u;
    [[maybe_unused]] auto _1 = ((Cs > 0 ? (strides[R - Cs - 1u] =
        strides[R - Cs] * a_dims[R - Cs]) : size_t()), ...);
    [[maybe_unused]] auto _2 = ((ret_dims[Is - 1] == 0u ?
        (ret_dims[Is - 1] = a_dims[Cs], ret_strides[Is - 1] += strides[Cs]) :
        ret_dims[Is - 1] == a_dims[Cs] ? ret_strides[Is - 1] += strides[Cs] :
        throw std::logic_error(WL_ERROR_TRANSPOSE_COLLAPSE)), ...);
    WL_THROW_IF_ABORT()
    if constexpr (std::is_pointer_v<Output>)
    {
        auto dst_ptr = ptr;
        _transpose_fill<RetRank>(a.data(), dst_ptr,
            ret_dims.data(), ret_strides.data());
    }
    else
    {
        ndarray<T, RetRank> ret(ret_dims);
        auto dst_ptr = ret.data();
        _transpose_fill<RetRank>(a.data(), dst_ptr,
            ret_dims.data(), ret_strides.data());
        return ret;
    }
}
template<typename X, int64_t... Is>
auto transpose(const X& x, const_int<Is>...)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    constexpr auto XR = array_rank_v<XT>;
    constexpr auto NL = sizeof...(Is);
    static_assert(1 <= NL && NL <= XR, WL_ERROR_BAD_LEVEL);
    static_assert(_is_valid_transpose<XR, size_t(Is)...>::value,
        WL_ERROR_BAD_LEVEL);
    return _transpose_impl(val(x), void_type{},
        typename _padded_transpose_levels<XR, Is...>::type{},
        std::make_index_sequence<XR>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto transpose(const X& x)
{
    WL_TRY_BEGIN()
    return transpose(x, const_int<2>{}, const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto conjugate_transpose(const X& x)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 2u, WL_ERROR_REQUIRE_ARRAY_RANK"two or higher.");
    using XV = value_type_t<X>;
    if constexpr (is_real_v<XV>)
        return transpose(x, const_int<2>{}, const_int<1>{});
    else
    {
        WL_THROW_IF_ABORT()
        const auto& valx = allows<view_category::Regular>(x);
        auto x_iter = valx.begin();
        if constexpr (XR == 2u)
        {
            const size_t dim0 = x.dims()[0];
            const size_t dim1 = x.dims()[1];
            ndarray<XV, 2u> ret(std::array<size_t, 2u>{dim1, dim0});
            auto ret_base = ret.data();
            for (size_t i = 0u; i < dim0; ++i, ++ret_base)
            {
                auto ret_iter = ret_base;
                WL_IGNORE_DEPENDENCIES
                for (size_t j = 0u; j < dim1; ++j, ++x_iter, ret_iter += dim0)
                    *ret_iter = std::conj(*x_iter);
            }
            return ret;
        }
        else
        {
            const size_t dim0 = x.dims()[0];
            const size_t dim1 = x.dims()[1];
            const auto dims_rest = utils::dims_take<3u, XR>(x.dims());
            const size_t chunk_size = utils::size_of_dims(dims_rest);
            ndarray<XV, XR> ret(utils::dims_join(
                std::array<size_t, 2u>{dim1, dim0}, dims_rest));
            auto ret_base = ret.data();
            for (size_t i = 0u; i < dim0; ++i, ret_base += chunk_size)
            {
                auto ret_base2 = ret_base;
                for (size_t j = 0u; j < dim1;
                    ++j, ret_base2 += dim0 * chunk_size)
                {
                    auto ret_iter = ret_base2;
                    WL_IGNORE_DEPENDENCIES
                    for (size_t k = 0u; k < chunk_size;
                        ++k, ++ret_iter, ++x_iter)
                    {
                        *ret_iter = std::conj(*x_iter);
                    }
                }
            }
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Level>
struct _flatten_max_level_impl;
template<int64_t... Is>
struct _flatten_max_level_impl<const_ints<Is...>> :
    _transpose_max_level<size_t(Is)...> {};
template<typename... Levels>
struct _flatten_max_level :
    _transpose_max_level<_flatten_max_level_impl<Levels>::value...> {};
template<>
struct _flatten_max_level<> : std::integral_constant<size_t, 0> {};
template<typename... Levels>
struct _flatten_levels_join;
template<int64_t... Is, int64_t... Js, typename... Levels>
struct _flatten_levels_join<const_ints<Is...>, const_ints<Js...>, Levels...> :
    _flatten_levels_join<const_ints<Is..., Js...>, Levels...> {};
template<int64_t... Is>
struct _flatten_levels_join<const_ints<Is...>>
{
    using type = const_ints<Is...>;
};
template<int64_t... Is, typename... Levels>
void _flatten_get_dims(const size_t* input_dims, size_t* ret_dims,
    const_ints<Is...>, Levels...)
{
    *ret_dims = (input_dims[Is - 1u] * ...);
    if constexpr (sizeof...(Levels) > 0u)
        _flatten_get_dims(input_dims, ret_dims + 1, Levels{}...);
}
template<size_t MaxLevel, typename X, size_t... Pads, typename... Levels>
auto _flatten_copy_impl(X&& x, std::index_sequence<Pads...>, Levels...)
{
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    constexpr auto RetRank = sizeof...(Pads) + sizeof...(Levels);
    std::array<size_t, RetRank> ret_dims;
    _flatten_get_dims(x.dims().data(), ret_dims.data(),
        Levels{}..., const_ints<int64_t(Pads + MaxLevel + 1u)>{}...);
    if constexpr (is_movable_v<X&&>)
        return ndarray<XV, RetRank>(ret_dims, std::move(x.data_vector()));
    else if constexpr (XT::category != view_category::General)
        return ndarray<XV, RetRank>(ret_dims, x.begin(), x.begin() + x.size());
    else
    {
        ndarray<XV, RetRank> ret(ret_dims);
        x.copy_to(ret.data());
        return ret;
    }
}
template<typename X, typename... Levels>
auto flatten_copy(X&& x, Levels...)
{
    constexpr auto XR = array_rank_v<remove_cvref_t<X>>;
    constexpr auto MaxLevel = _flatten_max_level<Levels...>::value;
    static_assert(1 <= MaxLevel && MaxLevel <= XR, WL_ERROR_BAD_LEVEL);
    return _flatten_copy_impl<MaxLevel>(std::forward<decltype(x)>(x),
        std::make_index_sequence<XR - MaxLevel>{}, Levels{}...);
}
template<typename T, int64_t... Is, size_t... Cs>
void _flatten_impl3(const size_t* dims, const T* src, T* dst,
    const_ints<Is...>, std::index_sequence<Cs...>)
{
    constexpr auto R = sizeof...(Is);
    std::array<size_t, R> strides;
    std::array<size_t, R> ret_dims;
    std::array<size_t, R> ret_strides;
    strides[R - 1u] = 1u;
    [[maybe_unused]] auto _1 = ((Cs > 0 ? (strides[R - Cs - 1u] =
        strides[R - Cs] * dims[R - Cs]) : size_t()), ...);
    [[maybe_unused]] auto _2 = ((ret_strides[Cs] = strides[Is - 1],
        ret_dims[Cs] = dims[Is - 1]), ...);
    _transpose_fill<R>(src, dst, ret_dims.data(), ret_strides.data());
}
template<typename X, size_t... Pads, typename... Levels>
auto _flatten_impl2(X&& x, Levels...)
{
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    constexpr auto XR = array_rank_v<XT>;
    constexpr auto RetRank = sizeof...(Levels);
    std::array<size_t, RetRank> ret_dims;
    _flatten_get_dims(x.dims().data(), ret_dims.data(), Levels{}...);
    ndarray<XV, RetRank> ret(ret_dims);
    const auto& valx = val(x);
    _flatten_impl3(valx.dims().data(), valx.data(), ret.data(),
        typename _flatten_levels_join<Levels...>::type{},
        std::make_index_sequence<XR>{});
    return ret;
}
template<size_t MaxLevel, typename X, size_t... Pads, typename... Levels>
auto _flatten_impl1(X&& x, std::index_sequence<Pads...>, Levels...)
{
    return _flatten_impl2(std::forward<decltype(x)>(x),
        Levels{}..., const_ints<int64_t(Pads + MaxLevel + 1u)>{}...);
}
template<typename X, typename... Levels>
auto flatten(X&& x, Levels...)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<remove_cvref_t<X>>;
    constexpr auto MaxLevel = _flatten_max_level<Levels...>::value;
    static_assert(1 <= MaxLevel && MaxLevel <= XR, WL_ERROR_BAD_LEVEL);
    return _flatten_impl1<MaxLevel>(std::forward<decltype(x)>(x),
        std::make_index_sequence<XR - MaxLevel>{}, Levels{}...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto flatten(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(1 <= XR, WL_ERROR_BAD_LEVEL);
    std::array<size_t, 1u> ret_dims{utils::size_of_dims(x.dims())};
    if constexpr (is_movable_v<X&&>)
        return ndarray<XV, 1u>(ret_dims, std::move(x.data_vector()));
    else if constexpr (XT::category != view_category::General)
        return ndarray<XV, 1u>(ret_dims, x.begin(), x.begin() + x.size());
    else
    {
        ndarray<XV, 1u> ret(ret_dims);
        x.copy_to(ret.data());
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
WL_INLINE int64_t _order_scalar(const X& x, const X& y)
{
    return x == y ? int64_t(0) : x < y ? int64_t(1) : int64_t(-1);
}
WL_INLINE int64_t _order_scalar(const boolean& x, const boolean& y)
{
    return x == y ? int64_t(0) : x ? int64_t(-1) : int64_t(1);
}
template<typename X>
WL_INLINE int64_t _order_scalar(const complex<X>& x, const complex<X>& y)
{
    const auto x_real = x.real();
    const auto y_real = y.real();
    if (x_real == y_real)
    {
        const auto x_imag = x.imag();
        const auto y_imag = y.imag();
        const auto abs_x_imag = wl::abs(x_imag);
        const auto abs_y_imag = wl::abs(y_imag);
        return abs_x_imag == abs_y_imag ? _order_scalar(x_imag, y_imag) :
            abs_x_imag < abs_y_imag ? int64_t(1) : int64_t(-1);
    }
    else
    {
        return x_real < y_real ? int64_t(1) : int64_t(-1);
    }
}
template<typename X, typename Y>
int64_t _order_array(const X& x, const Y& y, dim_checked)
{
    int64_t ret = 0;
    if constexpr (X::category != view_category::General)
    {
        y.for_each([&ret](const auto& b, const auto& a)
            {
                auto res = _order_scalar(a, b);
                if (res == 0) return false;
                ret = res;
                return true;
            }, x.begin());
    }
    else
    {
        x.for_each([&ret](const auto& a, const auto& b)
            {
                auto res = _order_scalar(a, b);
                if (res == 0) return false;
                ret = res;
                return true;
            }, y.begin());
    }
    return ret;
}
template<typename X, typename Y>
int64_t _order_array(const X& x, const Y& y)
{
    if (utils::check_dims(x.dims(), y.dims()))
        return _order_array(x, y, dim_checked{});
    else
        return std::lexicographical_compare(x.dims().begin(), x.dims().end(),
            y.dims().begin(), x.dims().end()) ? int64_t(1) : int64_t(-1);
}
template<typename Ret = int64_t, typename X, typename Y>
int64_t order(const X& x, const Y& y)
{
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<X>;
    static_assert(XR == YR, WL_ERROR_OPERAND_RANK);
    static_assert(is_integral_v<Ret>, WL_ERROR_BAD_RETURN);
    if constexpr (XR == 0)
    {
        static_assert(std::is_same_v<X, Y>, WL_ERROR_OPERAND_TYPE);
        return Ret(_order_scalar(x, y));
    }
    else
    {
        static_assert(std::is_same_v<value_type_t<X>, value_type_t<Y>>,
            WL_ERROR_OPERAND_TYPE);
        return Ret(_order_array(x, y));
    }
}
template<typename Ret = int64_t, typename X, typename Pred>
auto ordering(const X& x, const int64_t n, Pred pred)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    static_assert(is_integral_v<Ret>, WL_ERROR_BAD_RETURN);
    if (n == 0)
        return ndarray<Ret, 1u>{};
    const std::array<size_t, 1u> ret_dims{size_t(n > 0 ? n : -n)};
    const auto& valx = val(std::forward<decltype(x)>(x));
    const auto x_size = valx.dims()[0];
    const auto x_base = valx.template view_begin<1u>() - 1;
    std::vector<Ret> indices(x_size);
    for (size_t i = 0u; i < x_size; ++i)
        indices[i] = Ret(i + 1);
    if (n > 0)
    {
        auto order = [=](size_t a, size_t b)
        {
            WL_THROW_IF_ABORT()
            auto res = pred(*(x_base + a), *(x_base + b));
            using OrderType = decltype(res);
            if constexpr (std::is_same_v<OrderType, bool> ||
                is_boolean_v<OrderType>)
                return bool(res);
            else
            {
                static_assert(std::is_signed_v<OrderType>,
                    WL_ERROR_ORDER_PRED_TYPE);
                return res > OrderType(0);
            }
        };
        if (size_t(n) > x_size)
            throw std::logic_error(WL_ERROR_ORDERING_OUT_OF_RANGE);
        else if (size_t(n) == x_size)
            std::sort(indices.begin(), indices.end(), order);
        else
        {
            std::partial_sort(indices.begin(), indices.begin() + n,
                indices.end(), order);
            indices.resize(size_t(n));
        }
    }
    else
    {
        auto order = [=](size_t a, size_t b)
        {
            WL_THROW_IF_ABORT()
            auto res = pred(*(x_base + a), *(x_base + b));
            using OrderType = decltype(res);
            if constexpr (std::is_same_v<OrderType, bool> ||
                is_boolean_v<OrderType>)
                return !bool(res);
            else
            {
                static_assert(std::is_signed_v<OrderType>,
                    WL_ERROR_ORDER_PRED_TYPE);
                return res < OrderType(0);
            }
        };
        if (size_t(-n) > x_size)
            throw std::logic_error(WL_ERROR_ORDERING_OUT_OF_RANGE);
        else if (size_t(-n) == x_size)
            std::sort(indices.rbegin(), indices.rend(), order);
        else
        {
            std::partial_sort(indices.rbegin(), indices.rbegin() + (-n),
                indices.rend(), order);
            indices.erase(indices.begin(), indices.end() - (-n));
        }
    }
    return ndarray<Ret, 1u>(ret_dims, std::move(indices));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto ordering(const X& x, const int64_t n)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    if constexpr (XR == 1u)
    {
        using XV = value_type_t<X>;
        if constexpr (is_complex_v<XV> || is_boolean_v<XV>)
        {
            return ordering<Ret>(x, n, [](const auto& a, const auto& b)
                { return _order_scalar(a, b) > 0; });
        }
        else
        {
            static_assert(is_real_v<XV>, WL_ERROR_BAD_COMPARE);
            return ordering<Ret>(x, n, std::less<>{});
        }
    }
    else
    {
        return ordering<Ret>(x, n,
            [](const auto& a, const auto& b)
            { return _order_array(a, b, dim_checked{}) > 0; });
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X, typename Pred>
auto ordering(const X& x, all_type, Pred pred)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    return ordering<Ret>(x, x.dims()[0], pred);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto ordering(const X& x)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    return ordering<Ret>(x, x.dims()[0]);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X>
auto ordering(const X& x, all_type)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    return ordering<Ret>(x, x.dims()[0]);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename T, typename Pred>
auto _sort_simple(ndarray<T, 1u>&& a, Pred pred)
{
    WL_THROW_IF_ABORT()
    std::sort(a.begin(), a.end(), pred);
    return std::move(a);
}
template<typename T, typename Pred>
auto _sort_simple(const ndarray<T, 1u>& a, Pred pred)
{
    auto copy = a;
    WL_THROW_IF_ABORT()
    std::sort(copy.begin(), copy.end(), pred);
    return copy;
}
template<typename X, typename Pred>
auto sort(X&& x, Pred pred)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    if constexpr (XR == 1u)
    {
        auto&& valx = val(std::forward<decltype(x)>(x));
        using OrderType = remove_cvref_t<
            decltype(pred(*valx.begin(), *valx.begin()))>;
        if constexpr (std::is_same_v<OrderType, bool> ||
            is_boolean_v<OrderType>)
            return _sort_simple(valx, pred);
        else
        {
            static_assert(std::is_signed_v<OrderType>,
                WL_ERROR_ORDER_PRED_TYPE);
            return _sort_simple(valx, [=](const auto& a, const auto& b)
                { return pred(a, b) > OrderType(0); });
        }
    }
    else
    {
        const auto& valx = val(std::forward<decltype(x)>(x));
        const auto x_size = valx.dims()[0];
        const auto order_indices = ordering(valx, x_size, pred);
        const auto order_data = order_indices.data();
        const auto x_base = valx.template view_begin<1u>() - 1;
        ndarray<value_type_t<XT>, XR> ret(valx.dims());
        auto ret_iter = ret.template view_begin<1u>();
        for (size_t i = 0u; i < x_size; ++i, ++ret_iter)
            (*(x_base + order_data[i])).copy_to(ret_iter.begin());
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto sort(X&& x)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    constexpr auto XR = array_rank_v<XT>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    if constexpr (XR == 1u)
    {
        using XV = value_type_t<XT>;
        if constexpr (is_complex_v<XV> || is_boolean_v<XV>)
        {
            return sort(std::forward<decltype(x)>(x),
                [](const auto& a, const auto& b)
                { return _order_scalar(a, b) > 0; });
        }
        else
        {
            static_assert(is_real_v<XV>, WL_ERROR_BAD_COMPARE);
            return sort(std::forward<decltype(x)>(x), std::less<>{});
        }
    }
    else
    {
        return sort(std::forward<decltype(x)>(x),
            [](const auto& a, const auto& b)
            { return _order_array(a, b, dim_checked{}) > 0; });
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Pred>
auto ordered_q(const X& x, Pred pred)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto& copy = allows<view_category::Array>(x);
    const auto copy_length = copy.dims()[0];
    auto in_order = [=](const auto& a, const auto& b)
    {
        WL_THROW_IF_ABORT()
        using OrderType = remove_cvref_t<decltype(pred(a, b))>;
        if constexpr (std::is_same_v<OrderType, bool> ||
            is_boolean_v<OrderType>)
            return bool(pred(a, b));
        else
            return pred(a, b) >= OrderType(0);
    };
    auto iter = copy.template view_begin<1u>();
    auto ret = true;
    for (size_t i = 1u; ret && i < copy_length; ++i, ++iter)
        ret = ret && in_order(*iter, *(iter + 1));
    return boolean(ret);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto ordered_q(const X& x)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    const auto& copy = allows<view_category::Array>(x);
    const auto copy_length = copy.dims()[0];
    auto in_order = [=](const auto& a, const auto& b)
    {
        WL_THROW_IF_ABORT()
        constexpr auto AR = array_rank_v<remove_cvref_t<decltype(a)>>;
        if constexpr (AR == 0u)
            return _order_scalar(a, b) >= 0;
        else
            return _order_array(a, b, dim_checked{}) >= 0;
    };
    auto iter = copy.template view_begin<1u>();
    auto ret = true;
    for (size_t i = 1u; ret && i < copy_length; ++i, ++iter)
        ret = ret && in_order(*iter, *(iter + 1));
    return boolean(ret);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto append(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    using YT = remove_cvref_t<Y>;
    constexpr auto XR = array_rank_v<XT>;
    constexpr auto YR = array_rank_v<YT>;
    using XV = value_type_t<XT>;
    using YV = std::conditional_t<YR == 0u, YT, value_type_t<YT>>;
    static_assert(XR == YR + 1u, WL_ERROR_APPEND_RANK);
    static_assert(is_convertible_v<YV, XV>, WL_ERROR_JOIN_VALUE_TYPE);
    if constexpr (is_movable_v<X&&>)
    {
        x.append(std::forward<decltype(y)>(y));
        return std::move(x);
    }
    else if constexpr (XR == 1u)
    {
        ndarray<XV, XR> ret(std::array<size_t, 1u>{x.dims()[0] + 1u});
        const auto ret_iter = ret.data();
        x.copy_to(ret_iter);
        *(ret_iter + x.size()) = std::forward<decltype(y)>(y);
        return ret;
    }
    else
    {
        const auto x_elem_dims = utils::dims_take<2u, XR>(x.dims());
        if (!utils::check_dims(x_elem_dims, y.dims()))
            throw std::logic_error(WL_ERROR_INSERT_ELEM_DIMS);
        ndarray<XV, XR> ret(utils::dims_join(
            std::array<size_t, 1u>{x.dims()[0] + 1u}, x_elem_dims));
        const auto ret_iter = ret.data();
        x.copy_to(ret_iter);
        y.copy_to(ret_iter + x.size());
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto prepend(X&& x, Y&& y)
{
    WL_TRY_BEGIN()
    using XT = remove_cvref_t<X>;
    using YT = remove_cvref_t<Y>;
    constexpr auto XR = array_rank_v<XT>;
    constexpr auto YR = array_rank_v<YT>;
    using XV = value_type_t<XT>;
    using YV = std::conditional_t<YR == 0u, YT, value_type_t<YT>>;
    static_assert(XR == YR + 1u, WL_ERROR_APPEND_RANK);
    static_assert(is_convertible_v<YV, XV>, WL_ERROR_JOIN_VALUE_TYPE);
    if constexpr (XR == 1u)
    {
        ndarray<XV, XR> ret(std::array<size_t, 1u>{x.dims()[0] + 1u});
        const auto ret_iter = ret.data();
        *ret_iter = std::forward<decltype(y)>(y);
        x.copy_to(ret_iter + 1);
        return ret;
    }
    else
    {
        const auto x_elem_dims = utils::dims_take<2u, XR>(x.dims());
        if (!utils::check_dims(x_elem_dims, y.dims()))
            throw std::logic_error(WL_ERROR_INSERT_ELEM_DIMS);
        ndarray<XV, XR> ret(utils::dims_join(
            std::array<size_t, 1u>{x.dims()[0] + 1u}, x_elem_dims));
        const auto ret_iter = ret.data();
        y.copy_to(ret_iter);
        x.copy_to(ret_iter + y.size());
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename XV, size_t XR, typename Y>
auto append_to(ndarray<XV, XR>& x, Y&& y) -> const auto&
{
    WL_TRY_BEGIN()
    using YT = remove_cvref_t<Y>;
    constexpr auto YR = array_rank_v<YT>;
    using YV = std::conditional_t<YR == 0u, YT, value_type_t<YT>>;
    static_assert(XR == YR + 1u, WL_ERROR_APPEND_RANK);
    static_assert(is_convertible_v<YV, XV>, WL_ERROR_JOIN_VALUE_TYPE);
    x.append(std::forward<decltype(y)>(y));
    return x;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename XV, size_t XR, typename Y>
auto prepend_to(ndarray<XV, XR>& x, Y&& y) -> const auto&
{
    WL_TRY_BEGIN()
    using YT = remove_cvref_t<Y>;
    constexpr auto YR = array_rank_v<YT>;
    using YV = std::conditional_t<YR == 0u, YT, value_type_t<YT>>;
    static_assert(XR == YR + 1u, WL_ERROR_APPEND_RANK);
    static_assert(is_convertible_v<YV, XV>, WL_ERROR_JOIN_VALUE_TYPE);
    if constexpr (XR == 1u)
    {
        const auto x_size = x.size();
        const auto new_size = x_size + 1u;
        x.uninitialized_resize(
            std::array<size_t, 1u>{x.dims()[0] + 1u}, new_size);
        const auto x_iter = x.data();
        std::move_backward(x_iter, x_iter + x_size, x_iter + new_size);
        *x_iter = std::forward<decltype(y)>(y);
    }
    else
    {
        const auto x_elem_dims = utils::dims_take<2u, XR>(x.dims());
        if (!utils::check_dims(x_elem_dims, y.dims()))
            throw std::logic_error(WL_ERROR_INSERT_ELEM_DIMS);
        const auto x_size = x.size();
        const auto y_size = y.size();
        const auto new_size = x_size + y_size;
        x.uninitialized_resize(utils::dims_join(
            std::array<size_t, 1u>{x.dims()[0] + 1u}, x_elem_dims), new_size);
        const auto x_iter = x.data();
        std::move_backward(x_iter, x_iter + x_size, x_iter + new_size);
        y.copy_to(x_iter);
    }
    return x;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<size_t Level, size_t Rank, typename Arg>
auto _join_dims_by_args_impl(
    const std::array<size_t, Rank>& dims, const Arg& arg)
{
    if constexpr (is_argument_pack_v<Arg>)
    {
        return arg.size() == 0u ? size_t(0) :
            arg.size() * _join_dims_by_args_impl<Level>(dims, arg.get(0));
    }
    else
    {
        static_assert(array_rank_v<Arg> == Rank, WL_ERROR_JOIN_RANK);
        if (arg.size() > 0u)
        {
            const auto leading_check = utils::check_dims<Level - 1u>(
                dims.data(), arg.dims().data());
            const auto trailing_check = utils::check_dims<Rank - Level>(
                dims.data() + Level, arg.dims().data() + Level);
            if (!leading_check || !trailing_check)
                throw std::logic_error(WL_ERROR_INSERT_ELEM_DIMS);
            return arg.dims()[Level - 1];
        }
        else
            return size_t(0);
    }
}
template<size_t Level, size_t Rank, typename... Args>
void _join_dims_by_args(std::array<size_t, Rank>& dims, const Args&... args)
{
    dims[Level - 1] += (size_t(0) + ... +
        _join_dims_by_args_impl<Level>(dims, args));
}
template<size_t Level, size_t Rank, typename Iter, typename Arg>
void _join_copy_leveln(Iter& ret_base, size_t stride, const Arg& arg)
{
    if constexpr (is_argument_pack_v<Arg>)
    {
        if (arg.size() == 0)
            return;
        auto arg_dims = arg.get(0).dims();
        const auto leading_size = utils::size_of_dims(
            utils::dims_take<1u, Level - 1u>(arg_dims));
        const auto trailing_size = utils::size_of_dims(
            utils::dims_take<Level, Rank>(arg_dims));
        for (size_t k = 0u; k < arg.size(); ++k, ret_base += trailing_size)
        {
            const auto& arg_k = arg.get(k);
            auto arg_iter = arg_k.begin();
            auto ret_iter = ret_base;
            for (size_t i = 0u; i < leading_size; ++i, ret_iter += stride)
            {
                WL_IGNORE_DEPENDENCIES
                for (size_t j = 0u; j < trailing_size; ++j, ++arg_iter)
                    ret_iter[j] = *arg_iter;
            }
        }
    }
    else if (arg.size() > 0u)
    {
        const auto arg_dims = arg.dims();
        const auto leading_size = utils::size_of_dims(
            utils::dims_take<1u, Level - 1u>(arg_dims));
        const auto trailing_size = utils::size_of_dims(
            utils::dims_take<Level, Rank>(arg_dims));
        if constexpr (Arg::category == view_category::General)
        {
            auto ret_iter = ret_base;
            size_t j = 0u;
            arg.for_each([&](const auto& x)
                {
                    ret_iter[j] = x;
                    if ((++j) >= trailing_size)
                    {
                        j = 0u;
                        ret_iter += stride;
                    }
                });
        }
        else
        {
            auto arg_iter = arg.begin();
            auto ret_iter = ret_base;
            for (size_t i = 0u; i < leading_size; ++i, ret_iter += stride)
            {
                WL_IGNORE_DEPENDENCIES
                for (size_t j = 0u; j < trailing_size; ++j, ++arg_iter)
                    ret_iter[j] = *arg_iter;
            }
        }
        ret_base += trailing_size;
    }
}
template<typename Iter, typename Arg>
void _join_copy_level1(Iter& iter, const Arg& arg)
{
    if constexpr (is_argument_pack_v<Arg>)
    {
        for (size_t i = 0; i < arg.size(); ++i)
            _join_copy_level1(iter, arg.get(i));
    }
    else
    {
        arg.copy_to(iter);
        iter += arg.size();
    }
}
template<int64_t I, typename First, typename... Rest>
auto join(const_int<I>, First&& first, Rest&&... rest)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    using FirstType = remove_cvref_t<First>;
    if constexpr (is_argument_pack_v<FirstType>)
    {
        if (first.size() == 0u)
        {
            if constexpr (sizeof...(rest) > 0u)
                return join(const_int<I>{},
                    std::forward<decltype(rest)>(rest)...);
            else
            {
                using ItemType = value_type_t<FirstType>;
                constexpr auto rank = array_rank_v<ItemType>;
                using ValueType = std::conditional_t<
                    rank == 0u, ItemType, value_type_t<ItemType>>;
                return ndarray<value_type_t<ItemType>, rank>{};
            }
        }
        else
            return join(const_int<I>{}, first.get(0), first.get_pack(1),
                std::forward<decltype(rest)>(rest)...);
    }
    else
    {
        constexpr auto rank = array_rank_v<FirstType>;
        static_assert(1u <= Level && Level <= rank, WL_ERROR_BAD_LEVEL);
        auto ret_dims = first.dims();
        _join_dims_by_args<Level>(ret_dims, rest...);
        ndarray<value_type_t<FirstType>, rank> ret(ret_dims);
        if constexpr (Level == 1u)
        {
            auto ret_iter = ret.data();
            _join_copy_level1(ret_iter, first);
            [[maybe_unused]] const auto& _1 = (
                _join_copy_level1(ret_iter, rest), ..., 0);
        }
        else
        {
            auto ret_iter = ret.data();
            auto stride = utils::size_of_dims(
                utils::dims_take<Level, rank>(ret_dims));
            _join_copy_leveln<Level, rank>(ret_iter, stride, first);
            [[maybe_unused]] const auto& _1 = (
                _join_copy_leveln<Level, rank>(ret_iter, stride, rest), ..., 0);
        }
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename First, typename... Rest>
auto join(First&& first, Rest&&... rest)
{
    WL_TRY_BEGIN()
    return join(const_int<1>{}, std::forward<decltype(first)>(first),
        std::forward<decltype(rest)>(rest)...);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename First, typename... Rest>
auto set_union(const First& first, const Rest&... rest)
{
    WL_TRY_BEGIN()
    auto scalar_less = [](const auto& x, const auto& y)
    {
        return _order_scalar(x, y) == int64_t(1);
    };
    auto copy = join(first, rest...);
    using T = value_type_t<decltype(copy)>;
    constexpr auto R = array_rank_v<decltype(copy)>;
    const auto copy_length = copy.dims()[0];
    const auto copy_data = copy.data();
    if constexpr (R == 1u)
    {
        std::sort(copy_data, copy_data + copy_length, scalar_less);
        const auto copy_end = std::unique(
            copy_data, copy_data + copy_length);
        const auto union_size = size_t(copy_end - copy_data);
        copy.uninitialized_resize(std::array<size_t, 1u>{union_size});
        return copy;
    }
    else
    {
        const auto item_dims = utils::dims_take<2, R>(copy.dims());
        const auto item_size = utils::size_of_dims(item_dims);
        auto idx = range(size_t(0), copy_length - 1u);
        auto idx_begin = idx.data();
        auto sort_pred = [=](size_t a, size_t b)
        {
            WL_THROW_IF_ABORT()
            auto a_iter = copy_data + a * item_size;
            auto b_iter = copy_data + b * item_size;
            return std::lexicographical_compare(
                a_iter, a_iter + item_size,
                b_iter, b_iter + item_size,
                scalar_less);
        };
        std::sort(idx_begin, idx_begin + copy_length, sort_pred);
        auto unique_pred = [=](size_t a, size_t b)
        {
            auto a_iter = copy_data + a * item_size;
            auto b_iter = copy_data + b * item_size;
            return std::equal(a_iter, a_iter + item_size, b_iter);
        };
        const auto idx_end = std::unique(
            idx_begin, idx_begin + copy_length, unique_pred);
        const auto union_size = size_t(idx_end - idx_begin);
        ndarray<T, R> ret(utils::dims_join(
            std::array<size_t, 1u>{union_size}, item_dims));
        const auto copy_base = copy.template view_begin<1u>();
        auto ret_iter = ret.template view_begin<1u>();
        for (size_t i = 0u; i < union_size; ++i, ++ret_iter)
            (*(copy_base + idx_begin[i])).copy_to(ret_iter.begin());
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto _rotate_impl(const X& x, int64_t n)
{
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<X>;
    const auto item_count = x.dims()[0];
    if (item_count == 0u)
        return ndarray<XV, XR>(x.dims());
    const auto& valx = allows<view_category::Regular>(x);
    if (n >= int64_t(item_count))
        n = n % item_count;
    else if (n <= -int64_t(item_count))
        n = -((-n) % item_count);
    if (n == 0)
        return allows<view_category::Array>(valx);
    const auto item_size = utils::size_of_dims(
        utils::dims_take<2u, XR>(valx.dims()));
    auto x_iter = valx.begin();
    ndarray<XV, XR> ret(valx.dims());
    const auto ret_iter = ret.data();
    
    if (n >= 0)
    { // rotate right
        const auto size1 = size_t(n) * item_size;
        const auto size2 = ret.size() - size1;
        auto iter2 = ret_iter + size1;
        WL_IGNORE_DEPENDENCIES
        for (size_t i = 0; i < size2; ++i, ++iter2, ++x_iter)
            *iter2 = *x_iter;
        auto iter1 = ret_iter;
        WL_IGNORE_DEPENDENCIES
        for (size_t i = 0; i < size1; ++i, ++iter1, ++x_iter)
            *iter1 = *x_iter;
    }
    else
    { // rotate left
        const auto size1 = size_t(-n) * item_size;
        const auto size2 = ret.size() - size1;
        auto iter1 = ret_iter + size2;
        WL_IGNORE_DEPENDENCIES
        for (size_t i = 0; i < size1; ++i, ++iter1, ++x_iter)
            *iter1 = *x_iter;
        auto iter2 = ret_iter;
        WL_IGNORE_DEPENDENCIES
        for (size_t i = 0; i < size2; ++i, ++iter2, ++x_iter)
            *iter2 = *x_iter;
    }
    return ret;
}
template<typename X, typename N>
auto rotate_left(const X& x, const N& n)
{
    WL_TRY_BEGIN()
    static_assert(is_integral_v<N>, WL_ERROR_COUNTING_ARG);
    return _rotate_impl(x, -int64_t(n));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename N>
auto rotate_right(const X& x, const N& n)
{
    WL_TRY_BEGIN()
    static_assert(is_integral_v<N>, WL_ERROR_COUNTING_ARG);
    return _rotate_impl(x, int64_t(n));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto rotate_left(const X& x)
{
    WL_TRY_BEGIN()
    return _rotate_impl(x, -1);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto rotate_right(const X& x)
{
    WL_TRY_BEGIN()
    return _rotate_impl(x, 1);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<size_t I, size_t Level, typename Ret, typename Iter, typename IsEqual>
void _position_impl(const std::array<size_t, Level>& pos_dims,
    ndarray<Ret, 2u>& ret, ndarray<Ret, 1u>& pos_idx, Ret* const idx_base,
    Iter& x_iter, IsEqual is_equal)
{
    const auto dim = pos_dims[I];
    if constexpr (I + 1u < Level)
    {
        for (size_t i = 1u; i <= dim; ++i)
        {
            idx_base[I] = i;
            _position_impl<I + 1u, Level, Ret>(
                pos_dims, ret, pos_idx, idx_base, x_iter, is_equal);
        }
    }
    else
    {
        for (size_t i = 1u; i <= dim; ++i, ++x_iter)
        {
            if (is_equal(*x_iter))
            {
                idx_base[I] = i;
                ret.append(pos_idx, dim_checked{});
            }
        }
    }
}
template<typename Ret = int64_t, typename X, typename Y, int64_t I>
auto position(const X& x, const Y& y, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(1u <= Level && Level + YR == XR, WL_ERROR_BAD_LEVEL);
    const auto& valx = allows<view_category::Array>(x);
    const auto& valy = allows<view_category::Simple>(y);
    return position(valx, varg_tag{},
        [&](const auto& a) { return equal(a, valy); }, const_int<Level>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X, typename Function, int64_t I>
auto position(const X& x, varg_tag, Function f, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    static_assert(1u <= Level && Level <= XR, WL_ERROR_BAD_LEVEL);
    
    const auto& valx = allows<view_category::Array>(x);
    if constexpr (Level == 1u)
    {
        auto x_iter = valx.template view_begin<1u>();
        const auto size = valx.dims()[0];
        ndarray<Ret, 1u> ret;
        for (size_t i = 1u; i <= size; ++i, ++x_iter)
        {
            if (f(*x_iter))
                ret.append(Ret(i), dim_checked{});
        }
        const auto ret_size = ret.size();
        return ndarray<Ret, 2u>(std::array<size_t, 2u>{ret_size, 1u},
            std::move(ret).data_vector());
    }
    else
    {
        auto x_iter = valx.template view_begin<Level>();
        const auto pos_dims = utils::dims_take<1u, Level>(valx.dims());
        ndarray<Ret, 2u> ret(std::array<size_t, 2u>{0u, Level});
        ndarray<Ret, 1u> pos_idx(std::array<size_t, 1u>{Level});
        Ret* const idx_base = pos_idx.data();
        _position_impl<0u, Level, Ret>(
            pos_dims, ret, pos_idx, idx_base, x_iter, f);
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Ret = int64_t, typename X, typename Y>
auto position(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(XR > YR, WL_ERROR_POSITION_RANK);
    return position(x, y, const_int<XR - YR>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Function, int64_t I>
auto cases(const X& x, varg_tag, Function f, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    static_assert(1u <= Level && Level <= XR, WL_ERROR_BAD_LEVEL);
    using XV = value_type_t<X>;
    if constexpr (XR == Level)
    {
        using RT = remove_cvref_t<decltype(f(XV{}))>;
        static_assert(is_boolean_v<RT>, WL_ERROR_PRED_TYPE);
        ndarray<XV, 1u> ret;
        x.for_each([&](const auto& a) {
            if (f(a)) ret.append(a, dim_checked{}); });
        return ret;
    }
    else
    {
        const auto& valx = allows<view_category::Array>(x);
        auto view_iter = valx.template view_begin<Level>();
        const auto view_end = valx.template view_end<Level>();
        using RT = remove_cvref_t<decltype(f(*view_iter))>;
        static_assert(is_boolean_v<RT>, WL_ERROR_PRED_TYPE);
        ndarray<XV, XR - Level + 1u> ret;
        for (; view_iter != view_end; ++view_iter)
        {
            if (f(*view_iter))
                ret.append(*view_iter, dim_checked{});
        }
        return ret;
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y, int64_t I>
auto cases(const X& x, const Y& y, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(1u <= Level && Level <= XR, WL_ERROR_BAD_LEVEL);
    if constexpr (XR != YR + Level)
    {
        return ndarray<value_type_t<X>, XR - Level + 1u>{};
    }
    else
    {
        auto same_dims = true;
        if constexpr (YR > 0u)
            same_dims = utils::check_dims<YR>(
                x.dims().data() + Level, y.dims().data());
        if (!same_dims)
        {
            return ndarray<value_type_t<X>, XR - Level + 1u>{};
        }
        else
        {
            const auto& valy = allows<view_category::Simple>(y);
            return cases(x, varg_tag{},
                [&](const auto& a) { return same_q(a, valy, dim_checked{}); },
                const_int<Level>{});
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto cases(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(YR < XR, WL_ERROR_POSITION_RANK);
    return cases(x, y, const_int<XR - YR>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Function>
auto delete_cases(const X& x, varg_tag, Function f)
{
    WL_TRY_BEGIN()
    static_assert(array_rank_v<X> >= 1u, WL_ERROR_REQUIRE_ARRAY);
    return cases(x, varg_tag{},
        [=](auto&& a) {return !f(std::forward<decltype(a)>(a)); },
        const_int<1>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Function, int64_t I>
auto delete_cases(const X& x, varg_tag, Function f, const_int<I>)
{
    WL_TRY_BEGIN()
    static_assert(I == 1, WL_ERROR_DELETE_CASES_LEVEL);
    return delete_cases(x, varg_tag{}, f);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto delete_cases(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    static_assert(XR == YR + 1u, WL_ERROR_DELETE_CASES_LEVEL);
    auto same_dims = true;
    if constexpr (YR > 0u)
        same_dims = utils::check_dims<YR>(
            x.dims().data() + 1, y.dims().data());
    if (!same_dims)
    {
        return val(x);
    }
    else
    {
        const auto& valy = allows<view_category::Simple>(y);
        return cases(x, varg_tag{},
            [&](const auto& a) { return unsame_q(a, valy, dim_checked{}); },
            const_int<1>{});
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y, int64_t I>
auto delete_cases(const X& x, const Y& y, const_int<I>)
{
    WL_TRY_BEGIN()
    static_assert(I == 1, WL_ERROR_DELETE_CASES_LEVEL);
    return delete_cases(x, y);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Function, int64_t I>
auto member_q(const X& x, varg_tag, Function f, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    static_assert(1u <= Level && Level <= XR, WL_ERROR_BAD_LEVEL);
    using XV = value_type_t<X>;
    if constexpr (XR == Level)
    {
        using RT = remove_cvref_t<decltype(f(XV{}))>;
        static_assert(is_boolean_v<RT>, WL_ERROR_PRED_TYPE);
        auto ret = false;
        x.for_each([&](const auto& a) {
            ret = ret || f(a); return ret; });
        return boolean(ret);
    }
    else
    {
        const auto& valx = allows<view_category::Array>(x);
        auto view_iter = valx.template view_begin<Level>();
        const auto view_end = valx.template view_end<Level>();
        using RT = remove_cvref_t<decltype(f(*view_iter))>;
        static_assert(is_boolean_v<RT>, WL_ERROR_PRED_TYPE);
        auto ret = false;
        for (; view_iter != view_end && !ret; ++view_iter)
            ret = ret || f(*view_iter);
        return boolean(ret);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y, int64_t I>
auto member_q(const X& x, const Y& y, const_int<I>)
{
    WL_TRY_BEGIN()
    constexpr auto Level = I > 0 ? size_t(I) : size_t(0);
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(1u <= Level && Level <= XR, WL_ERROR_BAD_LEVEL);
    if constexpr (XR != YR + Level)
    {
        return const_false;
    }
    else
    {
        auto same_dims = true;
        if constexpr (YR > 0u)
            same_dims = utils::check_dims<YR>(
                x.dims().data() + Level, y.dims().data());
        if (!same_dims)
        {
            return const_false;
        }
        else
        {
            const auto& valy = allows<view_category::Simple>(y);
            return member_q(x, varg_tag{},
                [&](const auto& a) { return same_q(a, valy, dim_checked{}); },
                const_int<Level>{});
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto member_q(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(YR < XR, WL_ERROR_POSITION_RANK);
    return member_q(x, y, const_int<XR - YR>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Function, int64_t I>
auto free_q(const X& x, varg_tag, Function f, const_int<I>)
{
    WL_TRY_BEGIN()
    return !member_q(x, varg_tag{}, f, const_int<I>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y, int64_t I>
auto free_q(const X& x, const Y& y, const_int<I>)
{
    WL_TRY_BEGIN()
    return !member_q(x, y, const_int<I>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y>
auto free_q(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    return !member_q(x, y);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<bool ScalarY, typename X, typename Y>
void _insert_impl2(const X* WL_RESTRICT src_ptr, X* WL_RESTRICT dst_ptr,
    const Y* WL_RESTRICT y_ptr, const int64_t* WL_RESTRICT pos_ptr,
    const size_t x_size, const size_t y_size, const size_t pos_size)
{
    WL_THROW_IF_ABORT()
    size_t last_offset = 0u;
    size_t this_offset = 0u;
    for (size_t p = 0; p < pos_size; ++p, ++pos_ptr)
    {
        this_offset = size_t(ScalarY ? (*pos_ptr) : (*pos_ptr) * y_size);
        const auto copy_size = this_offset - last_offset;
        last_offset = this_offset;
        for (size_t i = 0; i < copy_size; ++i, ++src_ptr, ++dst_ptr)
            *dst_ptr = *src_ptr;
        if constexpr (ScalarY)
        {
            *dst_ptr = *y_ptr;
            ++dst_ptr;
        }
        else
        {
            for (size_t i = 0; i < y_size; ++i, ++dst_ptr)
                *dst_ptr = y_ptr[i];
        }
    }
    const auto copy_size = x_size - last_offset;
    for (size_t i = 0; i < copy_size; ++i, ++src_ptr, ++dst_ptr)
        *dst_ptr = *src_ptr;
}
template<typename X, typename Y>
auto _insert_impl1(X&& x, const Y& y, ndarray<int64_t, 1u> pos)
{
    const auto pos_size = pos.size();
    if (pos_size == 1u)
    {
        return _insert_impl1(std::forward<decltype(x)>(x), y, *(pos.data()));
    }
    else
    {
        using XT = remove_cvref_t<X>;
        using XV = value_type_t<XT>;
        constexpr auto XR = array_rank_v<XT>;
        constexpr auto YR = array_rank_v<Y>;
        pos.for_each([d0 = x.dims()[0] + 1u](auto& a){
            a = int64_t(convert_index(a, d0)); });
        auto* pos_begin = pos.data();
        auto* pos_end = pos_begin + pos.size();
        auto* pos_mid = std::is_sorted_until(pos_begin, pos_end);
        if (pos_mid != pos_end)
        {
            std::sort(pos_mid, pos_end);
            std::inplace_merge(pos_begin, pos_mid, pos_end);
        }
        const auto& valx = allows<view_category::Simple>(x);
        auto ret_dims = valx.dims();
        ret_dims[0] += pos_size;
        auto ret = ndarray<XV, XR>(ret_dims);
        if constexpr (YR == 0u)
        {
            _insert_impl2<true>(
                valx.data(), ret.data(), &y, pos.data(),
                valx.size(), 1u, pos.size());
        }
        else
        {
            const auto& valy = cast<ndarray<XV, YR>>(y);
            _insert_impl2<false>(
                valx.data(), ret.data(), valy.data(), pos.data(),
                valx.size(), valy.size(), pos.size());
        }
        return ret;
    }
}
template<typename X, typename Y>
auto _insert_impl1(X&& x, const Y& y, int64_t pos)
{
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    constexpr auto XR = array_rank_v<XT>;
    constexpr auto YR = array_rank_v<Y>;
    pos = int64_t(convert_index(pos, x.dims()[0] + 1u));
    const auto& valx = allows<view_category::Simple>(x);
    auto ret_dims = valx.dims();
    ret_dims[0] += 1u;
    auto ret = ndarray<XV, XR>(ret_dims);
    if constexpr (YR == 0u)
    {
        _insert_impl2<true>(
            valx.data(), ret.data(), &y, &pos,
            valx.size(), 1u, 1u);
    }
    else
    {
        const auto& valy = cast<ndarray<XV, YR>>(y);
        _insert_impl2<false>(
            valx.data(), ret.data(), valy.data(), &pos,
            valx.size(), valy.size(), 1u);
    }
    return ret;
}
template<typename X, typename Y, typename Pos>
auto insert(X&& x, const Y& y, Pos&& pos)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<remove_cvref_t<X>>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(XR == YR + 1u, WL_ERROR_INSERT_RANK);
    using PosT = remove_cvref_t<Pos>;
    using PosV = value_type_t<PosT>;
    
    if constexpr (YR >= 1u)
    {
        if (!utils::check_dims<YR>(x.dims().data() + 1, y.dims().data()))
            throw std::logic_error(WL_ERROR_INSERT_ELEM_DIMS);
    }
    if constexpr (array_rank_v<PosT> == 2u && is_integral_v<PosV>)
    {
        const auto& pos_dims = pos.dims();
        if (pos_dims[1] != 1u)
            throw std::logic_error(WL_ERROR_INSERT_POS_DIMS);
        if (pos_dims[0] == 0u)
            return val(x);
        else
        {
            auto ins_pos = ndarray<int64_t, 1u>(
                std::array<size_t, 1>{pos.size()});
            pos.copy_to(ins_pos.data());
            return _insert_impl1(
                std::forward<decltype(x)>(x), y, std::move(ins_pos));
        }
    }
    else if constexpr (is_integral_v<PosT>)
    {
        return _insert_impl1(std::forward<decltype(x)>(x), y, pos);
    }
    else
    {
        static_assert(always_false_v<Pos>, WL_ERROR_INSERT_POS_FORM);
        return val(x);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<bool ScalarY, typename X>
void _delete_impl2(const X* WL_RESTRICT src_ptr, X* WL_RESTRICT dst_ptr,
    const int64_t* WL_RESTRICT pos_ptr,
    const size_t x_size, const size_t y_size, const size_t pos_size)
{
    WL_THROW_IF_ABORT()
    size_t last_offset = 0u;
    size_t this_offset = 0u;
    for (size_t p = 0; p < pos_size; ++p, ++pos_ptr)
    {
        this_offset = size_t(ScalarY ? (*pos_ptr) : (*pos_ptr) * y_size);
        const auto copy_size = this_offset - last_offset;
        last_offset = this_offset;
        for (size_t i = 0; i < copy_size; ++i, ++src_ptr, ++dst_ptr)
            *dst_ptr = *src_ptr;
        src_ptr += ScalarY ? size_t(1u) : y_size;
    }
    const auto copy_size = x_size - last_offset;
    for (size_t i = 0; i < copy_size; ++i, ++src_ptr, ++dst_ptr)
        *dst_ptr = *src_ptr;
}
template<typename X>
auto _delete_impl1(X&& x, ndarray<int64_t, 1u> pos)
{
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    constexpr auto XR = array_rank_v<XT>;
    bool delete_single = false;
    size_t pos_unique_size = 0;
    if (pos.size() == 1u)
    {
        delete_single = true;
    }
    else
    {
        pos.for_each([d0 = x.dims()[0]](auto& a){
            a = int64_t(convert_index(a, d0)); });
        auto* pos_begin = pos.data();
        auto* pos_end = pos_begin + pos.size();
        auto* pos_mid = std::is_sorted_until(pos_begin, pos_end);
        if (pos_mid != pos_end)
        {
            std::sort(pos_mid, pos_end);
            std::inplace_merge(pos_begin, pos_mid, pos_end);
        }
        auto* pos_unique_end = std::unique(pos_begin, pos_end);
        if (pos_unique_end == pos_begin + 1)
            delete_single = true;
        else
            pos_unique_size = pos_unique_end - pos_begin;
    }
    if (delete_single)
    {
        return _delete_impl1(std::forward<decltype(x)>(x), *(pos.data()));
    }
    else
    {
        const auto& valx = allows<view_category::Simple>(x);
        auto ret_dims = valx.dims();
        ret_dims[0] -= pos_unique_size;
        auto ret = ndarray<XV, XR>(ret_dims);
        WL_THROW_IF_ABORT()
        if constexpr (XR == 1u)
            _delete_impl2<true>(valx.data(), ret.data(), pos.data(),
                valx.size(), 1u, pos_unique_size);
        else
            _delete_impl2<false>(
                valx.data(), ret.data(), pos.data(), valx.size(),
                utils::size_of_dims<XR - 1u>(x.dims().data() + 1u),
                pos_unique_size);
        return ret;
    }
}
template<typename X>
auto _delete_impl1(X&& x, int64_t pos)
{
    using XT = remove_cvref_t<X>;
    using XV = value_type_t<XT>;
    constexpr auto XR = array_rank_v<XT>;
    pos = int64_t(convert_index(pos, x.dims()[0]));
    const auto& valx = allows<view_category::Simple>(x);
    auto ret_dims = valx.dims();
    ret_dims[0] -= 1u;
    auto ret = ndarray<XV, XR>(ret_dims);
    if constexpr (XR == 1u)
        _delete_impl2<true>(valx.data(), ret.data(), &pos,
            valx.size(), 1u, 1u);
    else
        _delete_impl2<false>(valx.data(), ret.data(), &pos, valx.size(),
            utils::size_of_dims<XR - 1u>(x.dims().data() + 1u), 1u);
    return ret;
}
template<typename X, typename Pos>
auto delete_(X&& x, Pos&& pos)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<remove_cvref_t<X>>;
    using PosT = remove_cvref_t<Pos>;
    using PosV = value_type_t<PosT>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    if constexpr (array_rank_v<PosT> == 2u && is_integral_v<PosV>)
    {
        const auto& pos_dims = pos.dims();
        if (pos_dims[1] != 1u)
            throw std::logic_error(WL_ERROR_INSERT_POS_DIMS);
        if (pos_dims[0] == 0u)
            return val(x);
        else
        {
            auto del_pos = ndarray<int64_t, 1u>(
                std::array<size_t, 1>{pos.size()});
            pos.copy_to(del_pos.data());
            return _delete_impl1(
                std::forward<decltype(x)>(x), std::move(del_pos));
        }
    }
    else if constexpr (is_integral_v<PosT>)
    {
        return _delete_impl1(std::forward<decltype(x)>(x), pos);
    }
    else
    {
        static_assert(always_false_v<Pos>, WL_ERROR_INSERT_POS_FORM);
        return val(x);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Spec>
auto _take_get_spec(const Spec& spec)
{
    if constexpr (std::is_same_v<all_type, Spec>)
    {
        return const_all;
    }
    else if constexpr (is_integral_v<Spec>)
    {
        if constexpr (std::is_unsigned_v<Spec>)
            return make_span(const_all, spec);
        else if (spec > Spec(0))
            return make_span(int64_t(1), int64_t(spec));
        else
            return make_span(int64_t(spec), int64_t(-1));
    }
    else if constexpr (array_rank_v<Spec> == 1u &&
        is_integral_v<value_type_t<Spec>>)
    {
        const auto spec_size = spec.size();
        if (!(1u <= spec_size && spec_size <= 3u))
            throw std::logic_error(WL_ERROR_TAKE_SPEC_LIST_LENGTH);
        std::array<value_type_t<Spec>, 3u> spec_data;
        spec.copy_to(spec_data.data());
        if (spec_size == 1u)
            return make_span(
                spec_data[0], spec_data[0], value_type_t<Spec>(1));
        else if (spec_size == 2u)
            return make_span(
                spec_data[0], spec_data[1], value_type_t<Spec>(1));
        else
            return make_span(spec_data[0], spec_data[1], spec_data[2]);
    }
    else
    {
        static_assert(always_false_v<Spec>, WL_ERROR_TAKE_SPEC_TYPE);
    }
}
template<typename Spec>
auto _drop_get_spec(const Spec& spec)
{
    if constexpr (std::is_same_v<none_type, Spec>)
    {
        return const_all;
    }
    else if constexpr (is_integral_v<Spec>)
    {
        if constexpr (std::is_unsigned_v<Spec>)
            return make_span(complement_span_tag{}, const_all, spec);
        else if (spec > Spec(0))
            return make_span(complement_span_tag{},
                int64_t(1), int64_t(spec));
        else
            return make_span(complement_span_tag{},
                int64_t(spec), int64_t(-1));
    }
    else if constexpr (array_rank_v<Spec> == 1u &&
        is_integral_v<value_type_t<Spec>>)
    {
        const auto spec_size = spec.size();
        if (!(1u <= spec_size && spec_size <= 3u))
            throw std::logic_error(WL_ERROR_TAKE_SPEC_LIST_LENGTH);
        std::array<value_type_t<Spec>, 3u> spec_data;
        spec.copy_to(spec_data.data());
        if (spec_size == 1u)
            return make_span(complement_span_tag{},
                spec_data[0], spec_data[0], value_type_t<Spec>(1));
        else if (spec_size == 2u)
            return make_span(complement_span_tag{},
                spec_data[0], spec_data[1], value_type_t<Spec>(1));
        else
            return make_span(complement_span_tag{},
                spec_data[0], spec_data[1], spec_data[2]);
    }
    else
    {
        static_assert(always_false_v<Spec>, WL_ERROR_TAKE_SPEC_TYPE);
    }
}
template<typename X, typename... Specs>
auto take(const X& x, const Specs&... specs)
{
    WL_TRY_BEGIN()
    return val(part(x, _take_get_spec(specs)...));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename... Specs>
auto drop(const X& x, const Specs&... specs)
{
    WL_TRY_BEGIN()
    return val(part(x, _drop_get_spec(specs)...));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<size_t I, typename XV, size_t Level, size_t RR>
void _partition_copy_single(XV*& WL_RESTRICT dst, const XV* WL_RESTRICT src,
    const std::array<size_t, RR>& ret_dims,
    const std::array<size_t, Level>& strides)
{
    if constexpr (I == 0u)
    {
        WL_THROW_IF_ABORT()
    }
    if constexpr (I + 1u == Level)
    {
        const auto size = strides[Level - 1u];
        utils::restrict_copy_n(src, size, dst, no_check_abort_tag{});
        dst += size;
    }
    else if constexpr (I + 1u < Level)
    {
        const auto size = int64_t(ret_dims[Level + I]);
        for (int64_t i = 0; i < size; ++i)
            _partition_copy_single<I + 1u>(
                dst, src + i * strides[I], ret_dims, strides);
    }
    else
    {
        static_assert(always_false_v<XV>, WL_ERROR_INTERNAL);
    }
}
template<size_t I, typename XV, size_t Level, size_t RR>
void _partition_copy_batch(XV*& WL_RESTRICT dst, const XV* WL_RESTRICT src,
    const std::array<size_t, RR>& ret_dims,
    const std::array<size_t, Level>& strides,
    const std::array<size_t, Level>& d_strides)
{
    const auto size = ret_dims[I];
    for (size_t i = 0; i < size; ++i)
    {
        if constexpr (I + 1u == Level)
            _partition_copy_single<0u>(
                dst, src + i * d_strides[I], ret_dims, strides);
        else if constexpr (I + 1u < Level)
            _partition_copy_batch<I + 1u>(
                dst, src + i * d_strides[I], ret_dims, strides, d_strides);
        else
            static_assert(always_false_v<XV>, WL_ERROR_INTERNAL);
    }
}
template<typename XV, size_t XR, size_t Level>
auto _partition_impl(const XV* const x_data, std::array<size_t, XR> x_dims,
    std::array<size_t, Level> n, std::array<size_t, Level> d)
{
    // Max[0,Floor[(s+d-n)/d]]
    static_assert(1u <= Level && Level <= XR, WL_ERROR_INTERNAL);
    constexpr auto RR = XR + Level;
    std::array<size_t, RR> ret_dims;
    for (size_t i = 0; i < Level; ++i)
    {
        int64_t m = (x_dims[i] + d[i] - n[i]) / d[i];
        if (m <= 0)
            m = 0;
        ret_dims[i] = size_t(m);
        ret_dims[Level + i] = n[i];
    }
    for (size_t i = Level; i < XR; ++i)
        ret_dims[Level + i] = x_dims[i];
    ndarray<XV, RR> ret(ret_dims);
    if (ret.size() == 0u)
        return ret;
    std::array<size_t, Level> strides;
    std::array<size_t, Level> d_strides;
    size_t stride = 1u;
    for (int64_t i = XR - 1; i >= int64_t(Level); --i)
    {
        stride *= x_dims[i];
    }
    for (int64_t i = int64_t(Level) - 1; i >= 0; --i)
    {
        strides[i] = stride;
        d_strides[i] = stride * d[i];
        stride *= x_dims[i];
    }
    strides[Level - 1u] *= ret_dims[2u * Level - 1u];
    auto* ret_data = ret.data();
    _partition_copy_batch<0u>(ret_data, x_data, ret_dims, strides, d_strides);
    return ret;
}
template<size_t Level, typename Spec>
auto _partition_get_spec(const Spec& spec)
{
    std::array<size_t, Level> spec_array;
    if constexpr (array_rank_v<Spec> == 1u)
    {
        static_assert(is_integral_v<value_type_t<Spec>>,
            WL_ERROR_PARTITION_SPEC);
        if (spec.size() != Level)
            throw std::logic_error(WL_ERROR_PARTITION_SPEC_LENGTH);
        if (!all_true(spec,
            [](const auto& a) { return boolean(a > decltype(a)(0)); }))
            throw std::logic_error(WL_ERROR_PARTITION_NEGATIVE_SPEC);
        spec.copy_to(spec_array.data());
    }
    else
    {
        static_assert(array_rank_v<Spec> == 0u && is_integral_v<Spec>,
            WL_ERROR_PARTITION_SPEC);
        if (spec <= Spec(0))
            throw std::logic_error(WL_ERROR_PARTITION_NEGATIVE_SPEC);
        spec_array.fill(spec);
    }
    return spec_array;
}
template<typename X, int64_t I, typename N, typename D>
auto partition(const X& x, const_int<I>, const N& n, const D& d)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    constexpr auto Level = size_t(I);
    static_assert(1u <= I && I <= XR, WL_ERROR_PARTITION_LEVEL);
    const auto& valx = allows<view_category::Simple>(x);
    const auto n_array = _partition_get_spec<Level>(n);
    const auto d_array = _partition_get_spec<Level>(d);
    return _partition_impl(valx.data(), valx.dims(), n_array, d_array);
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, int64_t I, typename N>
auto partition(const X& x, const_int<I>, const N& n)
{
    return partition(x, const_int<I>{}, n, n);
}
template<typename X, typename N, typename D>
auto partition(const X& x, const N& n, const D& d)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    if constexpr (array_rank_v<N> == 0u && array_rank_v<D> == 0u)
    {
        return partition(x, const_int<1>{}, n, d);
    }
    else
    {
        constexpr auto Level = XR;
        if constexpr (array_rank_v<N> == 1u)
            if (n.size() != XR)
                throw std::logic_error(WL_ERROR_PARTITION_DEFAULT_LEVEL);
        if constexpr (array_rank_v<D> == 1u)
            if (d.size() != XR)
                throw std::logic_error(WL_ERROR_PARTITION_DEFAULT_LEVEL);
        return partition(x, const_int<int64_t(XR)>{}, n, d);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename N>
auto partition(const X& x, const N& n)
{
    return partition(x, n, n);
}
}
namespace wl
{
template<typename Z, typename X, typename Y>
void _dot_vv(Z* WL_RESTRICT pz, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const size_t K)
{
    auto z = Z(0);
    for (size_t k = 0u; k < K; ++k)
        z += Z(px[k]) * Z(py[k]);
    *pz += z;
}
template<typename Z, typename X, typename Y>
void _dot_mv(Z* WL_RESTRICT pz, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const size_t M, const size_t K)
{
    WL_THROW_IF_ABORT()
    for (size_t m = 0u; m < M; ++m)
        _dot_vv(pz + m, px + m * K, py, K);
}
template<typename Z, typename X, typename Y>
auto _dot_vm(Z* WL_RESTRICT pz, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const size_t K, const size_t N)
{
    WL_THROW_IF_ABORT()
    for (size_t k = 0u; k < K; k += 1)
    {
        const auto xk = Z(px[k]);
        const auto* WL_RESTRICT pyk = py + k * N;
        for (size_t n = 0u; n < N; ++n)
            pz[n] += xk * Z(pyk[n]);
    }
}
template<typename Z, typename X, typename Y>
auto _dot_mm(Z* WL_RESTRICT pz, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const size_t M, const size_t K, const size_t N)
{
    for (size_t m = 0; m < M; ++m)
        _dot_vm(pz + m * N, px + m * K, py, K, N);
}
template<typename X, typename Y>
auto dot(const X& x, const Y& y)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<X> && is_numerical_type_v<Y>,
        WL_ERROR_NUMERIC_ONLY);
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(XR >= 1u && YR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    using XV = value_type_t<X>;
    using YV = value_type_t<Y>;
    using C = common_type_t<XV, YV>;
    WL_THROW_IF_ABORT()
    const auto& valx = allows<view_category::Simple>(x);
    const auto& valy = allows<view_category::Simple>(y);
    const auto* px = valx.data();
    const auto* py = valy.data();
    const auto K = valx.dims()[XR - 1u];
    if (K != valy.dims()[0])
        throw std::logic_error(WL_ERROR_REQUIRE_NON_EMPTY);
    if constexpr (XR == 1u)
    {
        if constexpr (YR == 1u)
        {
            auto z = C(0);
            _dot_vv(&z, px, py, K);
            return z;
        }
        else
        {
            const auto ret_dims = utils::dims_take<2u, YR>(valy.dims());
            ndarray<C, YR - 1u> ret(ret_dims, C(0));
            const auto N = ret.size();
            auto* pz = ret.data();
            _dot_vm(pz, px, py, K, N);
            return ret;
        }
    }
    else
    {
        if constexpr (YR == 1u)
        {
            const auto ret_dims = utils::dims_take<1u, XR - 1u>(valx.dims());
            ndarray<C, XR - 1u> ret(ret_dims, C(0));
            const auto M = ret.size();
            auto* pz = ret.data();
            _dot_mv(pz, px, py, M, K);
            return ret;
        }
        else
        {
            const auto M_dims = utils::dims_take<1u, XR - 1u>(valx.dims());
            const auto N_dims = utils::dims_take<2u, YR>(valy.dims());
            const auto M = utils::size_of_dims(M_dims);
            const auto N = utils::size_of_dims(N_dims);
            ndarray<C, XR + YR - 2u> ret(
                utils::dims_join(M_dims, N_dims), C(0));
            auto* pz = ret.data();
            _dot_mm(pz, px, py, M, K, N);
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename Y, typename Z, typename... Rest>
auto dot(const X& x, const Y& y, const Z& z, const Rest&... rest)
{
    return dot(dot(x, y), z, rest...);
}
template<typename C, typename X, typename Y, typename F>
void _inner_f(C* WL_RESTRICT pc, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const ptrdiff_t dy, size_t K, F f)
{
    if (dy != 1)
    {
        WL_CHECK_ABORT_LOOP_BEGIN(K)
            for (auto k = _loop_begin; k < _loop_end; ++k)
                pc[k] = f(px[k], py[k * dy]);
        WL_CHECK_ABORT_LOOP_END()
    }
    else
    {
        WL_CHECK_ABORT_LOOP_BEGIN(K)
            for (auto k = _loop_begin; k < _loop_end; ++k)
                pc[k] = f(px[k], py[k]);
        WL_CHECK_ABORT_LOOP_END()
    }
}
template<typename C, typename X, typename Y, typename F, typename G>
auto _inner_vv(const X* WL_RESTRICT px, const Y* WL_RESTRICT py,
    const size_t K, F f, G g)
{
    ndarray<C, 1u> c(std::array<size_t, 1u>{K});
    auto pc = c.data();
    auto pack = argument_pack<C*, false>(pc, K);
    _inner_f(pc, px, py, 1, K, f);
    return g(pack);
}
template<typename C, typename Z, typename X, typename Y, typename F, typename G>
void _inner_mv(Z* WL_RESTRICT pz, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const size_t M, const size_t K, F f, G g)
{
    ndarray<C, 1u> c(std::array<size_t, 1u>{K});
    auto pc = c.data();
    auto pack = argument_pack<C*, false>(pc, K);
    for (size_t m = 0; m < M; ++m, ++pz, px += K)
    {
        _inner_f(pc, px, py, 1, K, f);
        *pz = g(pack);
    }
}
template<typename C, typename Z, typename X, typename Y, typename F, typename G>
void _inner_vm(Z* WL_RESTRICT pz, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const size_t K, const size_t N, F f, G g)
{
    ndarray<C, 1u> c(std::array<size_t, 1u>{K});
    auto pc = c.data();
    auto pack = argument_pack<C*, false>(pc, K);
    for (size_t n = 0; n < N; ++n, ++pz, ++py)
    {
        _inner_f(pc, px, py, N, K, f);
        *pz = g(pack);
    }
}
template<typename C, typename Z, typename X, typename Y, typename F, typename G>
void _inner_mm(Z* WL_RESTRICT pz, const X* WL_RESTRICT px,
    const Y* WL_RESTRICT py, const size_t M, const size_t K, const size_t N,
    F f, G g)
{
    ndarray<C, 1u> c(std::array<size_t, 1u>{K});
    auto pc = c.data();
    auto pack = argument_pack<C*, false>(pc, K);
    for (size_t m = 0; m < M; ++m, px += K)
    {
        for (size_t n = 0; n < N; ++n, ++pz)
        {
            _inner_f(pc, px, py + n, N, K, f);
            *pz = g(pack);
        }
    }
}
template<typename F, typename X, typename Y, typename G>
auto inner(F f, const X& x, const Y& y, G g)
{
    WL_TRY_BEGIN()
    constexpr auto XR = array_rank_v<X>;
    constexpr auto YR = array_rank_v<Y>;
    static_assert(XR >= 1u && YR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    static_assert(is_variadic_function_v<G>, WL_ERROR_REQUIRE_VARIADIC);
    using XV = value_type_t<X>;
    using YV = value_type_t<Y>;
    using C = remove_cvref_t<decltype(f(XV{}, YV{}))>;
    using Z = remove_cvref_t<decltype(
        g(std::declval<argument_pack<C*, false>>()))>;
    const auto& valx = allows<view_category::Simple>(x);
    const auto& valy = allows<view_category::Simple>(y);
    const auto* px = valx.data();
    const auto* py = valy.data();
    const auto K = valx.dims()[XR - 1u];
    if (K != valy.dims()[0])
        throw std::logic_error(WL_ERROR_REQUIRE_NON_EMPTY);
    if constexpr (XR == 1u)
    {
        if constexpr (YR == 1u)
        {
            return _inner_vv<C>(px, py, K, f, g);
        }
        else
        {
            const auto ret_dims = utils::dims_take<2u, YR>(valy.dims());
            ndarray<Z, YR - 1u> ret(ret_dims);
            const auto N = ret.size();
            auto* pz = ret.data();
            _inner_vm<C>(pz, px, py, K, N, f, g);
            return ret;
        }
    }
    else
    {
        if constexpr (YR == 1u)
        {
            const auto ret_dims = utils::dims_take<1u, XR - 1u>(valx.dims());
            ndarray<Z, XR - 1u> ret(ret_dims);
            const auto M = ret.size();
            auto* pz = ret.data();
            _inner_mv<C>(pz, px, py, M, K, f, g);
            return ret;
        }
        else
        {
            const auto M_dims = utils::dims_take<1u, XR - 1u>(valx.dims());
            const auto N_dims = utils::dims_take<2u, YR>(valy.dims());
            const auto M = utils::size_of_dims(M_dims);
            const auto N = utils::size_of_dims(N_dims);
            ndarray<Z, XR + YR - 2u> ret(utils::dims_join(M_dims, N_dims));
            auto* pz = ret.data();
            _inner_mm<C>(pz, px, py, M, K, N, f, g);
            return ret;
        }
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<size_t Level, size_t R>
void _tr_dims(size_t& ret_stride, size_t& ret_tr_size,
    const std::array<size_t, R>& x_dims)
{
    static_assert(1 <= Level && Level <= R, WL_ERROR_INTERNAL);
    size_t stride = 0u;
    size_t inner_size = 1u;
    size_t tr_size = size_t(-1);
    for (auto i = ptrdiff_t(Level - 1u); i >= 0; --i)
    {
        const size_t dim = x_dims[i];
        stride += inner_size;
        inner_size *= dim;
        if (dim < tr_size)
            tr_size = dim;
    }
    ret_stride = stride;
    ret_tr_size = tr_size;
}
template<typename X, typename F, int64_t I>
auto tr(const X& x, F f, const_int<I>)
{
    WL_TRY_BEGIN()
    static_assert(is_numerical_type_v<X>, WL_ERROR_NUMERIC_ONLY);
    constexpr auto XR = array_rank_v<X>;
    static_assert(XR >= 1u, WL_ERROR_REQUIRE_ARRAY);
    static_assert(0 < I && I <= int64_t(XR), WL_ERROR_BAD_LEVEL);
    static_assert(is_variadic_function_v<F>, WL_ERROR_REQUIRE_VARIADIC);
    using XV = value_type_t<X>;
    constexpr auto Level = size_t(I);
    if constexpr (Level == XR)
    {
        using RV = remove_cvref_t<decltype(
            f(std::declval<argument_pack<XV*, true>>()))>;
        if (x.size() == 0u)
        {
            return RV();
        }
        else
        {
            const auto& valx = allows<view_category::Simple>(x);
            size_t stride = 0u;
            size_t tr_size = 0u;
            _tr_dims<XR>(stride, tr_size, valx.dims());
            const auto pack = argument_pack<const XV*, true>(
                valx.data(), tr_size, stride);
            return f(pack);
        }
    }
    else
    {
        const auto& valx = allows<view_category::Array>(x);
        auto x_iter = valx.template view_begin<Level>();
        using PackType = argument_pack<decltype(x_iter), true>;
        using RT = remove_cvref_t<decltype(f(std::declval<PackType>()))>;
        size_t stride = 0u;
        size_t tr_size = 0u;
        _tr_dims<Level>(stride, tr_size, valx.dims());
        const auto pack = PackType(x_iter, tr_size, stride);
        return f(pack);
    }
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X, typename F>
auto tr(const X& x, F f)
{
    WL_TRY_BEGIN()
    return tr(x, f, const_int<array_rank_v<X>>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename X>
auto tr(const X& x)
{
    WL_TRY_BEGIN()
    return tr(x, WL_FUNCTION(plus), const_int<array_rank_v<X>>{});
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
}
namespace wl
{
template<typename X>
auto string_length(const X& x)
{
    WL_TRY_BEGIN()
    static_assert(is_string_type_v<X>, WL_ERROR_STRING_TYPE_ONLY);
    auto pure = [](const string& x)
    {
        return int64_t(x.size());
    };
    return utils::listable_function(pure, std::forward<decltype(x)>(x));
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Arg>
auto _string_join_attributes_by_args_impl(
    size_t& byte_size, bool& ascii_only, const Arg& arg)
{
    if constexpr (is_argument_pack_v<Arg>)
    {
        for (size_t i = 0; i < arg.size(); ++i)
        {
            byte_size += arg.get(i).byte_size();
            if (ascii_only)
                ascii_only = arg.get(i).ascii_only();
        }
        return byte_size;
    }
    else if constexpr (array_rank_v<Arg> >= 1u)
    {
        static_assert(is_string_v<value_type_t<Arg>>, WL_ERROR_STRING_ONLY);
        arg.for_each([&](const auto& x)
            {
                byte_size += x.byte_size();
                if (ascii_only)
                    ascii_only = x.ascii_only();
            });
        return byte_size;
    }
    else
    {
        static_assert(is_string_v<Arg>, WL_ERROR_STRING_ONLY);
        byte_size += arg.byte_size();
        if (ascii_only)
            ascii_only = arg.ascii_only();
    }
}
template<typename... Args>
auto _string_join_attributes_by_args(const Args&... args)
{
    size_t total_size = 0u;
    bool ascii_only = true;
    [[maybe_unused]] const auto& _1 = (
        _string_join_attributes_by_args_impl(
            total_size, ascii_only, args),
        ..., 0);
    return std::pair(total_size, ascii_only);
}
template<typename Char, typename Arg>
void _string_join_copy_by_args_impl(Char*& str, const Arg& arg)
{
    if constexpr (is_argument_pack_v<Arg>)
    {
        for (size_t i = 0; i < arg.size(); ++i)
            _string_join_copy_by_args_impl(str, arg.get(i));
    }
    else if constexpr (array_rank_v<Arg> >= 1u)
    {
        arg.for_each([&](const auto& x)
            { _string_join_copy_by_args_impl(str, x); });
    }
    else
    {
        const size_t byte_size = arg.byte_size();
        utils::restrict_copy_n(arg.byte_data(), byte_size, str);
        str += byte_size;
    }
}
template<typename Char, typename... Args>
auto _string_join_copy_by_args(Char*& str, const Args&... args)
{
    [[maybe_unused]] const auto& _1 = (
        _string_join_copy_by_args_impl(str, args), ..., 0);
}
template<typename... Args>
auto string_join(const Args&... args)
{
    WL_TRY_BEGIN()
    auto [total_size, ascii_only] = _string_join_sizes_by_args(args...);
    auto ret = string(total_size, ascii_only);
    auto ret_data = ret.byte_data();
    _string_join_copy_by_args(ret_data, args...);
    assert(ret.check_validity());
    return ret;
    WL_TRY_END(__func__, __FILE__, __LINE__)
}
template<typename Spec>
auto _string_take_impl_ascii_only()
{
    return string();
}
template<typename Iter, typename Offset>
Iter _string_take_find_offset(const Iter& begin, const Iter& end,
    const Offset offset, const bool adjust_end)
{
    if (std::is_unsigned_v<Offset> || offset > 0)
    {
        auto ret = begin;
        ret.apply_offset(offset - ptrdiff_t(!adjust_end), end);
        if (ret.pointer() > end.pointer())
            throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
        return ret;
    }
    else if (offset < 0)
    {
        auto ret = end;
        ret.apply_offset(offset + ptrdiff_t(adjust_end), begin);
        if (ret.pointer() < begin.pointer())
            throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
        return ret;
    }
    else
    {
        throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
        return begin;
    }
}
template<typename Iter>
auto _string_take_impl_unicode_1arg(const Iter& begin, const Iter& end,
    ptrdiff_t offset)
{
    const auto mid = _string_take_find_offset(
        begin, end, offset, (offset > 0));
    const auto byte_size = (offset > 0) ?
        size_t(mid.byte_difference(begin)) :
        size_t(end.byte_difference(mid));
    return string((offset > 0) ? begin.pointer() : mid.pointer(), byte_size,
        (byte_size == size_t(offset > 0 ? offset : -offset)));
}
template<typename Iter>
auto _string_take_impl_unicode_2args(const Iter& begin, const Iter& end,
    ptrdiff_t offset, ptrdiff_t string_size)
{
    if (string_size <= 0)
        return string();
    const auto mid1 = _string_take_find_offset(
        begin, end, offset, false);
    const auto mid2 = _string_take_find_offset(
        mid1, end, size_t(string_size), true);
    const auto byte_size = size_t(mid2.byte_difference(mid1));
    return string(mid1.pointer(), byte_size,
        (byte_size == size_t(string_size)));
}
template<typename Spec>
auto _string_take_impl_unicode(const string& str, const Spec& spec,
    ptrdiff_t total_size = -1)
{
    const auto begin = str.begin();
    const auto end = str.end();
    if constexpr (is_integral_v<Spec>)
    {
        if (spec == Spec(0))
            return string();
        else
            return _string_take_impl_unicode_1arg(
                begin, end, ptrdiff_t(spec));
    }
    else if constexpr (array_rank_v<Spec> == 1u &&
        is_integral_v<value_type_t<Spec>>)
    {
        const auto spec_size = spec.size();
        std::array<ptrdiff_t, 2u> offsets{};
        spec.copy_to(offsets.data());
        if (spec_size == 1u)
        {
            if (offsets[0] == 0)
                throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
            return _string_take_impl_unicode_2args(
                begin, end, offsets[0], 1u);
        }
        else if (spec_size == 2u)
        {
            if (offsets[0] == 0 || offsets[1] == 0)
                throw std::logic_error(WL_ERROR_STRING_TAKE_SPEC_LIST_LENGTH);
            if (offsets[0] * offsets[1] < 0)
            {
                if (total_size < 0)
                    total_size = str.size();
                if (offsets[0] < 0)
                    offsets[0] += ptrdiff_t(total_size + 1u);
                else
                    offsets[1] += ptrdiff_t(total_size + 1u);
            }
            return _string_take_impl_unicode_2args(
                begin, end, offsets[0], offsets[1] - offsets[0] + 1u);
        }
        else
        {
            throw std::logic_error(WL_ERROR_STRING_TAKE_SPEC_LIST_LENGTH);
        }
    }
    else if constexpr (array_rank_v<Spec> == 2u &&
        is_integral_v<value_type_t<Spec>>)
    {
        auto valspec = cast<ndarray<ptrdiff_t, 2u>>(spec);
        const auto ret_size = valspec.dims()[0];
        const auto spec_size = valspec.dims()[1];
        const auto spec_data = valspec.data();
        ndarray<string, 1u> ret(std::array<size_t, 1u>{ret_size});
        auto ret_data = ret.data();
        if (spec_size == 1u)
        {
            for (size_t i = 0; i < ret_size; ++i)
                ret_data[i] = _string_take_impl_unicode(str, spec_data[i]);
        }
        else if (spec_size == 2u)
        {
            if constexpr (std::is_signed_v<value_type_t<Spec>>)
            {
                if ((total_size < 0) && std::any_of(
                    spec_data, spec_data + 2u * ret_size,
                    [](auto i) { return i < 0; }))
                {
                    total_size = str.size();
                }
            }
            for (size_t i = 0; i < ret_size; ++i)
                ret_data[i] = _string_take_impl_unicode(str,
                    wl::list(spec_data[2u * i], spec_data[2u * i + 1u]),
                    total_size);
        }
        else
        {
            throw std::logic_error(WL_ERROR_STRING_TAKE_SPEC_LIST_LENGTH);
        }
        return ret;
    }
    else
    {
        static_assert(always_false_v<Spec>, WL_ERROR_TAKE_SPEC_TYPE);
    }
}
template<typename Spec>
auto _string_take_impl_ascii(const string& str, const Spec& spec)
{
    const auto begin = str.byte_begin();
    const auto end = str.byte_end();
    const auto total_size = str.byte_size();
    if constexpr (is_integral_v<Spec>)
    {
        if (spec == Spec(0))
            return string();
        else if (size_t(wl::abs(spec)) > total_size)
            throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
        else if (spec > Spec(0))
            return string(begin, size_t(spec), true);
        else
            return string(end + ptrdiff_t(spec), size_t(-spec), true);
    }
    else if constexpr (array_rank_v<Spec> == 1u &&
        is_integral_v<value_type_t<Spec>>)
    {
        const auto spec_size = spec.size();
        std::array<ptrdiff_t, 2u> offsets{};
        spec.copy_to(offsets.data());
        if (spec_size == 1u)
        {
            if (offsets[0] == 0 || size_t(wl::abs(offsets[0])) > total_size)
                throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
            else if (offsets[0] > 0)
                return string(begin + offsets[0] - 1, 1u, true);
            else
                return string(end + offsets[0], 1u, true);
        }
        else if (spec_size == 2u)
        {
            if (offsets[0] == 0 || offsets[1] == 0)
                throw std::logic_error(WL_ERROR_STRING_TAKE_SPEC_LIST_LENGTH);
            if (offsets[0] < 0)
                offsets[0] += ptrdiff_t(total_size + 1u);
            if (offsets[1] < 0)
                offsets[1] += ptrdiff_t(total_size + 1u);
            if (offsets[0] > offsets[1])
                return string();
            if (size_t(offsets[0]) > total_size ||
                size_t(offsets[1]) > total_size)
                throw std::logic_error(WL_ERROR_OUT_OF_RANGE);
            return string(begin + offsets[0] - 1,
                size_t(offsets[1] - offsets[0] + 1), true);
        }
        else
        {
            throw std::logic_error(WL_ERROR_STRING_TAKE_SPEC_LIST_LENGTH);
        }
    }
    else if constexpr (array_rank_v<Spec> == 2u &&
        is_integral_v<value_type_t<Spec>>)
    {
        auto valspec = cast<ndarray<ptrdiff_t, 2u>>(spec);
        const auto ret_size = valspec.dims()[0];
        const auto spec_size = valspec.dims()[1];
        const auto spec_data = valspec.data();
        ndarray<string, 1u> ret(std::array<size_t, 1u>{ret_size});
        auto ret_data = ret.data();
        if (spec_size == 1u)
        {
            for (size_t i = 0; i < ret_size; ++i)
                ret_data[i] = _string_take_impl_ascii(str, spec_data[i]);
        }
        else if (spec_size == 2u)
        {
            for (size_t i = 0; i < ret_size; ++i)
                ret_data[i] = _string_take_impl_ascii(str,
                    wl::list(spec_data[2u * i], spec_data[2u * i + 1u]));
        }
        else
        {
            throw std::logic_error(WL_ERROR_STRING_TAKE_SPEC_LIST_LENGTH);
        }
        return ret;
    }
    else
    {
        static_assert(always_false_v<Spec>, WL_ERROR_TAKE_SPEC_TYPE);
    }
}
template<typename Spec>
auto string_take(const string& str, const Spec& spec)
{
    if (str.ascii_only())
        return _string_take_impl_ascii(str, spec);
    else
        return _string_take_impl_unicode(str, spec);
}
}
namespace wl
{
}
